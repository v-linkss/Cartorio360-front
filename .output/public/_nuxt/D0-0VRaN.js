import{n as e,bz as a,r as t,a1 as r,ah as s,aM as n,bA as o,h as i,bB as c,bC as l,q as u,m as d,bD as f,M as y,bE as p,bF as h,F as m,bG as v}from"./Cqiv77yc.js";const g=e=>"defer"===e||!1===e;function _(...y){var p;const h="string"==typeof y[y.length-1]?y.pop():void 0;"string"!=typeof y[0]&&y.unshift(h);let[m,v,_={}]=y;if("string"!=typeof m)throw new TypeError("[nuxt] [asyncData] key must be a string.");if("function"!=typeof v)throw new TypeError("[nuxt] [asyncData] handler must be a function.");const D=e(),b=v;_.server=_.server??!0,_.default=_.default??(()=>a.value),_.getCachedData=_.getCachedData??(()=>D.isHydrating?D.payload.data[m]:D.static.data[m]),_.lazy=_.lazy??!1,_.immediate=_.immediate??!0,_.deep=_.deep??a.deep,_.dedupe=_.dedupe??"cancel";const w=()=>null!=_.getCachedData(m,D);if(!D._asyncData[m]||!_.immediate){(p=D.payload._errors)[m]??(p[m]=a.errorValue);const e=_.deep?t:r;D._asyncData[m]={data:e(_.getCachedData(m,D)??_.default()),pending:t(!w()),error:s(D.payload._errors,m),status:t("idle"),_default:_.default}}const C={...D._asyncData[m]};delete C._default,C.refresh=C.execute=(e={})=>{if(D._asyncDataPromises[m]){if(g(e.dedupe??_.dedupe))return D._asyncDataPromises[m];D._asyncDataPromises[m].cancelled=!0}if((e._initial||D.isHydrating&&!1!==e._initial)&&w())return Promise.resolve(_.getCachedData(m,D));C.pending.value=!0,C.status.value="pending";const t=new Promise(((e,a)=>{try{e(b(D))}catch(t){a(t)}})).then((async e=>{if(t.cancelled)return D._asyncDataPromises[m];let r=e;_.transform&&(r=await _.transform(e)),_.pick&&(r=function(e,a){const t={};for(const r of a)t[r]=e[r];return t}(r,_.pick)),D.payload.data[m]=r,C.data.value=r,C.error.value=a.errorValue,C.status.value="success"})).catch((e=>{if(t.cancelled)return D._asyncDataPromises[m];C.error.value=l(e),C.data.value=u(_.default()),C.status.value="error"})).finally((()=>{t.cancelled||(C.pending.value=!1,delete D._asyncDataPromises[m])}));return D._asyncDataPromises[m]=t,D._asyncDataPromises[m]},C.clear=()=>function(e,t){t in e.payload.data&&(e.payload.data[t]=void 0);t in e.payload._errors&&(e.payload._errors[t]=a.errorValue);e._asyncData[t]&&(e._asyncData[t].data.value=void 0,e._asyncData[t].error.value=a.errorValue,e._asyncData[t].pending.value=!1,e._asyncData[t].status.value="idle");t in e._asyncDataPromises&&(e._asyncDataPromises[t].cancelled=!0,e._asyncDataPromises[t]=void 0)}(D,m);const P=()=>C.refresh({_initial:!0}),x=!1!==_.server&&D.payload.serverRendered;{const e=d();if(e&&!e._nuxtOnBeforeMountCbs){e._nuxtOnBeforeMountCbs=[];const a=e._nuxtOnBeforeMountCbs;n((()=>{a.forEach((e=>{e()})),a.splice(0,a.length)})),o((()=>a.splice(0,a.length)))}x&&D.isHydrating&&(C.error.value||w())?(C.pending.value=!1,C.status.value=C.error.value?"error":"success"):e&&(D.payload.serverRendered&&D.isHydrating||_.lazy)&&_.immediate?e._nuxtOnBeforeMountCbs.push(P):_.immediate&&P();const a=f();if(_.watch){const e=i(_.watch,(()=>C.refresh()));a&&c(e)}const t=D.hook("app:data:refresh",(async e=>{e&&!e.includes(m)||await C.refresh()}));a&&c(t)}const k=Promise.resolve(D._asyncDataPromises[m]).then((()=>C));return Object.assign(k,C),k}function D(...e){const a="string"==typeof e[e.length-1]?e.pop():void 0;"string"!=typeof e[0]&&e.unshift(a);const[t,r,s={}]=e;return _(t,r,{...s,lazy:!0},null)}function b(e,a,t){const[r={},s]="string"==typeof a?[{},a]:[a,t],n=y((()=>p(e))),o=r.key||h([s,"string"==typeof n.value?n.value:"",...C(r)]);if(!o||"string"!=typeof o)throw new TypeError("[nuxt] [useFetch] key must be a string: "+o);if(!e)throw new Error("[nuxt] [useFetch] request is missing.");const i=o===s?"$f"+o:o;if(!r.baseURL&&"string"==typeof n.value&&"/"===n.value[0]&&"/"===n.value[1])throw new Error('[nuxt] [useFetch] the request URL must not start with "//".');const{server:c,lazy:l,default:u,transform:d,pick:f,watch:g,immediate:D,getCachedData:b,deep:w,dedupe:P,...x}=r,k=m({...v,...x,cache:"boolean"==typeof r.cache?void 0:r.cache});let z;return _(i,(()=>{var e;null==(e=null==z?void 0:z.abort)||e.call(z),z="undefined"!=typeof AbortController?new AbortController:{};const a=p(r.timeout);let t;return a&&(t=setTimeout((()=>z.abort()),a),z.signal.onabort=()=>clearTimeout(t)),(r.$fetch||globalThis.$fetch)(n.value,{signal:z.signal,...k}).finally((()=>{clearTimeout(t)}))}),{server:c,lazy:l,default:u,transform:d,pick:f,immediate:D,getCachedData:b,deep:w,dedupe:P,watch:!1===g?[]:[k,n,...g||[]]})}function w(e,a,t){const[r={},s]=[{},a];return b(e,{...r,lazy:!0},s)}function C(e){var a;const t=[(null==(a=p(e.method))?void 0:a.toUpperCase())||"GET",p(e.baseURL)];for(const r of[e.params||e.query]){const e=p(r);if(!e)continue;const a={};for(const[t,r]of Object.entries(e))a[p(t)]=p(r);t.push(a)}return t}export{D as a,w as b,b as u};
