import * as Vue from 'vue';
import { useSSRContext, ref, computed, watch as watch$1, mergeProps, unref, isRef, withCtx, createTextVNode, createVNode, openBlock, createBlock, toDisplayString, createCommentVNode, Fragment, renderList } from 'vue';
import { ssrRenderComponent, ssrInterpolate, ssrRenderList } from 'vue/server-renderer';
import { b as useNuxtApp, g as VBtn, h as VIcon, c as useRuntimeConfig, e as useCookie } from './server.mjs';
import { u as useFetch } from './fetch-DOsfzFYE.mjs';
import { V as VDialog } from './VDialog-BVe31KMa.mjs';
import { V as VCard, a as VCardTitle, c as VCardActions } from './VCard-CaQDfbK8.mjs';
import { h as VChipGroup, d as VChip } from './filter-zKsAASHM.mjs';

var instances = "ej2_instances";
var uid = 0;
var isBlazorPlatform = false;
function createInstance(classFunction, params) {
  var arrayParam = params;
  arrayParam.unshift(undefined);
  return new (Function.prototype.bind.apply(classFunction, arrayParam))();
}
function setImmediate(handler) {
  var unbind;
  var num = new Uint16Array(5);
  var intCrypto = (undefined).msCrypto || (undefined).crypto;
  intCrypto.getRandomValues(num);
  var secret = "ej2" + combineArray(num);
  var messageHandler = function(event) {
    if (event.source === undefined && typeof event.data === "string" && event.data.length <= 32 && event.data === secret) {
      handler();
      unbind();
    }
  };
  (undefined).addEventListener("message", messageHandler, false);
  (undefined).postMessage(secret, "*");
  return unbind = function() {
    (undefined).removeEventListener("message", messageHandler);
    handler = messageHandler = secret = undefined;
  };
}
function getValue(nameSpace, obj) {
  var value = obj;
  var splits = nameSpace.replace(/\[/g, ".").replace(/\]/g, "").split(".");
  for (var i = 0; i < splits.length && !isUndefined(value); i++) {
    value = value[splits[parseInt(i.toString(), 10)]];
  }
  return value;
}
function setValue(nameSpace, value, obj) {
  var keys2 = nameSpace.replace(/\[/g, ".").replace(/\]/g, "").split(".");
  var start = obj || {};
  var fromObj = start;
  var i;
  var length = keys2.length;
  var key;
  for (i = 0; i < length; i++) {
    key = keys2[parseInt(i.toString(), 10)];
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      continue;
    }
    if (i + 1 === length) {
      fromObj["" + key] = value === undefined ? {} : value;
    } else if (isNullOrUndefined(fromObj["" + key])) {
      fromObj["" + key] = {};
    }
    fromObj = fromObj["" + key];
  }
  return start;
}
function deleteObject(obj, key) {
  delete obj["" + key];
}
var containerObject = {};
function isObject(obj) {
  var objCon = {};
  return !isNullOrUndefined(obj) && obj.constructor === objCon.constructor;
}
function merge(source, destination) {
  if (!isNullOrUndefined(destination)) {
    var temrObj = source;
    var tempProp = destination;
    var keys2 = Object.keys(destination);
    var deepmerge = "deepMerge";
    for (var _i = 0, keys_1 = keys2; _i < keys_1.length; _i++) {
      var key = keys_1[_i];
      if (!isNullOrUndefined(temrObj["" + deepmerge]) && temrObj["" + deepmerge].indexOf(key) !== -1 && (isObject(tempProp["" + key]) || Array.isArray(tempProp["" + key]))) {
        extend(temrObj["" + key], temrObj["" + key], tempProp["" + key], true);
      } else {
        temrObj["" + key] = tempProp["" + key];
      }
    }
  }
}
function extend(copied, first, second, deep) {
  var result = copied && typeof copied === "object" ? copied : {};
  var length = arguments.length;
  var args = [copied, first, second, deep];
  if (deep) {
    length = length - 1;
  }
  var _loop_1 = function(i2) {
    if (!args[parseInt(i2.toString(), 10)]) {
      return "continue";
    }
    var obj1 = args[parseInt(i2.toString(), 10)];
    Object.keys(obj1).forEach(function(key) {
      var src = result["" + key];
      var copy = obj1["" + key];
      var clone;
      Array.isArray(copy) && Array.isArray(src) && copy.length !== src.length;
      var blazorEventExtend = true;
      if (deep && blazorEventExtend && (isObject(copy) || Array.isArray(copy))) {
        if (isObject(copy)) {
          clone = src ? src : {};
          if (Array.isArray(clone) && Object.prototype.hasOwnProperty.call(clone, "isComplexArray")) {
            extend(clone, {}, copy, deep);
          } else {
            result["" + key] = extend(clone, {}, copy, deep);
          }
        } else {
          clone = src ? src : [];
          result["" + key] = extend([], clone, copy, clone && clone.length || copy && copy.length);
        }
      } else {
        result["" + key] = copy;
      }
    });
  };
  for (var i = 1; i < length; i++) {
    _loop_1(i);
  }
  return result;
}
function isNullOrUndefined(value) {
  return value === undefined || value === null;
}
function isUndefined(value) {
  return "undefined" === typeof value;
}
function getUniqueID(definedName) {
  return definedName + "_" + uid++;
}
function debounce(eventFunction, delay) {
  var out;
  return function() {
    var _this = this;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var later = function() {
      out = null;
      return eventFunction.apply(_this, args);
    };
    clearTimeout(out);
    out = setTimeout(later, delay);
  };
}
function compareElementParent(child, parent) {
  var node = child;
  if (node === parent) {
    return true;
  } else if (node === undefined || !node) {
    return false;
  } else {
    return compareElementParent(node.parentNode, parent);
  }
}
function throwError(message) {
  try {
    throw new Error(message);
  } catch (e) {
    throw new Error(e.message + "\n" + e.stack);
  }
}
function print(element2, printWindow) {
  var div = (undefined).createElement("div");
  var links = [].slice.call((undefined).getElementsByTagName("head")[0].querySelectorAll("base, link, style"));
  var blinks = [].slice.call((undefined).getElementsByTagName("body")[0].querySelectorAll("link, style"));
  if (blinks.length) {
    for (var l = 0, len = blinks.length; l < len; l++) {
      links.push(blinks[parseInt(l.toString(), 10)]);
    }
  }
  var reference = "";
  if (isNullOrUndefined(printWindow)) {
    printWindow = (undefined).open("", "print", "height=452,width=1024,tabbar=no");
  }
  div.appendChild(element2.cloneNode(true));
  for (var i = 0, len = links.length; i < len; i++) {
    reference += links[parseInt(i.toString(), 10)].outerHTML;
  }
  printWindow.document.write("<!DOCTYPE html> <html><head>" + reference + "</head><body>" + div.innerHTML + "<script> (function() { window.ready = true; })(); <\/script></body></html>");
  printWindow.document.close();
  printWindow.focus();
  var interval = setInterval(function() {
    if (printWindow.ready) {
      printWindow.print();
      printWindow.close();
      clearInterval(interval);
    }
  }, 500);
  return printWindow;
}
function formatUnit(value) {
  var result = value + "";
  if (result.match(/auto|cm|mm|in|px|pt|pc|%|em|ex|ch|rem|vw|vh|vmin|vmax/)) {
    return result;
  }
  return result + "px";
}
function isBlazor() {
  return isBlazorPlatform;
}
function getElement(element2) {
  return element2;
}
function getInstance(element2, component) {
  var elem = typeof element2 === "string" ? (undefined).querySelector(element2) : element2;
  if (elem["" + instances]) {
    for (var _i = 0, _a = elem["" + instances]; _i < _a.length; _i++) {
      var inst = _a[_i];
      if (inst instanceof component) {
        return inst;
      }
    }
  }
  return null;
}
function uniqueID() {
  {
    return;
  }
}
function combineArray(num) {
  var ret = "";
  for (var i = 0; i < 5; i++) {
    ret += (i ? "," : "") + num[parseInt(i.toString(), 10)];
  }
  return ret;
}
var defaultNumberingSystem = {
  "latn": {
    "_digits": "0123456789",
    "_type": "numeric"
  }
};
var defaultNumberSymbols = {
  "decimal": ".",
  "group": ",",
  "percentSign": "%",
  "plusSign": "+",
  "minusSign": "-",
  "infinity": "\u221E",
  "nan": "NaN",
  "exponential": "E"
};
var latnNumberSystem = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
var ParserBase = (
  /** @class */
  function() {
    function ParserBase2() {
    }
    ParserBase2.getMainObject = function(obj, cName) {
      var value = "main." + cName;
      return getValue(value, obj);
    };
    ParserBase2.getNumberingSystem = function(obj) {
      return getValue("supplemental.numberingSystems", obj) || this.numberingSystems;
    };
    ParserBase2.reverseObject = function(prop, keys2) {
      var propKeys = keys2 || Object.keys(prop);
      var res = {};
      for (var _i = 0, propKeys_1 = propKeys; _i < propKeys_1.length; _i++) {
        var key = propKeys_1[_i];
        if (!Object.prototype.hasOwnProperty.call(res, prop["" + key])) {
          res[prop["" + key]] = key;
        }
      }
      return res;
    };
    ParserBase2.getSymbolRegex = function(props2) {
      var regexStr = props2.map(function(str) {
        return str.replace(/([.*+?^=!:${}()|[\]/\\])/g, "\\$1");
      }).join("|");
      var regExp2 = RegExp;
      return new regExp2(regexStr, "g");
    };
    ParserBase2.getSymbolMatch = function(prop) {
      var matchKeys = Object.keys(defaultNumberSymbols);
      var ret = {};
      for (var _i = 0, matchKeys_1 = matchKeys; _i < matchKeys_1.length; _i++) {
        var key = matchKeys_1[_i];
        ret[prop["" + key]] = defaultNumberSymbols["" + key];
      }
      return ret;
    };
    ParserBase2.constructRegex = function(val) {
      var len = val.length;
      var ret = "";
      for (var i = 0; i < len; i++) {
        if (i !== len - 1) {
          ret += val[parseInt(i.toString(), 10)] + "|";
        } else {
          ret += val[parseInt(i.toString(), 10)];
        }
      }
      return ret;
    };
    ParserBase2.convertValueParts = function(value, regex, obj) {
      return value.replace(regex, function(str) {
        return obj["" + str];
      });
    };
    ParserBase2.getDefaultNumberingSystem = function(obj) {
      var ret = {};
      ret.obj = getValue("numbers", obj);
      ret.nSystem = getValue("defaultNumberingSystem", ret.obj);
      return ret;
    };
    ParserBase2.getCurrentNumericOptions = function(curObj, numberSystem, needSymbols, blazorMode) {
      var ret = {};
      var cur = this.getDefaultNumberingSystem(curObj);
      if (!isUndefined(cur.nSystem) || blazorMode) {
        var digits = blazorMode ? getValue("obj.mapperDigits", cur) : getValue(cur.nSystem + "._digits", numberSystem);
        if (!isUndefined(digits)) {
          ret.numericPair = this.reverseObject(digits, latnNumberSystem);
          var regExp2 = RegExp;
          ret.numberParseRegex = new regExp2(this.constructRegex(digits), "g");
          ret.numericRegex = "[" + digits[0] + "-" + digits[9] + "]";
          if (needSymbols) {
            ret.numericRegex = digits[0] + "-" + digits[9];
            ret.symbolNumberSystem = getValue(blazorMode ? "numberSymbols" : "symbols-numberSystem-" + cur.nSystem, cur.obj);
            ret.symbolMatch = this.getSymbolMatch(ret.symbolNumberSystem);
            ret.numberSystem = cur.nSystem;
          }
        }
      }
      return ret;
    };
    ParserBase2.getNumberMapper = function(curObj, numberSystem, isNumber) {
      var ret = { mapper: {} };
      var cur = this.getDefaultNumberingSystem(curObj);
      if (!isUndefined(cur.nSystem)) {
        ret.numberSystem = cur.nSystem;
        ret.numberSymbols = getValue("symbols-numberSystem-" + cur.nSystem, cur.obj);
        ret.timeSeparator = getValue("timeSeparator", ret.numberSymbols);
        var digits = getValue(cur.nSystem + "._digits", numberSystem);
        if (!isUndefined(digits)) {
          for (var _i = 0, latnNumberSystem_1 = latnNumberSystem; _i < latnNumberSystem_1.length; _i++) {
            var i = latnNumberSystem_1[_i];
            ret.mapper[parseInt(i.toString(), 10)] = digits[parseInt(i.toString(), 10)];
          }
        }
      }
      return ret;
    };
    ParserBase2.nPair = "numericPair";
    ParserBase2.nRegex = "numericRegex";
    ParserBase2.numberingSystems = defaultNumberingSystem;
    return ParserBase2;
  }()
);
var blazorCurrencyData = {
  "DJF": "Fdj",
  "ERN": "Nfk",
  "ETB": "Br",
  "NAD": "$",
  "ZAR": "R",
  "XAF": "FCFA",
  "GHS": "GH\u20B5",
  "XDR": "XDR",
  "AED": "\u062F.\u0625.",
  "BHD": "\u062F.\u0628.",
  "DZD": "\u062F.\u062C.",
  "EGP": "\u062C.\u0645.",
  "ILS": "\u20AA",
  "IQD": "\u062F.\u0639.",
  "JOD": "\u062F.\u0627.",
  "KMF": "CF",
  "KWD": "\u062F.\u0643.",
  "LBP": "\u0644.\u0644.",
  "LYD": "\u062F.\u0644.",
  "MAD": "\u062F.\u0645.",
  "MRU": "\u0623.\u0645.",
  "OMR": "\u0631.\u0639.",
  "QAR": "\u0631.\u0642.",
  "SAR": "\u0631.\u0633.",
  "SDG": "\u062C.\u0633.",
  "SOS": "S",
  "SSP": "\xA3",
  "SYP": "\u0644.\u0633.",
  "TND": "\u062F.\u062A.",
  "YER": "\u0631.\u064A.",
  "CLP": "$",
  "INR": "\u20B9",
  "TZS": "TSh",
  "EUR": "\u20AC",
  "AZN": "\u20BC",
  "RUB": "\u20BD",
  "BYN": "Br",
  "ZMW": "K",
  "BGN": "\u043B\u0432.",
  "NGN": "\u20A6",
  "XOF": "CFA",
  "BDT": "\u09F3",
  "CNY": "\xA5",
  "BAM": "\u041A\u041C",
  "UGX": "USh",
  "USD": "$",
  "CZK": "K\u010D",
  "GBP": "\xA3",
  "DKK": "kr.",
  "KES": "Ksh",
  "CHF": "CHF",
  "MVR": "\u0783.",
  "BTN": "Nu.",
  "XCD": "EC$",
  "AUD": "$",
  "BBD": "$",
  "BIF": "FBu",
  "BMD": "$",
  "BSD": "$",
  "BWP": "P",
  "BZD": "$",
  "CAD": "$",
  "NZD": "$",
  "FJD": "$",
  "FKP": "\xA3",
  "GIP": "\xA3",
  "GMD": "D",
  "GYD": "$",
  "HKD": "$",
  "IDR": "Rp",
  "JMD": "$",
  "KYD": "$",
  "LRD": "$",
  "MGA": "Ar",
  "MOP": "MOP$",
  "MUR": "Rs",
  "MWK": "MK",
  "MYR": "RM",
  "PGK": "K",
  "PHP": "\u20B1",
  "PKR": "Rs",
  "RWF": "RF",
  "SBD": "$",
  "SCR": "SR",
  "SEK": "kr",
  "SGD": "$",
  "SHP": "\xA3",
  "SLL": "Le",
  "ANG": "NAf.",
  "SZL": "E",
  "TOP": "T$",
  "TTD": "$",
  "VUV": "VT",
  "WST": "WS$",
  "ARS": "$",
  "BOB": "Bs",
  "BRL": "R$",
  "COP": "$",
  "CRC": "\u20A1",
  "CUP": "$",
  "DOP": "$",
  "GTQ": "Q",
  "HNL": "L",
  "MXN": "$",
  "NIO": "C$",
  "PAB": "B/.",
  "PEN": "S/",
  "PYG": "\u20B2",
  "UYU": "$",
  "VES": "Bs.S",
  "IRR": "\u0631\u064A\u0627\u0644",
  "GNF": "FG",
  "CDF": "FC",
  "HTG": "G",
  "XPF": "FCFP",
  "HRK": "kn",
  "HUF": "Ft",
  "AMD": "\u058F",
  "ISK": "kr",
  "JPY": "\xA5",
  "GEL": "\u20BE",
  "CVE": "\u200B",
  "KZT": "\u20B8",
  "KHR": "\u17DB",
  "KPW": "\u20A9",
  "KRW": "\u20A9",
  "KGS": "\u0441\u043E\u043C",
  "AOA": "Kz",
  "LAK": "\u20AD",
  "MZN": "MTn",
  "MKD": "\u0434\u0435\u043D",
  "MNT": "\u20AE",
  "BND": "$",
  "MMK": "K",
  "NOK": "kr",
  "NPR": "\u0930\u0941",
  "AWG": "Afl.",
  "SRD": "$",
  "PLN": "z\u0142",
  "AFN": "\u060B",
  "STN": "Db",
  "MDL": "L",
  "RON": "lei",
  "UAH": "\u20B4",
  "LKR": "\u0DBB\u0DD4.",
  "ALL": "Lek\xEB",
  "RSD": "\u0434\u0438\u043D.",
  "TJS": "\u0441\u043C\u043D",
  "THB": "\u0E3F",
  "TMT": "m.",
  "TRY": "\u20BA",
  "UZS": "\u0441\u045E\u043C",
  "VND": "\u20AB",
  "TWD": "NT$"
};
function getBlazorCurrencySymbol(currencyCode) {
  return getValue(currencyCode || "", blazorCurrencyData);
}
var defaultCurrencyCode = "USD";
var NumberFormat$1 = null;
var DateFormat$1 = null;
function setNumberFormat(value) {
  NumberFormat$1 = value;
}
function setDateFormat(value) {
  DateFormat$1 = value;
}
var regExp$1 = RegExp;
var blazorCultureFormats = {
  "en-US": {
    "d": "M/d/y",
    "D": "EEEE, MMMM d, y",
    "f": "EEEE, MMMM d, y h:mm a",
    "F": "EEEE, MMMM d, y h:mm:s a",
    "g": "M/d/y h:mm a",
    "G": "M/d/yyyy h:mm:ss tt",
    "m": "MMMM d",
    "M": "MMMM d",
    "r": "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'",
    "R": "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'",
    "s": "yyyy'-'MM'-'dd'T'HH':'mm':'ss",
    "t": "h:mm tt",
    "T": "h:m:s tt",
    "u": "yyyy'-'MM'-'dd HH':'mm':'ss'Z'",
    "U": "dddd, MMMM d, yyyy h:mm:ss tt",
    "y": "MMMM yyyy",
    "Y": "MMMM yyyy"
  }
};
var IntlBase;
(function(IntlBase2) {
  IntlBase2.negativeDataRegex = /^(('[^']+'|''|[^*#@0,.E])*)(\*.)?((([#,]*[0,]*0+)(\.0*[0-9]*#*)?)|([#,]*@+#*))(E\+?0+)?(('[^']+'|''|[^*#@0,.E])*)$/;
  IntlBase2.customRegex = /^(('[^']+'|''|[^*#@0,.])*)(\*.)?((([0#,]*[0,]*[0#]*[0# ]*)(\.[0#]*)?)|([#,]*@+#*))(E\+?0+)?(('[^']+'|''|[^*#@0,.E])*)$/;
  IntlBase2.latnParseRegex = /0|1|2|3|4|5|6|7|8|9/g;
  var fractionRegex = /[0-9]/g;
  IntlBase2.defaultCurrency = "$";
  var mapper2 = ["infinity", "nan", "group", "decimal"];
  var patternRegex = /G|M|L|H|c|'| a|yy|y|EEEE|E/g;
  var patternMatch = {
    "G": "",
    "M": "m",
    "L": "m",
    "H": "h",
    "c": "d",
    "'": '"',
    " a": " AM/PM",
    "yy": "yy",
    "y": "yyyy",
    "EEEE": "dddd",
    "E": "ddd"
  };
  IntlBase2.dateConverterMapper = /dddd|ddd/ig;
  var defaultFirstDay = "sun";
  IntlBase2.islamicRegex = /^islamic/;
  var firstDayMapper = {
    "sun": 0,
    "mon": 1,
    "tue": 2,
    "wed": 3,
    "thu": 4,
    "fri": 5,
    "sat": 6
  };
  IntlBase2.formatRegex = new regExp$1("(^[ncpae]{1})([0-1]?[0-9]|20)?$", "i");
  IntlBase2.currencyFormatRegex = new regExp$1("(^[ca]{1})([0-1]?[0-9]|20)?$", "i");
  IntlBase2.curWithoutNumberRegex = /(c|a)$/ig;
  var typeMapper = {
    "$": "isCurrency",
    "%": "isPercent",
    "-": "isNegative",
    0: "nlead",
    1: "nend"
  };
  IntlBase2.dateParseRegex = /([a-z])\1*|'([^']|'')+'|''|./gi;
  IntlBase2.basicPatterns = ["short", "medium", "long", "full"];
  IntlBase2.defaultObject = {
    "dates": {
      "calendars": {
        "gregorian": {
          "months": {
            "stand-alone": {
              "abbreviated": {
                "1": "Jan",
                "2": "Feb",
                "3": "Mar",
                "4": "Apr",
                "5": "May",
                "6": "Jun",
                "7": "Jul",
                "8": "Aug",
                "9": "Sep",
                "10": "Oct",
                "11": "Nov",
                "12": "Dec"
              },
              "narrow": {
                "1": "J",
                "2": "F",
                "3": "M",
                "4": "A",
                "5": "M",
                "6": "J",
                "7": "J",
                "8": "A",
                "9": "S",
                "10": "O",
                "11": "N",
                "12": "D"
              },
              "wide": {
                "1": "January",
                "2": "February",
                "3": "March",
                "4": "April",
                "5": "May",
                "6": "June",
                "7": "July",
                "8": "August",
                "9": "September",
                "10": "October",
                "11": "November",
                "12": "December"
              }
            }
          },
          "days": {
            "stand-alone": {
              "abbreviated": {
                "sun": "Sun",
                "mon": "Mon",
                "tue": "Tue",
                "wed": "Wed",
                "thu": "Thu",
                "fri": "Fri",
                "sat": "Sat"
              },
              "narrow": {
                "sun": "S",
                "mon": "M",
                "tue": "T",
                "wed": "W",
                "thu": "T",
                "fri": "F",
                "sat": "S"
              },
              "short": {
                "sun": "Su",
                "mon": "Mo",
                "tue": "Tu",
                "wed": "We",
                "thu": "Th",
                "fri": "Fr",
                "sat": "Sa"
              },
              "wide": {
                "sun": "Sunday",
                "mon": "Monday",
                "tue": "Tuesday",
                "wed": "Wednesday",
                "thu": "Thursday",
                "fri": "Friday",
                "sat": "Saturday"
              }
            }
          },
          "dayPeriods": {
            "format": {
              "wide": {
                "am": "AM",
                "pm": "PM"
              }
            }
          },
          "eras": {
            "eraNames": {
              "0": "Before Christ",
              "0-alt-variant": "Before Common Era",
              "1": "Anno Domini",
              "1-alt-variant": "Common Era"
            },
            "eraAbbr": {
              "0": "BC",
              "0-alt-variant": "BCE",
              "1": "AD",
              "1-alt-variant": "CE"
            },
            "eraNarrow": {
              "0": "B",
              "0-alt-variant": "BCE",
              "1": "A",
              "1-alt-variant": "CE"
            }
          },
          "dateFormats": {
            "full": "EEEE, MMMM d, y",
            "long": "MMMM d, y",
            "medium": "MMM d, y",
            "short": "M/d/yy"
          },
          "timeFormats": {
            "full": "h:mm:ss a zzzz",
            "long": "h:mm:ss a z",
            "medium": "h:mm:ss a",
            "short": "h:mm a"
          },
          "dateTimeFormats": {
            "full": "{1} 'at' {0}",
            "long": "{1} 'at' {0}",
            "medium": "{1}, {0}",
            "short": "{1}, {0}",
            "availableFormats": {
              "d": "d",
              "E": "ccc",
              "Ed": "d E",
              "Ehm": "E h:mm a",
              "EHm": "E HH:mm",
              "Ehms": "E h:mm:ss a",
              "EHms": "E HH:mm:ss",
              "Gy": "y G",
              "GyMMM": "MMM y G",
              "GyMMMd": "MMM d, y G",
              "GyMMMEd": "E, MMM d, y G",
              "h": "h a",
              "H": "HH",
              "hm": "h:mm a",
              "Hm": "HH:mm",
              "hms": "h:mm:ss a",
              "Hms": "HH:mm:ss",
              "hmsv": "h:mm:ss a v",
              "Hmsv": "HH:mm:ss v",
              "hmv": "h:mm a v",
              "Hmv": "HH:mm v",
              "M": "L",
              "Md": "M/d",
              "MEd": "E, M/d",
              "MMM": "LLL",
              "MMMd": "MMM d",
              "MMMEd": "E, MMM d",
              "MMMMd": "MMMM d",
              "ms": "mm:ss",
              "y": "y",
              "yM": "M/y",
              "yMd": "M/d/y",
              "yMEd": "E, M/d/y",
              "yMMM": "MMM y",
              "yMMMd": "MMM d, y",
              "yMMMEd": "E, MMM d, y",
              "yMMMM": "MMMM y"
            }
          }
        },
        "islamic": {
          "months": {
            "stand-alone": {
              "abbreviated": {
                "1": "Muh.",
                "2": "Saf.",
                "3": "Rab. I",
                "4": "Rab. II",
                "5": "Jum. I",
                "6": "Jum. II",
                "7": "Raj.",
                "8": "Sha.",
                "9": "Ram.",
                "10": "Shaw.",
                "11": "Dhu\u02BBl-Q.",
                "12": "Dhu\u02BBl-H."
              },
              "narrow": {
                "1": "1",
                "2": "2",
                "3": "3",
                "4": "4",
                "5": "5",
                "6": "6",
                "7": "7",
                "8": "8",
                "9": "9",
                "10": "10",
                "11": "11",
                "12": "12"
              },
              "wide": {
                "1": "Muharram",
                "2": "Safar",
                "3": "Rabi\u02BB I",
                "4": "Rabi\u02BB II",
                "5": "Jumada I",
                "6": "Jumada II",
                "7": "Rajab",
                "8": "Sha\u02BBban",
                "9": "Ramadan",
                "10": "Shawwal",
                "11": "Dhu\u02BBl-Qi\u02BBdah",
                "12": "Dhu\u02BBl-Hijjah"
              }
            }
          },
          "days": {
            "stand-alone": {
              "abbreviated": {
                "sun": "Sun",
                "mon": "Mon",
                "tue": "Tue",
                "wed": "Wed",
                "thu": "Thu",
                "fri": "Fri",
                "sat": "Sat"
              },
              "narrow": {
                "sun": "S",
                "mon": "M",
                "tue": "T",
                "wed": "W",
                "thu": "T",
                "fri": "F",
                "sat": "S"
              },
              "short": {
                "sun": "Su",
                "mon": "Mo",
                "tue": "Tu",
                "wed": "We",
                "thu": "Th",
                "fri": "Fr",
                "sat": "Sa"
              },
              "wide": {
                "sun": "Sunday",
                "mon": "Monday",
                "tue": "Tuesday",
                "wed": "Wednesday",
                "thu": "Thursday",
                "fri": "Friday",
                "sat": "Saturday"
              }
            }
          },
          "dayPeriods": {
            "format": {
              "wide": {
                "am": "AM",
                "pm": "PM"
              }
            }
          },
          "eras": {
            "eraNames": {
              "0": "AH"
            },
            "eraAbbr": {
              "0": "AH"
            },
            "eraNarrow": {
              "0": "AH"
            }
          },
          "dateFormats": {
            "full": "EEEE, MMMM d, y G",
            "long": "MMMM d, y G",
            "medium": "MMM d, y G",
            "short": "M/d/y GGGGG"
          },
          "timeFormats": {
            "full": "h:mm:ss a zzzz",
            "long": "h:mm:ss a z",
            "medium": "h:mm:ss a",
            "short": "h:mm a"
          },
          "dateTimeFormats": {
            "full": "{1} 'at' {0}",
            "long": "{1} 'at' {0}",
            "medium": "{1}, {0}",
            "short": "{1}, {0}",
            "availableFormats": {
              "d": "d",
              "E": "ccc",
              "Ed": "d E",
              "Ehm": "E h:mm a",
              "EHm": "E HH:mm",
              "Ehms": "E h:mm:ss a",
              "EHms": "E HH:mm:ss",
              "Gy": "y G",
              "GyMMM": "MMM y G",
              "GyMMMd": "MMM d, y G",
              "GyMMMEd": "E, MMM d, y G",
              "h": "h a",
              "H": "HH",
              "hm": "h:mm a",
              "Hm": "HH:mm",
              "hms": "h:mm:ss a",
              "Hms": "HH:mm:ss",
              "M": "L",
              "Md": "M/d",
              "MEd": "E, M/d",
              "MMM": "LLL",
              "MMMd": "MMM d",
              "MMMEd": "E, MMM d",
              "MMMMd": "MMMM d",
              "ms": "mm:ss",
              "y": "y G",
              "yyyy": "y G",
              "yyyyM": "M/y GGGGG",
              "yyyyMd": "M/d/y GGGGG",
              "yyyyMEd": "E, M/d/y GGGGG",
              "yyyyMMM": "MMM y G",
              "yyyyMMMd": "MMM d, y G",
              "yyyyMMMEd": "E, MMM d, y G",
              "yyyyMMMM": "MMMM y G",
              "yyyyQQQ": "QQQ y G",
              "yyyyQQQQ": "QQQQ y G"
            }
          }
        }
      },
      "timeZoneNames": {
        "hourFormat": "+HH:mm;-HH:mm",
        "gmtFormat": "GMT{0}",
        "gmtZeroFormat": "GMT"
      }
    },
    "numbers": {
      "currencies": {
        "USD": {
          "displayName": "US Dollar",
          "symbol": "$",
          "symbol-alt-narrow": "$"
        },
        "EUR": {
          "displayName": "Euro",
          "symbol": "\u20AC",
          "symbol-alt-narrow": "\u20AC"
        },
        "GBP": {
          "displayName": "British Pound",
          "symbol-alt-narrow": "\xA3"
        }
      },
      "defaultNumberingSystem": "latn",
      "minimumGroupingDigits": "1",
      "symbols-numberSystem-latn": {
        "decimal": ".",
        "group": ",",
        "list": ";",
        "percentSign": "%",
        "plusSign": "+",
        "minusSign": "-",
        "exponential": "E",
        "superscriptingExponent": "\xD7",
        "perMille": "\u2030",
        "infinity": "\u221E",
        "nan": "NaN",
        "timeSeparator": ":"
      },
      "decimalFormats-numberSystem-latn": {
        "standard": "#,##0.###"
      },
      "percentFormats-numberSystem-latn": {
        "standard": "#,##0%"
      },
      "currencyFormats-numberSystem-latn": {
        "standard": "\xA4#,##0.00",
        "accounting": "\xA4#,##0.00;(\xA4#,##0.00)"
      },
      "scientificFormats-numberSystem-latn": {
        "standard": "#E0"
      }
    }
  };
  IntlBase2.blazorDefaultObject = {
    "numbers": {
      "mapper": {
        "0": "0",
        "1": "1",
        "2": "2",
        "3": "3",
        "4": "4",
        "5": "5",
        "6": "6",
        "7": "7",
        "8": "8",
        "9": "9"
      },
      "mapperDigits": "0123456789",
      "numberSymbols": {
        "decimal": ".",
        "group": ",",
        "plusSign": "+",
        "minusSign": "-",
        "percentSign": "%",
        "nan": "NaN",
        "timeSeparator": ":",
        "infinity": "\u221E"
      },
      "timeSeparator": ":",
      "currencySymbol": "$",
      "currencypData": {
        "nlead": "$",
        "nend": "",
        "groupSeparator": ",",
        "groupData": {
          "primary": 3
        },
        "maximumFraction": 2,
        "minimumFraction": 2
      },
      "percentpData": {
        "nlead": "",
        "nend": "%",
        "groupSeparator": ",",
        "groupData": {
          "primary": 3
        },
        "maximumFraction": 2,
        "minimumFraction": 2
      },
      "percentnData": {
        "nlead": "-",
        "nend": "%",
        "groupSeparator": ",",
        "groupData": {
          "primary": 3
        },
        "maximumFraction": 2,
        "minimumFraction": 2
      },
      "currencynData": {
        "nlead": "($",
        "nend": ")",
        "groupSeparator": ",",
        "groupData": {
          "primary": 3
        },
        "maximumFraction": 2,
        "minimumFraction": 2
      },
      "decimalnData": {
        "nlead": "-",
        "nend": "",
        "groupData": {
          "primary": 3
        },
        "maximumFraction": 2,
        "minimumFraction": 2
      },
      "decimalpData": {
        "nlead": "",
        "nend": "",
        "groupData": {
          "primary": 3
        },
        "maximumFraction": 2,
        "minimumFraction": 2
      }
    },
    "dates": {
      "dayPeriods": {
        "am": "AM",
        "pm": "PM"
      },
      "dateSeperator": "/",
      "days": {
        "abbreviated": {
          "sun": "Sun",
          "mon": "Mon",
          "tue": "Tue",
          "wed": "Wed",
          "thu": "Thu",
          "fri": "Fri",
          "sat": "Sat"
        },
        "short": {
          "sun": "Su",
          "mon": "Mo",
          "tue": "Tu",
          "wed": "We",
          "thu": "Th",
          "fri": "Fr",
          "sat": "Sa"
        },
        "wide": {
          "sun": "Sunday",
          "mon": "Monday",
          "tue": "Tuesday",
          "wed": "Wednesday",
          "thu": "Thursday",
          "fri": "Friday",
          "sat": "Saturday"
        }
      },
      "months": {
        "abbreviated": {
          "1": "Jan",
          "2": "Feb",
          "3": "Mar",
          "4": "Apr",
          "5": "May",
          "6": "Jun",
          "7": "Jul",
          "8": "Aug",
          "9": "Sep",
          "10": "Oct",
          "11": "Nov",
          "12": "Dec"
        },
        "wide": {
          "1": "January",
          "2": "February",
          "3": "March",
          "4": "April",
          "5": "May",
          "6": "June",
          "7": "July",
          "8": "August",
          "9": "September",
          "10": "October",
          "11": "November",
          "12": "December"
        }
      },
      "eras": {
        "1": "AD"
      }
    }
  };
  IntlBase2.monthIndex = {
    3: "abbreviated",
    4: "wide",
    5: "narrow",
    1: "abbreviated"
  };
  IntlBase2.month = "months";
  IntlBase2.days = "days";
  IntlBase2.patternMatcher = {
    C: "currency",
    P: "percent",
    N: "decimal",
    A: "currency",
    E: "scientific"
  };
  function getResultantPattern(skeleton, dateObject, type, isIslamic, blazorCulture) {
    var resPattern;
    var iType = type || "date";
    if (blazorCulture) {
      resPattern = compareBlazorDateFormats({ skeleton }, blazorCulture).format || compareBlazorDateFormats({ skeleton: "d" }, "en-US").format;
    } else {
      if (IntlBase2.basicPatterns.indexOf(skeleton) !== -1) {
        resPattern = getValue(iType + "Formats." + skeleton, dateObject);
        if (iType === "dateTime") {
          var dPattern = getValue("dateFormats." + skeleton, dateObject);
          var tPattern = getValue("timeFormats." + skeleton, dateObject);
          resPattern = resPattern.replace("{1}", dPattern).replace("{0}", tPattern);
        }
      } else {
        resPattern = getValue("dateTimeFormats.availableFormats." + skeleton, dateObject);
      }
      if (isUndefined(resPattern) && skeleton === "yMd") {
        resPattern = "M/d/y";
      }
    }
    return resPattern;
  }
  IntlBase2.getResultantPattern = getResultantPattern;
  function getDependables(cldr, culture, mode, isNumber) {
    var ret = {};
    var calendartype = mode || "gregorian";
    ret.parserObject = ParserBase.getMainObject(cldr, culture) || IntlBase2.defaultObject;
    if (isNumber) {
      ret.numericObject = getValue("numbers", ret.parserObject);
    } else {
      var dateString = "dates.calendars." + calendartype;
      ret.dateObject = getValue(dateString, ret.parserObject);
    }
    return ret;
  }
  IntlBase2.getDependables = getDependables;
  function getSymbolPattern(type, numSystem, obj, isAccount) {
    return getValue(type + "Formats-numberSystem-" + numSystem + (isAccount ? ".accounting" : ".standard"), obj) || (isAccount ? getValue(type + "Formats-numberSystem-" + numSystem + ".standard", obj) : "");
  }
  IntlBase2.getSymbolPattern = getSymbolPattern;
  function ConvertDateToWeekFormat(format) {
    format.match(IntlBase2.dateConverterMapper);
    return format;
  }
  IntlBase2.ConvertDateToWeekFormat = ConvertDateToWeekFormat;
  function compareBlazorDateFormats(formatOptions, culture) {
    var format = formatOptions.format || formatOptions.skeleton;
    var curFormatMapper = getValue((culture || "en-US") + "." + format, blazorCultureFormats);
    if (!curFormatMapper) {
      curFormatMapper = getValue("en-US." + format, blazorCultureFormats);
    }
    if (curFormatMapper) {
      curFormatMapper = ConvertDateToWeekFormat(curFormatMapper);
      formatOptions.format = curFormatMapper.replace(/tt/, "a");
    }
    return formatOptions;
  }
  IntlBase2.compareBlazorDateFormats = compareBlazorDateFormats;
  function getProperNumericSkeleton(skeleton) {
    var matches2 = skeleton.match(IntlBase2.formatRegex);
    var ret = {};
    var pattern = matches2[1].toUpperCase();
    ret.isAccount = pattern === "A";
    ret.type = IntlBase2.patternMatcher["" + pattern];
    if (skeleton.length > 1) {
      ret.fractionDigits = parseInt(matches2[2], 10);
    }
    return ret;
  }
  IntlBase2.getProperNumericSkeleton = getProperNumericSkeleton;
  function getFormatData(pattern, needFraction, cSymbol, fractionOnly) {
    var nData = fractionOnly ? {} : { nlead: "", nend: "" };
    var match = pattern.match(IntlBase2.customRegex);
    if (match) {
      if (!fractionOnly) {
        nData.nlead = changeCurrencySymbol(match[1], cSymbol);
        nData.nend = changeCurrencySymbol(match[10], cSymbol);
        nData.groupPattern = match[4];
      }
      var fraction = match[7];
      if (fraction && needFraction) {
        var fmatch = fraction.match(fractionRegex);
        if (!isNullOrUndefined(fmatch)) {
          nData.minimumFraction = fmatch.length;
        } else {
          nData.minimumFraction = 0;
        }
        nData.maximumFraction = fraction.length - 1;
      }
    }
    return nData;
  }
  IntlBase2.getFormatData = getFormatData;
  function changeCurrencySymbol(val, sym) {
    if (val) {
      val = val.replace(IntlBase2.defaultCurrency, sym);
      return sym === "" ? val.trim() : val;
    }
    return "";
  }
  IntlBase2.changeCurrencySymbol = changeCurrencySymbol;
  function getCurrencySymbol(numericObject, currencyCode, altSymbol, ignoreCurrency) {
    var symbol = altSymbol ? "." + altSymbol : ".symbol";
    var getCurrency = ignoreCurrency ? "$" : getValue("currencies." + currencyCode + symbol, numericObject) || getValue("currencies." + currencyCode + ".symbol-alt-narrow", numericObject) || "$";
    return getCurrency;
  }
  IntlBase2.getCurrencySymbol = getCurrencySymbol;
  function customFormat(format, dOptions, obj) {
    var options = {};
    var formatSplit = format.split(";");
    var data = ["pData", "nData", "zeroData"];
    for (var i = 0; i < formatSplit.length; i++) {
      options["" + data[parseInt(i.toString(), 10)]] = customNumberFormat(formatSplit[parseInt(i.toString(), 10)], dOptions, obj);
    }
    if (isNullOrUndefined(options.nData)) {
      options.nData = extend({}, options.pData);
      options.nData.nlead = isNullOrUndefined(dOptions) ? "-" + options.nData.nlead : dOptions.minusSymbol + options.nData.nlead;
    }
    return options;
  }
  IntlBase2.customFormat = customFormat;
  function customNumberFormat(format, dOptions, numObject) {
    var cOptions = { type: "decimal", minimumFractionDigits: 0, maximumFractionDigits: 0 };
    var pattern = format.match(IntlBase2.customRegex);
    if (isNullOrUndefined(pattern) || pattern[5] === "" && format !== "N/A") {
      cOptions.type = undefined;
      return cOptions;
    }
    cOptions.nlead = pattern[1];
    cOptions.nend = pattern[10];
    var integerPart = pattern[6];
    var spaceCapture = integerPart.match(/ $/g) ? true : false;
    var spaceGrouping = integerPart.replace(/ $/g, "").indexOf(" ") !== -1;
    cOptions.useGrouping = integerPart.indexOf(",") !== -1 || spaceGrouping;
    integerPart = integerPart.replace(/,/g, "");
    integerPart = /\s$/.test(integerPart) ? integerPart.replace(/ /g, "") : integerPart;
    var fractionPart = pattern[7];
    if (integerPart.indexOf("0") !== -1) {
      cOptions.minimumIntegerDigits = integerPart.length - integerPart.indexOf("0");
    }
    if (!isNullOrUndefined(fractionPart)) {
      cOptions.minimumFractionDigits = fractionPart.lastIndexOf("0");
      cOptions.maximumFractionDigits = fractionPart.lastIndexOf("#");
      if (cOptions.minimumFractionDigits === -1) {
        cOptions.minimumFractionDigits = 0;
      }
      if (cOptions.maximumFractionDigits === -1 || cOptions.maximumFractionDigits < cOptions.minimumFractionDigits) {
        cOptions.maximumFractionDigits = cOptions.minimumFractionDigits;
      }
    }
    if (!isNullOrUndefined(dOptions)) {
      dOptions.isCustomFormat = true;
      extend(cOptions, isCurrencyPercent([cOptions.nlead, cOptions.nend], "$", dOptions.currencySymbol));
      if (!cOptions.isCurrency) {
        extend(cOptions, isCurrencyPercent([cOptions.nlead, cOptions.nend], "%", dOptions.percentSymbol));
      }
    } else {
      extend(cOptions, isCurrencyPercent([cOptions.nlead, cOptions.nend], "%", "%"));
    }
    if (!isNullOrUndefined(numObject)) {
      var symbolPattern = getSymbolPattern(cOptions.type, dOptions.numberMapper.numberSystem, numObject, false);
      if (cOptions.useGrouping) {
        cOptions.groupSeparator = spaceGrouping ? " " : dOptions.numberMapper.numberSymbols[mapper2[2]];
        cOptions.groupData = NumberFormat$1.getGroupingDetails(symbolPattern.split(";")[0]);
      }
      cOptions.nlead = cOptions.nlead.replace(/'/g, "");
      cOptions.nend = spaceCapture ? " " + cOptions.nend.replace(/'/g, "") : cOptions.nend.replace(/'/g, "");
    }
    return cOptions;
  }
  IntlBase2.customNumberFormat = customNumberFormat;
  function isCurrencyPercent(parts, actual, symbol) {
    var options = { nlead: parts[0], nend: parts[1] };
    for (var i = 0; i < 2; i++) {
      var part = parts[parseInt(i.toString(), 10)];
      var loc = part.indexOf(actual);
      if (loc !== -1 && (loc < part.indexOf("'") || loc > part.lastIndexOf("'"))) {
        options["" + typeMapper[parseInt(i.toString(), 10)]] = part.substr(0, loc) + symbol + part.substr(loc + 1);
        options["" + typeMapper["" + actual]] = true;
        options.type = options.isCurrency ? "currency" : "percent";
        break;
      }
    }
    return options;
  }
  IntlBase2.isCurrencyPercent = isCurrencyPercent;
  function getDateSeparator(dateObj) {
    var value = (getValue("dateFormats.short", dateObj) || "").match(/[dM]([^dM])[dM]/i);
    return value ? value[1] : "/";
  }
  IntlBase2.getDateSeparator = getDateSeparator;
  function getActualDateTimeFormat(culture, options, cldr, isExcelFormat) {
    var dependable = getDependables(cldr, culture, options.calendar);
    var actualPattern = options.format || getResultantPattern(options.skeleton, dependable.dateObject, options.type);
    if (isExcelFormat) {
      actualPattern = actualPattern.replace(patternRegex, function(pattern2) {
        return patternMatch["" + pattern2];
      });
      if (actualPattern.indexOf("z") !== -1) {
        var tLength = actualPattern.match(/z/g).length;
        var timeZonePattern = undefined;
        var options_1 = { "timeZone": {} };
        options_1.numMapper = ParserBase.getNumberMapper(dependable.parserObject, ParserBase.getNumberingSystem(cldr));
        options_1.timeZone = getValue("dates.timeZoneNames", dependable.parserObject);
        var value = /* @__PURE__ */ new Date();
        var timezone = value.getTimezoneOffset();
        var pattern = tLength < 4 ? "+H;-H" : options_1.timeZone.hourFormat;
        pattern = pattern.replace(/:/g, options_1.numMapper.timeSeparator);
        if (timezone === 0) {
          timeZonePattern = options_1.timeZone.gmtZeroFormat;
        } else {
          timeZonePattern = DateFormat$1.getTimeZoneValue(timezone, pattern);
          timeZonePattern = options_1.timeZone.gmtFormat.replace(/\{0\}/, timeZonePattern);
        }
        actualPattern = actualPattern.replace(/[z]+/, '"' + timeZonePattern + '"');
      }
      actualPattern = actualPattern.replace(/ $/, "");
    }
    return actualPattern;
  }
  IntlBase2.getActualDateTimeFormat = getActualDateTimeFormat;
  function processSymbol(actual, option) {
    if (actual.indexOf(",") !== -1) {
      var split = actual.split(",");
      actual = split[0] + getValue("numberMapper.numberSymbols.group", option) + split[1].replace(".", getValue("numberMapper.numberSymbols.decimal", option));
    } else {
      actual = actual.replace(".", getValue("numberMapper.numberSymbols.decimal", option));
    }
    return actual;
  }
  IntlBase2.processSymbol = processSymbol;
  function getActualNumberFormat(culture, options, cldr, isExcel) {
    var dependable = getDependables(cldr, culture, "", true);
    var parseOptions = { custom: true };
    dependable.numericObject;
    var minFrac;
    var curObj = {};
    var curMatch = (options.format || "").match(IntlBase2.currencyFormatRegex);
    IntlBase2.formatRegex.test(options.format) ? getProperNumericSkeleton(options.format || "N") : {};
    var dOptions = {};
    if (curMatch) {
      dOptions.numberMapper = ParserBase.getNumberMapper(dependable.parserObject, ParserBase.getNumberingSystem(cldr), true);
      var curCode = getCurrencySymbol(dependable.numericObject, options.currency || defaultCurrencyCode, options.altSymbol);
      var symbolPattern = getSymbolPattern("currency", dOptions.numberMapper.numberSystem, dependable.numericObject, /a/i.test(options.format));
      symbolPattern = symbolPattern.replace(/\u00A4/g, curCode);
      var split = symbolPattern.split(";");
      curObj.hasNegativePattern = split.length > 1;
      curObj.nData = getFormatData(split[1] || "-" + split[0], true, curCode);
      curObj.pData = getFormatData(split[0], false, curCode);
      if (!curMatch[2] && !options.minimumFractionDigits && !options.maximumFractionDigits) {
        minFrac = getFormatData(symbolPattern.split(";")[0], true, "", true).minimumFraction;
      }
    }
    var actualPattern;
    if (IntlBase2.formatRegex.test(options.format) || !options.format) {
      extend(parseOptions, getProperNumericSkeleton(options.format || "N"));
      parseOptions.custom = false;
      actualPattern = "###0";
      if (parseOptions.fractionDigits || options.minimumFractionDigits || options.maximumFractionDigits || minFrac) {
        var defaultMinimum = 0;
        if (parseOptions.fractionDigits) {
          options.minimumFractionDigits = options.maximumFractionDigits = parseOptions.fractionDigits;
        }
        actualPattern = fractionDigitsPattern(actualPattern, minFrac || parseOptions.fractionDigits || options.minimumFractionDigits || defaultMinimum, options.maximumFractionDigits || defaultMinimum);
      }
      if (options.minimumIntegerDigits) {
        actualPattern = minimumIntegerPattern(actualPattern, options.minimumIntegerDigits);
      }
      if (options.useGrouping) {
        actualPattern = groupingPattern(actualPattern);
      }
      if (parseOptions.type === "currency" || parseOptions.type && isBlazor()) {
        var cPattern = actualPattern;
        actualPattern = curObj.pData.nlead + cPattern + curObj.pData.nend;
        if (curObj.hasNegativePattern || isBlazor()) {
          actualPattern += ";" + curObj.nData.nlead + cPattern + curObj.nData.nend;
        }
      }
      if (parseOptions.type === "percent" && true) {
        actualPattern += " %";
      }
    } else {
      actualPattern = options.format.replace(/'/g, '"');
    }
    if (Object.keys(dOptions).length > 0) {
      actualPattern = !isExcel ? processSymbol(actualPattern, dOptions) : actualPattern;
    }
    return actualPattern;
  }
  IntlBase2.getActualNumberFormat = getActualNumberFormat;
  function fractionDigitsPattern(pattern, minDigits, maxDigits) {
    pattern += ".";
    for (var a = 0; a < minDigits; a++) {
      pattern += "0";
    }
    if (minDigits < maxDigits) {
      var diff = maxDigits - minDigits;
      for (var b = 0; b < diff; b++) {
        pattern += "#";
      }
    }
    return pattern;
  }
  IntlBase2.fractionDigitsPattern = fractionDigitsPattern;
  function minimumIntegerPattern(pattern, digits) {
    var temp = pattern.split(".");
    var integer = "";
    for (var x = 0; x < digits; x++) {
      integer += "0";
    }
    return temp[1] ? integer + "." + temp[1] : integer;
  }
  IntlBase2.minimumIntegerPattern = minimumIntegerPattern;
  function groupingPattern(pattern) {
    var temp = pattern.split(".");
    var integer = temp[0];
    var no = 3 - integer.length % 3;
    var hash = no && no === 1 ? "#" : no === 2 ? "##" : "";
    integer = hash + integer;
    pattern = "";
    for (var x = integer.length - 1; x > 0; x = x - 3) {
      pattern = "," + integer[x - 2] + integer[x - 1] + integer[parseInt(x.toString(), 10)] + pattern;
    }
    pattern = pattern.slice(1);
    return temp[1] ? pattern + "." + temp[1] : pattern;
  }
  IntlBase2.groupingPattern = groupingPattern;
  function getWeekData(culture, cldr) {
    var firstDay = defaultFirstDay;
    var mapper3 = getValue("supplemental.weekData.firstDay", cldr);
    var iCulture = culture;
    if (/en-/.test(iCulture)) {
      iCulture = iCulture.slice(3);
    }
    iCulture = iCulture.slice(0, 2).toUpperCase() + iCulture.substr(2);
    if (mapper3) {
      firstDay = mapper3["" + iCulture] || mapper3[iCulture.slice(0, 2)] || defaultFirstDay;
    }
    return firstDayMapper["" + firstDay];
  }
  IntlBase2.getWeekData = getWeekData;
  function replaceBlazorCurrency(pData, aCurrency, rCurrency) {
    var iCurrency = getBlazorCurrencySymbol(rCurrency);
    if (aCurrency !== iCurrency) {
      for (var _i = 0, pData_1 = pData; _i < pData_1.length; _i++) {
        var data = pData_1[_i];
        data.nend = data.nend.replace(aCurrency, iCurrency);
        data.nlead = data.nlead.replace(aCurrency, iCurrency);
      }
    }
  }
  IntlBase2.replaceBlazorCurrency = replaceBlazorCurrency;
  function getWeekOfYear(date, firstDayOfWeek) {
    var newYear = new Date(date.getFullYear(), 0, 1);
    var day = newYear.getDay();
    var weeknum;
    day = day >= 0 ? day : day + 7;
    var daynum = Math.floor((date.getTime() - newYear.getTime() - (date.getTimezoneOffset() - newYear.getTimezoneOffset()) * 6e4) / 864e5) + 1;
    if (day < 4) {
      weeknum = Math.floor((daynum + day - firstDayOfWeek - 1) / 7) + 1;
      if (weeknum > 52) {
        var nYear = new Date(date.getFullYear() + 1, 0, 1);
        var nday = nYear.getDay();
        nday = nday >= 0 ? nday : nday + 7;
        weeknum = nday < 4 ? 1 : 53;
      }
    } else {
      weeknum = Math.floor((daynum + day - firstDayOfWeek - 1) / 7);
    }
    return weeknum;
  }
  IntlBase2.getWeekOfYear = getWeekOfYear;
})(IntlBase || (IntlBase = {}));
var headerRegex = /^(.*?):[ \t]*([^\r\n]*)$/gm;
var defaultType = "GET";
var Ajax = (
  /** @class */
  function() {
    function Ajax2(options, type, async, contentType) {
      this.mode = true;
      this.emitError = true;
      this.options = {};
      if (typeof options === "string") {
        this.url = options;
        this.type = type ? type.toUpperCase() : defaultType;
        this.mode = !isNullOrUndefined(async) ? async : true;
      } else if (typeof options === "object") {
        this.options = options;
        merge(this, this.options);
      }
      this.type = this.type ? this.type.toUpperCase() : defaultType;
      this.contentType = this.contentType !== undefined ? this.contentType : contentType;
    }
    Ajax2.prototype.send = function(data) {
      var _this = this;
      this.data = isNullOrUndefined(data) ? this.data : data;
      var eventArgs = {
        cancel: false,
        httpRequest: null
      };
      var promise = new Promise(function(resolve, reject) {
        _this.httpRequest = new (undefined)();
        _this.httpRequest.onreadystatechange = function() {
          _this.stateChange(resolve, reject);
        };
        if (!isNullOrUndefined(_this.onLoad)) {
          _this.httpRequest.onload = _this.onLoad;
        }
        if (!isNullOrUndefined(_this.onProgress)) {
          _this.httpRequest.onprogress = _this.onProgress;
        }
        if (!isNullOrUndefined(_this.onAbort)) {
          _this.httpRequest.onabort = _this.onAbort;
        }
        if (!isNullOrUndefined(_this.onError)) {
          _this.httpRequest.onerror = _this.onError;
        }
        if (!isNullOrUndefined(_this.onUploadProgress)) {
          _this.httpRequest.upload.onprogress = _this.onUploadProgress;
        }
        _this.httpRequest.open(_this.type, _this.url, _this.mode);
        if (!isNullOrUndefined(_this.data) && _this.contentType !== null) {
          _this.httpRequest.setRequestHeader("Content-Type", _this.contentType || "application/json; charset=utf-8");
        }
        if (_this.beforeSend) {
          eventArgs.httpRequest = _this.httpRequest;
          _this.beforeSend(eventArgs);
        }
        if (!eventArgs.cancel) {
          _this.httpRequest.send(!isNullOrUndefined(_this.data) ? _this.data : null);
        }
      });
      return promise;
    };
    Ajax2.prototype.successHandler = function(data) {
      if (this.onSuccess) {
        this.onSuccess(data, this);
      }
      return data;
    };
    Ajax2.prototype.failureHandler = function(reason) {
      if (this.onFailure) {
        this.onFailure(this.httpRequest);
      }
      return reason;
    };
    Ajax2.prototype.stateChange = function(resolve, reject) {
      var data = this.httpRequest.responseText;
      if (this.dataType && this.dataType.toLowerCase() === "json") {
        if (data === "") {
          data = undefined;
        } else {
          try {
            data = JSON.parse(data);
          } catch (error) {
          }
        }
      }
      if (this.httpRequest.readyState === 4) {
        if (this.httpRequest.status >= 200 && this.httpRequest.status <= 299 || this.httpRequest.status === 304) {
          resolve(this.successHandler(data));
        } else {
          if (this.emitError) {
            reject(new Error(this.failureHandler(this.httpRequest.statusText)));
          } else {
            resolve();
          }
        }
      }
    };
    Ajax2.prototype.getResponseHeader = function(key) {
      var responseHeaders = {};
      var headers = headerRegex.exec(this.httpRequest.getAllResponseHeaders());
      while (headers) {
        responseHeaders[headers[1].toLowerCase()] = headers[2];
        headers = headerRegex.exec(this.httpRequest.getAllResponseHeaders());
      }
      var header = responseHeaders[key.toLowerCase()];
      return isNullOrUndefined(header) ? null : header;
    };
    return Ajax2;
  }()
);
var Fetch = (
  /** @class */
  function() {
    function Fetch2(options, type, contentType) {
      this.type = "GET";
      this.emitError = true;
      if (typeof options === "string") {
        this.url = options;
        this.type = !isNullOrUndefined(type) ? type.toUpperCase() : this.type;
        this.contentType = contentType;
      } else if (isObject(options) && Object.keys(options).length > 0) {
        merge(this, options);
      }
      this.contentType = !isNullOrUndefined(this.contentType) ? this.contentType : "application/json; charset=utf-8";
    }
    Fetch2.prototype.send = function(data) {
      var _this = this;
      var contentTypes = {
        "application/json": "json",
        "multipart/form-data": "formData",
        "application/octet-stream": "blob",
        "application/x-www-form-urlencoded": "formData"
      };
      try {
        if (isNullOrUndefined(this.fetchRequest) && this.type === "GET") {
          this.fetchRequest = new Request(this.url, { method: this.type });
        } else if (isNullOrUndefined(this.fetchRequest)) {
          this.data = !isNullOrUndefined(data) ? data : this.data;
          this.fetchRequest = new Request(this.url, {
            method: this.type,
            headers: { "Content-Type": this.contentType },
            body: this.data
          });
        }
        var eventArgs = { cancel: false, fetchRequest: this.fetchRequest };
        this.triggerEvent(this["beforeSend"], eventArgs);
        if (eventArgs.cancel) {
          return null;
        }
        this.fetchResponse = fetch(this.fetchRequest);
        return this.fetchResponse.then(function(response) {
          _this.triggerEvent(_this["onLoad"], response);
          if (!response.ok) {
            throw response;
          }
          var responseType = "text";
          for (var _i = 0, _a = Object.keys(contentTypes); _i < _a.length; _i++) {
            var key = _a[_i];
            if (response.headers.get("Content-Type") && response.headers.get("Content-Type").indexOf(key) !== -1) {
              responseType = contentTypes[key];
            }
          }
          return response[responseType]();
        }).then(function(data2) {
          _this.triggerEvent(_this["onSuccess"], data2, _this);
          return data2;
        }).catch(function(error) {
          var returnVal = {};
          if (_this.emitError) {
            _this.triggerEvent(_this["onFailure"], error);
            returnVal = Promise.reject(error);
          }
          return returnVal;
        });
      } catch (error) {
        return error;
      }
    };
    Fetch2.prototype.triggerEvent = function(callback, data, instance) {
      if (!isNullOrUndefined(callback) && typeof callback === "function") {
        callback(data, instance);
      }
    };
    return Fetch2;
  }()
);
var REGX_MOBILE = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini|mobile/i;
var REGX_IE = /msie|trident/i;
var REGX_IE11 = /Trident\/7\./;
var REGX_IOS = /(ipad|iphone|ipod touch)/i;
var REGX_IOS7 = /(ipad|iphone|ipod touch);.*os 7_\d|(ipad|iphone|ipod touch);.*os 8_\d/i;
var REGX_ANDROID = /android/i;
var REGX_WINDOWS = /trident|windows phone|edge/i;
var REGX_VERSION = /(version)[ /]([\w.]+)/i;
var REGX_BROWSER = {
  OPERA: /(opera|opr)(?:.*version|)[ /]([\w.]+)/i,
  EDGE: /(edge)(?:.*version|)[ /]([\w.]+)/i,
  CHROME: /(chrome|crios)[ /]([\w.]+)/i,
  PANTHOMEJS: /(phantomjs)[ /]([\w.]+)/i,
  SAFARI: /(safari)[ /]([\w.]+)/i,
  WEBKIT: /(webkit)[ /]([\w.]+)/i,
  MSIE: /(msie|trident) ([\w.]+)/i,
  MOZILLA: /(mozilla)(?:.*? rv:([\w.]+)|)/i
};
var Browser = (
  /** @class */
  function() {
    function Browser2() {
    }
    Browser2.extractBrowserDetail = function() {
      var browserInfo = { culture: {} };
      var keys2 = Object.keys(REGX_BROWSER);
      var clientInfo = [];
      for (var _i = 0, keys_1 = keys2; _i < keys_1.length; _i++) {
        var key = keys_1[_i];
        clientInfo = Browser2.userAgent.match(REGX_BROWSER["" + key]);
        if (clientInfo) {
          browserInfo.name = clientInfo[1].toLowerCase() === "opr" ? "opera" : clientInfo[1].toLowerCase();
          browserInfo.name = clientInfo[1].toLowerCase() === "crios" ? "chrome" : browserInfo.name;
          browserInfo.version = clientInfo[2];
          browserInfo.culture.name = browserInfo.culture.language = (undefined).language;
          if (Browser2.userAgent.match(REGX_IE11)) {
            browserInfo.name = "msie";
            break;
          }
          var version = Browser2.userAgent.match(REGX_VERSION);
          if (browserInfo.name === "safari" && version) {
            browserInfo.version = version[2];
          }
          break;
        }
      }
      return browserInfo;
    };
    Browser2.getEvent = function(event) {
      var events = {
        start: {
          isPointer: "pointerdown",
          isTouch: "touchstart",
          isDevice: "mousedown"
        },
        move: {
          isPointer: "pointermove",
          isTouch: "touchmove",
          isDevice: "mousemove"
        },
        end: {
          isPointer: "pointerup",
          isTouch: "touchend",
          isDevice: "mouseup"
        },
        cancel: {
          isPointer: "pointercancel",
          isTouch: "touchcancel",
          isDevice: "mouseleave"
        }
      };
      return Browser2.isPointer ? events["" + event].isPointer : Browser2.isTouch ? events["" + event].isTouch + (!Browser2.isDevice ? " " + events["" + event].isDevice : "") : events["" + event].isDevice;
    };
    Browser2.getTouchStartEvent = function() {
      return Browser2.getEvent("start");
    };
    Browser2.getTouchEndEvent = function() {
      return Browser2.getEvent("end");
    };
    Browser2.getTouchMoveEvent = function() {
      return Browser2.getEvent("move");
    };
    Browser2.getTouchCancelEvent = function() {
      return Browser2.getEvent("cancel");
    };
    Browser2.isSafari = function() {
      return Browser2.isDevice && Browser2.isIos && Browser2.isTouch && false;
    };
    Browser2.getValue = function(key, regX) {
      var browserDetails = {};
      if ("undefined" === typeof browserDetails["" + key]) {
        return browserDetails["" + key] = regX.test(Browser2.userAgent);
      }
      return browserDetails["" + key];
    };
    Object.defineProperty(Browser2, "userAgent", {
      get: function() {
        return Browser2.uA;
      },
      //Properties
      /**
       * Property specifies the userAgent of the browser. Default userAgent value is based on the browser.
       * Also we can set our own userAgent.
       *
       * @param {string} uA ?
       */
      set: function(uA) {
        Browser2.uA = uA;
        (undefined).browserDetails = {};
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Browser2, "info", {
      //Read Only Properties
      /**
       * Property is to get the browser information like Name, Version and Language
       *
       * @returns {BrowserInfo} ?
       */
      get: function() {
        if (isUndefined((undefined).browserDetails.info)) {
          return (undefined).browserDetails.info = Browser2.extractBrowserDetail();
        }
        return (undefined).browserDetails.info;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Browser2, "isIE", {
      /**
       * Property is to get whether the userAgent is based IE.
       *
       * @returns {boolean} ?
       */
      get: function() {
        return Browser2.getValue("isIE", REGX_IE);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Browser2, "isTouch", {
      /**
       * Property is to get whether the browser has touch support.
       *
       * @returns {boolean} ?
       */
      get: function() {
        if (isUndefined((undefined).browserDetails.isTouch)) {
          return (undefined).browserDetails.isTouch = "ontouchstart" in (undefined).navigator || undefined || "ontouchstart" in undefined;
        }
        return (undefined).browserDetails.isTouch;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Browser2, "isPointer", {
      /**
       * Property is to get whether the browser has Pointer support.
       *
       * @returns {boolean} ?
       */
      get: function() {
        if (isUndefined((undefined).browserDetails.isPointer)) {
          return (undefined).browserDetails.isPointer = "pointerEnabled" in (undefined).navigator;
        }
        return (undefined).browserDetails.isPointer;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Browser2, "isMSPointer", {
      /**
       * Property is to get whether the browser has MSPointer support.
       *
       * @returns {boolean} ?
       */
      get: function() {
        if (isUndefined((undefined).browserDetails.isMSPointer)) {
          return (undefined).browserDetails.isMSPointer = "msPointerEnabled" in (undefined).navigator;
        }
        return (undefined).browserDetails.isMSPointer;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Browser2, "isDevice", {
      /**
       * Property is to get whether the userAgent is device based.
       *
       * @returns {boolean} ?
       */
      get: function() {
        return Browser2.getValue("isDevice", REGX_MOBILE);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Browser2, "isIos", {
      /**
       * Property is to get whether the userAgent is IOS.
       *
       * @returns {boolean} ?
       */
      get: function() {
        return Browser2.getValue("isIos", REGX_IOS);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Browser2, "isIos7", {
      /**
       * Property is to get whether the userAgent is Ios7.
       *
       * @returns {boolean} ?
       */
      get: function() {
        return Browser2.getValue("isIos7", REGX_IOS7);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Browser2, "isAndroid", {
      /**
       * Property is to get whether the userAgent is Android.
       *
       * @returns {boolean} ?
       */
      get: function() {
        return Browser2.getValue("isAndroid", REGX_ANDROID);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Browser2, "isWebView", {
      /**
       * Property is to identify whether application ran in web view.
       *
       * @returns {boolean} ?
       */
      get: function() {
        if (isUndefined((undefined).browserDetails.isWebView)) {
          (undefined).browserDetails.isWebView = !(isUndefined((undefined).cordova) && isUndefined((undefined).PhoneGap) && isUndefined((undefined).phonegap) && (undefined).forge !== "object");
          return (undefined).browserDetails.isWebView;
        }
        return (undefined).browserDetails.isWebView;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Browser2, "isWindows", {
      /**
       * Property is to get whether the userAgent is Windows.
       *
       * @returns {boolean} ?
       */
      get: function() {
        return Browser2.getValue("isWindows", REGX_WINDOWS);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Browser2, "touchStartEvent", {
      /**
       * Property is to get the touch start event. It returns event name based on browser.
       *
       * @returns {string} ?
       */
      get: function() {
        if (isUndefined((undefined).browserDetails.touchStartEvent)) {
          return (undefined).browserDetails.touchStartEvent = Browser2.getTouchStartEvent();
        }
        return (undefined).browserDetails.touchStartEvent;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Browser2, "touchMoveEvent", {
      /**
       * Property is to get the touch move event. It returns event name based on browser.
       *
       * @returns {string} ?
       */
      get: function() {
        if (isUndefined((undefined).browserDetails.touchMoveEvent)) {
          return (undefined).browserDetails.touchMoveEvent = Browser2.getTouchMoveEvent();
        }
        return (undefined).browserDetails.touchMoveEvent;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Browser2, "touchEndEvent", {
      /**
       * Property is to get the touch end event. It returns event name based on browser.
       *
       * @returns {string} ?
       */
      get: function() {
        if (isUndefined((undefined).browserDetails.touchEndEvent)) {
          return (undefined).browserDetails.touchEndEvent = Browser2.getTouchEndEvent();
        }
        return (undefined).browserDetails.touchEndEvent;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Browser2, "touchCancelEvent", {
      /**
       * Property is to cancel the touch end event.
       *
       * @returns {string} ?
       */
      get: function() {
        if (isUndefined((undefined).browserDetails.touchCancelEvent)) {
          return (undefined).browserDetails.touchCancelEvent = Browser2.getTouchCancelEvent();
        }
        return (undefined).browserDetails.touchCancelEvent;
      },
      enumerable: true,
      configurable: true
    });
    Browser2.uA = "";
    return Browser2;
  }()
);
var EventHandler = (
  /** @class */
  function() {
    function EventHandler2() {
    }
    EventHandler2.addOrGetEventData = function(element2) {
      if ("__eventList" in element2) {
        return element2.__eventList.events;
      } else {
        element2.__eventList = {};
        return element2.__eventList.events = [];
      }
    };
    EventHandler2.add = function(element2, eventName, listener, bindTo, intDebounce) {
      var eventData = EventHandler2.addOrGetEventData(element2);
      var debounceListener;
      if (intDebounce) {
        debounceListener = debounce(listener, intDebounce);
      } else {
        debounceListener = listener;
      }
      if (bindTo) {
        debounceListener = debounceListener.bind(bindTo);
      }
      var event = eventName.split(" ");
      for (var i = 0; i < event.length; i++) {
        eventData.push({
          name: event[parseInt(i.toString(), 10)],
          listener,
          debounce: debounceListener
        });
        if (Browser.isIE) {
          element2.addEventListener(event[parseInt(i.toString(), 10)], debounceListener);
        } else {
          element2.addEventListener(event[parseInt(i.toString(), 10)], debounceListener, { passive: false });
        }
      }
      return debounceListener;
    };
    EventHandler2.remove = function(element2, eventName, listener) {
      var eventData = EventHandler2.addOrGetEventData(element2);
      var event = eventName.split(" ");
      var _loop_1 = function(j2) {
        var index = -1;
        var debounceListener;
        if (eventData && eventData.length !== 0) {
          eventData.some(function(x, i) {
            return x.name === event[parseInt(j2.toString(), 10)] && x.listener === listener ? (index = i, debounceListener = x.debounce, true) : false;
          });
        }
        if (index !== -1) {
          eventData.splice(index, 1);
        }
        if (debounceListener) {
          element2.removeEventListener(event[parseInt(j2.toString(), 10)], debounceListener);
        }
      };
      for (var j = 0; j < event.length; j++) {
        _loop_1(j);
      }
    };
    EventHandler2.clearEvents = function(element2) {
      var eventData = EventHandler2.addOrGetEventData(element2);
      var copyData = extend([], undefined, eventData);
      for (var i = 0; i < copyData.length; i++) {
        var parseValue = copyData[parseInt(i.toString(), 10)];
        element2.removeEventListener(parseValue.name, parseValue.debounce);
        eventData.shift();
      }
    };
    EventHandler2.trigger = function(element2, eventName, eventProp) {
      var eventData = EventHandler2.addOrGetEventData(element2);
      for (var _i = 0, eventData_1 = eventData; _i < eventData_1.length; _i++) {
        var event_1 = eventData_1[_i];
        if (event_1.name === eventName) {
          event_1.debounce.call(this, eventProp);
        }
      }
    };
    return EventHandler2;
  }()
);
var __assign$1 = function() {
  __assign$1 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign$1.apply(this, arguments);
};
var SVG_REG = /^svg|^path|^g/;
function createElement(tagName, properties2) {
  var element2 = SVG_REG.test(tagName) ? (undefined).createElementNS("http://www.w3.org/2000/svg", tagName) : (undefined).createElement(tagName);
  if (typeof properties2 === "undefined") {
    return element2;
  }
  element2.innerHTML = properties2.innerHTML ? properties2.innerHTML : "";
  if (properties2.className !== undefined) {
    element2.className = properties2.className;
  }
  if (properties2.id !== undefined) {
    element2.id = properties2.id;
  }
  if (properties2.styles !== undefined) {
    element2.style.cssText = properties2.styles;
  }
  if (properties2.attrs !== undefined) {
    attributes(element2, properties2.attrs);
  }
  return element2;
}
function updateCSSText(element2, cssText) {
  var existingStyles = element2.style.cssText.split(";").reduce(function(styles, style) {
    var _a = style.split(":"), key = _a[0], value = _a[1];
    if (key && value) {
      styles[key.trim()] = value.trim();
    }
    return styles;
  }, {});
  var newStyles = cssText.split(";").reduce(function(styles, style) {
    var _a = style.split(":"), key = _a[0], value = _a[1];
    if (key && value) {
      styles[key.trim()] = value.trim();
    }
    return styles;
  }, {});
  var styleElement = (undefined).createElement("div");
  Object.keys(__assign$1({}, existingStyles, newStyles)).forEach(function(key) {
    styleElement.style.setProperty(key, newStyles[key] || existingStyles[key]);
  });
  element2.style.cssText = styleElement.style.cssText;
}
function addClass(elements, classes) {
  var classList2 = getClassList(classes);
  var regExp2 = RegExp;
  for (var _i = 0, _a = elements; _i < _a.length; _i++) {
    var ele = _a[_i];
    for (var _b = 0, classList_1 = classList2; _b < classList_1.length; _b++) {
      var className = classList_1[_b];
      if (isObject(ele)) {
        var curClass = getValue("attributes.className", ele);
        if (isNullOrUndefined(curClass)) {
          setValue("attributes.className", className, ele);
        } else if (!new regExp2("\\b" + className + "\\b", "i").test(curClass)) {
          setValue("attributes.className", curClass + " " + className, ele);
        }
      } else {
        if (!ele.classList.contains(className)) {
          ele.classList.add(className);
        }
      }
    }
  }
  return elements;
}
function removeClass(elements, classes) {
  var classList2 = getClassList(classes);
  for (var _i = 0, _a = elements; _i < _a.length; _i++) {
    var ele = _a[_i];
    var flag = isObject(ele);
    var canRemove = flag ? getValue("attributes.className", ele) : ele.className !== "";
    if (canRemove) {
      for (var _b = 0, classList_2 = classList2; _b < classList_2.length; _b++) {
        var className = classList_2[_b];
        if (flag) {
          var classes_1 = getValue("attributes.className", ele);
          var classArr = classes_1.split(" ");
          var index = classArr.indexOf(className);
          if (index !== -1) {
            classArr.splice(index, 1);
          }
          setValue("attributes.className", classArr.join(" "), ele);
        } else {
          ele.classList.remove(className);
        }
      }
    }
  }
  return elements;
}
function getClassList(classes) {
  var classList2 = [];
  if (typeof classes === "string") {
    classList2.push(classes);
  } else {
    classList2 = classes;
  }
  return classList2;
}
function isVisible(element2) {
  var ele = element2;
  return ele.style.visibility === "" && ele.offsetWidth > 0;
}
function prepend(fromElements, toElement, isEval) {
  var docFrag = (undefined).createDocumentFragment();
  for (var _i = 0, _a = fromElements; _i < _a.length; _i++) {
    var ele = _a[_i];
    docFrag.appendChild(ele);
  }
  toElement.insertBefore(docFrag, toElement.firstElementChild);
  if (isEval) {
    executeScript(toElement);
  }
  return fromElements;
}
function append(fromElements, toElement, isEval) {
  var docFrag = (undefined).createDocumentFragment();
  if (fromElements instanceof NodeList) {
    while (fromElements.length > 0) {
      docFrag.appendChild(fromElements[0]);
    }
  } else {
    for (var _i = 0, _a = fromElements; _i < _a.length; _i++) {
      var ele = _a[_i];
      docFrag.appendChild(ele);
    }
  }
  toElement.appendChild(docFrag);
  if (isEval) {
    executeScript(toElement);
  }
  return fromElements;
}
function executeScript(ele) {
  var eleArray = ele.querySelectorAll("script");
  eleArray.forEach(function(element2) {
    var script = (undefined).createElement("script");
    script.text = element2.innerHTML;
    (undefined).head.appendChild(script);
    detach(script);
  });
}
function detach(element2) {
  var parentNode = element2.parentNode;
  if (parentNode) {
    return parentNode.removeChild(element2);
  }
}
function remove(element2) {
  var parentNode = element2.parentNode;
  EventHandler.clearEvents(element2);
  parentNode.removeChild(element2);
}
function attributes(element2, attributes2) {
  var keys2 = Object.keys(attributes2);
  var ele = element2;
  for (var _i = 0, keys_1 = keys2; _i < keys_1.length; _i++) {
    var key = keys_1[_i];
    if (isObject(ele)) {
      var iKey = key;
      if (key === "tabindex") {
        iKey = "tabIndex";
      }
      ele.attributes["" + iKey] = attributes2["" + key];
    } else {
      ele.setAttribute(key, attributes2["" + key]);
    }
  }
  return ele;
}
function select(selector, context, needsVDOM) {
  if (context === undefined) {
    context = undefined;
  }
  selector = querySelectId(selector);
  return context.querySelector(selector);
}
function selectAll(selector, context, needsVDOM) {
  if (context === undefined) {
    context = undefined;
  }
  selector = querySelectId(selector);
  var nodeList = context.querySelectorAll(selector);
  return nodeList;
}
function querySelectId(selector) {
  var charRegex = /(!|"|\$|%|&|'|\(|\)|\*|\/|:|;|<|=|\?|@|\]|\^|`|{|}|\||\+|~)/g;
  if (selector.match(/#[0-9]/g) || selector.match(charRegex)) {
    var idList = selector.split(",");
    for (var i = 0; i < idList.length; i++) {
      var list = idList[parseInt(i.toString(), 10)].split(" ");
      for (var j = 0; j < list.length; j++) {
        if (list[parseInt(j.toString(), 10)].indexOf("#") > -1) {
          if (!list[parseInt(j.toString(), 10)].match(/\[.*\]/)) {
            var splitId = list[parseInt(j.toString(), 10)].split("#");
            if (splitId[1].match(/^\d/) || splitId[1].match(charRegex)) {
              var setId = list[parseInt(j.toString(), 10)].split(".");
              setId[0] = setId[0].replace(/#/, "[id='") + "']";
              list[parseInt(j.toString(), 10)] = setId.join(".");
            }
          }
        }
      }
      idList[parseInt(i.toString(), 10)] = list.join(" ");
    }
    return idList.join(",");
  }
  return selector;
}
function closest(element2, selector) {
  var el = element2;
  if (typeof el.closest === "function") {
    return el.closest(selector);
  }
  while (el && el.nodeType === 1) {
    if (matches(el, selector)) {
      return el;
    }
    el = el.parentNode;
  }
  return null;
}
function setStyleAttribute(element2, attrs) {
  if (attrs !== undefined) {
    Object.keys(attrs).forEach(function(key) {
      element2.style["" + key] = attrs["" + key];
    });
  }
}
function classList(element2, addClasses, removeClasses) {
  addClass([element2], addClasses);
  removeClass([element2], removeClasses);
}
function matches(element2, selector) {
  var matches2 = element2.matches || element2.msMatchesSelector || element2.webkitMatchesSelector;
  if (matches2) {
    return matches2.call(element2, selector);
  } else {
    return [].indexOf.call((undefined).querySelectorAll(selector), element2) !== -1;
  }
}
var Observer = (
  /** @class */
  function() {
    function Observer2(context) {
      this.ranArray = [];
      this.boundedEvents = {};
      if (isNullOrUndefined(context)) {
        return;
      }
      this.context = context;
    }
    Observer2.prototype.on = function(property, handler, context, id) {
      if (isNullOrUndefined(handler)) {
        return;
      }
      var cntxt = context || this.context;
      if (this.notExist(property)) {
        this.boundedEvents["" + property] = [{ handler, context: cntxt, id }];
        return;
      }
      if (!isNullOrUndefined(id)) {
        if (this.ranArray.indexOf(id) === -1) {
          this.ranArray.push(id);
          this.boundedEvents["" + property].push({ handler, context: cntxt, id });
        }
      } else if (!this.isHandlerPresent(this.boundedEvents["" + property], handler)) {
        this.boundedEvents["" + property].push({ handler, context: cntxt });
      }
    };
    Observer2.prototype.off = function(property, handler, id) {
      if (this.notExist(property)) {
        return;
      }
      var curObject = getValue(property, this.boundedEvents);
      if (handler) {
        for (var i = 0; i < curObject.length; i++) {
          if (id) {
            if (curObject[parseInt(i.toString(), 10)].id === id) {
              curObject.splice(i, 1);
              var indexLocation = this.ranArray.indexOf(id);
              if (indexLocation !== -1) {
                this.ranArray.splice(indexLocation, 1);
              }
              break;
            }
          } else if (handler === curObject[parseInt(i.toString(), 10)].handler) {
            curObject.splice(i, 1);
            break;
          }
        }
      } else {
        delete this.boundedEvents["" + property];
      }
    };
    Observer2.prototype.notify = function(property, argument, successHandler, errorHandler) {
      if (this.notExist(property)) {
        if (successHandler) {
          successHandler.call(this, argument);
        }
        return;
      }
      if (argument) {
        argument.name = property;
      }
      var blazor = "Blazor";
      var curObject = getValue(property, this.boundedEvents).slice(0);
      if ((undefined)["" + blazor]) {
        return this.blazorCallback(curObject, argument, successHandler, errorHandler, 0);
      } else {
        for (var _i = 0, curObject_1 = curObject; _i < curObject_1.length; _i++) {
          var cur = curObject_1[_i];
          cur.handler.call(cur.context, argument);
        }
        if (successHandler) {
          successHandler.call(this, argument);
        }
      }
    };
    Observer2.prototype.blazorCallback = function(objs, argument, successHandler, errorHandler, index) {
      var _this = this;
      var isTrigger = index === objs.length - 1;
      if (index < objs.length) {
        var obj_1 = objs[parseInt(index.toString(), 10)];
        var promise = obj_1.handler.call(obj_1.context, argument);
        if (promise && typeof promise.then === "function") {
          if (!successHandler) {
            return promise;
          }
          promise.then(function(data) {
            data = typeof data === "string" && _this.isJson(data) ? JSON.parse(data, _this.dateReviver) : data;
            extend(argument, argument, data, true);
            if (successHandler && isTrigger) {
              successHandler.call(obj_1.context, argument);
            } else {
              return _this.blazorCallback(objs, argument, successHandler, errorHandler, index + 1);
            }
          }).catch(function(data) {
            if (errorHandler) {
              errorHandler.call(obj_1.context, typeof data === "string" && _this.isJson(data) ? JSON.parse(data, _this.dateReviver) : data);
            }
          });
        } else if (successHandler && isTrigger) {
          successHandler.call(obj_1.context, argument);
        } else {
          return this.blazorCallback(objs, argument, successHandler, errorHandler, index + 1);
        }
      }
    };
    Observer2.prototype.dateReviver = function(key, value) {
      var dPattern = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/;
      if (typeof value === "string" && value.match(dPattern) !== null) {
        return new Date(value);
      }
      return value;
    };
    Observer2.prototype.isJson = function(value) {
      try {
        JSON.parse(value);
      } catch (e) {
        return false;
      }
      return true;
    };
    Observer2.prototype.destroy = function() {
      this.boundedEvents = this.context = undefined;
    };
    Observer2.prototype.offIntlEvents = function() {
      var eventsArr = this.boundedEvents["notifyExternalChange"];
      if (eventsArr) {
        for (var i = 0; i < eventsArr.length; i++) {
          var curContext = eventsArr[parseInt(i.toString(), 10)].context;
          if (curContext && curContext.detectFunction && curContext.randomId && curContext.isReactMock) {
            this.off("notifyExternalChange", curContext.detectFunction, curContext.randomId);
            i--;
          }
        }
        if (!this.boundedEvents["notifyExternalChange"].length) {
          delete this.boundedEvents["notifyExternalChange"];
        }
      }
    };
    Observer2.prototype.notExist = function(prop) {
      return Object.prototype.hasOwnProperty.call(this.boundedEvents, prop) === false || this.boundedEvents["" + prop].length <= 0;
    };
    Observer2.prototype.isHandlerPresent = function(boundedEvents, handler) {
      for (var _i = 0, boundedEvents_1 = boundedEvents; _i < boundedEvents_1.length; _i++) {
        var cur = boundedEvents_1[_i];
        if (cur.handler === handler) {
          return true;
        }
      }
      return false;
    };
    return Observer2;
  }()
);
var isColEName = new RegExp("]");
var Base = (
  /** @class */
  function() {
    function Base2(options, element2) {
      this.isRendered = false;
      this.isComplexArraySetter = false;
      this.isServerRendered = false;
      this.allowServerDataBinding = true;
      this.isProtectedOnChange = true;
      this.properties = {};
      this.changedProperties = {};
      this.oldProperties = {};
      this.bulkChanges = {};
      this.refreshing = false;
      this.ignoreCollectionWatch = false;
      this.finalUpdate = function() {
      };
      this.childChangedProperties = {};
      this.modelObserver = new Observer(this);
      if (!isUndefined(element2)) {
        if ("string" === typeof element2) {
          this.element = (undefined).querySelector(element2);
        } else {
          this.element = element2;
        }
        if (!isNullOrUndefined(this.element)) {
          this.isProtectedOnChange = false;
          this.addInstance();
        }
      }
      if (!isUndefined(options)) {
        this.setProperties(options, true);
      }
      this.isDestroyed = false;
    }
    Base2.prototype.setProperties = function(prop, muteOnChange) {
      var prevDetection = this.isProtectedOnChange;
      this.isProtectedOnChange = !!muteOnChange;
      merge(this, prop);
      if (muteOnChange !== true) {
        merge(this.changedProperties, prop);
        this.dataBind();
      }
      this.finalUpdate();
      this.changedProperties = {};
      this.oldProperties = {};
      this.isProtectedOnChange = prevDetection;
    };
    Base2.callChildDataBind = function(obj, parent) {
      var keys2 = Object.keys(obj);
      for (var _i = 0, keys_1 = keys2; _i < keys_1.length; _i++) {
        var key = keys_1[_i];
        if (parent["" + key] instanceof Array) {
          for (var _a = 0, _b = parent["" + key]; _a < _b.length; _a++) {
            var obj_1 = _b[_a];
            if (obj_1.dataBind !== undefined) {
              obj_1.dataBind();
            }
          }
        } else {
          parent["" + key].dataBind();
        }
      }
    };
    Base2.prototype.clearChanges = function() {
      this.finalUpdate();
      this.changedProperties = {};
      this.oldProperties = {};
      this.childChangedProperties = {};
    };
    Base2.prototype.dataBind = function() {
      Base2.callChildDataBind(this.childChangedProperties, this);
      if (Object.getOwnPropertyNames(this.changedProperties).length) {
        var prevDetection = this.isProtectedOnChange;
        var newChanges = this.changedProperties;
        var oldChanges = this.oldProperties;
        this.clearChanges();
        this.isProtectedOnChange = true;
        this.onPropertyChanged(newChanges, oldChanges);
        this.isProtectedOnChange = prevDetection;
      }
    };
    Base2.prototype.serverDataBind = function(newChanges) {
      {
        return;
      }
    };
    Base2.prototype.saveChanges = function(key, newValue, oldValue) {
      if (this.isProtectedOnChange) {
        return;
      }
      this.oldProperties["" + key] = oldValue;
      this.changedProperties["" + key] = newValue;
      this.finalUpdate();
      this.finalUpdate = setImmediate(this.dataBind.bind(this));
    };
    Base2.prototype.addEventListener = function(eventName, handler) {
      this.modelObserver.on(eventName, handler);
    };
    Base2.prototype.removeEventListener = function(eventName, handler) {
      this.modelObserver.off(eventName, handler);
    };
    Base2.prototype.trigger = function(eventName, eventProp, successHandler, errorHandler) {
      var _this = this;
      if (this.isDestroyed !== true) {
        var prevDetection = this.isProtectedOnChange;
        this.isProtectedOnChange = false;
        var data = this.modelObserver.notify(eventName, eventProp, successHandler, errorHandler);
        if (isColEName.test(eventName)) {
          var handler = getValue(eventName, this);
          if (handler) {
            var blazor = "Blazor";
            if ((undefined)["" + blazor]) {
              var promise = handler.call(this, eventProp);
              if (promise && typeof promise.then === "function") {
                if (!successHandler) {
                  data = promise;
                } else {
                  promise.then(function(data2) {
                    if (successHandler) {
                      data2 = typeof data2 === "string" && _this.modelObserver.isJson(data2) ? JSON.parse(data2) : data2;
                      successHandler.call(_this, data2);
                    }
                  }).catch(function(data2) {
                    if (errorHandler) {
                      data2 = typeof data2 === "string" && _this.modelObserver.isJson(data2) ? JSON.parse(data2) : data2;
                      errorHandler.call(_this, data2);
                    }
                  });
                }
              } else if (successHandler) {
                successHandler.call(this, eventProp);
              }
            } else {
              handler.call(this, eventProp);
              if (successHandler) {
                successHandler.call(this, eventProp);
              }
            }
          } else if (successHandler) {
            successHandler.call(this, eventProp);
          }
        }
        this.isProtectedOnChange = prevDetection;
        return data;
      }
    };
    Base2.prototype.addInstance = function() {
      var moduleClass = "e-" + this.getModuleName().toLowerCase();
      addClass([this.element], ["e-lib", moduleClass]);
      if (!isNullOrUndefined(this.element.ej2_instances)) {
        this.element.ej2_instances.push(this);
      } else {
        setValue("ej2_instances", [this], this.element);
      }
    };
    Base2.prototype.destroy = function() {
      var _this = this;
      this.element.ej2_instances = this.element.ej2_instances ? this.element.ej2_instances.filter(function(i) {
        if (proxyToRaw) {
          return proxyToRaw(i) !== proxyToRaw(_this);
        }
        return i !== _this;
      }) : [];
      removeClass([this.element], ["e-" + this.getModuleName()]);
      if (this.element.ej2_instances.length === 0) {
        removeClass([this.element], ["e-lib"]);
      }
      this.clearChanges();
      this.modelObserver.destroy();
      this.isDestroyed = true;
    };
    return Base2;
  }()
);
function getComponent(elem, comp) {
  var instance;
  var i;
  var ele = typeof elem === "string" ? (undefined).getElementById(elem) : elem;
  if (ele && ele.ej2_instances) {
    for (i = 0; i < ele.ej2_instances.length; i++) {
      instance = ele.ej2_instances[parseInt(i.toString(), 10)];
      if (typeof comp === "string") {
        var compName = instance.getModuleName();
        if (comp === compName) {
          return instance;
        }
      } else {
        if (instance instanceof comp) {
          return instance;
        }
      }
    }
  }
  return undefined;
}
var proxyToRaw;
var setProxyToRaw = function(toRaw) {
  proxyToRaw = toRaw;
};
function getObject(instance, curKey, defaultValue, type) {
  if (!Object.prototype.hasOwnProperty.call(instance.properties, curKey) || !(instance.properties["" + curKey] instanceof type)) {
    instance.properties["" + curKey] = createInstance(type, [instance, curKey, defaultValue]);
  }
  return instance.properties["" + curKey];
}
function getObjectArray(instance, curKey, defaultValue, type, isSetter, isFactory) {
  var result = [];
  var len = defaultValue ? defaultValue.length : 0;
  for (var i = 0; i < len; i++) {
    var curType = type;
    if (isSetter) {
      var inst = createInstance(curType, [instance, curKey, {}, true]);
      inst.setProperties(defaultValue[parseInt(i.toString(), 10)], true);
      result.push(inst);
    } else {
      result.push(createInstance(curType, [instance, curKey, defaultValue[parseInt(i.toString(), 10)], false]));
    }
  }
  return result;
}
function propertyGetter(defaultValue, curKey) {
  return function() {
    if (!Object.prototype.hasOwnProperty.call(this.properties, curKey)) {
      this.properties["" + curKey] = defaultValue;
    }
    return this.properties["" + curKey];
  };
}
function propertySetter(defaultValue, curKey) {
  return function(newValue) {
    if (this.properties["" + curKey] !== newValue) {
      var oldVal = Object.prototype.hasOwnProperty.call(this.properties, curKey) ? this.properties["" + curKey] : defaultValue;
      this.saveChanges(curKey, newValue, oldVal);
      this.properties["" + curKey] = newValue;
    }
  };
}
function complexGetter(defaultValue, curKey, type) {
  return function() {
    return getObject(this, curKey, defaultValue, type);
  };
}
function complexSetter(defaultValue, curKey, type) {
  return function(newValue) {
    getObject(this, curKey, defaultValue, type).setProperties(newValue);
  };
}
function complexArrayGetter(defaultValue, curKey, type) {
  return function() {
    var _this = this;
    if (!Object.prototype.hasOwnProperty.call(this.properties, curKey)) {
      var defCollection = getObjectArray(this, curKey, defaultValue, type, false);
      this.properties["" + curKey] = defCollection;
    }
    var ignore = this.controlParent !== undefined && this.controlParent.ignoreCollectionWatch || this.ignoreCollectionWatch;
    if (!Object.prototype.hasOwnProperty.call(this.properties["" + curKey], "push") && !ignore) {
      ["push", "pop"].forEach(function(extendFunc) {
        var descriptor = {
          value: complexArrayDefinedCallback(extendFunc, curKey, type, _this.properties["" + curKey]).bind(_this),
          configurable: true
        };
        Object.defineProperty(_this.properties["" + curKey], extendFunc, descriptor);
      });
    }
    if (!Object.prototype.hasOwnProperty.call(this.properties["" + curKey], "isComplexArray")) {
      Object.defineProperty(this.properties["" + curKey], "isComplexArray", { value: true });
    }
    return this.properties["" + curKey];
  };
}
function complexArraySetter(defaultValue, curKey, type) {
  return function(newValue) {
    this.isComplexArraySetter = true;
    var oldValueCollection = getObjectArray(this, curKey, defaultValue, type, false);
    var newValCollection = getObjectArray(this, curKey, newValue, type, true);
    this.isComplexArraySetter = false;
    this.saveChanges(curKey, newValCollection, oldValueCollection);
    this.properties["" + curKey] = newValCollection;
  };
}
function complexArrayDefinedCallback(dFunc, curKey, type, prop) {
  return function() {
    var newValue = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      newValue[_i] = arguments[_i];
    }
    var keyString = this.propName ? this.getParentKey() + "." + curKey + "-" : curKey + "-";
    switch (dFunc) {
      case "push":
        for (var i = 0; i < newValue.length; i++) {
          var newValueParse = newValue[parseInt(i.toString(), 10)];
          Array.prototype["" + dFunc].apply(prop, [newValueParse]);
          var model = getArrayModel(keyString + (prop.length - 1), newValueParse, !this.controlParent, dFunc);
          this.serverDataBind(model, newValue[parseInt(i.toString(), 10)], false, dFunc);
        }
        break;
      case "pop": {
        Array.prototype["" + dFunc].apply(prop);
        var model = getArrayModel(keyString + prop.length, null, !this.controlParent, dFunc);
        this.serverDataBind(model, { ejsAction: "pop" }, false, dFunc);
        break;
      }
    }
    return prop;
  };
}
function getArrayModel(keyString, value, isControlParent, arrayFunction) {
  var modelObject = keyString;
  if (isControlParent) {
    modelObject = {};
    modelObject["" + keyString] = value;
    if (value && typeof value === "object") {
      var action = "ejsAction";
      modelObject["" + keyString]["" + action] = arrayFunction;
    }
  }
  return modelObject;
}
function Property(defaultValue) {
  return function(target, key) {
    var propertyDescriptor = {
      set: propertySetter(defaultValue, key),
      get: propertyGetter(defaultValue, key),
      enumerable: true,
      configurable: true
    };
    Object.defineProperty(target, key, propertyDescriptor);
    addPropertyCollection(target, key, "prop", defaultValue);
  };
}
function Complex(defaultValue, type) {
  return function(target, key) {
    var propertyDescriptor = {
      set: complexSetter(defaultValue, key, type),
      get: complexGetter(defaultValue, key, type),
      enumerable: true,
      configurable: true
    };
    Object.defineProperty(target, key, propertyDescriptor);
    addPropertyCollection(target, key, "complexProp", defaultValue, type);
  };
}
function Collection(defaultValue, type) {
  return function(target, key) {
    var propertyDescriptor = {
      set: complexArraySetter(defaultValue, key, type),
      get: complexArrayGetter(defaultValue, key, type),
      enumerable: true,
      configurable: true
    };
    Object.defineProperty(target, key, propertyDescriptor);
    addPropertyCollection(target, key, "colProp", defaultValue, type);
  };
}
function Event() {
  return function(target, key) {
    var eventDescriptor = {
      set: function(newValue) {
        var oldValue = this.properties["" + key];
        if (oldValue !== newValue) {
          var finalContext = getParentContext(this, key);
          if (isUndefined(oldValue) === false) {
            finalContext.context.removeEventListener(finalContext.prefix, oldValue);
          }
          finalContext.context.addEventListener(finalContext.prefix, newValue);
          this.properties["" + key] = newValue;
        }
      },
      get: propertyGetter(undefined, key),
      enumerable: true,
      configurable: true
    };
    Object.defineProperty(target, key, eventDescriptor);
    addPropertyCollection(target, key, "event");
  };
}
function NotifyPropertyChanges(classConstructor) {
}
function addPropertyCollection(target, key, propertyType, defaultValue, type) {
  if (isUndefined(target.propList)) {
    target.propList = {
      props: [],
      complexProps: [],
      colProps: [],
      events: [],
      propNames: [],
      complexPropNames: [],
      colPropNames: [],
      eventNames: []
    };
  }
  target.propList[propertyType + "s"].push({
    propertyName: key,
    defaultValue,
    type
  });
  target.propList[propertyType + "Names"].push(key);
}
function getParentContext(context, prefix) {
  if (Object.prototype.hasOwnProperty.call(context, "parentObj") === false) {
    return { context, prefix };
  } else {
    var curText = getValue("propName", context);
    if (curText) {
      prefix = curText + "-" + prefix;
    }
    return getParentContext(getValue("parentObj", context), prefix);
  }
}
var __extends$l = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate$l = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Animation$1 = (
  /** @class */
  function(_super) {
    __extends$l(Animation2, _super);
    function Animation2(options) {
      var _this = _super.call(this, options, undefined) || this;
      _this.easing = {
        ease: "cubic-bezier(0.250, 0.100, 0.250, 1.000)",
        linear: "cubic-bezier(0.250, 0.250, 0.750, 0.750)",
        easeIn: "cubic-bezier(0.420, 0.000, 1.000, 1.000)",
        easeOut: "cubic-bezier(0.000, 0.000, 0.580, 1.000)",
        easeInOut: "cubic-bezier(0.420, 0.000, 0.580, 1.000)",
        elasticInOut: "cubic-bezier(0.5,-0.58,0.38,1.81)",
        elasticIn: "cubic-bezier(0.17,0.67,0.59,1.81)",
        elasticOut: "cubic-bezier(0.7,-0.75,0.99,1.01)"
      };
      return _this;
    }
    Animation_1 = Animation2;
    Animation2.prototype.animate = function(element2, options) {
      options = !options ? {} : options;
      var model = this.getModel(options);
      if (typeof element2 === "string") {
        var elements = Array.prototype.slice.call(selectAll(element2, undefined));
        for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
          var element_1 = elements_1[_i];
          model.element = element_1;
          Animation_1.delayAnimation(model);
        }
      } else {
        model.element = element2;
        Animation_1.delayAnimation(model);
      }
    };
    Animation2.stop = function(element2, model) {
      element2.style.animation = "";
      element2.removeAttribute("e-animate");
      var animationId = element2.getAttribute("e-animation-id");
      if (animationId) {
        var frameId = parseInt(animationId, 10);
        cancelAnimationFrame(frameId);
        element2.removeAttribute("e-animation-id");
      }
      if (model && model.end) {
        model.end.call(this, model);
      }
    };
    Animation2.delayAnimation = function(model) {
      if (animationMode === "Disable" || animationMode === GlobalAnimationMode.Disable) {
        if (model.begin) {
          model.begin.call(this, model);
        }
        if (model.end) {
          model.end.call(this, model);
        }
      } else {
        if (model.delay) {
          setTimeout(function() {
            Animation_1.applyAnimation(model);
          }, model.delay);
        } else {
          Animation_1.applyAnimation(model);
        }
      }
    };
    Animation2.applyAnimation = function(model) {
      var _this = this;
      model.timeStamp = 0;
      var step = 0;
      var timerId = 0;
      var prevTimeStamp = 0;
      var duration = model.duration;
      model.element.setAttribute("e-animate", "true");
      var startAnimation = function(timeStamp) {
        try {
          if (timeStamp) {
            prevTimeStamp = prevTimeStamp === 0 ? timeStamp : prevTimeStamp;
            model.timeStamp = timeStamp + model.timeStamp - prevTimeStamp;
            prevTimeStamp = timeStamp;
            if (!step && model.begin) {
              model.begin.call(_this, model);
            }
            step = step + 1;
            var avg = model.timeStamp / step;
            if (model.timeStamp < duration && model.timeStamp + avg < duration && model.element.getAttribute("e-animate")) {
              model.element.style.animation = model.name + " " + model.duration + "ms " + model.timingFunction;
              if (model.progress) {
                model.progress.call(_this, model);
              }
              requestAnimationFrame(startAnimation);
            } else {
              cancelAnimationFrame(timerId);
              model.element.removeAttribute("e-animation-id");
              model.element.removeAttribute("e-animate");
              model.element.style.animation = "";
              if (model.end) {
                model.end.call(_this, model);
              }
            }
          } else {
            timerId = requestAnimationFrame(startAnimation);
            model.element.setAttribute("e-animation-id", timerId.toString());
          }
        } catch (e) {
          cancelAnimationFrame(timerId);
          model.element.removeAttribute("e-animation-id");
          if (model.fail) {
            model.fail.call(_this, e);
          }
        }
      };
      startAnimation();
    };
    Animation2.prototype.getModel = function(options) {
      return {
        name: options.name || this.name,
        delay: options.delay || this.delay,
        duration: options.duration !== undefined ? options.duration : this.duration,
        begin: options.begin || this.begin,
        end: options.end || this.end,
        fail: options.fail || this.fail,
        progress: options.progress || this.progress,
        timingFunction: this.easing[options.timingFunction] ? this.easing[options.timingFunction] : options.timingFunction || this.easing[this.timingFunction]
      };
    };
    Animation2.prototype.onPropertyChanged = function(newProp, oldProp) {
    };
    Animation2.prototype.getModuleName = function() {
      return "animation";
    };
    Animation2.prototype.destroy = function() {
    };
    var Animation_1;
    __decorate$l([
      Property("FadeIn")
    ], Animation2.prototype, "name", undefined);
    __decorate$l([
      Property(400)
    ], Animation2.prototype, "duration", undefined);
    __decorate$l([
      Property("ease")
    ], Animation2.prototype, "timingFunction", undefined);
    __decorate$l([
      Property(0)
    ], Animation2.prototype, "delay", undefined);
    __decorate$l([
      Event()
    ], Animation2.prototype, "progress", undefined);
    __decorate$l([
      Event()
    ], Animation2.prototype, "begin", undefined);
    __decorate$l([
      Event()
    ], Animation2.prototype, "end", undefined);
    __decorate$l([
      Event()
    ], Animation2.prototype, "fail", undefined);
    Animation2 = Animation_1 = __decorate$l([
      NotifyPropertyChanges
    ], Animation2);
    return Animation2;
  }(Base)
);
function rippleEffect(element2, rippleOptions, done) {
  var rippleModel = getRippleModel(rippleOptions);
  if (rippleModel.rippleFlag === false || rippleModel.rippleFlag === undefined && true) {
    return function() {
    };
  }
  element2.setAttribute("data-ripple", "true");
  EventHandler.add(element2, "mousedown", rippleHandler, { parent: element2, rippleOptions: rippleModel });
  EventHandler.add(element2, "mouseup", rippleUpHandler, { parent: element2, rippleOptions: rippleModel, done });
  EventHandler.add(element2, "mouseleave", rippleLeaveHandler, { parent: element2, rippleOptions: rippleModel });
  if (Browser.isPointer) {
    EventHandler.add(element2, "transitionend", rippleLeaveHandler, { parent: element2, rippleOptions: rippleModel });
  }
  return function() {
    element2.removeAttribute("data-ripple");
    EventHandler.remove(element2, "mousedown", rippleHandler);
    EventHandler.remove(element2, "mouseup", rippleUpHandler);
    EventHandler.remove(element2, "mouseleave", rippleLeaveHandler);
    EventHandler.remove(element2, "transitionend", rippleLeaveHandler);
  };
}
function getRippleModel(rippleOptions) {
  var rippleModel = {
    selector: rippleOptions && rippleOptions.selector ? rippleOptions.selector : null,
    ignore: rippleOptions && rippleOptions.ignore ? rippleOptions.ignore : null,
    rippleFlag: rippleOptions && rippleOptions.rippleFlag,
    isCenterRipple: rippleOptions && rippleOptions.isCenterRipple,
    duration: rippleOptions && rippleOptions.duration ? rippleOptions.duration : 350
  };
  return rippleModel;
}
function rippleHandler(e) {
  var target = e.target;
  var selector = this.rippleOptions.selector;
  var element2 = selector ? closest(target, selector) : target;
  if (!element2 || this.rippleOptions && closest(target, this.rippleOptions.ignore)) {
    return;
  }
  var offset = element2.getBoundingClientRect();
  var offsetX = e.pageX - (undefined).body.scrollLeft;
  var offsetY = e.pageY - (!(undefined).body.scrollTop && (undefined).documentElement ? (undefined).documentElement.scrollTop : (undefined).body.scrollTop);
  var pageX = Math.max(Math.abs(offsetX - offset.left), Math.abs(offsetX - offset.right));
  var pageY = Math.max(Math.abs(offsetY - offset.top), Math.abs(offsetY - offset.bottom));
  var radius = Math.sqrt(pageX * pageX + pageY * pageY);
  var diameter = radius * 2 + "px";
  var x = offsetX - offset.left - radius;
  var y = offsetY - offset.top - radius;
  if (this.rippleOptions && this.rippleOptions.isCenterRipple) {
    x = 0;
    y = 0;
    diameter = "100%";
  }
  element2.classList.add("e-ripple");
  var duration = this.rippleOptions.duration.toString();
  var styles = "width: " + diameter + ";height: " + diameter + ";left: " + x + "px;top: " + y + "px;transition-duration: " + duration + "ms;";
  var rippleElement = createElement("div", { className: "e-ripple-element", styles });
  element2.appendChild(rippleElement);
  (undefined).getComputedStyle(rippleElement).getPropertyValue("opacity");
  rippleElement.style.transform = "scale(1)";
  if (element2 !== this.parent) {
    EventHandler.add(element2, "mouseleave", rippleLeaveHandler, { parent: this.parent, rippleOptions: this.rippleOptions });
  }
}
function rippleUpHandler(e) {
  removeRipple(e, this);
}
function rippleLeaveHandler(e) {
  removeRipple(e, this);
}
function removeRipple(e, eventArgs) {
  var duration = eventArgs.rippleOptions.duration;
  var target = e.target;
  var selector = eventArgs.rippleOptions.selector;
  var element2 = selector ? closest(target, selector) : target;
  if (!element2 || element2 && element2.className.indexOf("e-ripple") === -1) {
    return;
  }
  var rippleElements = selectAll(".e-ripple-element", element2);
  var rippleElement = rippleElements[rippleElements.length - 1];
  if (rippleElement) {
    rippleElement.style.opacity = "0.5";
  }
  if (eventArgs.parent !== element2) {
    EventHandler.remove(element2, "mouseleave", rippleLeaveHandler);
  }
  setTimeout(function() {
    if (rippleElement && rippleElement.parentNode) {
      rippleElement.parentNode.removeChild(rippleElement);
    }
    if (!element2.getElementsByClassName("e-ripple-element").length) {
      element2.classList.remove("e-ripple");
    }
    if (eventArgs.done) {
      eventArgs.done(e);
    }
  }, duration);
}
var animationMode;
var GlobalAnimationMode;
(function(GlobalAnimationMode2) {
  GlobalAnimationMode2["Default"] = "Default";
  GlobalAnimationMode2["Enable"] = "Enable";
  GlobalAnimationMode2["Disable"] = "Disable";
})(GlobalAnimationMode || (GlobalAnimationMode = {}));
var MODULE_SUFFIX = "Module";
var ModuleLoader = (
  /** @class */
  function() {
    function ModuleLoader2(parent) {
      this.loadedModules = [];
      this.parent = parent;
    }
    ModuleLoader2.prototype.inject = function(requiredModules, moduleList) {
      var reqLength = requiredModules.length;
      if (reqLength === 0) {
        this.clean();
        return;
      }
      if (this.loadedModules.length) {
        this.clearUnusedModule(requiredModules);
      }
      for (var i = 0; i < reqLength; i++) {
        var modl = requiredModules[parseInt(i.toString(), 10)];
        for (var _i = 0, moduleList_1 = moduleList; _i < moduleList_1.length; _i++) {
          var module = moduleList_1[_i];
          var modName = modl.member;
          if (module && module.prototype.getModuleName() === modl.member && !this.isModuleLoaded(modName)) {
            var moduleObject = createInstance(module, modl.args);
            var memberName = this.getMemberName(modName);
            if (modl.isProperty) {
              setValue(memberName, module, this.parent);
            } else {
              setValue(memberName, moduleObject, this.parent);
            }
            var loadedModule = modl;
            loadedModule.member = memberName;
            this.loadedModules.push(loadedModule);
          }
        }
      }
    };
    ModuleLoader2.prototype.clean = function() {
      for (var _i = 0, _a = this.loadedModules; _i < _a.length; _i++) {
        var modules = _a[_i];
        if (!modules.isProperty) {
          getValue(modules.member, this.parent).destroy();
        }
      }
      this.loadedModules = [];
    };
    ModuleLoader2.prototype.getNonInjectedModules = function(requiredModules) {
      var _this = this;
      return requiredModules.filter(function(module) {
        return !_this.isModuleLoaded(module.member);
      });
    };
    ModuleLoader2.prototype.clearUnusedModule = function(moduleList) {
      var _this = this;
      var usedModules = moduleList.map(function(arg) {
        return _this.getMemberName(arg.member);
      });
      var removableModule = this.loadedModules.filter(function(module) {
        return usedModules.indexOf(module.member) === -1;
      });
      for (var _i = 0, removableModule_1 = removableModule; _i < removableModule_1.length; _i++) {
        var mod = removableModule_1[_i];
        if (!mod.isProperty) {
          getValue(mod.member, this.parent).destroy();
        }
        this.loadedModules.splice(this.loadedModules.indexOf(mod), 1);
        deleteObject(this.parent, mod.member);
      }
    };
    ModuleLoader2.prototype.getMemberName = function(name) {
      return name[0].toLowerCase() + name.substring(1) + MODULE_SUFFIX;
    };
    ModuleLoader2.prototype.isModuleLoaded = function(modName) {
      for (var _i = 0, _a = this.loadedModules; _i < _a.length; _i++) {
        var mod = _a[_i];
        if (mod.member === this.getMemberName(modName)) {
          return true;
        }
      }
      return false;
    };
    return ModuleLoader2;
  }()
);
var ChildProperty = (
  /** @class */
  function() {
    function ChildProperty2(parent, propName, defaultValue, isArray) {
      this.isComplexArraySetter = false;
      this.properties = {};
      this.changedProperties = {};
      this.childChangedProperties = {};
      this.oldProperties = {};
      this.finalUpdate = function() {
      };
      this.callChildDataBind = getValue("callChildDataBind", Base);
      this.parentObj = parent;
      this.controlParent = this.parentObj.controlParent || this.parentObj;
      this.propName = propName;
      this.isParentArray = isArray;
      this.setProperties(defaultValue, true);
    }
    ChildProperty2.prototype.updateChange = function(val, propName) {
      if (val === true) {
        this.parentObj.childChangedProperties["" + propName] = val;
      } else {
        delete this.parentObj.childChangedProperties["" + propName];
      }
      if (this.parentObj.updateChange) {
        this.parentObj.updateChange(val, this.parentObj.propName);
      }
    };
    ChildProperty2.prototype.updateTimeOut = function() {
      if (this.parentObj.updateTimeOut) {
        this.parentObj.finalUpdate();
        this.parentObj.updateTimeOut();
      } else {
        var changeTime_1 = setTimeout(this.parentObj.dataBind.bind(this.parentObj));
        var clearUpdate = function() {
          clearTimeout(changeTime_1);
        };
        this.finalUpdate = clearUpdate;
      }
    };
    ChildProperty2.prototype.clearChanges = function() {
      this.finalUpdate();
      this.updateChange(false, this.propName);
      this.oldProperties = {};
      this.changedProperties = {};
    };
    ChildProperty2.prototype.setProperties = function(prop, muteOnChange) {
      if (muteOnChange === true) {
        merge(this, prop);
        this.updateChange(false, this.propName);
        this.clearChanges();
      } else {
        merge(this, prop);
      }
    };
    ChildProperty2.prototype.dataBind = function() {
      this.callChildDataBind(this.childChangedProperties, this);
      if (this.isParentArray) {
        var curIndex = this.parentObj[this.propName].indexOf(this);
        if (Object.keys(this.changedProperties).length) {
          setValue(this.propName + "." + curIndex, this.changedProperties, this.parentObj.changedProperties);
          setValue(this.propName + "." + curIndex, this.oldProperties, this.parentObj.oldProperties);
        }
      } else {
        this.parentObj.changedProperties[this.propName] = this.changedProperties;
        this.parentObj.oldProperties[this.propName] = this.oldProperties;
      }
      this.clearChanges();
    };
    ChildProperty2.prototype.saveChanges = function(key, newValue, oldValue, restrictServerDataBind) {
      if (this.controlParent.isProtectedOnChange) {
        return;
      }
      if (!restrictServerDataBind) {
        this.serverDataBind(key, newValue, true);
      }
      this.oldProperties["" + key] = oldValue;
      this.changedProperties["" + key] = newValue;
      this.updateChange(true, this.propName);
      this.finalUpdate();
      this.updateTimeOut();
    };
    ChildProperty2.prototype.serverDataBind = function(key, value, isSaveChanges, action) {
    };
    ChildProperty2.prototype.getParentKey = function(isSaveChanges) {
      var index = "";
      var propName = this.propName;
      if (this.isParentArray) {
        index = this.parentObj[this.propName].indexOf(this);
        var valueLength = this.parentObj[this.propName].length;
        valueLength = isSaveChanges ? valueLength : valueLength > 0 ? valueLength - 1 : 0;
        index = index !== -1 ? "-" + index : "-" + valueLength;
        propName = propName + index;
      }
      if (this.controlParent !== this.parentObj) {
        propName = this.parentObj.getParentKey() + "." + this.propName + index;
      }
      return propName;
    };
    return ChildProperty2;
  }()
);
var HijriParser;
(function(HijriParser2) {
  var dateCorrection = [
    28607,
    28636,
    28665,
    28695,
    28724,
    28754,
    28783,
    28813,
    28843,
    28872,
    28901,
    28931,
    28960,
    28990,
    29019,
    29049,
    29078,
    29108,
    29137,
    29167,
    29196,
    29226,
    29255,
    29285,
    29315,
    29345,
    29375,
    29404,
    29434,
    29463,
    29492,
    29522,
    29551,
    29580,
    29610,
    29640,
    29669,
    29699,
    29729,
    29759,
    29788,
    29818,
    29847,
    29876,
    29906,
    29935,
    29964,
    29994,
    30023,
    30053,
    30082,
    30112,
    30141,
    30171,
    30200,
    30230,
    30259,
    30289,
    30318,
    30348,
    30378,
    30408,
    30437,
    30467,
    30496,
    30526,
    30555,
    30585,
    30614,
    30644,
    30673,
    30703,
    30732,
    30762,
    30791,
    30821,
    30850,
    30880,
    30909,
    30939,
    30968,
    30998,
    31027,
    31057,
    31086,
    31116,
    31145,
    31175,
    31204,
    31234,
    31263,
    31293,
    31322,
    31352,
    31381,
    31411,
    31441,
    31471,
    31500,
    31530,
    31559,
    31589,
    31618,
    31648,
    31676,
    31706,
    31736,
    31766,
    31795,
    31825,
    31854,
    31884,
    31913,
    31943,
    31972,
    32002,
    32031,
    32061,
    32090,
    32120,
    32150,
    32180,
    32209,
    32239,
    32268,
    32298,
    32327,
    32357,
    32386,
    32416,
    32445,
    32475,
    32504,
    32534,
    32563,
    32593,
    32622,
    32652,
    32681,
    32711,
    32740,
    32770,
    32799,
    32829,
    32858,
    32888,
    32917,
    32947,
    32976,
    33006,
    33035,
    33065,
    33094,
    33124,
    33153,
    33183,
    33213,
    33243,
    33272,
    33302,
    33331,
    33361,
    33390,
    33420,
    33450,
    33479,
    33509,
    33539,
    33568,
    33598,
    33627,
    33657,
    33686,
    33716,
    33745,
    33775,
    33804,
    33834,
    33863,
    33893,
    33922,
    33952,
    33981,
    34011,
    34040,
    34069,
    34099,
    34128,
    34158,
    34187,
    34217,
    34247,
    34277,
    34306,
    34336,
    34365,
    34395,
    34424,
    34454,
    34483,
    34512,
    34542,
    34571,
    34601,
    34631,
    34660,
    34690,
    34719,
    34749,
    34778,
    34808,
    34837,
    34867,
    34896,
    34926,
    34955,
    34985,
    35015,
    35044,
    35074,
    35103,
    35133,
    35162,
    35192,
    35222,
    35251,
    35280,
    35310,
    35340,
    35370,
    35399,
    35429,
    35458,
    35488,
    35517,
    35547,
    35576,
    35605,
    35635,
    35665,
    35694,
    35723,
    35753,
    35782,
    35811,
    35841,
    35871,
    35901,
    35930,
    35960,
    35989,
    36019,
    36048,
    36078,
    36107,
    36136,
    36166,
    36195,
    36225,
    36254,
    36284,
    36314,
    36343,
    36373,
    36403,
    36433,
    36462,
    36492,
    36521,
    36551,
    36580,
    36610,
    36639,
    36669,
    36698,
    36728,
    36757,
    36786,
    36816,
    36845,
    36875,
    36904,
    36934,
    36963,
    36993,
    37022,
    37052,
    37081,
    37111,
    37141,
    37170,
    37200,
    37229,
    37259,
    37288,
    37318,
    37347,
    37377,
    37406,
    37436,
    37465,
    37495,
    37524,
    37554,
    37584,
    37613,
    37643,
    37672,
    37701,
    37731,
    37760,
    37790,
    37819,
    37849,
    37878,
    37908,
    37938,
    37967,
    37997,
    38027,
    38056,
    38085,
    38115,
    38144,
    38174,
    38203,
    38233,
    38262,
    38292,
    38322,
    38351,
    38381,
    38410,
    38440,
    38469,
    38499,
    38528,
    38558,
    38587,
    38617,
    38646,
    38676,
    38705,
    38735,
    38764,
    38794,
    38823,
    38853,
    38882,
    38912,
    38941,
    38971,
    39001,
    39030,
    39059,
    39089,
    39118,
    39148,
    39178,
    39208,
    39237,
    39267,
    39297,
    39326,
    39355,
    39385,
    39414,
    39444,
    39473,
    39503,
    39532,
    39562,
    39592,
    39621,
    39650,
    39680,
    39709,
    39739,
    39768,
    39798,
    39827,
    39857,
    39886,
    39916,
    39946,
    39975,
    40005,
    40035,
    40064,
    40094,
    40123,
    40153,
    40182,
    40212,
    40241,
    40271,
    40300,
    40330,
    40359,
    40389,
    40418,
    40448,
    40477,
    40507,
    40536,
    40566,
    40595,
    40625,
    40655,
    40685,
    40714,
    40744,
    40773,
    40803,
    40832,
    40862,
    40892,
    40921,
    40951,
    40980,
    41009,
    41039,
    41068,
    41098,
    41127,
    41157,
    41186,
    41216,
    41245,
    41275,
    41304,
    41334,
    41364,
    41393,
    41422,
    41452,
    41481,
    41511,
    41540,
    41570,
    41599,
    41629,
    41658,
    41688,
    41718,
    41748,
    41777,
    41807,
    41836,
    41865,
    41894,
    41924,
    41953,
    41983,
    42012,
    42042,
    42072,
    42102,
    42131,
    42161,
    42190,
    42220,
    42249,
    42279,
    42308,
    42337,
    42367,
    42397,
    42426,
    42456,
    42485,
    42515,
    42545,
    42574,
    42604,
    42633,
    42662,
    42692,
    42721,
    42751,
    42780,
    42810,
    42839,
    42869,
    42899,
    42929,
    42958,
    42988,
    43017,
    43046,
    43076,
    43105,
    43135,
    43164,
    43194,
    43223,
    43253,
    43283,
    43312,
    43342,
    43371,
    43401,
    43430,
    43460,
    43489,
    43519,
    43548,
    43578,
    43607,
    43637,
    43666,
    43696,
    43726,
    43755,
    43785,
    43814,
    43844,
    43873,
    43903,
    43932,
    43962,
    43991,
    44021,
    44050,
    44080,
    44109,
    44139,
    44169,
    44198,
    44228,
    44258,
    44287,
    44317,
    44346,
    44375,
    44405,
    44434,
    44464,
    44493,
    44523,
    44553,
    44582,
    44612,
    44641,
    44671,
    44700,
    44730,
    44759,
    44788,
    44818,
    44847,
    44877,
    44906,
    44936,
    44966,
    44996,
    45025,
    45055,
    45084,
    45114,
    45143,
    45172,
    45202,
    45231,
    45261,
    45290,
    45320,
    45350,
    45380,
    45409,
    45439,
    45468,
    45498,
    45527,
    45556,
    45586,
    45615,
    45644,
    45674,
    45704,
    45733,
    45763,
    45793,
    45823,
    45852,
    45882,
    45911,
    45940,
    45970,
    45999,
    46028,
    46058,
    46088,
    46117,
    46147,
    46177,
    46206,
    46236,
    46265,
    46295,
    46324,
    46354,
    46383,
    46413,
    46442,
    46472,
    46501,
    46531,
    46560,
    46590,
    46620,
    46649,
    46679,
    46708,
    46738,
    46767,
    46797,
    46826,
    46856,
    46885,
    46915,
    46944,
    46974,
    47003,
    47033,
    47063,
    47092,
    47122,
    47151,
    47181,
    47210,
    47240,
    47269,
    47298,
    47328,
    47357,
    47387,
    47417,
    47446,
    47476,
    47506,
    47535,
    47565,
    47594,
    47624,
    47653,
    47682,
    47712,
    47741,
    47771,
    47800,
    47830,
    47860,
    47890,
    47919,
    47949,
    47978,
    48008,
    48037,
    48066,
    48096,
    48125,
    48155,
    48184,
    48214,
    48244,
    48273,
    48303,
    48333,
    48362,
    48392,
    48421,
    48450,
    48480,
    48509,
    48538,
    48568,
    48598,
    48627,
    48657,
    48687,
    48717,
    48746,
    48776,
    48805,
    48834,
    48864,
    48893,
    48922,
    48952,
    48982,
    49011,
    49041,
    49071,
    49100,
    49130,
    49160,
    49189,
    49218,
    49248,
    49277,
    49306,
    49336,
    49365,
    49395,
    49425,
    49455,
    49484,
    49514,
    49543,
    49573,
    49602,
    49632,
    49661,
    49690,
    49720,
    49749,
    49779,
    49809,
    49838,
    49868,
    49898,
    49927,
    49957,
    49986,
    50016,
    50045,
    50075,
    50104,
    50133,
    50163,
    50192,
    50222,
    50252,
    50281,
    50311,
    50340,
    50370,
    50400,
    50429,
    50459,
    50488,
    50518,
    50547,
    50576,
    50606,
    50635,
    50665,
    50694,
    50724,
    50754,
    50784,
    50813,
    50843,
    50872,
    50902,
    50931,
    50960,
    50990,
    51019,
    51049,
    51078,
    51108,
    51138,
    51167,
    51197,
    51227,
    51256,
    51286,
    51315,
    51345,
    51374,
    51403,
    51433,
    51462,
    51492,
    51522,
    51552,
    51582,
    51611,
    51641,
    51670,
    51699,
    51729,
    51758,
    51787,
    51816,
    51846,
    51876,
    51906,
    51936,
    51965,
    51995,
    52025,
    52054,
    52083,
    52113,
    52142,
    52171,
    52200,
    52230,
    52260,
    52290,
    52319,
    52349,
    52379,
    52408,
    52438,
    52467,
    52497,
    52526,
    52555,
    52585,
    52614,
    52644,
    52673,
    52703,
    52733,
    52762,
    52792,
    52822,
    52851,
    52881,
    52910,
    52939,
    52969,
    52998,
    53028,
    53057,
    53087,
    53116,
    53146,
    53176,
    53205,
    53235,
    53264,
    53294,
    53324,
    53353,
    53383,
    53412,
    53441,
    53471,
    53500,
    53530,
    53559,
    53589,
    53619,
    53648,
    53678,
    53708,
    53737,
    53767,
    53796,
    53825,
    53855,
    53884,
    53913,
    53943,
    53973,
    54003,
    54032,
    54062,
    54092,
    54121,
    54151,
    54180,
    54209,
    54239,
    54268,
    54297,
    54327,
    54357,
    54387,
    54416,
    54446,
    54476,
    54505,
    54535,
    54564,
    54593,
    54623,
    54652,
    54681,
    54711,
    54741,
    54770,
    54800,
    54830,
    54859,
    54889,
    54919,
    54948,
    54977,
    55007,
    55036,
    55066,
    55095,
    55125,
    55154,
    55184,
    55213,
    55243,
    55273,
    55302,
    55332,
    55361,
    55391,
    55420,
    55450,
    55479,
    55508,
    55538,
    55567,
    55597,
    55627,
    55657,
    55686,
    55716,
    55745,
    55775,
    55804,
    55834,
    55863,
    55892,
    55922,
    55951,
    55981,
    56011,
    56040,
    56070,
    56100,
    56129,
    56159,
    56188,
    56218,
    56247,
    56276,
    56306,
    56335,
    56365,
    56394,
    56424,
    56454,
    56483,
    56513,
    56543,
    56572,
    56601,
    56631,
    56660,
    56690,
    56719,
    56749,
    56778,
    56808,
    56837,
    56867,
    56897,
    56926,
    56956,
    56985,
    57015,
    57044,
    57074,
    57103,
    57133,
    57162,
    57192,
    57221,
    57251,
    57280,
    57310,
    57340,
    57369,
    57399,
    57429,
    57458,
    57487,
    57517,
    57546,
    57576,
    57605,
    57634,
    57664,
    57694,
    57723,
    57753,
    57783,
    57813,
    57842,
    57871,
    57901,
    57930,
    57959,
    57989,
    58018,
    58048,
    58077,
    58107,
    58137,
    58167,
    58196,
    58226,
    58255,
    58285,
    58314,
    58343,
    58373,
    58402,
    58432,
    58461,
    58491,
    58521,
    58551,
    58580,
    58610,
    58639,
    58669,
    58698,
    58727,
    58757,
    58786,
    58816,
    58845,
    58875,
    58905,
    58934,
    58964,
    58994,
    59023,
    59053,
    59082,
    59111,
    59141,
    59170,
    59200,
    59229,
    59259,
    59288,
    59318,
    59348,
    59377,
    59407,
    59436,
    59466,
    59495,
    59525,
    59554,
    59584,
    59613,
    59643,
    59672,
    59702,
    59731,
    59761,
    59791,
    59820,
    59850,
    59879,
    59909,
    59939,
    59968,
    59997,
    60027,
    60056,
    60086,
    60115,
    60145,
    60174,
    60204,
    60234,
    60264,
    60293,
    60323,
    60352,
    60381,
    60411,
    60440,
    60469,
    60499,
    60528,
    60558,
    60588,
    60618,
    60648,
    60677,
    60707,
    60736,
    60765,
    60795,
    60824,
    60853,
    60883,
    60912,
    60942,
    60972,
    61002,
    61031,
    61061,
    61090,
    61120,
    61149,
    61179,
    61208,
    61237,
    61267,
    61296,
    61326,
    61356,
    61385,
    61415,
    61445,
    61474,
    61504,
    61533,
    61563,
    61592,
    61621,
    61651,
    61680,
    61710,
    61739,
    61769,
    61799,
    61828,
    61858,
    61888,
    61917,
    61947,
    61976,
    62006,
    62035,
    62064,
    62094,
    62123,
    62153,
    62182,
    62212,
    62242,
    62271,
    62301,
    62331,
    62360,
    62390,
    62419,
    62448,
    62478,
    62507,
    62537,
    62566,
    62596,
    62625,
    62655,
    62685,
    62715,
    62744,
    62774,
    62803,
    62832,
    62862,
    62891,
    62921,
    62950,
    62980,
    63009,
    63039,
    63069,
    63099,
    63128,
    63157,
    63187,
    63216,
    63246,
    63275,
    63305,
    63334,
    63363,
    63393,
    63423,
    63453,
    63482,
    63512,
    63541,
    63571,
    63600,
    63630,
    63659,
    63689,
    63718,
    63747,
    63777,
    63807,
    63836,
    63866,
    63895,
    63925,
    63955,
    63984,
    64014,
    64043,
    64073,
    64102,
    64131,
    64161,
    64190,
    64220,
    64249,
    64279,
    64309,
    64339,
    64368,
    64398,
    64427,
    64457,
    64486,
    64515,
    64545,
    64574,
    64603,
    64633,
    64663,
    64692,
    64722,
    64752,
    64782,
    64811,
    64841,
    64870,
    64899,
    64929,
    64958,
    64987,
    65017,
    65047,
    65076,
    65106,
    65136,
    65166,
    65195,
    65225,
    65254,
    65283,
    65313,
    65342,
    65371,
    65401,
    65431,
    65460,
    65490,
    65520,
    65549,
    65579,
    65608,
    65638,
    65667,
    65697,
    65726,
    65755,
    65785,
    65815,
    65844,
    65874,
    65903,
    65933,
    65963,
    65992,
    66022,
    66051,
    66081,
    66110,
    66140,
    66169,
    66199,
    66228,
    66258,
    66287,
    66317,
    66346,
    66376,
    66405,
    66435,
    66465,
    66494,
    66524,
    66553,
    66583,
    66612,
    66641,
    66671,
    66700,
    66730,
    66760,
    66789,
    66819,
    66849,
    66878,
    66908,
    66937,
    66967,
    66996,
    67025,
    67055,
    67084,
    67114,
    67143,
    67173,
    67203,
    67233,
    67262,
    67292,
    67321,
    67351,
    67380,
    67409,
    67439,
    67468,
    67497,
    67527,
    67557,
    67587,
    67617,
    67646,
    67676,
    67705,
    67735,
    67764,
    67793,
    67823,
    67852,
    67882,
    67911,
    67941,
    67971,
    68e3,
    68030,
    68060,
    68089,
    68119,
    68148,
    68177,
    68207,
    68236,
    68266,
    68295,
    68325,
    68354,
    68384,
    68414,
    68443,
    68473,
    68502,
    68532,
    68561,
    68591,
    68620,
    68650,
    68679,
    68708,
    68738,
    68768,
    68797,
    68827,
    68857,
    68886,
    68916,
    68946,
    68975,
    69004,
    69034,
    69063,
    69092,
    69122,
    69152,
    69181,
    69211,
    69240,
    69270,
    69300,
    69330,
    69359,
    69388,
    69418,
    69447,
    69476,
    69506,
    69535,
    69565,
    69595,
    69624,
    69654,
    69684,
    69713,
    69743,
    69772,
    69802,
    69831,
    69861,
    69890,
    69919,
    69949,
    69978,
    70008,
    70038,
    70067,
    70097,
    70126,
    70156,
    70186,
    70215,
    70245,
    70274,
    70303,
    70333,
    70362,
    70392,
    70421,
    70451,
    70481,
    70510,
    70540,
    70570,
    70599,
    70629,
    70658,
    70687,
    70717,
    70746,
    70776,
    70805,
    70835,
    70864,
    70894,
    70924,
    70954,
    70983,
    71013,
    71042,
    71071,
    71101,
    71130,
    71159,
    71189,
    71218,
    71248,
    71278,
    71308,
    71337,
    71367,
    71397,
    71426,
    71455,
    71485,
    71514,
    71543,
    71573,
    71602,
    71632,
    71662,
    71691,
    71721,
    71751,
    71781,
    71810,
    71839,
    71869,
    71898,
    71927,
    71957,
    71986,
    72016,
    72046,
    72075,
    72105,
    72135,
    72164,
    72194,
    72223,
    72253,
    72282,
    72311,
    72341,
    72370,
    72400,
    72429,
    72459,
    72489,
    72518,
    72548,
    72577,
    72607,
    72637,
    72666,
    72695,
    72725,
    72754,
    72784,
    72813,
    72843,
    72872,
    72902,
    72931,
    72961,
    72991,
    73020,
    73050,
    73080,
    73109,
    73139,
    73168,
    73197,
    73227,
    73256,
    73286,
    73315,
    73345,
    73375,
    73404,
    73434,
    73464,
    73493,
    73523,
    73552,
    73581,
    73611,
    73640,
    73669,
    73699,
    73729,
    73758,
    73788,
    73818,
    73848,
    73877,
    73907,
    73936,
    73965,
    73995,
    74024,
    74053,
    74083,
    74113,
    74142,
    74172,
    74202,
    74231,
    74261,
    74291,
    74320,
    74349,
    74379,
    74408,
    74437,
    74467,
    74497,
    74526,
    74556,
    74586,
    74615,
    74645,
    74675,
    74704,
    74733,
    74763,
    74792,
    74822,
    74851,
    74881,
    74910,
    74940,
    74969,
    74999,
    75029,
    75058,
    75088,
    75117,
    75147,
    75176,
    75206,
    75235,
    75264,
    75294,
    75323,
    75353,
    75383,
    75412,
    75442,
    75472,
    75501,
    75531,
    75560,
    75590,
    75619,
    75648,
    75678,
    75707,
    75737,
    75766,
    75796,
    75826,
    75856,
    75885,
    75915,
    75944,
    75974,
    76003,
    76032,
    76062,
    76091,
    76121,
    76150,
    76180,
    76210,
    76239,
    76269,
    76299,
    76328,
    76358,
    76387,
    76416,
    76446,
    76475,
    76505,
    76534,
    76564,
    76593,
    76623,
    76653,
    76682,
    76712,
    76741,
    76771,
    76801,
    76830,
    76859,
    76889,
    76918,
    76948,
    76977,
    77007,
    77036,
    77066,
    77096,
    77125,
    77155,
    77185,
    77214,
    77243,
    77273,
    77302,
    77332,
    77361,
    77390,
    77420,
    77450,
    77479,
    77509,
    77539,
    77569,
    77598,
    77627,
    77657,
    77686,
    77715,
    77745,
    77774,
    77804,
    77833,
    77863,
    77893,
    77923,
    77952,
    77982,
    78011,
    78041,
    78070,
    78099,
    78129,
    78158,
    78188,
    78217,
    78247,
    78277,
    78307,
    78336,
    78366,
    78395,
    78425,
    78454,
    78483,
    78513,
    78542,
    78572,
    78601,
    78631,
    78661,
    78690,
    78720,
    78750,
    78779,
    78808,
    78838,
    78867,
    78897,
    78926,
    78956,
    78985,
    79015,
    79044,
    79074,
    79104,
    79133,
    79163,
    79192,
    79222,
    79251,
    79281,
    79310,
    79340,
    79369,
    79399,
    79428,
    79458,
    79487,
    79517,
    79546,
    79576,
    79606,
    79635,
    79665,
    79695,
    79724,
    79753,
    79783,
    79812,
    79841,
    79871,
    79900,
    79930,
    79960,
    79990
  ];
  function getHijriDate(gDate) {
    var day = gDate.getDate();
    var month2 = gDate.getMonth();
    var year = gDate.getFullYear();
    var tMonth = month2 + 1;
    var tYear = year;
    if (tMonth < 3) {
      tYear -= 1;
      tMonth += 12;
    }
    var yPrefix = Math.floor(tYear / 100);
    var julilanOffset = yPrefix - Math.floor(yPrefix / 4) - 2;
    var julianNumber = Math.floor(365.25 * (tYear + 4716)) + Math.floor(30.6001 * (tMonth + 1)) + day - julilanOffset - 1524;
    yPrefix = Math.floor((julianNumber - 186721625e-2) / 36524.25);
    julilanOffset = yPrefix - Math.floor(yPrefix / 4) + 1;
    var b = julianNumber + julilanOffset + 1524;
    var c = Math.floor((b - 122.1) / 365.25);
    var d = Math.floor(365.25 * c);
    var tempMonth = Math.floor((b - d) / 30.6001);
    day = b - d - Math.floor(30.6001 * tempMonth);
    month2 = Math.floor((b - d) / 20.6001);
    if (month2 > 13) {
      c += 1;
      month2 -= 12;
    }
    month2 -= 1;
    year = c - 4716;
    var modifiedJulianDate = julianNumber - 24e5;
    var iyear = 10631 / 30;
    var z = julianNumber - 1948084;
    var cyc = Math.floor(z / 10631);
    z = z - 10631 * cyc;
    var j = Math.floor((z - 0.1335) / iyear);
    var iy = 30 * cyc + j;
    z = z - Math.floor(j * iyear + 0.1335);
    var im = Math.floor((z + 28.5001) / 29.5);
    if (im === 13) {
      im = 12;
    }
    var tempDay = z - Math.floor(29.5001 * im - 29);
    var i = 0;
    for (; i < dateCorrection.length; i++) {
      if (dateCorrection[parseInt(i.toString(), 10)] > modifiedJulianDate) {
        break;
      }
    }
    var iln = i + 16260;
    var ii = Math.floor((iln - 1) / 12);
    var hYear = ii + 1;
    var hmonth = iln - 12 * ii;
    var hDate = modifiedJulianDate - dateCorrection[i - 1] + 1;
    if ((hDate + "").length > 2) {
      hDate = tempDay;
      hmonth = im;
      hYear = iy;
    }
    return { year: hYear, month: hmonth, date: hDate };
  }
  HijriParser2.getHijriDate = getHijriDate;
  function toGregorian(year, month2, day) {
    var iy = year;
    var im = month2;
    var id = day;
    var ii = iy - 1;
    var iln = ii * 12 + 1 + (im - 1);
    var i = iln - 16260;
    var mcjdn = id + dateCorrection[i - 1] - 1;
    var julianDate = mcjdn + 24e5;
    var z = Math.floor(julianDate + 0.5);
    var a = Math.floor((z - 186721625e-2) / 36524.25);
    a = z + 1 + a - Math.floor(a / 4);
    var b = a + 1524;
    var c = Math.floor((b - 122.1) / 365.25);
    var d = Math.floor(365.25 * c);
    var e = Math.floor((b - d) / 30.6001);
    var gDay = b - d - Math.floor(e * 30.6001);
    var gMonth = e - (e > 13.5 ? 13 : 1);
    var gYear = c - (gMonth > 2.5 ? 4716 : 4715);
    if (gYear <= 0) {
      gMonth--;
    }
    return /* @__PURE__ */ new Date(gYear + "/" + gMonth + "/" + gDay);
  }
  HijriParser2.toGregorian = toGregorian;
})(HijriParser || (HijriParser = {}));
var abbreviateRegexGlobal = /\/MMMMM|MMMM|MMM|a|LLLL|LLL|EEEEE|EEEE|E|K|cccc|ccc|WW|W|G+|z+/gi;
var standalone$1 = "stand-alone";
var weekdayKey = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];
var timeSetter$1 = {
  m: "getMinutes",
  h: "getHours",
  H: "getHours",
  s: "getSeconds",
  d: "getDate",
  f: "getMilliseconds"
};
var datePartMatcher = {
  "M": "month",
  "d": "day",
  "E": "weekday",
  "c": "weekday",
  "y": "year",
  "m": "minute",
  "h": "hour",
  "H": "hour",
  "s": "second",
  "L": "month",
  "a": "designator",
  "z": "timeZone",
  "Z": "timeZone",
  "G": "era",
  "f": "milliseconds"
};
var timeSeparator = "timeSeparator";
var DateFormat = (
  /** @class */
  function() {
    function DateFormat2() {
    }
    DateFormat2.dateFormat = function(culture, option, cldr) {
      var _this = this;
      var dependable = IntlBase.getDependables(cldr, culture, option.calendar);
      getValue("parserObject.numbers", dependable);
      var dateObject = dependable.dateObject;
      var formatOptions = { isIslamic: IntlBase.islamicRegex.test(option.calendar) };
      formatOptions.firstDayOfWeek = IntlBase.getWeekData(culture, cldr);
      var resPattern = option.format || IntlBase.getResultantPattern(option.skeleton, dependable.dateObject, option.type, false, "");
      formatOptions.dateSeperator = IntlBase.getDateSeparator(dependable.dateObject);
      if (isUndefined(resPattern)) {
        throwError("Format options or type given must be invalid");
      } else {
        resPattern = IntlBase.ConvertDateToWeekFormat(resPattern);
        formatOptions.pattern = resPattern;
        formatOptions.numMapper = ParserBase.getNumberMapper(dependable.parserObject, ParserBase.getNumberingSystem(cldr));
        var patternMatch = resPattern.match(abbreviateRegexGlobal) || [];
        for (var _i = 0, patternMatch_1 = patternMatch; _i < patternMatch_1.length; _i++) {
          var str = patternMatch_1[_i];
          var len = str.length;
          var char = str[0];
          if (char === "K") {
            char = "h";
          }
          switch (char) {
            case "E":
            case "c":
              {
                formatOptions.weekday = dependable.dateObject["" + IntlBase.days]["" + standalone$1][IntlBase.monthIndex["" + len]];
              }
              break;
            case "M":
            case "L":
              {
                formatOptions.month = dependable.dateObject["" + IntlBase.month]["" + standalone$1][IntlBase.monthIndex["" + len]];
              }
              break;
            case "a":
              formatOptions.designator = getValue("dayPeriods.format.wide", dateObject);
              break;
            case "G": {
              var eText = len <= 3 ? "eraAbbr" : len === 4 ? "eraNames" : "eraNarrow";
              formatOptions.era = getValue("eras." + eText, dependable.dateObject);
              break;
            }
            case "z":
              formatOptions.timeZone = getValue("dates.timeZoneNames", dependable.parserObject);
              break;
          }
        }
      }
      return function(value) {
        if (isNaN(value.getDate())) {
          return null;
        }
        return _this.intDateFormatter(value, formatOptions);
      };
    };
    DateFormat2.intDateFormatter = function(value, options) {
      var pattern = options.pattern;
      var ret = "";
      var matches2 = pattern.match(IntlBase.dateParseRegex);
      var dObject = this.getCurrentDateValue(value, options.isIslamic);
      for (var _i = 0, matches_1 = matches2; _i < matches_1.length; _i++) {
        var match = matches_1[_i];
        var length_1 = match.length;
        var char = match[0];
        if (char === "K") {
          char = "h";
        }
        var curval = undefined;
        var curvalstr = "";
        var isNumber = undefined;
        var processNumber = undefined;
        var curstr = "";
        switch (char) {
          case "M":
          case "L":
            curval = dObject.month;
            if (length_1 > 2) {
              ret += options.month["" + curval];
            } else {
              isNumber = true;
            }
            break;
          case "E":
          case "c":
            ret += options.weekday["" + weekdayKey[value.getDay()]];
            break;
          case "H":
          case "h":
          case "m":
          case "s":
          case "d":
          case "f":
            isNumber = true;
            if (char === "d") {
              curval = dObject.date;
            } else if (char === "f") {
              isNumber = false;
              processNumber = true;
              curvalstr = value["" + timeSetter$1["" + char]]().toString();
              curvalstr = curvalstr.substring(0, length_1);
              var curlength = curvalstr.length;
              if (length_1 !== curlength) {
                if (length_1 > 3) {
                  continue;
                }
                for (var i = 0; i < length_1 - curlength; i++) {
                  curvalstr = "0" + curvalstr.toString();
                }
              }
              curstr += curvalstr;
            } else {
              curval = value["" + timeSetter$1["" + char]]();
            }
            if (char === "h") {
              curval = curval % 12 || 12;
            }
            break;
          case "y":
            processNumber = true;
            curstr += dObject.year;
            if (length_1 === 2) {
              curstr = curstr.substr(curstr.length - 2);
            }
            break;
          case "a": {
            var desig = value.getHours() < 12 ? "am" : "pm";
            ret += options.designator["" + desig];
            break;
          }
          case "G": {
            var dec = value.getFullYear() < 0 ? 0 : 1;
            var retu = options.era["" + dec];
            if (isNullOrUndefined(retu)) {
              retu = options.era[dec ? 0 : 1];
            }
            ret += retu || "";
            break;
          }
          case "'":
            ret += match === "''" ? "'" : match.replace(/'/g, "");
            break;
          case "z": {
            var timezone = value.getTimezoneOffset();
            var pattern_1 = length_1 < 4 ? "+H;-H" : options.timeZone.hourFormat;
            pattern_1 = pattern_1.replace(/:/g, options.numMapper.timeSeparator);
            if (timezone === 0) {
              ret += options.timeZone.gmtZeroFormat;
            } else {
              processNumber = true;
              curstr = this.getTimeZoneValue(timezone, pattern_1);
            }
            curstr = options.timeZone.gmtFormat.replace(/\{0\}/, curstr);
            break;
          }
          case ":":
            ret += options.numMapper.numberSymbols["" + timeSeparator];
            break;
          case "/":
            ret += options.dateSeperator;
            break;
          case "W":
            isNumber = true;
            curval = IntlBase.getWeekOfYear(value, options.firstDayOfWeek);
            break;
          default:
            ret += match;
        }
        if (isNumber) {
          processNumber = true;
          curstr = this.checkTwodigitNumber(curval, length_1);
        }
        if (processNumber) {
          ret += ParserBase.convertValueParts(curstr, IntlBase.latnParseRegex, options.numMapper.mapper);
        }
      }
      return ret;
    };
    DateFormat2.getCurrentDateValue = function(value, isIslamic) {
      if (isIslamic) {
        return HijriParser.getHijriDate(value);
      }
      return { year: value.getFullYear(), month: value.getMonth() + 1, date: value.getDate() };
    };
    DateFormat2.checkTwodigitNumber = function(val, len) {
      var ret = val + "";
      if (len === 2 && ret.length !== 2) {
        return "0" + ret;
      }
      return ret;
    };
    DateFormat2.getTimeZoneValue = function(tVal, pattern) {
      var _this = this;
      var splt = pattern.split(";");
      var curPattern = splt[tVal > 0 ? 1 : 0];
      var no = Math.abs(tVal);
      return curPattern = curPattern.replace(/HH?|mm/g, function(str) {
        var len = str.length;
        var ishour = str.indexOf("H") !== -1;
        return _this.checkTwodigitNumber(Math.floor(ishour ? no / 60 : no % 60), len);
      });
    };
    return DateFormat2;
  }()
);
setDateFormat(DateFormat);
var errorText = {
  "ms": "minimumSignificantDigits",
  "ls": "maximumSignificantDigits",
  "mf": "minimumFractionDigits",
  "lf": "maximumFractionDigits"
};
var percentSign = "percentSign";
var minusSign = "minusSign";
var mapper$1 = ["infinity", "nan", "group", "decimal", "exponential"];
var NumberFormat = (
  /** @class */
  function() {
    function NumberFormat2() {
    }
    NumberFormat2.numberFormatter = function(culture, option, cldr) {
      var _this = this;
      var fOptions = extend({}, option);
      var cOptions = {};
      var dOptions = {};
      var symbolPattern;
      var dependable = IntlBase.getDependables(cldr, culture, "", true);
      dependable.numericObject;
      dOptions.numberMapper = ParserBase.getNumberMapper(dependable.parserObject, ParserBase.getNumberingSystem(cldr), true);
      dOptions.currencySymbol = IntlBase.getCurrencySymbol(dependable.numericObject, fOptions.currency || defaultCurrencyCode, option.altSymbol, option.ignoreCurrency);
      dOptions.percentSymbol = dOptions.numberMapper.numberSymbols["" + percentSign];
      dOptions.minusSymbol = dOptions.numberMapper.numberSymbols["" + minusSign];
      var symbols = dOptions.numberMapper.numberSymbols;
      if (option.format && !IntlBase.formatRegex.test(option.format)) {
        cOptions = IntlBase.customFormat(option.format, dOptions, dependable.numericObject);
        if (!isUndefined(fOptions.useGrouping) && fOptions.useGrouping) {
          fOptions.useGrouping = cOptions.pData.useGrouping;
        }
      } else {
        extend(fOptions, IntlBase.getProperNumericSkeleton(option.format || "N"));
        fOptions.isCurrency = fOptions.type === "currency";
        fOptions.isPercent = fOptions.type === "percent";
        {
          symbolPattern = IntlBase.getSymbolPattern(fOptions.type, dOptions.numberMapper.numberSystem, dependable.numericObject, fOptions.isAccount);
        }
        fOptions.groupOne = this.checkValueRange(fOptions.maximumSignificantDigits, fOptions.minimumSignificantDigits, true);
        this.checkValueRange(fOptions.maximumFractionDigits, fOptions.minimumFractionDigits, false, true);
        if (!isUndefined(fOptions.fractionDigits)) {
          fOptions.minimumFractionDigits = fOptions.maximumFractionDigits = fOptions.fractionDigits;
        }
        if (isUndefined(fOptions.useGrouping)) {
          fOptions.useGrouping = true;
        }
        if (fOptions.isCurrency && true) {
          symbolPattern = symbolPattern.replace(/\u00A4/g, IntlBase.defaultCurrency);
        }
        {
          var split = symbolPattern.split(";");
          cOptions.nData = IntlBase.getFormatData(split[1] || "-" + split[0], true, dOptions.currencySymbol);
          cOptions.pData = IntlBase.getFormatData(split[0], false, dOptions.currencySymbol);
          if (fOptions.useGrouping) {
            fOptions.groupSeparator = symbols[mapper$1[2]];
            fOptions.groupData = this.getGroupingDetails(split[0]);
          }
        }
        var minFrac = isUndefined(fOptions.minimumFractionDigits);
        if (minFrac) {
          fOptions.minimumFractionDigits = cOptions.nData.minimumFraction;
        }
        if (isUndefined(fOptions.maximumFractionDigits)) {
          var mval = cOptions.nData.maximumFraction;
          fOptions.maximumFractionDigits = isUndefined(mval) && fOptions.isPercent ? 0 : mval;
        }
        var mfrac = fOptions.minimumFractionDigits;
        var lfrac = fOptions.maximumFractionDigits;
        if (!isUndefined(mfrac) && !isUndefined(lfrac)) {
          if (mfrac > lfrac) {
            fOptions.maximumFractionDigits = mfrac;
          }
        }
      }
      extend(cOptions.nData, fOptions);
      extend(cOptions.pData, fOptions);
      return function(value) {
        if (isNaN(value)) {
          return symbols[mapper$1[1]];
        } else if (!isFinite(value)) {
          return symbols[mapper$1[0]];
        }
        return _this.intNumberFormatter(value, cOptions, dOptions, option);
      };
    };
    NumberFormat2.getGroupingDetails = function(pattern) {
      var ret = {};
      var match = pattern.match(IntlBase.negativeDataRegex);
      if (match && match[4]) {
        var pattern_1 = match[4];
        var p = pattern_1.lastIndexOf(",");
        if (p !== -1) {
          var temp = pattern_1.split(".")[0];
          ret.primary = temp.length - p - 1;
          var s = pattern_1.lastIndexOf(",", p - 1);
          if (s !== -1) {
            ret.secondary = p - 1 - s;
          }
        }
      }
      return ret;
    };
    NumberFormat2.checkValueRange = function(val1, val2, checkbothExist, isFraction) {
      var decide = isFraction ? "f" : "s";
      var dint = 0;
      var str1 = errorText["l" + decide];
      var str2 = errorText["m" + decide];
      if (!isUndefined(val1)) {
        this.checkRange(val1, str1, isFraction);
        dint++;
      }
      if (!isUndefined(val2)) {
        this.checkRange(val2, str2, isFraction);
        dint++;
      }
      if (dint === 2) {
        if (val1 < val2) {
          throwError(str2 + "specified must be less than the" + str1);
        } else {
          return true;
        }
      } else if (checkbothExist && dint === 1) {
        throwError("Both" + str2 + "and" + str2 + "must be present");
      }
      return false;
    };
    NumberFormat2.checkRange = function(val, text, isFraction) {
      var range = isFraction ? [0, 20] : [1, 21];
      if (val < range[0] || val > range[1]) {
        throwError(text + "value must be within the range" + range[0] + "to" + range[1]);
      }
    };
    NumberFormat2.intNumberFormatter = function(value, fOptions, dOptions, option) {
      var curData;
      if (isUndefined(fOptions.nData.type)) {
        return undefined;
      } else {
        if (value < 0) {
          value = value * -1;
          curData = fOptions.nData;
        } else if (value === 0) {
          curData = fOptions.zeroData || fOptions.pData;
        } else {
          curData = fOptions.pData;
        }
        var fValue = "";
        if (curData.isPercent) {
          value = value * 100;
        }
        if (curData.groupOne) {
          fValue = this.processSignificantDigits(value, curData.minimumSignificantDigits, curData.maximumSignificantDigits);
        } else {
          fValue = this.processFraction(value, curData.minimumFractionDigits, curData.maximumFractionDigits, option);
          if (curData.minimumIntegerDigits) {
            fValue = this.processMinimumIntegers(fValue, curData.minimumIntegerDigits);
          }
          if (dOptions.isCustomFormat && curData.minimumFractionDigits < curData.maximumFractionDigits && /\d+\.\d+/.test(fValue)) {
            var temp = fValue.split(".");
            var decimalPart = temp[1];
            var len = decimalPart.length;
            for (var i = len - 1; i >= 0; i--) {
              if (decimalPart[parseInt(i.toString(), 10)] === "0" && i >= curData.minimumFractionDigits) {
                decimalPart = decimalPart.slice(0, i);
              } else {
                break;
              }
            }
            fValue = temp[0] + "." + decimalPart;
          }
        }
        if (curData.type === "scientific") {
          fValue = value.toExponential(curData.maximumFractionDigits);
          fValue = fValue.replace("e", dOptions.numberMapper.numberSymbols[mapper$1[4]]);
        }
        fValue = fValue.replace(".", dOptions.numberMapper.numberSymbols[mapper$1[3]]);
        fValue = curData.format === "#,###,,;(#,###,,)" ? this.customPivotFormat(parseInt(fValue, 10)) : fValue;
        if (curData.useGrouping) {
          fValue = this.groupNumbers(fValue, curData.groupData.primary, curData.groupSeparator || ",", dOptions.numberMapper.numberSymbols[mapper$1[3]] || ".", curData.groupData.secondary);
        }
        fValue = ParserBase.convertValueParts(fValue, IntlBase.latnParseRegex, dOptions.numberMapper.mapper);
        if (curData.nlead === "N/A") {
          return curData.nlead;
        } else {
          if (fValue === "0" && option && option.format === "0") {
            return fValue + curData.nend;
          }
          return curData.nlead + fValue + curData.nend;
        }
      }
    };
    NumberFormat2.processSignificantDigits = function(value, min, max) {
      var temp = value + "";
      var tn;
      var length = temp.length;
      if (length < min) {
        return value.toPrecision(min);
      } else {
        temp = value.toPrecision(max);
        tn = +temp;
        return tn + "";
      }
    };
    NumberFormat2.groupNumbers = function(val, level1, sep, decimalSymbol, level2) {
      var flag = !isNullOrUndefined(level2) && level2 !== 0;
      var split = val.split(decimalSymbol);
      var prefix = split[0];
      var length = prefix.length;
      var str = "";
      while (length > level1) {
        str = prefix.slice(length - level1, length) + (str.length ? sep + str : "");
        length -= level1;
        if (flag) {
          level1 = level2;
          flag = false;
        }
      }
      split[0] = prefix.slice(0, length) + (str.length ? sep : "") + str;
      return split.join(decimalSymbol);
    };
    NumberFormat2.processFraction = function(value, min, max, option) {
      var temp = (value + "").split(".")[1];
      var length = temp ? temp.length : 0;
      if (min && length < min) {
        var ret = "";
        if (length === 0) {
          ret = value.toFixed(min);
        } else {
          ret += value;
          for (var j = 0; j < min - length; j++) {
            ret += "0";
          }
          return ret;
        }
        return value.toFixed(min);
      } else if (!isNullOrUndefined(max) && (length > max || max === 0)) {
        return value.toFixed(max);
      }
      var str = value + "";
      if (str[0] === "0" && option && option.format === "###.00") {
        str = str.slice(1);
      }
      return str;
    };
    NumberFormat2.processMinimumIntegers = function(value, min) {
      var temp = value.split(".");
      var lead = temp[0];
      var len = lead.length;
      if (len < min) {
        for (var i = 0; i < min - len; i++) {
          lead = "0" + lead;
        }
        temp[0] = lead;
      }
      return temp.join(".");
    };
    NumberFormat2.customPivotFormat = function(value) {
      if (value >= 5e5) {
        value /= 1e6;
        var _a = value.toString().split(".");
        _a[0];
        var decimal = _a[1];
        return decimal && +decimal.substring(0, 1) >= 5 ? Math.ceil(value).toString() : Math.floor(value).toString();
      }
      return "";
    };
    return NumberFormat2;
  }()
);
setNumberFormat(NumberFormat);
var standalone = "stand-alone";
var latnRegex = /^[0-9]*$/;
var timeSetter = {
  minute: "setMinutes",
  hour: "setHours",
  second: "setSeconds",
  day: "setDate",
  month: "setMonth",
  milliseconds: "setMilliseconds"
};
var month = "months";
var DateParser = (
  /** @class */
  function() {
    function DateParser2() {
    }
    DateParser2.dateParser = function(culture, option, cldr) {
      var _this = this;
      var dependable = IntlBase.getDependables(cldr, culture, option.calendar);
      var numOptions = ParserBase.getCurrentNumericOptions(dependable.parserObject, ParserBase.getNumberingSystem(cldr), false, isBlazor());
      var parseOptions = {};
      var resPattern = option.format || IntlBase.getResultantPattern(option.skeleton, dependable.dateObject, option.type, false, "");
      var regexString = "";
      var hourOnly;
      if (isUndefined(resPattern)) {
        throwError("Format options or type given must be invalid");
      } else {
        resPattern = IntlBase.ConvertDateToWeekFormat(resPattern);
        parseOptions = { isIslamic: IntlBase.islamicRegex.test(option.calendar), pattern: resPattern, evalposition: {}, culture };
        var patternMatch = resPattern.match(IntlBase.dateParseRegex) || [];
        var length_1 = patternMatch.length;
        var gmtCorrection = 0;
        var zCorrectTemp = 0;
        var isgmtTraversed = false;
        var nRegx = numOptions.numericRegex;
        var numMapper = ParserBase.getNumberMapper(dependable.parserObject, ParserBase.getNumberingSystem(cldr));
        for (var i = 0; i < length_1; i++) {
          var str = patternMatch[parseInt(i.toString(), 10)];
          var len = str.length;
          var char = str[0] === "K" ? "h" : str[0];
          var isNumber = undefined;
          var canUpdate = undefined;
          var charKey = datePartMatcher["" + char];
          var optional = len === 2 ? "" : "?";
          if (isgmtTraversed) {
            gmtCorrection = zCorrectTemp;
            isgmtTraversed = false;
          }
          switch (char) {
            case "E":
            case "c": {
              var weekData = undefined;
              {
                weekData = dependable.dateObject["" + IntlBase.days]["" + standalone][IntlBase.monthIndex["" + len]];
              }
              var weekObject = ParserBase.reverseObject(weekData);
              regexString += "(" + Object.keys(weekObject).join("|") + ")";
              break;
            }
            case "M":
            case "L":
            case "d":
            case "m":
            case "s":
            case "h":
            case "H":
            case "f":
              canUpdate = true;
              if ((char === "M" || char === "L") && len > 2) {
                var monthData = undefined;
                {
                  monthData = dependable.dateObject["" + month]["" + standalone][IntlBase.monthIndex["" + len]];
                }
                parseOptions["" + charKey] = ParserBase.reverseObject(monthData);
                regexString += "(" + Object.keys(parseOptions["" + charKey]).join("|") + ")";
              } else if (char === "f") {
                if (len > 3) {
                  continue;
                }
                isNumber = true;
                regexString += "(" + nRegx + nRegx + "?" + nRegx + "?)";
              } else {
                isNumber = true;
                regexString += "(" + nRegx + nRegx + optional + ")";
              }
              if (char === "h") {
                parseOptions.hour12 = true;
              }
              break;
            case "W": {
              var opt = len === 1 ? "?" : "";
              regexString += "(" + nRegx + opt + nRegx + ")";
              break;
            }
            case "y":
              canUpdate = isNumber = true;
              if (len === 2) {
                regexString += "(" + nRegx + nRegx + ")";
              } else {
                regexString += "(" + nRegx + "{" + len + ",})";
              }
              break;
            case "a": {
              canUpdate = true;
              var periodValur = getValue("dayPeriods.format.wide", dependable.dateObject);
              parseOptions["" + charKey] = ParserBase.reverseObject(periodValur);
              regexString += "(" + Object.keys(parseOptions["" + charKey]).join("|") + ")";
              break;
            }
            case "G": {
              canUpdate = true;
              var eText = len <= 3 ? "eraAbbr" : len === 4 ? "eraNames" : "eraNarrow";
              parseOptions["" + charKey] = ParserBase.reverseObject(getValue("eras." + eText, dependable.dateObject));
              regexString += "(" + Object.keys(parseOptions["" + charKey]).join("|") + "?)";
              break;
            }
            case "z": {
              var tval = (/* @__PURE__ */ new Date()).getTimezoneOffset();
              canUpdate = tval !== 0;
              parseOptions["" + charKey] = getValue("dates.timeZoneNames", dependable.parserObject);
              var tzone = parseOptions["" + charKey];
              hourOnly = len < 4;
              var hpattern = hourOnly ? "+H;-H" : tzone.hourFormat;
              hpattern = hpattern.replace(/:/g, numMapper.timeSeparator);
              regexString += "(" + this.parseTimeZoneRegx(hpattern, tzone, nRegx) + ")?";
              isgmtTraversed = true;
              zCorrectTemp = hourOnly ? 6 : 12;
              break;
            }
            case "'": {
              var iString = str.replace(/'/g, "");
              regexString += "(" + iString + ")?";
              break;
            }
            default:
              regexString += "([\\D])";
              break;
          }
          if (canUpdate) {
            parseOptions.evalposition["" + charKey] = { isNumber, pos: i + 1 + gmtCorrection, hourOnly };
          }
          if (i === length_1 - 1 && !isNullOrUndefined(regexString)) {
            var regExp2 = RegExp;
            parseOptions.parserRegex = new regExp2("^" + regexString + "$", "i");
          }
        }
      }
      return function(value) {
        var parsedDateParts = _this.internalDateParse(value, parseOptions, numOptions);
        if (isNullOrUndefined(parsedDateParts) || !Object.keys(parsedDateParts).length) {
          return null;
        }
        if (parseOptions.isIslamic) {
          var dobj = {};
          var tYear = parsedDateParts.year;
          var tDate = parsedDateParts.day;
          var tMonth = parsedDateParts.month;
          var ystrig = tYear ? tYear + "" : "";
          var is2DigitYear = ystrig.length === 2;
          if (!tYear || !tMonth || !tDate || is2DigitYear) {
            dobj = HijriParser.getHijriDate(/* @__PURE__ */ new Date());
          }
          if (is2DigitYear) {
            tYear = parseInt((dobj.year + "").slice(0, 2) + ystrig, 10);
          }
          var dateObject = HijriParser.toGregorian(tYear || dobj.year, tMonth || dobj.month, tDate || dobj.date);
          parsedDateParts.year = dateObject.getFullYear();
          parsedDateParts.month = dateObject.getMonth() + 1;
          parsedDateParts.day = dateObject.getDate();
        }
        return _this.getDateObject(parsedDateParts);
      };
    };
    DateParser2.getDateObject = function(options, value) {
      var res = value || /* @__PURE__ */ new Date();
      res.setMilliseconds(0);
      var tKeys = ["hour", "minute", "second", "milliseconds", "month", "day"];
      var y = options.year;
      var desig = options.designator;
      var tzone = options.timeZone;
      if (!isUndefined(y)) {
        var len = (y + "").length;
        if (len <= 2) {
          var century = Math.floor(res.getFullYear() / 100) * 100;
          y += century;
        }
        res.setFullYear(y);
      }
      for (var _i = 0, tKeys_1 = tKeys; _i < tKeys_1.length; _i++) {
        var key = tKeys_1[_i];
        var tValue = options["" + key];
        if (isUndefined(tValue) && key === "day") {
          res.setDate(1);
        }
        if (!isUndefined(tValue)) {
          if (key === "month") {
            tValue -= 1;
            if (tValue < 0 || tValue > 11) {
              return /* @__PURE__ */ new Date("invalid");
            }
            var pDate = res.getDate();
            res.setDate(1);
            res[timeSetter["" + key]](tValue);
            var lDate = new Date(res.getFullYear(), tValue + 1, 0).getDate();
            res.setDate(pDate < lDate ? pDate : lDate);
          } else {
            if (key === "day") {
              var lastDay = new Date(res.getFullYear(), res.getMonth() + 1, 0).getDate();
              if (tValue < 1 || tValue > lastDay) {
                return null;
              }
            }
            res["" + timeSetter["" + key]](tValue);
          }
        }
      }
      if (!isUndefined(desig)) {
        var hour = res.getHours();
        if (desig === "pm") {
          res.setHours(hour + (hour === 12 ? 0 : 12));
        } else if (hour === 12) {
          res.setHours(0);
        }
      }
      if (!isUndefined(tzone)) {
        var tzValue = tzone - res.getTimezoneOffset();
        if (tzValue !== 0) {
          res.setMinutes(res.getMinutes() + tzValue);
        }
      }
      return res;
    };
    DateParser2.internalDateParse = function(value, parseOptions, num) {
      var matches2 = value.match(parseOptions.parserRegex);
      var retOptions = { "hour": 0, "minute": 0, "second": 0 };
      if (isNullOrUndefined(matches2)) {
        return null;
      } else {
        var props2 = Object.keys(parseOptions.evalposition);
        for (var _i = 0, props_1 = props2; _i < props_1.length; _i++) {
          var prop = props_1[_i];
          var curObject = parseOptions.evalposition["" + prop];
          var matchString = matches2[curObject.pos];
          if (curObject.isNumber) {
            retOptions["" + prop] = this.internalNumberParser(matchString, num);
          } else {
            if (prop === "timeZone" && !isUndefined(matchString)) {
              var pos = curObject.pos;
              var val = undefined;
              var tmatch = matches2[pos + 1];
              var flag = !isUndefined(tmatch);
              if (curObject.hourOnly) {
                val = this.getZoneValue(flag, tmatch, matches2[pos + 4], num) * 60;
              } else {
                val = this.getZoneValue(flag, tmatch, matches2[pos + 7], num) * 60;
                val += this.getZoneValue(flag, matches2[pos + 4], matches2[pos + 10], num);
              }
              if (!isNullOrUndefined(val)) {
                retOptions["" + prop] = val;
              }
            } else {
              var cultureOptions = ["en-US", "en-MH", "en-MP"];
              matchString = prop === "month" && !parseOptions.isIslamic && (parseOptions.culture === "en" || parseOptions.culture === "en-GB" || parseOptions.culture === "en-US") ? matchString[0].toUpperCase() + matchString.substring(1).toLowerCase() : matchString;
              matchString = prop !== "month" && prop === "designator" && parseOptions.culture && parseOptions.culture.indexOf("en-") !== -1 && cultureOptions.indexOf(parseOptions.culture) === -1 ? matchString.toLowerCase() : matchString;
              retOptions["" + prop] = parseOptions["" + prop]["" + matchString];
            }
          }
        }
        if (parseOptions.hour12) {
          retOptions.hour12 = true;
        }
      }
      return retOptions;
    };
    DateParser2.internalNumberParser = function(value, option) {
      value = ParserBase.convertValueParts(value, option.numberParseRegex, option.numericPair);
      if (latnRegex.test(value)) {
        return +value;
      }
      return null;
    };
    DateParser2.parseTimeZoneRegx = function(hourFormat, tZone, nRegex) {
      var pattern = tZone.gmtFormat;
      var ret;
      var cRegex = "(" + nRegex + ")(" + nRegex + ")";
      ret = hourFormat.replace("+", "\\+");
      if (hourFormat.indexOf("HH") !== -1) {
        ret = ret.replace(/HH|mm/g, "(" + cRegex + ")");
      } else {
        ret = ret.replace(/H|m/g, "(" + cRegex + "?)");
      }
      var splitStr = ret.split(";").map(function(str) {
        return pattern.replace("{0}", str);
      });
      ret = splitStr.join("|") + "|" + tZone.gmtZeroFormat;
      return ret;
    };
    DateParser2.getZoneValue = function(flag, val1, val2, num) {
      var ival = flag ? val1 : val2;
      if (!ival) {
        return 0;
      }
      var value = this.internalNumberParser(ival, num);
      if (flag) {
        return -value;
      }
      return value;
    };
    return DateParser2;
  }()
);
var regExp = RegExp;
var parseRegex = new regExp("^([^0-9]*)(([0-9,]*[0-9]+)(.[0-9]+)?)([Ee][+-]?[0-9]+)?([^0-9]*)$");
var groupRegex = /,/g;
var keys = ["minusSign", "infinity"];
var NumberParser = (
  /** @class */
  function() {
    function NumberParser2() {
    }
    NumberParser2.numberParser = function(culture, option, cldr) {
      var _this = this;
      var dependable = IntlBase.getDependables(cldr, culture, "", true);
      var parseOptions = { custom: true };
      if (IntlBase.formatRegex.test(option.format) || !option.format) {
        extend(parseOptions, IntlBase.getProperNumericSkeleton(option.format || "N"));
        parseOptions.custom = false;
        if (!parseOptions.fractionDigits) {
          if (option.maximumFractionDigits) {
            parseOptions.maximumFractionDigits = option.maximumFractionDigits;
          }
        }
      } else {
        extend(parseOptions, IntlBase.customFormat(option.format, null, null));
      }
      getValue("numbers", dependable.parserObject);
      var numOptions = ParserBase.getCurrentNumericOptions(dependable.parserObject, ParserBase.getNumberingSystem(cldr), true, isBlazor());
      parseOptions.symbolRegex = ParserBase.getSymbolRegex(Object.keys(numOptions.symbolMatch));
      parseOptions.infinity = numOptions.symbolNumberSystem[keys[1]];
      var symbolpattern;
      {
        symbolpattern = IntlBase.getSymbolPattern(parseOptions.type, numOptions.numberSystem, dependable.numericObject, parseOptions.isAccount);
        if (symbolpattern) {
          symbolpattern = symbolpattern.replace(/\u00A4/g, IntlBase.defaultCurrency);
          var split = symbolpattern.split(";");
          parseOptions.nData = IntlBase.getFormatData(split[1] || "-" + split[0], true, "");
          parseOptions.pData = IntlBase.getFormatData(split[0], true, "");
        }
      }
      return function(value) {
        return _this.getParsedNumber(value, parseOptions, numOptions);
      };
    };
    NumberParser2.getParsedNumber = function(value, options, numOptions) {
      var isNegative;
      var isPercent;
      var tempValue;
      var lead;
      var end;
      var ret;
      if (value.indexOf(options.infinity) !== -1) {
        return Infinity;
      } else {
        value = ParserBase.convertValueParts(value, options.symbolRegex, numOptions.symbolMatch);
        value = ParserBase.convertValueParts(value, numOptions.numberParseRegex, numOptions.numericPair);
        value = value.indexOf("-") !== -1 ? value.replace("-.", "-0.") : value;
        if (value.indexOf(".") === 0) {
          value = "0" + value;
        }
        var matches2 = value.match(parseRegex);
        if (isNullOrUndefined(matches2)) {
          return NaN;
        }
        lead = matches2[1];
        tempValue = matches2[2];
        var exponent = matches2[5];
        end = matches2[6];
        isNegative = options.custom ? lead === options.nData.nlead && end === options.nData.nend : lead.indexOf(options.nData.nlead) !== -1 && end.indexOf(options.nData.nend) !== -1;
        isPercent = isNegative ? options.nData.isPercent : options.pData.isPercent;
        tempValue = tempValue.replace(groupRegex, "");
        if (exponent) {
          tempValue += exponent;
        }
        ret = +tempValue;
        if (options.type === "percent" || isPercent) {
          ret = ret / 100;
        }
        if (options.custom || options.fractionDigits) {
          ret = parseFloat(ret.toFixed(options.custom ? isNegative ? options.nData.maximumFractionDigits : options.pData.maximumFractionDigits : options.fractionDigits));
        }
        if (options.maximumFractionDigits) {
          ret = this.convertMaxFracDigits(tempValue, options, ret, isNegative);
        }
        if (isNegative) {
          ret *= -1;
        }
        return ret;
      }
    };
    NumberParser2.convertMaxFracDigits = function(value, options, ret, isNegative) {
      var decimalSplitValue = value.split(".");
      if (decimalSplitValue[1] && decimalSplitValue[1].length > options.maximumFractionDigits) {
        ret = +ret.toFixed(options.custom ? isNegative ? options.nData.maximumFractionDigits : options.pData.maximumFractionDigits : options.maximumFractionDigits);
      }
      return ret;
    };
    return NumberParser2;
  }()
);
var onIntlChange = new Observer();
var rightToLeft = false;
var cldrData = {};
var defaultCulture = "en-US";
var mapper = ["numericObject", "dateObject"];
var Internationalization = (
  /** @class */
  function() {
    function Internationalization2(cultureName) {
      if (cultureName) {
        this.culture = cultureName;
      }
    }
    Internationalization2.prototype.getDateFormat = function(options) {
      return DateFormat.dateFormat(this.getCulture(), options || { type: "date", skeleton: "short" }, cldrData);
    };
    Internationalization2.prototype.getNumberFormat = function(options) {
      if (options && !options.currency) {
        options.currency = defaultCurrencyCode;
      }
      return NumberFormat.numberFormatter(this.getCulture(), options || {}, cldrData);
    };
    Internationalization2.prototype.getDateParser = function(options) {
      return DateParser.dateParser(this.getCulture(), options || { skeleton: "short", type: "date" }, cldrData);
    };
    Internationalization2.prototype.getNumberParser = function(options) {
      return NumberParser.numberParser(this.getCulture(), options || { format: "N" }, cldrData);
    };
    Internationalization2.prototype.formatNumber = function(value, option) {
      return this.getNumberFormat(option)(value);
    };
    Internationalization2.prototype.formatDate = function(value, option) {
      return this.getDateFormat(option)(value);
    };
    Internationalization2.prototype.parseDate = function(value, option) {
      return this.getDateParser(option)(value);
    };
    Internationalization2.prototype.parseNumber = function(value, option) {
      return this.getNumberParser(option)(value);
    };
    Internationalization2.prototype.getDatePattern = function(option, isExcelFormat) {
      return IntlBase.getActualDateTimeFormat(this.getCulture(), option, cldrData, isExcelFormat);
    };
    Internationalization2.prototype.getNumberPattern = function(option, isExcel) {
      return IntlBase.getActualNumberFormat(this.getCulture(), option, cldrData, isExcel);
    };
    Internationalization2.prototype.getFirstDayOfWeek = function() {
      return IntlBase.getWeekData(this.getCulture(), cldrData);
    };
    Internationalization2.prototype.getCulture = function() {
      return this.culture || defaultCulture;
    };
    return Internationalization2;
  }()
);
function getNumericObject(locale, type) {
  var numObject = IntlBase.getDependables(cldrData, locale, "", true)[mapper[0]];
  var dateObject = IntlBase.getDependables(cldrData, locale, "")[mapper[1]];
  var numSystem = getValue("defaultNumberingSystem", numObject);
  var symbPattern = getValue("symbols-numberSystem-" + numSystem, numObject);
  var pattern = IntlBase.getSymbolPattern("decimal", numSystem, numObject, false);
  return extend(symbPattern, IntlBase.getFormatData(pattern, true, "", true), { "dateSeparator": IntlBase.getDateSeparator(dateObject) });
}
function getDefaultDateObject(mode) {
  return IntlBase.getDependables(cldrData, "", mode, false)[mapper[1]];
}
var bypassKey = [
  115,
  121,
  110,
  99,
  102,
  117,
  115,
  105,
  111,
  110,
  46,
  105,
  115,
  76,
  105,
  99,
  86,
  97,
  108,
  105,
  100,
  97,
  116,
  101,
  100
];
var LicenseValidator = (
  /** @class */
  function() {
    function LicenseValidator2(key) {
      this.isValidated = false;
      this.isLicensed = true;
      this.version = "29";
      this.platform = /JavaScript|ASPNET|ASPNETCORE|ASPNETMVC|FileFormats|essentialstudio/i;
      this.errors = {
        noLicense: "<span>This application was built using a trial version of Syncfusion<sup>\xAE</sup> Essential Studio<sup>\xAE</sup>. To remove the license validation message permanently, a valid license key must be included.</span>",
        trailExpired: "<span>This application was built using a trial version of Syncfusion<sup>\xAE</sup> Essential Studio<sup>\xAE</sup>. To remove the license validation message permanently, a valid license key must be included.</span>",
        versionMismatched: "<span>The included Syncfusion<sup>\xAE</sup> license key is invalid.</span>",
        platformMismatched: "<span>The included Syncfusion<sup>\xAE</sup> license key is invalid.</span>",
        invalidKey: "<span>The included Syncfusion<sup>\xAE</sup> license key is invalid.</span>"
      };
      this.minVersion = null;
      this.manager = /* @__PURE__ */ function() {
        var licKey = null;
        function set(key2) {
          licKey = key2;
        }
        function get() {
          return licKey;
        }
        return {
          setKey: set,
          getKey: get
        };
      }();
      this.npxManager = /* @__PURE__ */ function() {
        var npxLicKey = "npxKeyReplace";
        function get() {
          return npxLicKey;
        }
        return {
          getKey: get
        };
      }();
      this.manager.setKey(key);
    }
    LicenseValidator2.prototype.validate = function() {
      var contentKey = [
        115,
        121,
        110,
        99,
        102,
        117,
        115,
        105,
        111,
        110,
        46,
        108,
        105,
        99,
        101,
        110,
        115,
        101,
        67,
        111,
        110,
        116,
        101,
        110,
        116
      ];
      var URLKey = [
        115,
        121,
        110,
        99,
        102,
        117,
        115,
        105,
        111,
        110,
        46,
        99,
        108,
        97,
        105,
        109,
        65,
        99,
        99,
        111,
        117,
        110,
        116,
        85,
        82,
        76
      ];
      if (!this.isValidated && (!getValue(convertToChar(bypassKey), containerObject) && !getValue("Blazor", containerObject))) {
        var validateMsg = undefined;
        if (this.manager && this.manager.getKey() || this.npxManager && this.npxManager.getKey() !== "npxKeyReplace") {
          var result = this.getInfoFromKey();
          if (result && result.length) {
            for (var _i = 0, result_1 = result; _i < result_1.length; _i++) {
              var res = result_1[_i];
              if (!this.platform.test(res.platform) || res.invalidPlatform) {
                validateMsg = this.errors.platformMismatched;
              } else {
                if (res.minVersion >= res.lastValue && res.minVersion !== res.lastValue || res.lastValue < parseInt(this.version, 10)) {
                  validateMsg = this.errors.versionMismatched;
                  validateMsg = validateMsg.replace("##LicenseVersion", res.version);
                  validateMsg = validateMsg.replace("##Requireversion", this.version + ".x");
                } else {
                  if (res.lastValue == null || isNaN(res.lastValue)) {
                    validateMsg = this.errors.versionMismatched;
                    validateMsg = validateMsg.replace("##LicenseVersion", res.version);
                    validateMsg = validateMsg.replace("##Requireversion", this.version + ".x");
                  }
                }
                if (res.expiryDate) {
                  var expDate = new Date(res.expiryDate);
                  var currDate = /* @__PURE__ */ new Date();
                  if (expDate !== currDate && expDate < currDate) {
                    validateMsg = this.errors.trailExpired;
                  } else {
                    break;
                  }
                }
              }
            }
          } else {
            validateMsg = this.errors.invalidKey;
          }
        } else {
          var licenseContent = getValue(convertToChar(contentKey), containerObject);
          getValue(convertToChar(URLKey), containerObject);
          if (licenseContent && licenseContent !== "") {
            validateMsg = licenseContent;
          } else {
            validateMsg = this.errors.noLicense;
          }
        }
        this.isValidated = true;
        setValue(convertToChar(bypassKey), this.isValidated, containerObject);
      }
      return this.isLicensed;
    };
    LicenseValidator2.prototype.getDecryptedData = function(key) {
      try {
        return atob(key);
      } catch (error) {
        return "";
      }
    };
    LicenseValidator2.prototype.getInfoFromKey = function() {
      try {
        var licKey = "";
        var pkey = [
          5439488,
          7929856,
          5111808,
          6488064,
          4587520,
          7667712,
          5439488,
          6881280,
          5177344,
          7208960,
          4194304,
          4456448,
          6619136,
          7733248,
          5242880,
          7077888,
          6356992,
          7602176,
          4587520,
          7274496,
          7471104,
          7143424
        ];
        var decryptedStr = [];
        var resultArray = [];
        var invalidPlatform = false;
        var isNpxKey = false;
        if (this.manager.getKey()) {
          licKey = this.manager.getKey();
        } else {
          isNpxKey = true;
          licKey = this.npxManager.getKey().split("npxKeyReplace")[1];
        }
        var licKeySplit = licKey.split(";");
        for (var _i = 0, licKeySplit_1 = licKeySplit; _i < licKeySplit_1.length; _i++) {
          var lKey = licKeySplit_1[_i];
          var decodeStr = this.getDecryptedData(lKey);
          if (!decodeStr) {
            continue;
          }
          var k = 0;
          var buffr = "";
          if (!isNpxKey) {
            for (var i = 0; i < decodeStr.length; i++, k++) {
              if (k === pkey.length) {
                k = 0;
              }
              var c = decodeStr.charCodeAt(i);
              buffr += String.fromCharCode(c ^ pkey[parseInt(k.toString(), 10)] >> 16);
            }
          } else {
            var charKey = decodeStr[decodeStr.length - 1];
            var decryptedKey = [];
            for (var i = 0; i < decodeStr.length; i++) {
              decryptedKey[parseInt(i.toString(), 10)] = decodeStr[parseInt(i.toString(), 10)].charCodeAt(0) - charKey.charCodeAt(0);
            }
            for (var i = 0; i < decryptedKey.length; i++) {
              buffr += String.fromCharCode(decryptedKey[parseInt(i.toString(), 10)]);
            }
          }
          if (this.platform.test(buffr)) {
            decryptedStr = buffr.split(";");
            invalidPlatform = false;
            if (decryptedStr.length > 3) {
              var minVersion = parseInt(decryptedStr[1].split(".")[0], 10);
              var lastValue = parseInt(decryptedStr[4], 10);
              resultArray.push({
                platform: decryptedStr[0],
                version: decryptedStr[1],
                expiryDate: decryptedStr[2],
                lastValue,
                minVersion
              });
            }
          } else if (buffr && buffr.split(";").length > 3) {
            invalidPlatform = true;
          }
        }
        if (invalidPlatform && !resultArray.length) {
          return [{ invalidPlatform }];
        } else {
          return resultArray.length ? resultArray : null;
        }
      } catch (error) {
        return null;
      }
    };
    return LicenseValidator2;
  }()
);
new LicenseValidator();
function convertToChar(cArr) {
  var ret = "";
  for (var _i = 0, cArr_1 = cArr; _i < cArr_1.length; _i++) {
    var arr = cArr_1[_i];
    ret += String.fromCharCode(arr);
  }
  return ret;
}
function registerLicense(key) {
  new LicenseValidator(key);
}
var __extends$k = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate$k = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var componentCount = 0;
var lastPageID;
var lastHistoryLen = 0;
var Component = (
  /** @class */
  function(_super) {
    __extends$k(Component2, _super);
    function Component2(options, selector) {
      var _this = _super.call(this, options, selector) || this;
      _this.randomId = uniqueID();
      _this.isStringTemplate = false;
      _this.needsID = false;
      _this.isReactHybrid = false;
      _this.isAngular = false;
      _this.isReact = false;
      _this.isVue = false;
      if (isNullOrUndefined(_this.enableRtl)) {
        _this.setProperties({ "enableRtl": rightToLeft }, true);
      }
      if (isNullOrUndefined(_this.locale)) {
        _this.setProperties({ "locale": defaultCulture }, true);
      }
      _this.moduleLoader = new ModuleLoader(_this);
      _this.localObserver = new Observer(_this);
      onIntlChange.on("notifyExternalChange", _this.detectFunction, _this, _this.randomId);
      if (!isUndefined(selector)) {
        _this.appendTo();
      }
      return _this;
    }
    Component2.prototype.requiredModules = function() {
      return [];
    };
    Component2.prototype.destroy = function() {
      if (this.isDestroyed) {
        return;
      }
      if (this.enablePersistence) {
        this.setPersistData();
        this.detachUnloadEvent();
      }
      this.localObserver.destroy();
      if (this.refreshing) {
        return;
      }
      removeClass([this.element], ["e-control"]);
      this.trigger("destroyed", { cancel: false });
      _super.prototype.destroy.call(this);
      this.moduleLoader.clean();
      onIntlChange.off("notifyExternalChange", this.detectFunction, this.randomId);
    };
    Component2.prototype.refresh = function() {
      this.refreshing = true;
      this.moduleLoader.clean();
      this.destroy();
      this.clearChanges();
      this.localObserver = new Observer(this);
      this.preRender();
      this.injectModules();
      this.render();
      this.refreshing = false;
    };
    Component2.prototype.accessMount = function() {
      if (this.mount && !this.isReactHybrid) {
        this.mount();
      }
    };
    Component2.prototype.getRootElement = function() {
      if (this.isReactHybrid) {
        return this.actualElement;
      } else {
        return this.element;
      }
    };
    Component2.prototype.getLocalData = function() {
      var eleId = this.getModuleName() + this.element.id;
      {
        return (undefined).localStorage.getItem(eleId);
      }
    };
    Component2.prototype.attachUnloadEvent = function() {
      this.handleUnload = this.handleUnload.bind(this);
      (undefined).addEventListener("pagehide", this.handleUnload);
    };
    Component2.prototype.handleUnload = function() {
      this.setPersistData();
    };
    Component2.prototype.detachUnloadEvent = function() {
      (undefined).removeEventListener("pagehide", this.handleUnload);
    };
    Component2.prototype.appendTo = function(selector) {
      if (!isNullOrUndefined(selector) && typeof selector === "string") {
        this.element = select(selector, undefined);
      } else if (!isNullOrUndefined(selector)) {
        this.element = selector;
      }
      if (!isNullOrUndefined(this.element)) {
        var moduleClass = "e-" + this.getModuleName().toLowerCase();
        addClass([this.element], ["e-control", moduleClass]);
        this.isProtectedOnChange = false;
        if (this.needsID && !this.element.id) {
          this.element.id = this.getUniqueID(this.getModuleName());
        }
        if (this.enablePersistence) {
          this.mergePersistData();
          this.attachUnloadEvent();
        }
        var inst = getValue("ej2_instances", this.element);
        if (!inst || inst.indexOf(this) === -1) {
          _super.prototype.addInstance.call(this);
        }
        this.preRender();
        this.injectModules();
        var ignoredComponents = {
          schedule: "all",
          diagram: "all",
          PdfViewer: "all",
          grid: ["logger"],
          richtexteditor: ["link", "table", "image", "audio", "video", "formatPainter", "emojiPicker", "pasteCleanup", "htmlEditor", "toolbar", "importExport"],
          treegrid: ["filter"],
          gantt: ["tooltip"],
          chart: ["Export", "Zoom"],
          accumulationchart: ["Export"],
          "query-builder": "all"
        };
        var component = this.getModuleName();
        if (this.requiredModules && (!ignoredComponents["" + component] || ignoredComponents["" + component] !== "all")) {
          var modulesRequired = this.requiredModules();
          for (var _i = 0, _a = this.moduleLoader.getNonInjectedModules(modulesRequired); _i < _a.length; _i++) {
            var module = _a[_i];
            var moduleName = module.name ? module.name : module.member;
            if (ignoredComponents["" + component] && ignoredComponents["" + component].indexOf(module.member) !== -1) {
              continue;
            }
            var componentName = component.charAt(0).toUpperCase() + component.slice(1);
            console.warn('[WARNING] :: Module "' + moduleName + '" is not available in ' + componentName + " component! You either misspelled the module name or forgot to load it.");
          }
        }
        this.render();
        if (!this.mount) {
          this.trigger("created");
        } else {
          this.accessMount();
        }
      }
    };
    Component2.prototype.renderComplete = function(wrapperElement) {
      this.isRendered = true;
    };
    Component2.prototype.dataBind = function() {
      this.injectModules();
      _super.prototype.dataBind.call(this);
    };
    Component2.prototype.on = function(event, handler, context) {
      if (typeof event === "string") {
        this.localObserver.on(event, handler, context);
      } else {
        for (var _i = 0, event_1 = event; _i < event_1.length; _i++) {
          var arg = event_1[_i];
          this.localObserver.on(arg.event, arg.handler, arg.context);
        }
      }
    };
    Component2.prototype.off = function(event, handler) {
      if (typeof event === "string") {
        this.localObserver.off(event, handler);
      } else {
        for (var _i = 0, event_2 = event; _i < event_2.length; _i++) {
          var arg = event_2[_i];
          this.localObserver.off(arg.event, arg.handler);
        }
      }
    };
    Component2.prototype.notify = function(property, argument) {
      if (this.isDestroyed !== true) {
        this.localObserver.notify(property, argument);
      }
    };
    Component2.prototype.getInjectedModules = function() {
      return this.injectedModules;
    };
    Component2.Inject = function() {
      var moduleList = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        moduleList[_i] = arguments[_i];
      }
      if (!this.prototype.injectedModules) {
        this.prototype.injectedModules = [];
      }
      for (var i = 0; i < moduleList.length; i++) {
        if (this.prototype.injectedModules.indexOf(moduleList[parseInt(i.toString(), 10)]) === -1) {
          this.prototype.injectedModules.push(moduleList[parseInt(i.toString(), 10)]);
        }
      }
    };
    Component2.prototype.createElement = function(tagName, prop, isVDOM) {
      return createElement(tagName, prop);
    };
    Component2.prototype.triggerStateChange = function(handler, argument) {
      if (this.isReactHybrid) {
        this.setState();
        this.currentContext = { calls: handler, args: argument };
      }
    };
    Component2.prototype.injectModules = function() {
      if (this.injectedModules && this.injectedModules.length) {
        this.moduleLoader.inject(this.requiredModules(), this.injectedModules);
      }
    };
    Component2.prototype.detectFunction = function(args) {
      var prop = Object.keys(args);
      if (prop.length) {
        this[prop[0]] = args[prop[0]];
      }
    };
    Component2.prototype.mergePersistData = function() {
      var data;
      {
        data = (undefined).localStorage.getItem(this.getModuleName() + this.element.id);
      }
      if (!(isNullOrUndefined(data) || data === "")) {
        this.setProperties(JSON.parse(data), true);
      }
    };
    Component2.prototype.setPersistData = function() {
      if (!this.isDestroyed) {
        {
          (undefined).localStorage.setItem(this.getModuleName() + this.element.id, this.getPersistData());
        }
      }
    };
    Component2.prototype.renderReactTemplates = function(callback) {
      if (!isNullOrUndefined(callback)) {
        callback();
      }
    };
    Component2.prototype.clearTemplate = function(templateName, index) {
    };
    Component2.prototype.getUniqueID = function(definedName) {
      if (this.isHistoryChanged()) {
        componentCount = 0;
      }
      lastPageID = this.pageID((undefined).href);
      lastHistoryLen = history.length;
      return definedName + "_" + lastPageID + "_" + componentCount++;
    };
    Component2.prototype.pageID = function(url) {
      var hash = 0;
      if (url.length === 0) {
        return hash;
      }
      for (var i = 0; i < url.length; i++) {
        var char = url.charCodeAt(i);
        hash = (hash << 5) - hash + char;
        hash = hash & hash;
      }
      return Math.abs(hash);
    };
    Component2.prototype.isHistoryChanged = function() {
      return lastPageID !== this.pageID((undefined).href) || lastHistoryLen !== history.length;
    };
    Component2.prototype.addOnPersist = function(options) {
      var _this = this;
      var persistObj = {};
      for (var _i = 0, options_1 = options; _i < options_1.length; _i++) {
        var key = options_1[_i];
        var objValue = getValue(key, this);
        if (!isUndefined(objValue)) {
          setValue(key, this.getActualProperties(objValue), persistObj);
        }
      }
      return JSON.stringify(persistObj, function(key2, value) {
        return _this.getActualProperties(value);
      });
    };
    Component2.prototype.getActualProperties = function(obj) {
      if (obj instanceof ChildProperty) {
        return getValue("properties", obj);
      } else {
        return obj;
      }
    };
    Component2.prototype.ignoreOnPersist = function(options) {
      return JSON.stringify(this.iterateJsonProperties(this.properties, options));
    };
    Component2.prototype.iterateJsonProperties = function(obj, ignoreList) {
      var newObj = {};
      var _loop_1 = function(key2) {
        if (ignoreList.indexOf(key2) === -1) {
          var value = obj["" + key2];
          if (typeof value === "object" && !(value instanceof Array)) {
            var newList = ignoreList.filter(function(str) {
              var regExp2 = RegExp;
              return new regExp2(key2 + ".").test(str);
            }).map(function(str) {
              return str.replace(key2 + ".", "");
            });
            newObj["" + key2] = this_1.iterateJsonProperties(this_1.getActualProperties(value), newList);
          } else {
            newObj["" + key2] = value;
          }
        }
      };
      var this_1 = this;
      for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {
        var key = _a[_i];
        _loop_1(key);
      }
      return newObj;
    };
    __decorate$k([
      Property(false)
    ], Component2.prototype, "enablePersistence", undefined);
    __decorate$k([
      Property()
    ], Component2.prototype, "enableRtl", undefined);
    __decorate$k([
      Property()
    ], Component2.prototype, "locale", undefined);
    Component2 = __decorate$k([
      NotifyPropertyChanges
    ], Component2);
    return Component2;
  }(Base)
);
var __extends$j = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate$j = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var defaultPosition = { left: 0, top: 0, bottom: 0, right: 0 };
var isDraggedObject = { isDragged: false };
var Position = (
  /** @class */
  function(_super) {
    __extends$j(Position2, _super);
    function Position2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$j([
      Property(0)
    ], Position2.prototype, "left", undefined);
    __decorate$j([
      Property(0)
    ], Position2.prototype, "top", undefined);
    return Position2;
  }(ChildProperty)
);
var Draggable = (
  /** @class */
  function(_super) {
    __extends$j(Draggable2, _super);
    function Draggable2(element2, options) {
      var _this = _super.call(this, options, element2) || this;
      _this.dragLimit = Draggable_1.getDefaultPosition();
      _this.borderWidth = Draggable_1.getDefaultPosition();
      _this.padding = Draggable_1.getDefaultPosition();
      _this.diffX = 0;
      _this.prevLeft = 0;
      _this.prevTop = 0;
      _this.dragProcessStarted = false;
      _this.eleTop = 0;
      _this.tapHoldTimer = 0;
      _this.externalInitialize = false;
      _this.diffY = 0;
      _this.parentScrollX = 0;
      _this.parentScrollY = 0;
      _this.droppables = {};
      _this.bind();
      return _this;
    }
    Draggable_1 = Draggable2;
    Draggable2.prototype.bind = function() {
      this.toggleEvents();
      if (Browser.isIE) {
        addClass([this.element], "e-block-touch");
      }
      this.droppables[this.scope] = {};
    };
    Draggable2.getDefaultPosition = function() {
      return extend({}, defaultPosition);
    };
    Draggable2.prototype.toggleEvents = function(isUnWire) {
      var ele;
      if (!isUndefined(this.handle)) {
        ele = select(this.handle, this.element);
      }
      var handler = this.enableTapHold && Browser.isDevice && Browser.isTouch ? this.mobileInitialize : this.initialize;
      if (isUnWire) {
        EventHandler.remove(ele || this.element, Browser.isSafari() ? "touchstart" : Browser.touchStartEvent, handler);
      } else {
        EventHandler.add(ele || this.element, Browser.isSafari() ? "touchstart" : Browser.touchStartEvent, handler, this);
      }
    };
    Draggable2.prototype.mobileInitialize = function(evt) {
      var _this = this;
      var target = evt.currentTarget;
      this.tapHoldTimer = setTimeout(function() {
        _this.externalInitialize = true;
        _this.removeTapholdTimer();
        _this.initialize(evt, target);
      }, this.tapHoldThreshold);
      EventHandler.add(undefined, Browser.isSafari() ? "touchmove" : Browser.touchMoveEvent, this.removeTapholdTimer, this);
      EventHandler.add(undefined, Browser.isSafari() ? "touchend" : Browser.touchEndEvent, this.removeTapholdTimer, this);
    };
    Draggable2.prototype.removeTapholdTimer = function() {
      clearTimeout(this.tapHoldTimer);
      EventHandler.remove(undefined, Browser.isSafari() ? "touchmove" : Browser.touchMoveEvent, this.removeTapholdTimer);
      EventHandler.remove(undefined, Browser.isSafari() ? "touchend" : Browser.touchEndEvent, this.removeTapholdTimer);
    };
    Draggable2.prototype.getScrollableParent = function(element2, axis) {
      var scroll = { "vertical": "scrollHeight", "horizontal": "scrollWidth" };
      var client = { "vertical": "clientHeight", "horizontal": "clientWidth" };
      if (isNullOrUndefined(element2)) {
        return null;
      }
      if (element2[scroll["" + axis]] > element2[client["" + axis]]) {
        if (axis === "vertical" ? element2.scrollTop > 0 : element2.scrollLeft > 0) {
          if (axis === "vertical") {
            this.parentScrollY = this.parentScrollY + (this.parentScrollY === 0 ? element2.scrollTop : element2.scrollTop - this.parentScrollY);
            this.tempScrollHeight = element2.scrollHeight;
          } else {
            this.parentScrollX = this.parentScrollX + (this.parentScrollX === 0 ? element2.scrollLeft : element2.scrollLeft - this.parentScrollX);
            this.tempScrollWidth = element2.scrollWidth;
          }
          if (!isNullOrUndefined(element2)) {
            return this.getScrollableParent(element2.parentNode, axis);
          } else {
            return element2;
          }
        } else {
          return this.getScrollableParent(element2.parentNode, axis);
        }
      } else {
        return this.getScrollableParent(element2.parentNode, axis);
      }
    };
    Draggable2.prototype.getScrollableValues = function() {
      this.parentScrollX = 0;
      this.parentScrollY = 0;
      this.element.classList.contains("e-dialog") && this.element.classList.contains("e-dlg-modal");
      this.getScrollableParent(this.element.parentNode, "vertical");
      this.getScrollableParent(this.element.parentNode, "horizontal");
    };
    Draggable2.prototype.initialize = function(evt, curTarget) {
      this.currentStateTarget = evt.target;
      if (this.isDragStarted()) {
        return;
      } else {
        this.isDragStarted(true);
        this.externalInitialize = false;
      }
      this.target = evt.currentTarget || curTarget;
      this.dragProcessStarted = false;
      if (this.abort) {
        var abortSelectors = this.abort;
        if (typeof abortSelectors === "string") {
          abortSelectors = [abortSelectors];
        }
        for (var i = 0; i < abortSelectors.length; i++) {
          if (!isNullOrUndefined(closest(evt.target, abortSelectors[parseInt(i.toString(), 10)]))) {
            if (this.isDragStarted()) {
              this.isDragStarted(true);
            }
            return;
          }
        }
      }
      if (this.preventDefault && !isUndefined(evt.changedTouches) && evt.type !== "touchstart") {
        evt.preventDefault();
      }
      this.element.setAttribute("aria-grabbed", "true");
      var intCoord = this.getCoordinates(evt);
      this.initialPosition = { x: intCoord.pageX, y: intCoord.pageY };
      if (!this.clone) {
        var pos = this.element.getBoundingClientRect();
        this.getScrollableValues();
        if (evt.clientX === evt.pageX) {
          this.parentScrollX = 0;
        }
        if (evt.clientY === evt.pageY) {
          this.parentScrollY = 0;
        }
        this.relativeXPosition = intCoord.pageX - (pos.left + this.parentScrollX);
        this.relativeYPosition = intCoord.pageY - (pos.top + this.parentScrollY);
      }
      if (this.externalInitialize) {
        this.intDragStart(evt);
      } else {
        EventHandler.add(undefined, Browser.isSafari() ? "touchmove" : Browser.touchMoveEvent, this.intDragStart, this);
        EventHandler.add(undefined, Browser.isSafari() ? "touchend" : Browser.touchEndEvent, this.intDestroy, this);
      }
      this.toggleEvents(true);
      if (evt.type !== "touchstart" && this.isPreventSelect) {
        (undefined).body.classList.add("e-prevent-select");
      }
      this.externalInitialize = false;
      EventHandler.trigger((undefined).documentElement, Browser.isSafari() ? "touchstart" : Browser.touchStartEvent, evt);
    };
    Draggable2.prototype.intDragStart = function(evt) {
      this.removeTapholdTimer();
      var isChangeTouch = !isUndefined(evt.changedTouches);
      if (isChangeTouch && evt.changedTouches.length !== 1) {
        return;
      }
      var intCordinate = this.getCoordinates(evt);
      var pos;
      var styleProp = getComputedStyle(this.element);
      this.margin = {
        left: parseInt(styleProp.marginLeft, 10),
        top: parseInt(styleProp.marginTop, 10),
        right: parseInt(styleProp.marginRight, 10),
        bottom: parseInt(styleProp.marginBottom, 10)
      };
      var element2 = this.element;
      if (this.clone && this.dragTarget) {
        var intClosest = closest(evt.target, this.dragTarget);
        if (!isNullOrUndefined(intClosest)) {
          element2 = intClosest;
        }
      }
      if (this.isReplaceDragEle) {
        element2 = this.currentStateCheck(evt.target, element2);
      }
      this.offset = this.calculateParentPosition(element2);
      this.position = this.getMousePosition(evt, this.isDragScroll);
      var x = this.initialPosition.x - intCordinate.pageX;
      var y = this.initialPosition.y - intCordinate.pageY;
      var distance = Math.sqrt(x * x + y * y);
      if (distance >= this.distance || this.externalInitialize) {
        var ele = this.getHelperElement(evt);
        if (!ele || isNullOrUndefined(ele)) {
          return;
        }
        if (isChangeTouch) {
          evt.preventDefault();
        }
        var dragTargetElement = this.helperElement = ele;
        this.parentClientRect = this.calculateParentPosition(dragTargetElement.offsetParent);
        if (this.dragStart) {
          var curTarget = this.getProperTargetElement(evt);
          var args = {
            event: evt,
            element: element2,
            target: curTarget,
            bindEvents: null,
            dragElement: dragTargetElement
          };
          this.trigger("dragStart", args);
        }
        if (this.dragArea) {
          this.setDragArea();
        } else {
          this.dragLimit = { left: 0, right: 0, bottom: 0, top: 0 };
          this.borderWidth = { top: 0, left: 0 };
        }
        pos = { left: this.position.left - this.parentClientRect.left, top: this.position.top - this.parentClientRect.top };
        if (this.clone && !this.enableTailMode) {
          this.diffX = this.position.left - this.offset.left;
          this.diffY = this.position.top - this.offset.top;
        }
        this.getScrollableValues();
        var styles = getComputedStyle(element2);
        var marginTop = parseFloat(styles.marginTop);
        if (this.clone && marginTop !== 0) {
          pos.top += marginTop;
        }
        this.eleTop = !isNaN(parseFloat(styles.top)) ? parseFloat(styles.top) - this.offset.top : 0;
        if (this.enableScrollHandler && !this.clone) {
          pos.top -= this.parentScrollY;
          pos.left -= this.parentScrollX;
        }
        var posValue = this.getProcessedPositionValue({
          top: pos.top - this.diffY + "px",
          left: pos.left - this.diffX + "px"
        });
        if (this.dragArea && typeof this.dragArea !== "string" && this.dragArea.classList.contains("e-kanban-content") && this.dragArea.style.position === "relative") {
          pos.top += this.dragArea.scrollTop;
        }
        this.dragElePosition = { top: pos.top, left: pos.left };
        setStyleAttribute(dragTargetElement, this.getDragPosition({ position: "absolute", left: posValue.left, top: posValue.top }));
        EventHandler.remove(undefined, Browser.isSafari() ? "touchmove" : Browser.touchMoveEvent, this.intDragStart);
        EventHandler.remove(undefined, Browser.isSafari() ? "touchend" : Browser.touchEndEvent, this.intDestroy);
        {
          this.bindDragEvents(dragTargetElement);
        }
      }
    };
    Draggable2.prototype.bindDragEvents = function(dragTargetElement) {
      if (isVisible(dragTargetElement)) {
        EventHandler.add(undefined, Browser.isSafari() ? "touchmove" : Browser.touchMoveEvent, this.intDrag, this);
        EventHandler.add(undefined, Browser.isSafari() ? "touchend" : Browser.touchEndEvent, this.intDragStop, this);
        this.setGlobalDroppables(false, this.element, dragTargetElement);
      } else {
        this.toggleEvents();
        (undefined).body.classList.remove("e-prevent-select");
      }
    };
    Draggable2.prototype.elementInViewport = function(el) {
      this.top = el.offsetTop;
      this.left = el.offsetLeft;
      this.width = el.offsetWidth;
      this.height = el.offsetHeight;
      while (el.offsetParent) {
        el = el.offsetParent;
        this.top += el.offsetTop;
        this.left += el.offsetLeft;
      }
      return this.top >= (undefined).pageYOffset && this.left >= (undefined).pageXOffset && this.top + this.height <= (undefined).pageYOffset + (undefined).innerHeight && this.left + this.width <= (undefined).pageXOffset + (undefined).innerWidth;
    };
    Draggable2.prototype.getProcessedPositionValue = function(value) {
      if (this.queryPositionInfo) {
        return this.queryPositionInfo(value);
      }
      return value;
    };
    Draggable2.prototype.calculateParentPosition = function(ele) {
      if (isNullOrUndefined(ele)) {
        return { left: 0, top: 0 };
      }
      var rect = ele.getBoundingClientRect();
      var style = getComputedStyle(ele);
      return {
        left: rect.left + (undefined).pageXOffset - parseInt(style.marginLeft, 10),
        top: rect.top + (undefined).pageYOffset - parseInt(style.marginTop, 10)
      };
    };
    Draggable2.prototype.intDrag = function(evt) {
      if (!isUndefined(evt.changedTouches) && evt.changedTouches.length !== 1) {
        return;
      }
      if (this.clone && evt.changedTouches && Browser.isDevice && Browser.isTouch) {
        evt.preventDefault();
      }
      var left;
      var top;
      this.position = this.getMousePosition(evt, this.isDragScroll);
      var docHeight = this.getDocumentWidthHeight("Height");
      if (docHeight < this.position.top) {
        this.position.top = docHeight;
      }
      var docWidth = this.getDocumentWidthHeight("Width");
      if (docWidth < this.position.left) {
        this.position.left = docWidth;
      }
      if (this.drag) {
        var curTarget = this.getProperTargetElement(evt);
        this.trigger("drag", { event: evt, element: this.element, target: curTarget });
      }
      var eleObj = this.checkTargetElement(evt);
      if (eleObj.target && eleObj.instance) {
        var flag = true;
        if (this.hoverObject) {
          if (this.hoverObject.instance !== eleObj.instance) {
            this.triggerOutFunction(evt, eleObj);
          } else {
            flag = false;
          }
        }
        if (flag) {
          eleObj.instance.dragData[this.scope] = this.droppables[this.scope];
          eleObj.instance.intOver(evt, eleObj.target);
          this.hoverObject = eleObj;
        }
      } else if (this.hoverObject) {
        this.triggerOutFunction(evt, eleObj);
      }
      var helperElement = this.droppables[this.scope].helper;
      this.parentClientRect = this.calculateParentPosition(this.helperElement.offsetParent);
      var tLeft = this.parentClientRect.left;
      var tTop = this.parentClientRect.top;
      var intCoord = this.getCoordinates(evt);
      var pagex = intCoord.pageX;
      var pagey = intCoord.pageY;
      var dLeft = this.position.left - this.diffX;
      var dTop = this.position.top - this.diffY;
      var styles = getComputedStyle(helperElement);
      if (this.dragArea) {
        if (this.enableAutoScroll) {
          this.setDragArea();
        }
        if (this.pageX !== pagex || this.skipDistanceCheck) {
          var helperWidth = helperElement.offsetWidth + (parseFloat(styles.marginLeft) + parseFloat(styles.marginRight));
          if (this.dragLimit.left > dLeft && dLeft > 0) {
            left = this.dragLimit.left;
          } else if (this.dragLimit.right + (undefined).pageXOffset < dLeft + helperWidth && dLeft > 0) {
            left = dLeft - (dLeft - this.dragLimit.right) + (undefined).pageXOffset - helperWidth;
          } else {
            left = dLeft < 0 ? this.dragLimit.left : dLeft;
          }
        }
        if (this.pageY !== pagey || this.skipDistanceCheck) {
          var helperHeight = helperElement.offsetHeight + (parseFloat(styles.marginTop) + parseFloat(styles.marginBottom));
          if (this.dragLimit.top > dTop && dTop > 0) {
            top = this.dragLimit.top;
          } else if (this.dragLimit.bottom + (undefined).pageYOffset < dTop + helperHeight && dTop > 0) {
            top = dTop - (dTop - this.dragLimit.bottom) + (undefined).pageYOffset - helperHeight;
          } else {
            top = dTop < 0 ? this.dragLimit.top : dTop;
          }
        }
      } else {
        left = dLeft;
        top = dTop;
      }
      var iTop = tTop + this.borderWidth.top;
      var iLeft = tLeft + this.borderWidth.left;
      if (this.dragProcessStarted) {
        if (isNullOrUndefined(top)) {
          top = this.prevTop;
        }
        if (isNullOrUndefined(left)) {
          left = this.prevLeft;
        }
      }
      var draEleTop;
      var draEleLeft;
      if (this.helperElement.classList.contains("e-treeview")) {
        if (this.dragArea) {
          this.dragLimit.top = this.clone ? this.dragLimit.top : 0;
          draEleTop = top - iTop < 0 ? this.dragLimit.top : top - this.borderWidth.top;
          draEleLeft = left - iLeft < 0 ? this.dragLimit.left : left - this.borderWidth.left;
        } else {
          draEleTop = top - this.borderWidth.top;
          draEleLeft = left - this.borderWidth.left;
        }
      } else {
        if (this.dragArea) {
          var isDialogEle = this.helperElement.classList.contains("e-dialog");
          this.dragLimit.top = this.clone ? this.dragLimit.top : 0;
          draEleTop = top - iTop < 0 ? this.dragLimit.top : top - iTop;
          draEleLeft = left - iLeft < 0 ? isDialogEle ? left - (iLeft - this.borderWidth.left) : this.dragElePosition.left : left - iLeft;
        } else {
          draEleTop = top - iTop;
          draEleLeft = left - iLeft;
        }
      }
      var marginTop = parseFloat(getComputedStyle(this.element).marginTop);
      if (marginTop > 0) {
        if (this.clone) {
          draEleTop += marginTop;
          if (dTop < 0) {
            if (marginTop + dTop >= 0) {
              draEleTop = marginTop + dTop;
            } else {
              draEleTop -= marginTop;
            }
          }
          if (this.dragArea) {
            draEleTop = this.dragLimit.bottom < draEleTop ? this.dragLimit.bottom : draEleTop;
          }
        }
        if (top - iTop < 0) {
          if (dTop + marginTop + (helperElement.offsetHeight - iTop) >= 0) {
            var tempDraEleTop = this.dragLimit.top + dTop - iTop;
            if (tempDraEleTop + marginTop + iTop < 0) {
              draEleTop -= marginTop + iTop;
            } else {
              draEleTop = tempDraEleTop;
            }
          } else {
            draEleTop -= marginTop + iTop;
          }
        }
      }
      if (this.dragArea && this.helperElement.classList.contains("e-treeview")) {
        var helperHeight = helperElement.offsetHeight + (parseFloat(styles.marginTop) + parseFloat(styles.marginBottom));
        draEleTop = draEleTop + helperHeight > this.dragLimit.bottom ? this.dragLimit.bottom - helperHeight : draEleTop;
      }
      if (this.enableScrollHandler && !this.clone) {
        draEleTop -= this.parentScrollY;
        draEleLeft -= this.parentScrollX;
      }
      if (this.dragArea && typeof this.dragArea !== "string" && this.dragArea.classList.contains("e-kanban-content") && this.dragArea.style.position === "relative") {
        draEleTop += this.dragArea.scrollTop;
      }
      var dragValue = this.getProcessedPositionValue({ top: draEleTop + "px", left: draEleLeft + "px" });
      if (this.isPreventScroll) {
        dragValue = this.getProcessedPositionValue({
          top: this.position.top - this.parentClientRect.top - 2 + "px",
          left: this.position.left - this.parentClientRect.left - 2 + "px"
        });
      }
      setStyleAttribute(helperElement, this.getDragPosition(dragValue));
      if (!this.elementInViewport(helperElement) && this.enableAutoScroll && !this.helperElement.classList.contains("e-treeview")) {
        this.helperElement.scrollIntoView();
      }
      var elements = (undefined).querySelectorAll(":hover");
      if (this.enableAutoScroll && this.helperElement.classList.contains("e-treeview")) {
        if (elements.length === 0) {
          elements = this.getPathElements(evt);
        }
        var scrollParent = this.getScrollParent(elements, false);
        if (this.elementInViewport(this.helperElement)) {
          this.getScrollPosition(scrollParent, draEleTop);
        } else if (!this.elementInViewport(this.helperElement)) {
          elements = [].slice.call((undefined).querySelectorAll(":hover"));
          if (elements.length === 0) {
            elements = this.getPathElements(evt);
          }
          scrollParent = this.getScrollParent(elements, true);
          this.getScrollPosition(scrollParent, draEleTop);
        }
      }
      this.dragProcessStarted = true;
      this.prevLeft = left;
      this.prevTop = top;
      this.position.left = left;
      this.position.top = top;
      this.pageX = pagex;
      this.pageY = pagey;
    };
    Draggable2.prototype.getScrollParent = function(node, reverse) {
      var nodeEl = reverse ? node.reverse() : node;
      var hasScroll;
      for (var i = nodeEl.length - 1; i >= 0; i--) {
        hasScroll = (undefined).getComputedStyle(nodeEl[parseInt(i.toString(), 10)])["overflow-y"];
        if ((hasScroll === "auto" || hasScroll === "scroll") && nodeEl[parseInt(i.toString(), 10)].scrollHeight > nodeEl[parseInt(i.toString(), 10)].clientHeight) {
          return nodeEl[parseInt(i.toString(), 10)];
        }
      }
      hasScroll = (undefined).getComputedStyle((undefined).scrollingElement)["overflow-y"];
      if (hasScroll === "visible") {
        (undefined).scrollingElement.style.overflow = "auto";
        return (undefined).scrollingElement;
      }
    };
    Draggable2.prototype.getScrollPosition = function(nodeEle, draEleTop) {
      if (nodeEle && nodeEle === (undefined).scrollingElement) {
        if (nodeEle.clientHeight + (undefined).scrollingElement.scrollTop - this.helperElement.clientHeight < draEleTop && nodeEle.getBoundingClientRect().height + this.parentClientRect.top > draEleTop) {
          nodeEle.scrollTop += this.helperElement.clientHeight;
        } else if (nodeEle.scrollTop > draEleTop - this.helperElement.clientHeight) {
          nodeEle.scrollTop -= this.helperElement.clientHeight;
        }
      } else if (nodeEle && nodeEle !== (undefined).scrollingElement) {
        var docScrollTop = (undefined).scrollingElement.scrollTop;
        var helperClientHeight = this.helperElement.clientHeight;
        if (nodeEle.clientHeight + nodeEle.getBoundingClientRect().top - helperClientHeight + docScrollTop < draEleTop) {
          nodeEle.scrollTop += this.helperElement.clientHeight;
        } else if (nodeEle.getBoundingClientRect().top > draEleTop - helperClientHeight - docScrollTop) {
          nodeEle.scrollTop -= this.helperElement.clientHeight;
        }
      }
    };
    Draggable2.prototype.getPathElements = function(evt) {
      var elementTop = evt.clientX > 0 ? evt.clientX : 0;
      var elementLeft = evt.clientY > 0 ? evt.clientY : 0;
      return (undefined).elementsFromPoint(elementTop, elementLeft);
    };
    Draggable2.prototype.triggerOutFunction = function(evt, eleObj) {
      this.hoverObject.instance.intOut(evt, eleObj.target);
      this.hoverObject.instance.dragData[this.scope] = null;
      this.hoverObject = null;
    };
    Draggable2.prototype.getDragPosition = function(dragValue) {
      var temp = extend({}, dragValue);
      if (this.axis) {
        if (this.axis === "x") {
          delete temp.top;
        } else if (this.axis === "y") {
          delete temp.left;
        }
      }
      return temp;
    };
    Draggable2.prototype.getDocumentWidthHeight = function(str) {
      var docBody = (undefined).body;
      var docEle = (undefined).documentElement;
      var returnValue = Math.max(docBody["scroll" + str], docEle["scroll" + str], docBody["offset" + str], docEle["offset" + str], docEle["client" + str]);
      return returnValue;
    };
    Draggable2.prototype.intDragStop = function(evt) {
      this.dragProcessStarted = false;
      if (!isUndefined(evt.changedTouches) && evt.changedTouches.length !== 1) {
        return;
      }
      var type = ["touchend", "pointerup", "mouseup"];
      if (type.indexOf(evt.type) !== -1) {
        if (this.dragStop) {
          var curTarget = this.getProperTargetElement(evt);
          this.trigger("dragStop", { event: evt, element: this.element, target: curTarget, helper: this.helperElement });
        }
        this.intDestroy(evt);
      } else {
        this.element.setAttribute("aria-grabbed", "false");
      }
      var eleObj = this.checkTargetElement(evt);
      if (eleObj.target && eleObj.instance) {
        eleObj.instance.dragStopCalled = true;
        eleObj.instance.dragData[this.scope] = this.droppables[this.scope];
        eleObj.instance.intDrop(evt, eleObj.target);
      }
      this.setGlobalDroppables(true);
      (undefined).body.classList.remove("e-prevent-select");
    };
    Draggable2.prototype.intDestroy = function(evt) {
      this.dragProcessStarted = false;
      this.toggleEvents();
      (undefined).body.classList.remove("e-prevent-select");
      this.element.setAttribute("aria-grabbed", "false");
      EventHandler.remove(undefined, Browser.isSafari() ? "touchmove" : Browser.touchMoveEvent, this.intDragStart);
      EventHandler.remove(undefined, Browser.isSafari() ? "touchend" : Browser.touchEndEvent, this.intDragStop);
      EventHandler.remove(undefined, Browser.isSafari() ? "touchend" : Browser.touchEndEvent, this.intDestroy);
      EventHandler.remove(undefined, Browser.isSafari() ? "touchmove" : Browser.touchMoveEvent, this.intDrag);
      if (this.isDragStarted()) {
        this.isDragStarted(true);
      }
    };
    Draggable2.prototype.onPropertyChanged = function(newProp, oldProp) {
    };
    Draggable2.prototype.getModuleName = function() {
      return "draggable";
    };
    Draggable2.prototype.isDragStarted = function(change) {
      if (change) {
        isDraggedObject.isDragged = !isDraggedObject.isDragged;
      }
      return isDraggedObject.isDragged;
    };
    Draggable2.prototype.setDragArea = function() {
      var eleWidthBound;
      var eleHeightBound;
      var top = 0;
      var left = 0;
      var ele;
      var type = typeof this.dragArea;
      if (type === "string") {
        ele = select(this.dragArea);
      } else {
        ele = this.dragArea;
      }
      if (ele) {
        var elementArea = ele.getBoundingClientRect();
        eleWidthBound = ele.scrollWidth ? ele.scrollWidth : elementArea.right - elementArea.left;
        eleHeightBound = ele.scrollHeight ? this.dragArea && !isNullOrUndefined(this.helperElement) && this.helperElement.classList.contains("e-treeview") ? ele.clientHeight : ele.scrollHeight : elementArea.bottom - elementArea.top;
        var keys2 = ["Top", "Left", "Bottom", "Right"];
        var styles = getComputedStyle(ele);
        for (var i = 0; i < keys2.length; i++) {
          var key = keys2[parseInt(i.toString(), 10)];
          var tborder = styles["border" + key + "Width"];
          var tpadding = styles["padding" + key];
          var lowerKey = key.toLowerCase();
          this.borderWidth["" + lowerKey] = isNaN(parseFloat(tborder)) ? 0 : parseFloat(tborder);
          this.padding["" + lowerKey] = isNaN(parseFloat(tpadding)) ? 0 : parseFloat(tpadding);
        }
        if (this.dragArea && !isNullOrUndefined(this.helperElement) && this.helperElement.classList.contains("e-treeview")) {
          top = elementArea.top + (undefined).scrollingElement.scrollTop;
        } else {
          top = elementArea.top;
        }
        left = elementArea.left;
        this.dragLimit.left = left + this.borderWidth.left + this.padding.left;
        this.dragLimit.top = ele.offsetTop + this.borderWidth.top + this.padding.top;
        this.dragLimit.right = left + eleWidthBound - (this.borderWidth.right + this.padding.right);
        this.dragLimit.bottom = top + eleHeightBound - (this.borderWidth.bottom + this.padding.bottom);
      }
    };
    Draggable2.prototype.getProperTargetElement = function(evt) {
      var intCoord = this.getCoordinates(evt);
      var ele;
      var prevStyle = this.helperElement.style.pointerEvents || "";
      var isPointer = evt.type.indexOf("pointer") !== -1 && Browser.info.name === "safari" && parseInt(Browser.info.version, 10) > 12;
      if (compareElementParent(evt.target, this.helperElement) || evt.type.indexOf("touch") !== -1 || isPointer) {
        this.helperElement.style.pointerEvents = "none";
        ele = (undefined).elementFromPoint(intCoord.clientX, intCoord.clientY);
        this.helperElement.style.pointerEvents = prevStyle;
      } else {
        ele = evt.target;
      }
      return ele;
    };
    Draggable2.prototype.currentStateCheck = function(ele, oldEle) {
      var elem;
      if (!isNullOrUndefined(this.currentStateTarget) && this.currentStateTarget !== ele) {
        elem = this.currentStateTarget;
      } else {
        elem = !isNullOrUndefined(oldEle) ? oldEle : ele;
      }
      return elem;
    };
    Draggable2.prototype.getMousePosition = function(evt, isdragscroll) {
      var dragEle = evt.srcElement !== undefined ? evt.srcElement : evt.target;
      var intCoord = this.getCoordinates(evt);
      var pageX;
      var pageY;
      var isOffsetParent = isNullOrUndefined(dragEle.offsetParent);
      if (isdragscroll) {
        pageX = this.clone ? intCoord.pageX : intCoord.pageX + (isOffsetParent ? 0 : dragEle.offsetParent.scrollLeft) - this.relativeXPosition;
        pageY = this.clone ? intCoord.pageY : intCoord.pageY + (isOffsetParent ? 0 : dragEle.offsetParent.scrollTop) - this.relativeYPosition;
      } else {
        pageX = this.clone ? intCoord.pageX : intCoord.pageX + (undefined).pageXOffset - this.relativeXPosition;
        pageY = this.clone ? intCoord.pageY : intCoord.pageY + (undefined).pageYOffset - this.relativeYPosition;
      }
      if ((undefined).scrollingElement && (!isdragscroll && !this.clone)) {
        var ele = (undefined).scrollingElement;
        var isVerticalScroll = ele.scrollHeight > 0 && ele.scrollHeight > ele.clientHeight && ele.scrollTop > 0;
        var isHorrizontalScroll = ele.scrollWidth > 0 && ele.scrollWidth > ele.clientWidth && ele.scrollLeft > 0;
        pageX = isHorrizontalScroll ? pageX - ele.scrollLeft : pageX;
        pageY = isVerticalScroll ? pageY - ele.scrollTop : pageY;
      }
      return {
        left: pageX - (this.margin.left + this.cursorAt.left),
        top: pageY - (this.margin.top + this.cursorAt.top)
      };
    };
    Draggable2.prototype.getCoordinates = function(evt) {
      if (evt.type.indexOf("touch") > -1) {
        return evt.changedTouches[0];
      }
      return evt;
    };
    Draggable2.prototype.getHelperElement = function(evt) {
      var element2;
      if (this.clone) {
        if (this.helper) {
          element2 = this.helper({ sender: evt, element: this.target, currentTargetElement: this.currentStateTarget });
        } else {
          element2 = createElement("div", { className: "e-drag-helper e-block-touch", innerHTML: "Draggable" });
          (undefined).body.appendChild(element2);
        }
      } else {
        element2 = this.element;
      }
      return element2;
    };
    Draggable2.prototype.setGlobalDroppables = function(reset, drag, helper) {
      this.droppables[this.scope] = reset ? null : {
        draggable: drag,
        helper,
        draggedElement: this.element
      };
    };
    Draggable2.prototype.checkTargetElement = function(evt) {
      var target = this.getProperTargetElement(evt);
      var dropIns = this.getDropInstance(target);
      if (!dropIns && target && !isNullOrUndefined(target.parentNode)) {
        var parent_1 = closest(target.parentNode, ".e-droppable") || target.parentElement;
        if (parent_1) {
          dropIns = this.getDropInstance(parent_1);
        }
      }
      return { target, instance: dropIns };
    };
    Draggable2.prototype.getDropInstance = function(ele) {
      var name = "getModuleName";
      var drop;
      var eleInst = ele && ele.ej2_instances;
      if (eleInst) {
        for (var _i = 0, eleInst_1 = eleInst; _i < eleInst_1.length; _i++) {
          var inst = eleInst_1[_i];
          if (inst["" + name]() === "droppable") {
            drop = inst;
            break;
          }
        }
      }
      return drop;
    };
    Draggable2.prototype.destroy = function() {
      this.toggleEvents(true);
      _super.prototype.destroy.call(this);
    };
    var Draggable_1;
    __decorate$j([
      Complex({}, Position)
    ], Draggable2.prototype, "cursorAt", undefined);
    __decorate$j([
      Property(true)
    ], Draggable2.prototype, "clone", undefined);
    __decorate$j([
      Property()
    ], Draggable2.prototype, "dragArea", undefined);
    __decorate$j([
      Property()
    ], Draggable2.prototype, "isDragScroll", undefined);
    __decorate$j([
      Property()
    ], Draggable2.prototype, "isReplaceDragEle", undefined);
    __decorate$j([
      Property(true)
    ], Draggable2.prototype, "isPreventSelect", undefined);
    __decorate$j([
      Property(false)
    ], Draggable2.prototype, "isPreventScroll", undefined);
    __decorate$j([
      Event()
    ], Draggable2.prototype, "drag", undefined);
    __decorate$j([
      Event()
    ], Draggable2.prototype, "dragStart", undefined);
    __decorate$j([
      Event()
    ], Draggable2.prototype, "dragStop", undefined);
    __decorate$j([
      Property(1)
    ], Draggable2.prototype, "distance", undefined);
    __decorate$j([
      Property()
    ], Draggable2.prototype, "handle", undefined);
    __decorate$j([
      Property()
    ], Draggable2.prototype, "abort", undefined);
    __decorate$j([
      Property()
    ], Draggable2.prototype, "helper", undefined);
    __decorate$j([
      Property("default")
    ], Draggable2.prototype, "scope", undefined);
    __decorate$j([
      Property("")
    ], Draggable2.prototype, "dragTarget", undefined);
    __decorate$j([
      Property()
    ], Draggable2.prototype, "axis", undefined);
    __decorate$j([
      Property()
    ], Draggable2.prototype, "queryPositionInfo", undefined);
    __decorate$j([
      Property(false)
    ], Draggable2.prototype, "enableTailMode", undefined);
    __decorate$j([
      Property(false)
    ], Draggable2.prototype, "skipDistanceCheck", undefined);
    __decorate$j([
      Property(true)
    ], Draggable2.prototype, "preventDefault", undefined);
    __decorate$j([
      Property(false)
    ], Draggable2.prototype, "enableAutoScroll", undefined);
    __decorate$j([
      Property(false)
    ], Draggable2.prototype, "enableTapHold", undefined);
    __decorate$j([
      Property(750)
    ], Draggable2.prototype, "tapHoldThreshold", undefined);
    __decorate$j([
      Property(false)
    ], Draggable2.prototype, "enableScrollHandler", undefined);
    Draggable2 = Draggable_1 = __decorate$j([
      NotifyPropertyChanges
    ], Draggable2);
    return Draggable2;
  }(Base)
);
var __extends$i = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate$i = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Droppable = (
  /** @class */
  function(_super) {
    __extends$i(Droppable2, _super);
    function Droppable2(element2, options) {
      var _this = _super.call(this, options, element2) || this;
      _this.mouseOver = false;
      _this.dragData = {};
      _this.dragStopCalled = false;
      _this.bind();
      return _this;
    }
    Droppable2.prototype.bind = function() {
      this.wireEvents();
    };
    Droppable2.prototype.wireEvents = function() {
      EventHandler.add(this.element, Browser.isSafari() ? "touchend" : Browser.touchEndEvent, this.intDrop, this);
    };
    Droppable2.prototype.onPropertyChanged = function(newProp, oldProp) {
    };
    Droppable2.prototype.getModuleName = function() {
      return "droppable";
    };
    Droppable2.prototype.intOver = function(event, element2) {
      if (!this.mouseOver) {
        var drag = this.dragData[this.scope];
        this.trigger("over", { event, target: element2, dragData: drag });
        this.mouseOver = true;
      }
    };
    Droppable2.prototype.intOut = function(event, element2) {
      if (this.mouseOver) {
        this.trigger("out", { evt: event, target: element2 });
        this.mouseOver = false;
      }
    };
    Droppable2.prototype.intDrop = function(evt, element2) {
      if (!this.dragStopCalled) {
        return;
      } else {
        this.dragStopCalled = false;
      }
      var accept = true;
      var drag = this.dragData[this.scope];
      var isDrag = drag ? drag.helper && isVisible(drag.helper) : false;
      var area;
      if (isDrag) {
        area = this.isDropArea(evt, drag.helper, element2);
        if (this.accept) {
          accept = matches(drag.helper, this.accept);
        }
      }
      if (isDrag && this.drop && area.canDrop && accept) {
        this.trigger("drop", { event: evt, target: area.target, droppedElement: drag.helper, dragData: drag });
      }
      this.mouseOver = false;
    };
    Droppable2.prototype.isDropArea = function(evt, helper, element2) {
      var area = { canDrop: true, target: element2 || evt.target };
      var isTouch = evt.type === "touchend";
      if (isTouch || area.target === helper) {
        helper.style.display = "none";
        var coord = isTouch ? evt.changedTouches[0] : evt;
        var ele = (undefined).elementFromPoint(coord.clientX, coord.clientY);
        area.canDrop = false;
        area.canDrop = compareElementParent(ele, this.element);
        if (area.canDrop) {
          area.target = ele;
        }
        helper.style.display = "";
      }
      return area;
    };
    Droppable2.prototype.destroy = function() {
      EventHandler.remove(this.element, Browser.isSafari() ? "touchend" : Browser.touchEndEvent, this.intDrop);
      _super.prototype.destroy.call(this);
    };
    __decorate$i([
      Property()
    ], Droppable2.prototype, "accept", undefined);
    __decorate$i([
      Property("default")
    ], Droppable2.prototype, "scope", undefined);
    __decorate$i([
      Event()
    ], Droppable2.prototype, "drop", undefined);
    __decorate$i([
      Event()
    ], Droppable2.prototype, "over", undefined);
    __decorate$i([
      Event()
    ], Droppable2.prototype, "out", undefined);
    Droppable2 = __decorate$i([
      NotifyPropertyChanges
    ], Droppable2);
    return Droppable2;
  }(Base)
);
var __extends$h = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate$h = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var keyCode = {
  "backspace": 8,
  "tab": 9,
  "enter": 13,
  "shift": 16,
  "control": 17,
  "alt": 18,
  "pause": 19,
  "capslock": 20,
  "space": 32,
  "escape": 27,
  "pageup": 33,
  "pagedown": 34,
  "end": 35,
  "home": 36,
  "leftarrow": 37,
  "uparrow": 38,
  "rightarrow": 39,
  "downarrow": 40,
  "insert": 45,
  "delete": 46,
  "f1": 112,
  "f2": 113,
  "f3": 114,
  "f4": 115,
  "f5": 116,
  "f6": 117,
  "f7": 118,
  "f8": 119,
  "f9": 120,
  "f10": 121,
  "f11": 122,
  "f12": 123,
  "semicolon": 186,
  "plus": 187,
  "comma": 188,
  "minus": 189,
  "dot": 190,
  "forwardslash": 191,
  "graveaccent": 192,
  "openbracket": 219,
  "backslash": 220,
  "closebracket": 221,
  "singlequote": 222
};
var KeyboardEvents = (
  /** @class */
  function(_super) {
    __extends$h(KeyboardEvents2, _super);
    function KeyboardEvents2(element2, options) {
      var _this = _super.call(this, options, element2) || this;
      _this.keyPressHandler = function(e) {
        var isAltKey = e.altKey;
        var isCtrlKey = e.ctrlKey;
        var isShiftKey = e.shiftKey;
        var curkeyCode = e.which;
        var keys2 = Object.keys(_this.keyConfigs);
        for (var _i = 0, keys_1 = keys2; _i < keys_1.length; _i++) {
          var key = keys_1[_i];
          var configCollection = _this.keyConfigs["" + key].split(",");
          for (var _a = 0, configCollection_1 = configCollection; _a < configCollection_1.length; _a++) {
            var rconfig = configCollection_1[_a];
            var rKeyObj = KeyboardEvents_1.getKeyConfigData(rconfig.trim());
            if (isAltKey === rKeyObj.altKey && isCtrlKey === rKeyObj.ctrlKey && isShiftKey === rKeyObj.shiftKey && curkeyCode === rKeyObj.keyCode) {
              e.action = key;
              if (_this.keyAction) {
                _this.keyAction(e);
              }
            }
          }
        }
      };
      _this.bind();
      return _this;
    }
    KeyboardEvents_1 = KeyboardEvents2;
    KeyboardEvents2.prototype.destroy = function() {
      this.unwireEvents();
      _super.prototype.destroy.call(this);
    };
    KeyboardEvents2.prototype.onPropertyChanged = function(newProp, oldProp) {
    };
    KeyboardEvents2.prototype.bind = function() {
      this.wireEvents();
    };
    KeyboardEvents2.prototype.getModuleName = function() {
      return "keyboard";
    };
    KeyboardEvents2.prototype.wireEvents = function() {
      this.element.addEventListener(this.eventName, this.keyPressHandler);
    };
    KeyboardEvents2.prototype.unwireEvents = function() {
      this.element.removeEventListener(this.eventName, this.keyPressHandler);
    };
    KeyboardEvents2.getKeyConfigData = function(config) {
      if (config in this.configCache) {
        return this.configCache["" + config];
      }
      var keys2 = config.toLowerCase().split("+");
      var keyData = {
        altKey: keys2.indexOf("alt") !== -1 ? true : false,
        ctrlKey: keys2.indexOf("ctrl") !== -1 ? true : false,
        shiftKey: keys2.indexOf("shift") !== -1 ? true : false,
        keyCode: null
      };
      if (keys2[keys2.length - 1].length > 1 && !!Number(keys2[keys2.length - 1])) {
        keyData.keyCode = Number(keys2[keys2.length - 1]);
      } else {
        keyData.keyCode = KeyboardEvents_1.getKeyCode(keys2[keys2.length - 1]);
      }
      KeyboardEvents_1.configCache["" + config] = keyData;
      return keyData;
    };
    KeyboardEvents2.getKeyCode = function(keyVal) {
      return keyCode["" + keyVal] || keyVal.toUpperCase().charCodeAt(0);
    };
    var KeyboardEvents_1;
    KeyboardEvents2.configCache = {};
    __decorate$h([
      Property({})
    ], KeyboardEvents2.prototype, "keyConfigs", undefined);
    __decorate$h([
      Property("keyup")
    ], KeyboardEvents2.prototype, "eventName", undefined);
    __decorate$h([
      Event()
    ], KeyboardEvents2.prototype, "keyAction", undefined);
    KeyboardEvents2 = KeyboardEvents_1 = __decorate$h([
      NotifyPropertyChanges
    ], KeyboardEvents2);
    return KeyboardEvents2;
  }(Base)
);
var L10n = (
  /** @class */
  function() {
    function L10n2(controlName, localeStrings, locale) {
      this.controlName = controlName;
      this.localeStrings = localeStrings;
      this.setLocale(locale || defaultCulture);
    }
    L10n2.prototype.setLocale = function(locale) {
      var intLocale = this.intGetControlConstant(L10n2.locale, locale);
      this.currentLocale = intLocale || this.localeStrings;
    };
    L10n2.load = function(localeObject) {
      this.locale = extend(this.locale, localeObject, {}, true);
    };
    L10n2.prototype.getConstant = function(prop) {
      if (!isNullOrUndefined(this.currentLocale["" + prop])) {
        return this.currentLocale["" + prop];
      } else {
        return this.localeStrings["" + prop] || "";
      }
    };
    L10n2.prototype.intGetControlConstant = function(curObject, locale) {
      if (curObject["" + locale]) {
        return curObject["" + locale][this.controlName];
      }
      return null;
    };
    L10n2.locale = {};
    return L10n2;
  }()
);
var __extends$g = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate$g = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SwipeSettings = (
  /** @class */
  function(_super) {
    __extends$g(SwipeSettings2, _super);
    function SwipeSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$g([
      Property(50)
    ], SwipeSettings2.prototype, "swipeThresholdDistance", undefined);
    return SwipeSettings2;
  }(ChildProperty)
);
var swipeRegex = /(Up|Down)/;
var Touch = (
  /** @class */
  function(_super) {
    __extends$g(Touch2, _super);
    function Touch2(element2, options) {
      var _this = _super.call(this, options, element2) || this;
      _this.touchAction = true;
      _this.tapCount = 0;
      _this.startEvent = function(evt) {
        if (_this.touchAction === true) {
          var point = _this.updateChangeTouches(evt);
          if (evt.changedTouches !== undefined) {
            _this.touchAction = false;
          }
          _this.isTouchMoved = false;
          _this.movedDirection = "";
          _this.startPoint = _this.lastMovedPoint = { clientX: point.clientX, clientY: point.clientY };
          _this.startEventData = point;
          _this.hScrollLocked = _this.vScrollLocked = false;
          _this.tStampStart = Date.now();
          _this.timeOutTapHold = setTimeout(function() {
            _this.tapHoldEvent(evt);
          }, _this.tapHoldThreshold);
          EventHandler.add(_this.element, Browser.touchMoveEvent, _this.moveEvent, _this);
          EventHandler.add(_this.element, Browser.touchEndEvent, _this.endEvent, _this);
          EventHandler.add(_this.element, Browser.touchCancelEvent, _this.cancelEvent, _this);
        }
      };
      _this.moveEvent = function(evt) {
        var point = _this.updateChangeTouches(evt);
        _this.movedPoint = point;
        _this.isTouchMoved = !(point.clientX === _this.startPoint.clientX && point.clientY === _this.startPoint.clientY);
        var eScrollArgs = {};
        if (_this.isTouchMoved) {
          clearTimeout(_this.timeOutTapHold);
          _this.calcScrollPoints(evt);
          var scrollArg = {
            startEvents: _this.startEventData,
            originalEvent: evt,
            startX: _this.startPoint.clientX,
            startY: _this.startPoint.clientY,
            distanceX: _this.distanceX,
            distanceY: _this.distanceY,
            scrollDirection: _this.scrollDirection,
            velocity: _this.getVelocity(point)
          };
          eScrollArgs = extend(eScrollArgs, {}, scrollArg);
          _this.trigger("scroll", eScrollArgs);
          _this.lastMovedPoint = { clientX: point.clientX, clientY: point.clientY };
        }
      };
      _this.cancelEvent = function(evt) {
        clearTimeout(_this.timeOutTapHold);
        clearTimeout(_this.timeOutTap);
        _this.tapCount = 0;
        _this.swipeFn(evt);
        EventHandler.remove(_this.element, Browser.touchCancelEvent, _this.cancelEvent);
      };
      _this.endEvent = function(evt) {
        _this.swipeFn(evt);
        if (!_this.isTouchMoved) {
          if (typeof _this.tap === "function") {
            _this.trigger("tap", { originalEvent: evt, tapCount: ++_this.tapCount });
            _this.timeOutTap = setTimeout(function() {
              _this.tapCount = 0;
            }, _this.tapThreshold);
          }
        }
        _this.modeclear();
      };
      _this.swipeFn = function(evt) {
        clearTimeout(_this.timeOutTapHold);
        clearTimeout(_this.timeOutTap);
        var point = _this.updateChangeTouches(evt);
        var diffX = point.clientX - _this.startPoint.clientX;
        var diffY = point.clientY - _this.startPoint.clientY;
        diffX = Math.floor(diffX < 0 ? -1 * diffX : diffX);
        diffY = Math.floor(diffY < 0 ? -1 * diffY : diffX);
        _this.isTouchMoved = diffX > 1 || diffY > 1;
        var isFirefox = /Firefox/.test(Browser.userAgent);
        if (isFirefox && point.clientX === 0 && point.clientY === 0 && evt.type === "mouseup") {
          _this.isTouchMoved = false;
        }
        _this.endPoint = point;
        _this.calcPoints(evt);
        var swipeArgs = {
          originalEvent: evt,
          startEvents: _this.startEventData,
          startX: _this.startPoint.clientX,
          startY: _this.startPoint.clientY,
          distanceX: _this.distanceX,
          distanceY: _this.distanceY,
          swipeDirection: _this.movedDirection,
          velocity: _this.getVelocity(point)
        };
        if (_this.isTouchMoved) {
          var tDistance = _this.swipeSettings.swipeThresholdDistance;
          var eSwipeArgs = extend(undefined, _this.defaultArgs, swipeArgs);
          var canTrigger = false;
          var ele = _this.element;
          var scrollBool = _this.isScrollable(ele);
          var moved = swipeRegex.test(_this.movedDirection);
          if (tDistance < _this.distanceX && !moved || tDistance < _this.distanceY && moved) {
            if (!scrollBool) {
              canTrigger = true;
            } else {
              canTrigger = _this.checkSwipe(ele, moved);
            }
          }
          if (canTrigger) {
            _this.trigger("swipe", eSwipeArgs);
          }
        }
        _this.modeclear();
      };
      _this.modeclear = function() {
        _this.modeClear = setTimeout(function() {
          _this.touchAction = true;
        }, typeof _this.tap !== "function" ? 0 : 20);
        _this.lastTapTime = (/* @__PURE__ */ new Date()).getTime();
        EventHandler.remove(_this.element, Browser.touchMoveEvent, _this.moveEvent);
        EventHandler.remove(_this.element, Browser.touchEndEvent, _this.endEvent);
        EventHandler.remove(_this.element, Browser.touchCancelEvent, _this.cancelEvent);
      };
      _this.bind();
      return _this;
    }
    Touch2.prototype.onPropertyChanged = function(newProp, oldProp) {
    };
    Touch2.prototype.bind = function() {
      this.wireEvents();
      if (Browser.isIE) {
        this.element.classList.add("e-block-touch");
      }
    };
    Touch2.prototype.destroy = function() {
      this.unwireEvents();
      _super.prototype.destroy.call(this);
    };
    Touch2.prototype.wireEvents = function() {
      EventHandler.add(this.element, Browser.touchStartEvent, this.startEvent, this);
    };
    Touch2.prototype.unwireEvents = function() {
      EventHandler.remove(this.element, Browser.touchStartEvent, this.startEvent);
    };
    Touch2.prototype.getModuleName = function() {
      return "touch";
    };
    Touch2.prototype.isScrollable = function(element2) {
      var eleStyle = getComputedStyle(element2);
      var style = eleStyle.overflow + eleStyle.overflowX + eleStyle.overflowY;
      if (/(auto|scroll)/.test(style)) {
        return true;
      }
      return false;
    };
    Touch2.prototype.tapHoldEvent = function(evt) {
      this.tapCount = 0;
      this.touchAction = true;
      EventHandler.remove(this.element, Browser.touchMoveEvent, this.moveEvent);
      EventHandler.remove(this.element, Browser.touchEndEvent, this.endEvent);
      var eTapArgs = { originalEvent: evt };
      this.trigger("tapHold", eTapArgs);
      EventHandler.remove(this.element, Browser.touchCancelEvent, this.cancelEvent);
    };
    Touch2.prototype.calcPoints = function(evt) {
      var point = this.updateChangeTouches(evt);
      this.defaultArgs = { originalEvent: evt };
      this.distanceX = Math.abs(Math.abs(point.clientX) - Math.abs(this.startPoint.clientX));
      this.distanceY = Math.abs(Math.abs(point.clientY) - Math.abs(this.startPoint.clientY));
      if (this.distanceX > this.distanceY) {
        this.movedDirection = point.clientX > this.startPoint.clientX ? "Right" : "Left";
      } else {
        this.movedDirection = point.clientY < this.startPoint.clientY ? "Up" : "Down";
      }
    };
    Touch2.prototype.calcScrollPoints = function(evt) {
      var point = this.updateChangeTouches(evt);
      this.defaultArgs = { originalEvent: evt };
      this.distanceX = Math.abs(Math.abs(point.clientX) - Math.abs(this.lastMovedPoint.clientX));
      this.distanceY = Math.abs(Math.abs(point.clientY) - Math.abs(this.lastMovedPoint.clientY));
      if ((this.distanceX > this.distanceY || this.hScrollLocked === true) && this.vScrollLocked === false) {
        this.scrollDirection = point.clientX > this.lastMovedPoint.clientX ? "Right" : "Left";
        this.hScrollLocked = true;
      } else {
        this.scrollDirection = point.clientY < this.lastMovedPoint.clientY ? "Up" : "Down";
        this.vScrollLocked = true;
      }
    };
    Touch2.prototype.getVelocity = function(pnt) {
      var newX = pnt.clientX;
      var newY = pnt.clientY;
      var newT = Date.now();
      var xDist = newX - this.startPoint.clientX;
      var yDist = newY - this.startPoint.clientX;
      var interval = newT - this.tStampStart;
      return Math.sqrt(xDist * xDist + yDist * yDist) / interval;
    };
    Touch2.prototype.checkSwipe = function(ele, flag) {
      var keys2 = ["scroll", "offset"];
      var temp = flag ? ["Height", "Top"] : ["Width", "Left"];
      if (ele[keys2[0] + temp[0]] <= ele[keys2[1] + temp[0]]) {
        return true;
      }
      return ele[keys2[0] + temp[1]] === 0 || ele[keys2[1] + temp[0]] + ele[keys2[0] + temp[1]] >= ele[keys2[0] + temp[0]];
    };
    Touch2.prototype.updateChangeTouches = function(evt) {
      var point = evt.changedTouches && evt.changedTouches.length !== 0 ? evt.changedTouches[0] : evt;
      return point;
    };
    __decorate$g([
      Event()
    ], Touch2.prototype, "tap", undefined);
    __decorate$g([
      Event()
    ], Touch2.prototype, "tapHold", undefined);
    __decorate$g([
      Event()
    ], Touch2.prototype, "swipe", undefined);
    __decorate$g([
      Event()
    ], Touch2.prototype, "scroll", undefined);
    __decorate$g([
      Property(350)
    ], Touch2.prototype, "tapThreshold", undefined);
    __decorate$g([
      Property(750)
    ], Touch2.prototype, "tapHoldThreshold", undefined);
    __decorate$g([
      Complex({}, SwipeSettings)
    ], Touch2.prototype, "swipeSettings", undefined);
    Touch2 = __decorate$g([
      NotifyPropertyChanges
    ], Touch2);
    return Touch2;
  }(Base)
);
var LINES = new RegExp("\\n|\\r|\\s\\s+", "g");
var QUOTES = new RegExp(/'|"/g);
var IF_STMT = new RegExp("if ?\\(");
var ELSEIF_STMT = new RegExp("else if ?\\(");
var ELSE_STMT = new RegExp("else");
var FOR_STMT = new RegExp("for ?\\(");
var IF_OR_FOR = new RegExp("(/if|/for)");
var CALL_FUNCTION = new RegExp("\\((.*)\\)", "");
var NOT_NUMBER = new RegExp("^[0-9]+$", "g");
var WORD = new RegExp(`[\\w"'.\\s+]+`, "g");
var DBL_QUOTED_STR = new RegExp('"(.*?)"', "g");
var WORDIF = new RegExp(`[\\w"'@#$.\\s-+]+`, "g");
var exp = new RegExp("\\${([^}]*)}", "g");
var ARR_OBJ = /^\..*/gm;
var SINGLE_SLASH = /\\/gi;
var DOUBLE_SLASH = /\\\\/gi;
var WORDFUNC = new RegExp(`[\\w"'@#$.\\s+]+`, "g");
var WINDOWFUNC = /\window\./gm;
function compile$2(template, helper, ignorePrefix) {
  if (typeof template === "function") {
    return template;
  } else {
    var argName = "data";
    var evalExpResult = evalExp(template, argName, helper, ignorePrefix);
    var condtion = `var valueRegEx = (/value=\\'([A-Za-z0-9 _]*)((.)([\\w)(!-;?-\u25A0\\s]+)['])/g);
        var hrefRegex = (/(?:href)([\\s='"./]+)([\\w-./?=&\\\\#"]+)((.)([\\w)(!-;/?-\u25A0\\s]+)['])/g);
        if(str.match(valueRegEx)){
            var check = str.match(valueRegEx);
            var str1 = str;
            for (var i=0; i < check.length; i++) {
                var check1 = str.match(valueRegEx)[i].split('value=')[1];
                var change = check1.match(/^'/) !== null ? check1.replace(/^'/, '"') : check1;
                change =change.match(/.$/)[0] === '\\'' ? change.replace(/.$/,'"') : change;
                str1 = str1.replace(check1, change);
            }
            str = str.replace(str, str1);
        }
        else if (str.match(/(?:href='')/) === null) {
            if(str.match(hrefRegex)) {
                var check = str.match(hrefRegex);
                var str1 = str;
                for (var i=0; i < check.length; i++) {
                    var check1 = str.match(hrefRegex)[i].split('href=')[1];
                    if (check1) {
                        var change = check1.match(/^'/) !== null ? check1.replace(/^'/, '"') : check1;
                        change =change.match(/.$/)[0] === '\\'' ? change.replace(/.$/,'"') : change;
                        str1 = str1.replace(check1, change);
                    }
                }
                str = str.replace(str, str1);
            }
        }
        `;
    var fnCode = 'var str="' + evalExpResult + '";' + condtion + " return str;";
    var fn = new Function(argName, fnCode);
    return fn.bind(helper);
  }
}
function evalExp(str, nameSpace, helper, ignorePrefix) {
  var varCOunt = 0;
  var localKeys = [];
  var isClass = str.match(/class="([^"]+|)\s{2}/g);
  var singleSpace = "";
  if (isClass) {
    isClass.forEach(function(value) {
      singleSpace = value.replace(/\s\s+/g, " ");
      str = str.replace(value, singleSpace);
    });
  }
  if (exp.test(str)) {
    var insideBraces = false;
    var outputString = "";
    for (var i = 0; i < str.length; i++) {
      if (str[i + ""] === "$" && str[i + 1] === "{") {
        insideBraces = true;
      } else if (str[i + ""] === "}") {
        insideBraces = false;
      }
      outputString += str[i + ""] === '"' && !insideBraces ? '\\"' : str[i + ""];
    }
    str = outputString;
  } else {
    str = str.replace(/\\?"/g, '\\"');
  }
  return str.replace(LINES, "").replace(DBL_QUOTED_STR, "'$1'").replace(exp, function(match, cnt, offset, matchStr) {
    var SPECIAL_CHAR = /@|#|\$/gm;
    var matches2 = cnt.match(CALL_FUNCTION);
    if (matches2) {
      var rlStr = matches2[1];
      if (ELSEIF_STMT.test(cnt)) {
        cnt = '";} ' + cnt.replace(matches2[1], rlStr.replace(WORD, function(str2) {
          str2 = str2.trim();
          return addNameSpace(str2, !QUOTES.test(str2) && localKeys.indexOf(str2) === -1, nameSpace, localKeys, ignorePrefix);
        })) + '{ \n str = str + "';
      } else if (IF_STMT.test(cnt)) {
        cnt = '"; ' + cnt.replace(matches2[1], rlStr.replace(WORDIF, function(strs) {
          return HandleSpecialCharArrObj(strs, nameSpace, localKeys, ignorePrefix);
        })) + '{ \n str = str + "';
      } else if (FOR_STMT.test(cnt)) {
        var rlStr_1 = matches2[1].split(" of ");
        cnt = '"; ' + cnt.replace(matches2[1], function(mtc) {
          localKeys.push(rlStr_1[0]);
          localKeys.push(rlStr_1[0] + "Index");
          varCOunt = varCOunt + 1;
          return "var i" + varCOunt + "=0; i" + varCOunt + " < " + addNameSpace(rlStr_1[1], true, nameSpace, localKeys, ignorePrefix) + ".length; i" + varCOunt + "++";
        }) + "{ \n " + rlStr_1[0] + "= " + addNameSpace(rlStr_1[1], true, nameSpace, localKeys, ignorePrefix) + "[i" + varCOunt + "]; \n var " + rlStr_1[0] + "Index=i" + varCOunt + '; \n str = str + "';
      } else {
        var fnStr = cnt.split("(");
        var fNameSpace = helper && Object.prototype.hasOwnProperty.call(helper, fnStr[0]) ? "this." : "global";
        fNameSpace = /\./.test(fnStr[0]) ? "" : fNameSpace;
        var ftArray = matches2[1].split(",");
        if (matches2[1].length !== 0 && !/data/.test(ftArray[0]) && !/window./.test(ftArray[0])) {
          matches2[1] = fNameSpace === "global" ? nameSpace + "." + matches2[1] : matches2[1];
        }
        var splRegexp = /@|\$|#/gm;
        var arrObj = /\]\./gm;
        if (WINDOWFUNC.test(cnt) && arrObj.test(cnt) || splRegexp.test(cnt)) {
          var splArrRegexp = /@|\$|#|\]\./gm;
          if (splArrRegexp.test(cnt)) {
            cnt = '"+ ' + (fNameSpace === "global" ? "" : fNameSpace) + cnt.replace(matches2[1], rlStr.replace(WORDFUNC, function(strs) {
              return HandleSpecialCharArrObj(strs, nameSpace, localKeys, ignorePrefix);
            })) + '+ "';
          }
        } else {
          cnt = '" + ' + (fNameSpace === "global" ? "" : fNameSpace) + cnt.replace(rlStr, addNameSpace(matches2[1].replace(/,( |)data.|,/gi, "," + nameSpace + ".").replace(/,( |)data.window/gi, ",window"), fNameSpace === "global" ? false : true, nameSpace, localKeys, ignorePrefix)) + '+"';
        }
      }
    } else if (ELSE_STMT.test(cnt)) {
      cnt = '"; ' + cnt.replace(ELSE_STMT, '} else { \n str = str + "');
    } else if (cnt.match(IF_OR_FOR)) {
      cnt = cnt.replace(IF_OR_FOR, '"; \n } \n str = str + "');
    } else if (SPECIAL_CHAR.test(cnt)) {
      if (cnt.match(SINGLE_SLASH)) {
        cnt = SlashReplace(cnt);
      }
      cnt = '"+' + NameSpaceForspecialChar(cnt, localKeys.indexOf(cnt) === -1, nameSpace, localKeys) + '"]+"';
    } else {
      if (cnt.match(SINGLE_SLASH)) {
        cnt = SlashReplace(cnt);
        cnt = '"+' + NameSpaceForspecialChar(cnt, localKeys.indexOf(cnt) === -1, nameSpace, localKeys) + '"]+"';
      } else {
        cnt = cnt !== "" ? '"+' + addNameSpace(cnt.replace(/,/gi, "+" + nameSpace + "."), localKeys.indexOf(cnt) === -1, nameSpace, localKeys, ignorePrefix) + '+"' : "${}";
      }
    }
    return cnt;
  });
}
function addNameSpace(str, addNS, nameSpace, ignoreList, ignorePrefix) {
  return addNS && !NOT_NUMBER.test(str) && ignoreList.indexOf(str.split(".")[0]) === -1 && !ignorePrefix && str !== "true" && str !== "false" ? nameSpace + "." + str : str;
}
function NameSpaceArrObj(str, addNS, nameSpace, ignoreList) {
  var arrObjReg = /^\..*/gm;
  return addNS && !NOT_NUMBER.test(str) && ignoreList.indexOf(str.split(".")[0]) === -1 && !arrObjReg.test(str) ? nameSpace + "." + str : str;
}
function NameSpaceForspecialChar(str, addNS, nameSpace, ignoreList) {
  return addNS && !NOT_NUMBER.test(str) && ignoreList.indexOf(str.split(".")[0]) === -1 ? nameSpace + '["' + str : str;
}
function SlashReplace(tempStr) {
  var double = "\\\\";
  if (tempStr.match(DOUBLE_SLASH)) {
    return tempStr;
  } else {
    return tempStr.replace(SINGLE_SLASH, double);
  }
}
function HandleSpecialCharArrObj(str, nameSpaceNew, keys2, ignorePrefix) {
  str = str.trim();
  var windowFunc = /\window\./gm;
  if (!windowFunc.test(str)) {
    var quotes = /'|"/gm;
    var splRegexp = /@|\$|#/gm;
    if (splRegexp.test(str)) {
      str = NameSpaceForspecialChar(str, keys2.indexOf(str) === -1, nameSpaceNew, keys2) + '"]';
    }
    if (ARR_OBJ.test(str)) {
      return NameSpaceArrObj(str, !quotes.test(str) && keys2.indexOf(str) === -1, nameSpaceNew, keys2);
    } else {
      return addNameSpace(str, !quotes.test(str) && keys2.indexOf(str) === -1, nameSpaceNew, keys2, ignorePrefix);
    }
  } else {
    return str;
  }
}
var HAS_ROW = /^[\n\r.]+<tr|^<tr/;
var HAS_SVG = /^[\n\r.]+<svg|^<path|^<g/;
function getRandomId() {
  return "-" + Math.random().toString(36).substr(2, 5);
}
function compile$1(templateString, helper, ignorePrefix) {
  var compiler = engineObj.compile(templateString, helper, ignorePrefix);
  return function(data, component, propName, templateId, isStringTemplate, index, element2, root) {
    var result = compiler(data, component, propName, element2, root);
    if (typeof result === "string") {
      if (HAS_SVG.test(result)) {
        var ele = createElement("svg", { innerHTML: result });
        return ele.childNodes;
      } else {
        var ele = createElement(HAS_ROW.test(result) ? "table" : "div", { innerHTML: result });
        return ele.childNodes;
      }
    } else {
      return result;
    }
  };
}
function updateBlazorTemplate(templateId, templateName, comp, isEmpty, callBack) {
}
function resetBlazorTemplate(templateId, templateName, index) {
  var templateDiv = (undefined).getElementById(templateId);
  if (templateDiv) {
    var innerTemplates = templateDiv.getElementsByClassName("blazor-inner-template");
    for (var i = 0; i < innerTemplates.length; i++) {
      var tempId = " ";
      if (!isNullOrUndefined(index)) {
        tempId = innerTemplates[parseInt(index.toString(), 10)].getAttribute("data-templateId");
      } else {
        tempId = innerTemplates[parseInt(i.toString(), 10)].getAttribute("data-templateId");
      }
      var tempElement = (undefined).getElementById(tempId);
      if (tempElement) {
        var length_1 = tempElement.childNodes.length;
        for (var j = 0; j < length_1; j++) {
          if (!isNullOrUndefined(index)) {
            innerTemplates[parseInt(index.toString(), 10)].appendChild(tempElement.childNodes[0]);
            i = innerTemplates.length;
          } else {
            innerTemplates[parseInt(i.toString(), 10)].appendChild(tempElement.childNodes[0]);
          }
        }
      }
    }
  }
}
function setTemplateEngine(classObj) {
  engineObj.compile = classObj.compile;
}
function getTemplateEngine() {
  return engineObj.compile;
}
function initializeCSPTemplate(template, helper) {
  var boundFunc;
  template.prototype.CSPTemplate = true;
  if (!isNullOrUndefined(helper)) {
    boundFunc = template.bind(helper);
    boundFunc.prototype = Object.create(template.prototype);
  } else {
    boundFunc = template;
  }
  return boundFunc;
}
var Engine = (
  /** @class */
  function() {
    function Engine2() {
    }
    Engine2.prototype.compile = function(templateString, helper, ignorePrefix) {
      if (helper === undefined) {
        helper = {};
      }
      return compile$2(templateString, helper);
    };
    return Engine2;
  }()
);
var engineObj = { compile: new Engine().compile };
var removeTags = [
  "script",
  "style",
  "iframe[src]",
  'link[href*="javascript:"]',
  'object[type="text/x-scriptlet"]',
  'object[data^="data:text/html;base64"]',
  'img[src^="data:text/html;base64"]',
  '[src^="javascript:"]',
  '[dynsrc^="javascript:"]',
  '[lowsrc^="javascript:"]',
  '[type^="application/x-shockwave-flash"]'
];
var removeAttrs = [
  { attribute: "href", selector: '[href*="javascript:"]' },
  { attribute: "href", selector: "a[href]" },
  { attribute: "background", selector: '[background^="javascript:"]' },
  { attribute: "style", selector: '[style*="javascript:"]' },
  { attribute: "style", selector: '[style*="expression("]' },
  { attribute: "href", selector: 'a[href^="data:text/html;base64"]' }
];
var jsEvents = [
  "onchange",
  "onclick",
  "onmouseover",
  "onmouseout",
  "onkeydown",
  "onload",
  "onerror",
  "onblur",
  "onfocus",
  "onbeforeload",
  "onbeforeunload",
  "onkeyup",
  "onsubmit",
  "onafterprint",
  "onbeforeonload",
  "onbeforeprint",
  "oncanplay",
  "oncanplaythrough",
  "oncontextmenu",
  "ondblclick",
  "ondrag",
  "ondragend",
  "ondragenter",
  "ondragleave",
  "ondragover",
  "ondragstart",
  "ondrop",
  "ondurationchange",
  "onemptied",
  "onended",
  "onformchange",
  "onforminput",
  "onhaschange",
  "oninput",
  "oninvalid",
  "onkeypress",
  "onloadeddata",
  "onloadedmetadata",
  "onloadstart",
  "onmessage",
  "onmousedown",
  "onmousemove",
  "onmouseup",
  "onmousewheel",
  "onoffline",
  "onoine",
  "ononline",
  "onpagehide",
  "onpageshow",
  "onpause",
  "onplay",
  "onplaying",
  "onpopstate",
  "onprogress",
  "onratechange",
  "onreadystatechange",
  "onredo",
  "onresize",
  "onscroll",
  "onseeked",
  "onseeking",
  "onselect",
  "onstalled",
  "onstorage",
  "onsuspend",
  "ontimeupdate",
  "onundo",
  "onunload",
  "onvolumechange",
  "onwaiting",
  "onmouseenter",
  "onmouseleave",
  "onstart",
  "onpropertychange",
  "oncopy",
  "ontoggle",
  "onpointerout",
  "onpointermove",
  "onpointerleave",
  "onpointerenter",
  "onpointerrawupdate",
  "onpointerover",
  "onbeforecopy",
  "onbeforecut",
  "onbeforeinput"
];
var SanitizeHtmlHelper = (
  /** @class */
  function() {
    function SanitizeHtmlHelper2() {
    }
    SanitizeHtmlHelper2.beforeSanitize = function() {
      return {
        selectors: {
          tags: removeTags,
          attributes: removeAttrs
        }
      };
    };
    SanitizeHtmlHelper2.sanitize = function(value) {
      if (isNullOrUndefined(value)) {
        return value;
      }
      var item = this.beforeSanitize();
      var output = this.serializeValue(item, value);
      return output;
    };
    SanitizeHtmlHelper2.serializeValue = function(item, value) {
      this.removeAttrs = item.selectors.attributes;
      this.removeTags = item.selectors.tags;
      this.wrapElement = (undefined).createElement("div");
      this.wrapElement.innerHTML = value;
      this.removeXssTags();
      this.removeJsEvents();
      this.removeXssAttrs();
      var tempEleValue = this.wrapElement.innerHTML;
      this.removeElement();
      this.wrapElement = null;
      return tempEleValue.replace(/&amp;/g, "&");
    };
    SanitizeHtmlHelper2.removeElement = function() {
      var nodes = this.wrapElement.children;
      for (var j = 0; j < nodes.length; j++) {
        var attribute = nodes[parseInt(j.toString(), 10)].attributes;
        for (var i = 0; i < attribute.length; i++) {
          this.wrapElement.children[parseInt(j.toString(), 10)].removeAttribute(attribute[parseInt(i.toString(), 10)].localName);
        }
      }
    };
    SanitizeHtmlHelper2.removeXssTags = function() {
      var elements = this.wrapElement.querySelectorAll(this.removeTags.join(","));
      if (elements.length > 0) {
        elements.forEach(function(element2) {
          detach(element2);
        });
      } else {
        return;
      }
    };
    SanitizeHtmlHelper2.removeJsEvents = function() {
      var elements = this.wrapElement.querySelectorAll("[" + jsEvents.join("],[") + "]");
      if (elements.length > 0) {
        elements.forEach(function(element2) {
          jsEvents.forEach(function(attr) {
            if (element2.hasAttribute(attr)) {
              element2.removeAttribute(attr);
            }
          });
        });
      } else {
        return;
      }
    };
    SanitizeHtmlHelper2.removeXssAttrs = function() {
      var _this = this;
      this.removeAttrs.forEach(function(item, index) {
        var elements = _this.wrapElement.querySelectorAll(item.selector);
        if (elements.length > 0) {
          if (item.selector === "a[href]") {
            elements.forEach(function(element2) {
              if (element2.getAttribute(item.attribute).replace(/\t|\s|&/, "").indexOf("javascript:alert") !== -1) {
                element2.removeAttribute(item.attribute);
              }
            });
          } else {
            elements.forEach(function(element2) {
              element2.removeAttribute(item.attribute);
            });
          }
        }
      });
    };
    return SanitizeHtmlHelper2;
  }()
);
var Crop = (
  /** @class */
  function() {
    function Crop2(parent) {
      this.croppedDegree = 0;
      this.cropDestPoints = { startX: 0, startY: 0, width: 0, height: 0 };
      this.tempFlipPanPoint = { x: 0, y: 0 };
      this.isPreventScaling = false;
      this.isInitCrop = false;
      this.isTransformCrop = false;
      this.parent = parent;
      this.addEventListener();
    }
    Crop2.prototype.destroy = function() {
      if (this.parent.isDestroyed) {
        return;
      }
      this.removeEventListener();
    };
    Crop2.prototype.addEventListener = function() {
      this.parent.on("crop", this.cropping, this);
      this.parent.on("destroyed", this.destroy, this);
    };
    Crop2.prototype.removeEventListener = function() {
      this.parent.off("crop", this.cropping);
      this.parent.off("destroyed", this.destroy);
    };
    Crop2.prototype.cropping = function(args) {
      this.updateCropPvtVar();
      switch (args.prop) {
        case "cropCircle":
          this.cropCircle(args.value["context"], args.value["isSave"], args.value["isFlip"]);
          break;
        case "setCurrSelPoints":
          this.setCurrSelPoints(args.value["isSetDimension"]);
          break;
        case "updateRotatePan":
          this.updateRotatePan();
          break;
        case "crop":
          this.crop(args.value["obj"]);
          break;
        case "calcRatio":
          this.calcRatio(args.value["obj"], args.value["dimension"]);
          break;
        case "getCurrFlipState":
          this.getCurrFlipState(args.value["panObj"]);
          break;
        case "getPreviousCropCurrentObj":
          args.value["obj"]["prevObj"] = this.prevCropCurrObj;
          break;
        case "setPreviousCropCurrentObj":
          this.prevCropCurrObj = args.value["obj"];
          break;
        case "setCropDestPoints":
          this.cropDestPoints = args.value["point"];
          break;
        case "getTempFlipPanPoint":
          args.value["obj"]["point"] = this.tempFlipPanPoint;
          break;
        case "setTempFlipPanPoint":
          if (isNullOrUndefined(args.value["isAdd"])) {
            this.tempFlipPanPoint = args.value["point"];
          } else {
            this.tempFlipPanPoint.x += args.value["point"].x;
            this.tempFlipPanPoint.y += args.value["point"].y;
          }
          break;
        case "getPreventScaling":
          args.value["obj"]["bool"] = this.isPreventScaling;
          break;
        case "adjustStraightenForShapes":
          this.adjustStraightenForShapes(args.value["type"], args.value["isInitialRotated"]);
          break;
        case "resizeWrapper":
          this.resizeWrapper();
          break;
        case "setTransformCrop":
          this.isTransformCrop = args.value["bool"];
          break;
        case "setInitCrop":
          this.isInitCrop = args.value["bool"];
          break;
        case "resetZoom":
          this.resetZoom();
          break;
        case "revertTransform":
          this.revertTransform(args.value["type"], args.value["coll"]);
          break;
        case "reset":
          this.reset();
          break;
      }
    };
    Crop2.prototype.getModuleName = function() {
      return "crop";
    };
    Crop2.prototype.updateCropPvtVar = function() {
      var parent = this.parent;
      if (parent.lowerCanvas) {
        this.lowerContext = parent.lowerCanvas.getContext("2d");
      }
      if (parent.upperCanvas) {
        this.upperContext = parent.upperCanvas.getContext("2d");
      }
    };
    Crop2.prototype.reset = function() {
      this.prevCropCurrObj = null;
      this.croppedDegree = 0;
      this.cropDestPoints = { startX: 0, startY: 0, width: 0, height: 0 };
      this.tempFlipPanPoint = { x: 0, y: 0 };
      this.isPreventScaling = false;
      this.isInitCrop = false;
      this.isTransformCrop = false;
    };
    Crop2.prototype.cropImg = function(isRotateCrop) {
      var parent = this.parent;
      var isNullCrop = isNullOrUndefined(isRotateCrop);
      var resizeIcon = parent.element.querySelector("#" + parent.element.id + "_nonaspectratio");
      var actPoint = parent.activeObj.activePoint;
      var img = parent.img;
      var isRotated = false;
      for (var i = 0, len = parent.rotateFlipColl.length; i < len; i++) {
        var currentValue = parent.rotateFlipColl[i];
        if (currentValue === 90 || currentValue === -90) {
          isRotated = true;
        }
      }
      parent.notify("draw", { prop: "setImageEdited", onPropertyChange: false });
      if (isNullCrop || resizeIcon) {
        this.croppedDegree = parent.transform.degree;
      }
      if (isNullCrop && parent.transform.degree !== 0 || isRotated) {
        this.updateCropObj();
        var point = { startX: img.destLeft, startY: img.destTop, width: img.destWidth, height: img.destHeight };
        parent.notify("transform", { prop: "setCurrDestinationPoint", onPropertyChange: false, value: { point } });
        this.rotateCrop();
      } else if (isNullCrop && parent.transform.currFlipState !== "") {
        this.updateCropObj();
        var point = { startX: img.destLeft, startY: img.destTop, width: img.destWidth, height: img.destHeight };
        parent.notify("transform", { prop: "setCurrDestinationPoint", onPropertyChange: false, value: { point } });
        this.flipCrop();
      } else {
        this.adjustStraightenForShapes("initial", false);
        parent.notify("draw", { prop: "setTempZoomFactor", onPropertyChange: false, value: { tempZoomFactor: parent.transform.zoomFactor } });
        var ratio = this.calcRatio();
        if (isNullCrop || !isRotateCrop) {
          this.updateCropObj();
          parent.notify("draw", { prop: "resetPanPoints", onPropertyChange: false });
          parent.notify("shape", { prop: "updImgRatioForActObj", onPropertyChange: false });
          var point = { startX: img.destLeft, startY: img.destTop, width: img.destWidth, height: img.destHeight };
          parent.notify("transform", { prop: "setCurrDestinationPoint", onPropertyChange: false, value: { point } });
          parent.currSelectionPoint = extend({}, parent.activeObj, {}, true);
          this.cropDestPoints = { startX: img.destLeft, startY: img.destTop, width: img.destWidth, height: img.destHeight };
        }
        var obj = { width: 0, height: 0 };
        parent.notify("transform", { prop: "calcMaxDimension", onPropertyChange: false, value: {
          width: actPoint.width * ratio.width,
          height: actPoint.height * ratio.height,
          obj,
          isImgShape: null
        } });
        var maxDimension = obj;
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        parent.img = {
          srcLeft: actPoint.startX * ratio.width - img.destLeft * ratio.width,
          srcTop: actPoint.startY * ratio.height - img.destTop * ratio.height,
          srcWidth: actPoint.width * ratio.width,
          srcHeight: actPoint.height * ratio.height,
          destLeft: (parent.lowerCanvas.clientWidth - maxDimension.width) / 2,
          destTop: (parent.lowerCanvas.clientHeight - maxDimension.height + 1) / 2,
          destWidth: maxDimension.width,
          destHeight: maxDimension.height
        };
        var temp = this.lowerContext.filter;
        parent.notify("draw", { prop: "drawImage", onPropertyChange: false });
        this.lowerContext.filter = "none";
        var activeObj = extend({}, parent.activeObj, {}, true);
        this.cropObjColl();
        parent.transform.straighten = 0;
        parent.activeObj = activeObj;
        this.cropFreehandDrawColl();
        parent.shapeColl = [];
        parent.notify("shape", { prop: "updateShapeColl", onPropertyChange: false });
        parent.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
        });
        parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
        parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.upperContext } });
        if (parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle") {
          this.cropCircle(this.lowerContext);
        } else {
          parent.isCircleCrop = false;
        }
        this.lowerContext.filter = temp;
        parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        parent.currObjType.isCustomCrop = false;
        parent.pan(false);
        parent.transform.defaultZoomFactor = 0;
      }
    };
    Crop2.prototype.adjustStraightenForShapes = function(type, isInitialRotated) {
      var parent = this.parent;
      var center = {
        x: parent.img.destLeft + parent.img.destWidth / 2,
        y: parent.img.destTop + parent.img.destHeight / 2
      };
      for (var _i = 0, _a = parent.objColl; _i < _a.length; _i++) {
        var obj = _a[_i];
        if (["rectangle", "ellipse", "text", "image", "redact"].indexOf(obj.shape) !== -1) {
          if (isInitialRotated || obj.rotatedAngle !== 0) {
            var _b = obj.activePoint, startX = _b.startX, startY = _b.startY, width = _b.width, height = _b.height;
            var angle = type === "initial" ? obj.rotatedAngle : -obj.rotatedAngle;
            var diffX = startX + width / 2 - center.x;
            var diffY = startY + height / 2 - center.y;
            var cosAngle = Math.cos(angle);
            var sinAngle = Math.sin(angle);
            var centerX = cosAngle * diffX - sinAngle * diffY + center.x;
            var centerY = sinAngle * diffX + cosAngle * diffY + center.y;
            var diffXUpdated = centerX - startX - width / 2;
            var diffYUpdated = centerY - startY - height / 2;
            obj.activePoint.startX += diffXUpdated;
            obj.activePoint.startY += diffYUpdated;
            obj.activePoint.endX += diffXUpdated;
            obj.activePoint.endY += diffYUpdated;
          }
        }
      }
    };
    Crop2.prototype.updateCropObj = function() {
      this.parent.afterCropActions = [];
      var object = { currObj: {} };
      this.parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
      var obj = object["currObj"];
      obj.straighten = this.parent.transform.straighten;
      this.parent.cropObj = extend({}, obj, {}, true);
    };
    Crop2.prototype.rotateCrop = function() {
      var parent = this.parent;
      var flipState = this.getCurrFlipState();
      var shape = parent.activeObj.shape || "";
      parent.notify("shape", { prop: "updImgRatioForActObj", onPropertyChange: false });
      parent.currSelectionPoint = extend({}, parent.activeObj, {}, true);
      parent.objColl.push(parent.activeObj);
      parent.activeObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
      var activeObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
      var tempCurrSelObj = extend({}, parent.currSelectionPoint, {}, true);
      var preventSelObj = { bool: null };
      parent.notify("transform", { prop: "getPreventSelect", onPropertyChange: false, value: { obj: preventSelObj } });
      parent.notify("transform", { prop: "setPreventSelect", onPropertyChange: false, value: { bool: true } });
      var coll = extend([], parent.rotateFlipColl, [], true);
      this.panToSelRangle(true);
      activeObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate", obj: activeObj } });
      parent.objColl.pop();
      parent.notify("shape", { prop: "updImgRatioForActObj", onPropertyChange: false });
      parent.objColl.push(parent.activeObj);
      var straighten = parent.transform.straighten;
      if (straighten !== 0) {
        parent.transform.straighten = 0;
        parent.straightenBaseImageCanvas();
        parent.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
        });
        parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        parent.notify("draw", { prop: "render-image", value: { isMouseWheel: false } });
      }
      this.resetZoom();
      var afterCropActions = extend([], parent.afterCropActions, [], true);
      this.revertTransform("initial", coll);
      if (straighten !== 0) {
        parent.transform.straighten = flipState === "horizontal" || flipState === "vertical" ? -straighten : straighten;
        parent.straightenBaseImageCanvas();
        parent.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
        });
        parent.notify("draw", { prop: "render-image", value: { isMouseWheel: false } });
        parent.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
        });
      }
      activeObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate", obj: activeObj } });
      parent.objColl.pop();
      parent.transform.degree = 0;
      var object = { isIntersect: null };
      parent.notify("draw", { prop: "updateImgCanvasPoints", onPropertyChange: false });
      parent.notify("draw", { prop: "isLinesIntersect", onPropertyChange: false, value: { obj: object } });
      var count = 0;
      while (straighten !== 0 && object["isIntersect"]) {
        count++;
        if (count === 50) {
          break;
        }
        parent.notify("transform", {
          prop: "zoomAction",
          onPropertyChange: false,
          value: { zoomFactor: 0.025, zoomPoint: null },
          isResize: null
        });
        parent.notify("draw", { prop: "updateImgCanvasPoints", onPropertyChange: false });
        parent.notify("draw", { prop: "isLinesIntersect", onPropertyChange: false, value: { obj: object } });
      }
      this.cropImg(true);
      this.revertTransform("reverse", coll);
      parent.afterCropActions = afterCropActions;
      parent.currSelectionPoint = tempCurrSelObj;
      parent.notify("transform", { prop: "setPreventSelect", onPropertyChange: false, value: { bool: preventSelObj["bool"] } });
      parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
      parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.upperContext } });
      if (shape === "crop-circle") {
        this.cropCircle(this.lowerContext);
      }
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      parent.notify("draw", { prop: "resetPanPoints", onPropertyChange: false });
    };
    Crop2.prototype.revertTransform = function(type, coll) {
      var parent = this.parent;
      var obj = { isRotate: false };
      if (type === "initial") {
        for (var i = coll.length - 1; i >= 0; i--) {
          var value = coll[i];
          switch (value) {
            case 90:
              parent.notify("transform", { prop: "rotate", value: { degree: -90, obj } });
              break;
            case -90:
              parent.notify("transform", { prop: "rotate", value: { degree: 90, obj } });
              break;
            default:
              parent.notify("transform", { prop: "flipImage", value: { direction: parent.toPascalCase(value.toString()) } });
              break;
          }
        }
      } else {
        this.updateFlipState();
        for (var i = 0, len = coll.length; i < len; i++) {
          var value = coll[i];
          switch (value) {
            case 90:
              parent.notify("transform", { prop: "rotate", value: { degree: 90, obj } });
              break;
            case -90:
              parent.notify("transform", { prop: "rotate", value: { degree: -90, obj } });
              break;
            default:
              parent.notify("transform", { prop: "flipImage", value: { direction: parent.toPascalCase(value.toString()) } });
              break;
          }
        }
      }
    };
    Crop2.prototype.updateFlipState = function() {
      var parent = this.parent;
      var objColl = parent.objColl;
      for (var i = 0, len = objColl.length; i < len; i++) {
        objColl[i].shapeFlip = "";
      }
      var pointColl = parent.pointColl;
      for (var i = 0; i < parent.freehandCounter; i++) {
        pointColl[i].shapeFlip = "";
      }
    };
    Crop2.prototype.resetZoom = function() {
      var parent = this.parent;
      if (parent.transform.zoomFactor > 0) {
        var zoomFactor = parent.transform.zoomFactor;
        var isUndoRedo = parent.isUndoRedo;
        parent.setProperties({ zoomSettings: { zoomFactor: zoomFactor * 10 } }, true);
        parent.notify("transform", {
          prop: "setPreviousZoomValue",
          onPropertyChange: false,
          value: { previousZoomValue: parent.zoomSettings.zoomFactor }
        });
        for (var i = 0; i < zoomFactor * 10; i++) {
          parent.isUndoRedo = true;
          parent.notify("transform", {
            prop: "zoomAction",
            onPropertyChange: false,
            value: { zoomFactor: -0.1, zoomPoint: null },
            isResize: null
          });
        }
        parent.isUndoRedo = isUndoRedo;
        parent.notify("draw", { prop: "resetPanPoints", onPropertyChange: false });
      }
    };
    Crop2.prototype.flipCrop = function() {
      var parent = this.parent;
      parent.notify("transform", { prop: "setReverseFlip", onPropertyChange: false, value: { isReverseFlip: true } });
      parent.panPoint.totalPannedPoint.x += this.tempFlipPanPoint.x;
      parent.panPoint.totalPannedPoint.y += this.tempFlipPanPoint.y;
      var tempCurrFlipState = parent.transform.currFlipState;
      var obj = { flipColl: null };
      parent.notify("transform", { prop: "getFlipColl", onPropertyChange: false, value: { obj } });
      var tempFlipColl = obj["flipColl"];
      parent.notify("transform", { prop: "setFlipColl", onPropertyChange: false, value: { flipColl: [] } });
      parent.notify("shape", { prop: "updImgRatioForActObj", onPropertyChange: false });
      parent.objColl.push(parent.activeObj);
      if (parent.transform.degree === 0) {
        var panX = -parent.cropObj.totalPannedPoint.x;
        var panY = -parent.cropObj.totalPannedPoint.y;
        parent.img.destLeft += panX;
        parent.img.destTop += panY;
        parent.notify("transform", { prop: "drawPannImage", value: { point: { x: panX, y: panY } } });
        parent.activeObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate", obj: parent.activeObj } });
        parent.objColl.pop();
        parent.notify("shape", { prop: "updImgRatioForActObj", onPropertyChange: false });
        parent.objColl.push(parent.activeObj);
      }
      this.resetZoom();
      parent.currSelectionPoint = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
      this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      var temp = this.lowerContext.filter;
      parent.notify("draw", { prop: "drawImage", onPropertyChange: false });
      this.updateFlipState();
      parent.notify("shape", { prop: "redrawObj", onPropertyChange: false, value: { degree: this.getCurrFlipState() } });
      parent.notify("freehand-draw", {
        prop: "flipFHDColl",
        onPropertyChange: false,
        value: { value: this.getCurrFlipState() }
      });
      parent.activeObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
      parent.objColl.pop();
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate" } });
      this.cropImg(true);
      parent.notify("transform", { prop: "setReverseRotate", onPropertyChange: false, value: { bool: true } });
      this.lowerContext.setTransform(1, 0, 0, 1, 0, 0);
      parent.notify("draw", { prop: "setDestPoints", onPropertyChange: false });
      parent.notify("draw", {
        prop: "currTransState",
        onPropertyChange: false,
        value: { type: "initial", isPreventDestination: null, context: null, isPreventCircleCrop: null }
      });
      parent.notify("draw", { prop: "drawImage", onPropertyChange: false });
      this.lowerContext.filter = temp;
      parent.notify("draw", { prop: "setRotateZoom", onPropertyChange: false, value: { isRotateZoom: false } });
      parent.notify("draw", {
        prop: "currTransState",
        onPropertyChange: false,
        value: { type: "reverse", isPreventDestination: null, context: null, isPreventCircleCrop: null }
      });
      parent.transform.currFlipState = tempCurrFlipState;
      parent.notify("transform", { prop: "setFlipColl", onPropertyChange: false, value: { flipColl: tempFlipColl } });
      this.lowerContext.filter = "none";
      this.updateFlipState();
      parent.notify("shape", { prop: "redrawObj", onPropertyChange: false, value: { degree: this.getCurrFlipState() } });
      parent.notify("freehand-draw", {
        prop: "flipFHDColl",
        onPropertyChange: false,
        value: { value: this.getCurrFlipState() }
      });
      parent.notify("shape", {
        prop: "drawAnnotations",
        onPropertyChange: false,
        value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
      });
      this.lowerContext.filter = temp;
      if (parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle" || parent.isCircleCrop) {
        this.cropCircle(this.lowerContext);
      }
      parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
      parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.upperContext } });
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      parent.notify("transform", { prop: "setReverseFlip", onPropertyChange: false, value: { isReverseFlip: false } });
      parent.notify("draw", { prop: "resetPanPoints", onPropertyChange: false });
      this.tempFlipPanPoint = { x: 0, y: 0 };
    };
    Crop2.prototype.cropObjColl = function() {
      var parent = this.parent;
      var point;
      var shape;
      var obj;
      if (parent.objColl.length > 0) {
        for (var i = 0, len = parent.objColl.length; i < len; i++) {
          obj = parent.objColl[i];
          point = obj.activePoint;
          var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY, width = _a.width, height = _a.height;
          shape = obj.shape;
          obj.imageRatio = {
            startX: (point.startX - startX) / width,
            startY: (point.startY - startY) / height,
            endX: (point.endX - startX) / width,
            endY: (point.endY - startY) / height,
            width: width / point.width,
            height: height / point.height
          };
          var degree = undefined;
          var size = undefined;
          switch (shape) {
            case "text":
              degree = obj.shapeDegree === 0 ? parent.transform.degree : parent.transform.degree - obj.shapeDegree;
              size = degree === 0 || Math.abs(degree) === 180 ? point.width : point.height;
              obj.textSettings.fontRatio = size / obj.textSettings.fontSize;
              break;
            case "line":
            case "arrow":
              this.cropPointCollection(i);
              if (shape === "arrow") {
                parent.notify("shape", { prop: "updateArrowRatio", onPropertyChange: false, value: { obj } });
              }
              break;
            case "path":
              this.cropPointCollection(i);
              break;
          }
        }
      }
    };
    Crop2.prototype.cropPointCollection = function(i) {
      var parent = this.parent;
      var shape = parent.objColl[i].shape;
      var x;
      var y;
      var width;
      var height;
      var point = parent.activeObj.activePoint;
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      if (shape === "path") {
        x = point.startX;
        y = point.startY;
        width = point.width;
        height = point.height;
      } else {
        x = destLeft;
        y = destTop;
        width = destWidth;
        height = destHeight;
      }
      var pointColl = parent.objColl[i].pointColl;
      for (var n = 0, len = pointColl.length; n < len; n++) {
        pointColl[n].ratioX = (pointColl[n].x - x) / width;
        pointColl[n].ratioY = (pointColl[n].y - y) / height;
      }
    };
    Crop2.prototype.cropFreehandDrawColl = function() {
      var parent = this.parent;
      var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY, width = _a.width, height = _a.height;
      for (var n = 0; n < parent.freehandCounter; n++) {
        parent.points = extend([], parent.pointColl[n].points, []);
        parent.notify("freehand-draw", { prop: "setPointCounter", onPropertyChange: false, value: { value: 0 } });
        var len = parent.points.length;
        for (var l = 0; l < len; l++) {
          parent.points[l].ratioX = (parent.points[l].x - startX) / width;
          parent.points[l].ratioY = (parent.points[l].y - startY) / height;
        }
      }
      parent.notify("freehand-draw", { prop: "updateCropPtsForSel", onPropertyChange: false });
    };
    Crop2.prototype.resetAnnotations = function() {
      var parent = this.parent;
      parent.objColl = [];
      parent.pointColl = [];
      parent.freehandCounter = 0;
      parent.notify("freehand-draw", { prop: "resetStraightenPoint" });
    };
    Crop2.prototype.setCurrSelPoints = function(isSetDimension) {
      var parent = this.parent;
      parent.allowDownScale = false;
      var destPoint = this.cropDestPoints;
      var filter = this.lowerContext.filter;
      var isCropTab = parent.isCropTab;
      parent.img = {
        srcLeft: 0,
        srcTop: 0,
        srcWidth: parent.baseImgCanvas.width,
        srcHeight: parent.baseImgCanvas.height,
        destLeft: destPoint.startX,
        destTop: destPoint.startY,
        destWidth: destPoint.width,
        destHeight: destPoint.height
      };
      var img = parent.img;
      var currSelPoint = parent.currSelectionPoint;
      this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      if (isSetDimension) {
        parent.notify("draw", { prop: "setDestPoints", onPropertyChange: false });
      }
      parent.notify("draw", {
        prop: "currTransState",
        onPropertyChange: false,
        value: { type: "initial", isPreventDestination: null, context: null, isPreventCircleCrop: null }
      });
      if (this.croppedDegree === 0 && parent.transform.degree === 0 && currSelPoint && currSelPoint.shape !== "crop-circle" && currSelPoint.shape !== "crop-square") {
        img.destLeft = destPoint.startX;
        img.destTop = destPoint.startY;
        img.destWidth = destPoint.width;
        img.destHeight = destPoint.height;
      }
      if (parent.transform.degree === 0) {
        img.destLeft += parent.panPoint.totalPannedInternalPoint.x;
        img.destTop += parent.panPoint.totalPannedInternalPoint.y;
      }
      parent.notify("draw", { prop: "drawImage", onPropertyChange: false });
      this.lowerContext.filter = filter;
      parent.notify("draw", {
        prop: "currTransState",
        onPropertyChange: false,
        value: { type: "reverse", isPreventDestination: null, context: null, isPreventCircleCrop: true }
      });
      var cropObjColl = extend([], parent.objColl, null, true);
      var cropPointColl = extend([], parent.pointColl, null, true);
      var straightenObj = { straightenPoint: null };
      parent.notify("freehand-draw", {
        prop: "getStraightenPoint",
        onPropertyChange: false,
        value: { obj: straightenObj }
      });
      this.resetAnnotations();
      if (isNullOrUndefined(parent.activeObj.shape) && parent.cropObj.activeObj.shape) {
        parent.activeObj = extend({}, parent.cropObj.activeObj, null, true);
      }
      this.panToSelRangle();
      parent.isCropTab = isCropTab;
      parent.objColl = cropObjColl;
      parent.pointColl = cropPointColl;
      parent.freehandCounter = parent.pointColl.length;
      if (straightenObj["straightenPoint"]["x"] && straightenObj["straightenPoint"]["y"]) {
        parent.notify("freehand-draw", {
          prop: "setStraightenPoint",
          onPropertyChange: false,
          value: {
            x: straightenObj["straightenPoint"]["x"],
            y: straightenObj["straightenPoint"]["y"],
            ratioX: straightenObj["straightenPoint"]["ratioX"],
            ratioY: straightenObj["straightenPoint"]["ratioY"]
          }
        });
      }
      if (parent.cropObj.activeObj.shape) {
        var destPoints = { startX: img.destLeft, startY: img.destTop, width: img.destWidth, height: img.destHeight };
        if (currSelPoint && currSelPoint.activePoint) {
          var _a = currSelPoint.activePoint, startX = _a.startX, startY = _a.startY, width = _a.width, height = _a.height;
          img.destLeft = startX;
          img.destTop = startY;
          img.destWidth = width;
          img.destHeight = height;
        }
        parent.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
        });
        img.destLeft = destPoints.startX;
        img.destTop = destPoints.startY;
        img.destWidth = destPoints.width;
        img.destHeight = destPoints.height;
        parent.notify("freehand-draw", { prop: "updateFHDColl", onPropertyChange: false });
        cropObjColl = extend([], parent.objColl, null, true);
        cropPointColl = extend([], parent.pointColl, null, true);
        parent.notify("freehand-draw", { prop: "getStraightenPoint", onPropertyChange: false, value: { obj: straightenObj } });
        this.resetAnnotations();
        var object = { selPointColl: null };
        parent.notify("freehand-draw", { prop: "getSelPointColl", onPropertyChange: false, value: { obj: object } });
        var cropSelPointColl = object["selPointColl"];
        parent.notify("freehand-draw", { prop: "setSelPointColl", onPropertyChange: false, value: { obj: { selPointColl: [] } } });
        parent.cropObj.filter = this.lowerContext.filter;
        var actObj = extend({}, parent.currSelectionPoint, null, true);
        parent.notify("draw", { prop: "setCurrentObj", onPropertyChange: false, value: { obj: null } });
        parent.activeObj = extend({}, actObj, null, true);
        var activeObj = extend({}, parent.activeObj, null, true);
        parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        parent.currSelectionPoint = null;
        parent.isCircleCrop = false;
        if (parent.transform.degree !== 0) {
          if (isNullOrUndefined(parent.activeObj.shape) && parent.cropObj.activeObj.shape) {
            parent.activeObj = extend({}, parent.cropObj.activeObj, null, true);
          }
          parent.notify("transform", { prop: "drawPannedImage", value: { xDiff: 0, yDiff: 0 } });
          parent.panPoint.currentPannedPoint = { x: 0, y: 0 };
        }
        parent.objColl = cropObjColl;
        parent.pointColl = cropPointColl;
        parent.freehandCounter = parent.pointColl.length;
        if (straightenObj["straightenPoint"]["x"] && straightenObj["straightenPoint"]["y"]) {
          parent.notify("freehand-draw", {
            prop: "setStraightenPoint",
            onPropertyChange: false,
            value: {
              x: straightenObj["straightenPoint"]["x"],
              y: straightenObj["straightenPoint"]["y"],
              ratioX: straightenObj["straightenPoint"]["ratioX"],
              ratioY: straightenObj["straightenPoint"]["ratioY"]
            }
          });
        }
        parent.notify("freehand-draw", {
          prop: "setSelPointColl",
          onPropertyChange: false,
          value: { obj: { selPointColl: cropSelPointColl } }
        });
        parent.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "iterate", pen: "iterate", isPreventApply: null }
        });
        this.adjustStraightenForShapes("reverse", false);
        parent.notify("freehand-draw", { prop: "updateFHDColl", onPropertyChange: false, value: { isPreventApply: true } });
        parent.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
        });
        if (parent.transform.degree === 0) {
          parent.notify("transform", {
            prop: "drawPannImage",
            onPropertyChange: false,
            value: { point: { x: 0, y: 0 } }
          });
        } else {
          if (isNullOrUndefined(parent.activeObj.shape) && parent.cropObj.activeObj.shape) {
            parent.activeObj = extend({}, parent.cropObj.activeObj, null, true);
          }
          parent.notify("transform", { prop: "drawPannedImage", value: { xDiff: 0, yDiff: 0 } });
          parent.panPoint.currentPannedPoint = { x: 0, y: 0 };
        }
        parent.activeObj = activeObj;
        parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate" } });
        parent.notify("transform", {
          prop: "setTempPanMove",
          onPropertyChange: false,
          value: { point: null }
        });
        if (!this.isInitCrop && parent.transform.degree === 0 && parent.cropObj.currFlipState !== "" && parent.cropObj.cropZoom !== 0) {
          this.isInitCrop = true;
          var obj = { activeObj: null };
          parent.notify("draw", { prop: "getStraightenActObj", onPropertyChange: false, value: { obj } });
          parent.notify("draw", { prop: "performCancel", value: { isContextualToolbar: null } });
          parent.notify("draw", { prop: "setStraightenActObj", onPropertyChange: false, value: { activeObj: obj["activeObj"] } });
          parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
            type: "croptransform",
            isApplyBtn: false,
            isCropping: null,
            isZooming: null,
            cType: null
          } });
        } else {
          this.isInitCrop = false;
        }
      } else {
        this.adjustStraightenForShapes("reverse", true);
        parent.notify("freehand-draw", { prop: "updateFHDColl", onPropertyChange: false, value: { isPreventApply: true } });
        var temp = this.lowerContext.filter;
        this.lowerContext.filter = "none";
        parent.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "iterate", pen: "iterate", isPreventApply: null }
        });
        this.lowerContext.filter = temp;
        parent.currSelectionPoint = null;
      }
      if ((undefined).querySelector(".e-ie-straighten-value-span")) {
        (undefined).querySelector(".e-ie-straighten-value-span").innerHTML = parent.transform.straighten.toString() + "&#176";
      }
    };
    Crop2.prototype.panToSelRangle = function(isReverse) {
      var parent = this.parent;
      var pannedPoint = parent.cropObj.totalPannedClientPoint;
      var panX = parent.transform.degree !== 0 ? isReverse ? -pannedPoint.x : pannedPoint.x : 0;
      var panY = parent.transform.degree !== 0 ? isReverse ? -pannedPoint.y : pannedPoint.y : 0;
      if (parent.transform.degree !== 0) {
        parent.panPoint.currentPannedPoint = { x: panX, y: panY };
        parent.notify("transform", { prop: "drawPannedImage", value: { xDiff: panX, yDiff: panY } });
        parent.panPoint.currentPannedPoint = { x: 0, y: 0 };
      }
    };
    Crop2.prototype.cropCircle = function(context, isSave, isFlip) {
      var parent = this.parent;
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      if (isFlip && parent.transform.currFlipState !== "") {
        parent.notify("draw", {
          prop: "setTransform",
          onPropertyChange: false,
          value: { context, value: parent.transform.currFlipState, isReverse: null }
        });
      }
      var temp = context.filter;
      context.filter = "none";
      context.globalCompositeOperation = "destination-in";
      context.beginPath();
      var centerX = isNullOrUndefined(isSave) ? destLeft + destWidth / 2 : context.canvas.width / 2;
      var centerY = isNullOrUndefined(isSave) ? destTop + destHeight / 2 : context.canvas.height / 2;
      var radius = isSave ? context.canvas.width / 2 : destWidth / 2;
      context.arc(centerX, centerY, radius, 0, Math.PI * 2);
      context.closePath();
      context.fill();
      context.restore();
      context.globalCompositeOperation = "source-over";
      parent.currObjType.isActiveObj = parent.isCircleCrop = true;
      context.filter = temp;
      if (isFlip && parent.transform.currFlipState !== "") {
        parent.notify("draw", {
          prop: "setTransform",
          onPropertyChange: false,
          value: { context, value: parent.transform.currFlipState, isReverse: null }
        });
      }
    };
    Crop2.prototype.getCurrCropState = function() {
      var parent = this.parent;
      var flipState = "";
      var obj = { flipColl: null };
      parent.notify("transform", { prop: "getFlipColl", onPropertyChange: false, value: { obj } });
      flipState = this.getCurrFlipState();
      if (parent.transform.degree === -90 || parent.transform.degree === -270) {
        if (flipState === "horizontal") {
          flipState = "vertical";
        } else if (flipState === "vertical") {
          flipState = "horizontal";
        }
      }
      if (flipState === "") {
        flipState = obj["flipColl"].length > 1 ? this.getCurrFlipState() : parent.transform.currFlipState;
      }
      return flipState;
    };
    Crop2.prototype.updateRotatePan = function() {
      var parent = this.parent;
      if (isNullOrUndefined(parent.panPoint.currentPannedPoint)) {
        return;
      }
      var panRegion = "";
      var degree = parent.transform.degree;
      var _a = parent.panPoint.currentPannedPoint, x = _a.x, y = _a.y;
      if (parent.rotateFlipColl.length > 0 && typeof parent.rotateFlipColl[0] === "number" && degree < 0) {
        panRegion = this.getCurrCropState();
      } else {
        panRegion = this.getCurrFlipState();
      }
      if (degree % 90 === 0 && degree % 180 !== 0) {
        if (degree === 90 || degree === -90 && (panRegion === "horizontal" || panRegion === "vertical") || degree === -270 && (panRegion === "" || panRegion === "verticalHorizontal" || panRegion === "horizontalVertical")) {
          if (panRegion === "horizontal" || panRegion === "") {
            parent.img.destLeft += y;
          } else {
            parent.img.destLeft -= y;
          }
          if (panRegion === "" || panRegion === "vertical") {
            parent.img.destTop -= x;
          } else {
            parent.img.destTop += x;
          }
        } else if (degree === 270 || degree === -270 && (panRegion === "horizontal" || panRegion === "vertical") || degree === -90 && (panRegion === "" || panRegion === "verticalHorizontal" || panRegion === "horizontalVertical")) {
          if (panRegion === "" || panRegion === "horizontal") {
            parent.img.destLeft -= y;
          } else {
            parent.img.destLeft += y;
          }
          if (panRegion === "" || panRegion === "vertical") {
            parent.img.destTop += x;
          } else {
            parent.img.destTop -= x;
          }
        }
      } else {
        if (degree === 180 || degree === -180) {
          if (panRegion === "" || panRegion === "vertical") {
            parent.img.destLeft -= x;
          } else {
            parent.img.destLeft += x;
          }
          if (panRegion === "" || panRegion === "horizontal") {
            parent.img.destTop -= y;
          } else {
            parent.img.destTop += y;
          }
        }
      }
    };
    Crop2.prototype.crop = function(obj) {
      var parent = this.parent;
      var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
      if (!parent.disabled && parent.isImageLoaded) {
        var object = { isCropToolbar: parent.isCropToolbar };
        if (parent.currObjType.isUndoAction && !object["isCropToolbar"]) {
          parent.notify("undo-redo", { prop: "refreshUrc", value: { bool: null } });
        }
        var transitionArgs = {
          cancel: false,
          startPoint: { x: startX, y: startY },
          endPoint: { x: endX, y: endY },
          preventScaling: false
        };
        if (!object["isCropToolbar"]) {
          parent.trigger("cropping", transitionArgs);
          parent.editCompleteArgs = transitionArgs;
        }
        this.cropEvent(transitionArgs, obj, object);
      }
    };
    Crop2.prototype.cropEvent = function(transitionArgs, obj, object) {
      var parent = this.parent;
      var splitWords;
      if (!transitionArgs.cancel) {
        splitWords = parent.activeObj.shape ? parent.activeObj.shape.split("-") : [];
        if (!parent.disabled && parent.activeObj.horTopLine && (parent.currObjType.isCustomCrop || splitWords.length > 0 && splitWords[0] === "crop")) {
          obj.isCrop = true;
          var prevCropObj = extend({}, parent.cropObj, {}, true);
          var prevObj = extend({}, this.prevCropCurrObj, {}, true);
          if (transitionArgs.preventScaling) {
            this.isPreventScaling = true;
          } else {
            this.isPreventScaling = false;
          }
          this.cropImg();
          if (this.isPreventScaling) {
            parent.aspectWidth = parent.img.destWidth;
            parent.aspectHeight = parent.img.destHeight;
          }
          parent.notify("freehand-draw", { prop: "resetStraightenPoint" });
          parent.isCropTab = false;
          parent.transform.zoomFactor = 0;
          parent.setProperties({ zoomSettings: { zoomFactor: 1 } }, true);
          parent.notify("transform", {
            prop: "setPreviousZoomValue",
            onPropertyChange: false,
            value: { previousZoomValue: parent.zoomSettings.zoomFactor }
          });
          if (!Browser.isDevice) {
            this.updateUndoRedoColl(prevObj, prevCropObj, object);
          }
          parent.notify("transform", {
            prop: "setCropDimension",
            onPropertyChange: false,
            value: { width: parent.cropObj.destPoints.width, height: parent.cropObj.destPoints.height }
          });
          var aspectIcon = parent.element.querySelector("#" + parent.element.id + "_aspectratio");
          var nonAspectIcon = parent.element.querySelector("#" + parent.element.id + "_nonaspectratio");
          parent.notify("draw", { prop: "render-image", value: { isMouseWheel: false } });
          if (!object["isCropToolbar"] && (isNullOrUndefined(aspectIcon) && isNullOrUndefined(nonAspectIcon))) {
            parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
              type: "main",
              isApplyBtn: false,
              isCropping: false,
              isZooming: null,
              cType: null
            } });
          }
          this.resizeWrapper();
          if (Browser.isDevice) {
            this.updateUndoRedoColl(prevObj, prevCropObj, object);
          }
        }
      }
    };
    Crop2.prototype.updateUndoRedoColl = function(prevObj, prevCropObj, object) {
      var parent = this.parent;
      var currSelPtObj = { prevCurrSelectionPoint: parent.prevCurrSelectionPoint };
      prevObj.currSelectionPoint = extend({}, currSelPtObj["prevCurrSelectionPoint"], {}, true);
      parent.notify("undo-redo", {
        prop: "updateUndoRedoColl",
        onPropertyChange: false,
        value: {
          operation: "crop",
          previousObj: prevObj,
          previousObjColl: prevObj.objColl,
          previousPointColl: prevObj.pointColl,
          previousSelPointColl: prevObj.selPointColl,
          previousCropObj: prevCropObj,
          previousText: null,
          currentText: null,
          previousFilter: null,
          isCircleCrop: parent.isCircleCrop
        }
      });
      if (!object["isCropToolbar"]) {
        parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
      }
    };
    Crop2.prototype.resizeWrapper = function() {
      var parent = this.parent;
      if (Browser.isDevice) {
        var elem = parent.element;
        var ctxToolbar = elem.querySelector("#" + elem.id + "_contextualToolbarArea");
        if (ctxToolbar && ctxToolbar.style.position === "" && !this.isTransformCrop) {
          ctxToolbar.style.position = "absolute";
          parent.isStraightening = false;
          parent.update();
          parent.notify("filter", { prop: "setAdjustmentValue", value: { adjustmentValue: parent.canvasFilter } });
        }
      }
    };
    Crop2.prototype.calcRatio = function(obj, dimension) {
      var parent = this.parent;
      var degree = parent.transform.degree;
      var _a = parent.img, destWidth = _a.destWidth, destHeight = _a.destHeight;
      var _b = dimension || parent.baseImgCanvas, width = _b.width, height = _b.height;
      var widthRatio = degree === 0 || degree % 180 === 0 ? width / destWidth : height / destWidth;
      var heightRatio = degree === 0 || degree % 180 === 0 ? height / destHeight : width / destHeight;
      if (obj) {
        obj["width"] = widthRatio;
        obj["height"] = heightRatio;
      }
      return { width: widthRatio, height: heightRatio };
    };
    Crop2.prototype.getCurrFlipState = function(panObj) {
      var parent = this.parent;
      var obj = { panRegion: "" };
      var object = { collection: parent.rotateFlipColl };
      parent.notify("shape", {
        prop: "alignRotateFlipColl",
        onPropertyChange: false,
        value: { collection: parent.rotateFlipColl, isRotateFlipCollection: true, obj: object }
      });
      parent.rotateFlipColl = object["collection"];
      for (var i = 0, len = parent.rotateFlipColl.length; i < len; i++) {
        parent.notify("transform", {
          prop: "setCurrPanRegion",
          onPropertyChange: false,
          value: { region: obj["panRegion"], type: parent.rotateFlipColl[i], obj }
        });
      }
      if (panObj) {
        panObj["panRegion"] = obj["panRegion"];
      }
      return obj["panRegion"];
    };
    return Crop2;
  }()
);
var elementRect;
var popupRect;
var element;
var parentDocument$1;
var fixedParent = false;
function calculateRelativeBasedPosition(anchor, element2) {
  var fixedElement = false;
  var anchorPos = { left: 0, top: 0 };
  var tempAnchor = anchor;
  if (!anchor || !element2) {
    return anchorPos;
  }
  if (isNullOrUndefined(element2.offsetParent) && element2.style.position === "fixed") {
    fixedElement = true;
  }
  while ((element2.offsetParent || fixedElement) && anchor && element2.offsetParent !== anchor) {
    anchorPos.left += anchor.offsetLeft;
    anchorPos.top += anchor.offsetTop;
    anchor = anchor.offsetParent;
  }
  anchor = tempAnchor;
  while ((element2.offsetParent || fixedElement) && anchor && element2.offsetParent !== anchor) {
    anchorPos.left -= anchor.scrollLeft;
    anchorPos.top -= anchor.scrollTop;
    anchor = anchor.parentElement;
  }
  return anchorPos;
}
function calculatePosition(currentElement, positionX, positionY, parentElement, targetValues) {
  popupRect = undefined;
  popupRect = targetValues;
  fixedParent = parentElement ? true : false;
  if (!currentElement) {
    return { left: 0, top: 0 };
  }
  if (!positionX) {
    positionX = "left";
  }
  if (!positionY) {
    positionY = "top";
  }
  parentDocument$1 = currentElement.ownerDocument;
  element = currentElement;
  var pos = { left: 0, top: 0 };
  return updatePosition(positionX.toLowerCase(), positionY.toLowerCase(), pos);
}
function setPosx(value, pos) {
  pos.left = value;
}
function setPosy(value, pos) {
  pos.top = value;
}
function updatePosition(posX, posY, pos) {
  elementRect = element.getBoundingClientRect();
  switch (posY + posX) {
    case "topcenter":
      setPosx(getElementHCenter(), pos);
      setPosy(getElementTop(), pos);
      break;
    case "topright":
      setPosx(getElementRight(), pos);
      setPosy(getElementTop(), pos);
      break;
    case "centercenter":
      setPosx(getElementHCenter(), pos);
      setPosy(getElementVCenter(), pos);
      break;
    case "centerright":
      setPosx(getElementRight(), pos);
      setPosy(getElementVCenter(), pos);
      break;
    case "centerleft":
      setPosx(getElementLeft(), pos);
      setPosy(getElementVCenter(), pos);
      break;
    case "bottomcenter":
      setPosx(getElementHCenter(), pos);
      setPosy(getElementBottom(), pos);
      break;
    case "bottomright":
      setPosx(getElementRight(), pos);
      setPosy(getElementBottom(), pos);
      break;
    case "bottomleft":
      setPosx(getElementLeft(), pos);
      setPosy(getElementBottom(), pos);
      break;
    default:
    case "topleft":
      setPosx(getElementLeft(), pos);
      setPosy(getElementTop(), pos);
      break;
  }
  element = null;
  return pos;
}
function getBodyScrollTop$1() {
  return parentDocument$1.documentElement.scrollTop || parentDocument$1.body.scrollTop;
}
function getBodyScrollLeft$1() {
  return parentDocument$1.documentElement.scrollLeft || parentDocument$1.body.scrollLeft;
}
function getElementBottom() {
  return fixedParent ? elementRect.bottom : elementRect.bottom + getBodyScrollTop$1();
}
function getElementVCenter() {
  return getElementTop() + elementRect.height / 2;
}
function getElementTop() {
  return fixedParent ? elementRect.top : elementRect.top + getBodyScrollTop$1();
}
function getElementLeft() {
  return elementRect.left + getBodyScrollLeft$1();
}
function getElementRight() {
  var popupWidth = element && ((element.classList.contains("e-date-wrapper") || element.classList.contains("e-datetime-wrapper")) && element.classList.contains("e-rtl") || element.classList.contains("e-ddl") && element.classList.contains("e-rtl") || element.classList.contains("e-date-range-wrapper")) ? popupRect ? popupRect.width : 0 : popupRect && elementRect.width >= popupRect.width ? popupRect.width : 0;
  if (element && element.classList.contains("e-rtl") && element.classList.contains("e-multiselect")) {
    popupWidth = popupRect.width;
  }
  return elementRect.right + getBodyScrollLeft$1() - popupWidth;
}
function getElementHCenter() {
  return getElementLeft() + elementRect.width / 2;
}
var parentDocument;
var targetContainer;
function fit(element2, viewPortElement, axis, position) {
  if (viewPortElement === undefined) {
    viewPortElement = null;
  }
  if (axis === undefined) {
    axis = { X: false, Y: false };
  }
  if (!axis.Y && !axis.X) {
    return { left: 0, top: 0 };
  }
  var elemData = element2.getBoundingClientRect();
  targetContainer = viewPortElement;
  parentDocument = element2.ownerDocument;
  if (!position) {
    position = calculatePosition(element2, "left", "top");
  }
  if (axis.X) {
    var containerWidth = targetContainer ? getTargetContainerWidth() : getViewPortWidth();
    var containerLeft = ContainerLeft();
    var containerRight = ContainerRight();
    var overLeft = containerLeft - position.left;
    var overRight = position.left + elemData.width - containerRight;
    if (elemData.width > containerWidth) {
      if (overLeft > 0 && overRight <= 0) {
        position.left = containerRight - elemData.width;
      } else if (overRight > 0 && overLeft <= 0) {
        position.left = containerLeft;
      } else {
        position.left = overLeft > overRight ? containerRight - elemData.width : containerLeft;
      }
    } else if (overLeft > 0) {
      position.left += overLeft;
    } else if (overRight > 0) {
      position.left -= overRight;
    }
  }
  if (axis.Y) {
    var containerHeight = targetContainer ? getTargetContainerHeight() : getViewPortHeight();
    var containerTop = ContainerTop();
    var containerBottom = ContainerBottom();
    var overTop = containerTop - position.top;
    var overBottom = position.top + elemData.height - containerBottom;
    if (elemData.height > containerHeight) {
      if (overTop > 0 && overBottom <= 0) {
        position.top = containerBottom - elemData.height;
      } else if (overBottom > 0 && overTop <= 0) {
        position.top = containerTop;
      } else {
        position.top = overTop > overBottom ? containerBottom - elemData.height : containerTop;
      }
    } else if (overTop > 0) {
      position.top += overTop;
    } else if (overBottom > 0) {
      position.top -= overBottom;
    }
  }
  return position;
}
function isCollide(element2, viewPortElement, x, y) {
  if (viewPortElement === undefined) {
    viewPortElement = null;
  }
  var elemOffset = calculatePosition(element2, "left", "top");
  if (x) {
    elemOffset.left = x;
  }
  if (y) {
    elemOffset.top = y;
  }
  var data = [];
  targetContainer = viewPortElement;
  parentDocument = element2.ownerDocument;
  var elementRect2 = element2.getBoundingClientRect();
  var top = elemOffset.top;
  var left = elemOffset.left;
  var right = elemOffset.left + elementRect2.width;
  var bottom = elemOffset.top + elementRect2.height;
  var yAxis = topCollideCheck(top, bottom);
  var xAxis = leftCollideCheck(left, right);
  if (yAxis.topSide) {
    data.push("top");
  }
  if (xAxis.rightSide) {
    data.push("right");
  }
  if (xAxis.leftSide) {
    data.push("left");
  }
  if (yAxis.bottomSide) {
    data.push("bottom");
  }
  return data;
}
function flip(element2, target, offsetX, offsetY, positionX, positionY, viewPortElement, axis, fixedParent2) {
  if (viewPortElement === undefined) {
    viewPortElement = null;
  }
  if (axis === undefined) {
    axis = { X: true, Y: true };
  }
  if (!target || !element2 || !positionX || !positionY || !axis.X && !axis.Y) {
    return;
  }
  var tEdge = {
    TL: null,
    TR: null,
    BL: null,
    BR: null
  }, eEdge = {
    TL: null,
    TR: null,
    BL: null,
    BR: null
    /* eslint-enable */
  };
  var elementRect2;
  if ((undefined).getComputedStyle(element2).display === "none") {
    var oldVisibility = element2.style.visibility;
    element2.style.visibility = "hidden";
    element2.style.display = "block";
    elementRect2 = element2.getBoundingClientRect();
    element2.style.removeProperty("display");
    element2.style.visibility = oldVisibility;
  } else {
    elementRect2 = element2.getBoundingClientRect();
  }
  var pos = {
    posX: positionX,
    posY: positionY,
    offsetX,
    offsetY,
    position: { left: 0, top: 0 }
  };
  targetContainer = viewPortElement;
  parentDocument = target.ownerDocument;
  updateElementData(target, tEdge, pos, fixedParent2, elementRect2);
  setPosition(eEdge, pos, elementRect2);
  if (axis.X) {
    leftFlip(target, eEdge, tEdge, pos, elementRect2, true);
  }
  if (axis.Y && tEdge.TL.top > -1) {
    topFlip(target, eEdge, tEdge, pos, elementRect2, true);
  }
  setPopup(element2, pos, elementRect2);
}
function setPopup(element2, pos, elementRect2) {
  var left = 0;
  var top = 0;
  if (element2.offsetParent != null && (getComputedStyle(element2.offsetParent).position === "absolute" || getComputedStyle(element2.offsetParent).position === "relative")) {
    var data = calculatePosition(element2.offsetParent, "left", "top", false, elementRect2);
    left = data.left;
    top = data.top;
  }
  var scaleX = 1;
  var scaleY = 1;
  var tranformElement = getTransformElement(element2);
  if (tranformElement) {
    var transformStyle = getComputedStyle(tranformElement).transform;
    if (transformStyle !== "none") {
      var matrix = new DOMMatrix(transformStyle);
      scaleX = matrix.a;
      scaleY = matrix.d;
    }
    var zoomStyle = getComputedStyle(tranformElement).zoom;
    if (zoomStyle !== "none") {
      var bodyZoom = getZoomValue((undefined).body);
      scaleX = bodyZoom * scaleX;
      scaleY = bodyZoom * scaleY;
    }
  }
  element2.style.top = pos.position.top / scaleY + pos.offsetY - top / scaleY + "px";
  element2.style.left = pos.position.left / scaleX + pos.offsetX - left / scaleX + "px";
}
function getZoomValue(element2) {
  var zoomValue = getComputedStyle(element2).zoom;
  return parseFloat(zoomValue) || 1;
}
function getTransformElement(element2) {
  while (element2) {
    var transform = (undefined).getComputedStyle(element2).transform;
    var zoom = getZoomValue((undefined).body);
    if (transform && transform !== "none" || zoom && zoom !== 1) {
      return element2;
    }
    if (element2 === (undefined).body) {
      return null;
    }
    element2 = element2.offsetParent || element2.parentElement;
  }
  return null;
}
function updateElementData(target, edge, pos, fixedParent2, elementRect2) {
  pos.position = calculatePosition(target, pos.posX, pos.posY, fixedParent2, elementRect2);
  edge.TL = calculatePosition(target, "left", "top", fixedParent2, elementRect2);
  edge.TR = calculatePosition(target, "right", "top", fixedParent2, elementRect2);
  edge.BR = calculatePosition(target, "left", "bottom", fixedParent2, elementRect2);
  edge.BL = calculatePosition(target, "right", "bottom", fixedParent2, elementRect2);
}
function setPosition(eStatus, pos, elementRect2) {
  eStatus.TL = { top: pos.position.top + pos.offsetY, left: pos.position.left + pos.offsetX };
  eStatus.TR = { top: eStatus.TL.top, left: eStatus.TL.left + elementRect2.width };
  eStatus.BL = {
    top: eStatus.TL.top + elementRect2.height,
    left: eStatus.TL.left
  };
  eStatus.BR = {
    top: eStatus.TL.top + elementRect2.height,
    left: eStatus.TL.left + elementRect2.width
  };
}
function leftCollideCheck(left, right) {
  var leftSide = false, rightSide = false;
  if (left - getBodyScrollLeft() < ContainerLeft()) {
    leftSide = true;
  }
  if (right > ContainerRight()) {
    rightSide = true;
  }
  return { leftSide, rightSide };
}
function leftFlip(target, edge, tEdge, pos, elementRect2, deepCheck) {
  var collideSide = leftCollideCheck(edge.TL.left, edge.TR.left);
  if (tEdge.TL.left - getBodyScrollLeft() <= ContainerLeft()) {
    collideSide.leftSide = false;
  }
  if (tEdge.TR.left > ContainerRight()) {
    collideSide.rightSide = false;
  }
  if (collideSide.leftSide && !collideSide.rightSide || !collideSide.leftSide && collideSide.rightSide) {
    if (pos.posX === "right") {
      pos.posX = "left";
    } else {
      pos.posX = "right";
    }
    pos.offsetX = pos.offsetX + elementRect2.width;
    pos.offsetX = -1 * pos.offsetX;
    pos.position = calculatePosition(target, pos.posX, pos.posY, false);
    setPosition(edge, pos, elementRect2);
    if (deepCheck) {
      leftFlip(target, edge, tEdge, pos, elementRect2, false);
    }
  }
}
function topFlip(target, edge, tEdge, pos, elementRect2, deepCheck) {
  var collideSide = topCollideCheck(edge.TL.top, edge.BL.top);
  if (tEdge.TL.top - getBodyScrollTop() <= ContainerTop()) {
    collideSide.topSide = false;
  }
  if (tEdge.BL.top >= ContainerBottom() && target.getBoundingClientRect().bottom < (undefined).innerHeight) {
    collideSide.bottomSide = false;
  }
  if (collideSide.topSide && !collideSide.bottomSide || !collideSide.topSide && collideSide.bottomSide) {
    if (pos.posY === "top") {
      pos.posY = "bottom";
    } else {
      pos.posY = "top";
    }
    pos.offsetY = pos.offsetY + elementRect2.height;
    pos.offsetY = -1 * pos.offsetY;
    pos.position = calculatePosition(target, pos.posX, pos.posY, false, elementRect2);
    setPosition(edge, pos, elementRect2);
    if (deepCheck) {
      topFlip(target, edge, tEdge, pos, elementRect2, false);
    }
  }
}
function topCollideCheck(top, bottom) {
  var topSide = false, bottomSide = false;
  if (top - getBodyScrollTop() < ContainerTop()) {
    topSide = true;
  }
  if (bottom > ContainerBottom()) {
    bottomSide = true;
  }
  return { topSide, bottomSide };
}
function getTargetContainerWidth() {
  return targetContainer.getBoundingClientRect().width;
}
function getTargetContainerHeight() {
  return targetContainer.getBoundingClientRect().height;
}
function getTargetContainerLeft() {
  return targetContainer.getBoundingClientRect().left;
}
function getTargetContainerTop() {
  return targetContainer.getBoundingClientRect().top;
}
function ContainerTop() {
  if (targetContainer) {
    return getTargetContainerTop();
  }
  return 0;
}
function ContainerLeft() {
  if (targetContainer) {
    return getTargetContainerLeft();
  }
  return 0;
}
function ContainerRight() {
  if (targetContainer) {
    return getBodyScrollLeft() + getTargetContainerLeft() + getTargetContainerWidth();
  }
  return getBodyScrollLeft() + getViewPortWidth();
}
function ContainerBottom() {
  if (targetContainer) {
    return getBodyScrollTop() + getTargetContainerTop() + getTargetContainerHeight();
  }
  return getBodyScrollTop() + getViewPortHeight();
}
function getBodyScrollTop() {
  return parentDocument.documentElement.scrollTop || parentDocument.body.scrollTop;
}
function getBodyScrollLeft() {
  return parentDocument.documentElement.scrollLeft || parentDocument.body.scrollLeft;
}
function getViewPortHeight() {
  return (undefined).innerHeight;
}
function getViewPortWidth() {
  var windowWidth = (undefined).innerWidth;
  var documentReact = (undefined).documentElement.getBoundingClientRect();
  var offsetWidth = isNullOrUndefined((undefined).documentElement) ? 0 : documentReact.width;
  return windowWidth - (windowWidth - offsetWidth);
}
function destroy() {
  targetContainer = null;
  parentDocument = null;
}
var __extends$f = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate$f = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var PositionData = (
  /** @class */
  function(_super) {
    __extends$f(PositionData2, _super);
    function PositionData2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$f([
      Property("left")
    ], PositionData2.prototype, "X", undefined);
    __decorate$f([
      Property("top")
    ], PositionData2.prototype, "Y", undefined);
    return PositionData2;
  }(ChildProperty)
);
var CLASSNAMES$1 = {
  ROOT: "e-popup",
  RTL: "e-rtl",
  OPEN: "e-popup-open",
  CLOSE: "e-popup-close"
};
var Popup = (
  /** @class */
  function(_super) {
    __extends$f(Popup2, _super);
    function Popup2(element2, options) {
      return _super.call(this, options, element2) || this;
    }
    Popup2.prototype.onPropertyChanged = function(newProp, oldProp) {
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "width":
            setStyleAttribute(this.element, { "width": formatUnit(newProp.width) });
            break;
          case "height":
            setStyleAttribute(this.element, { "height": formatUnit(newProp.height) });
            break;
          case "zIndex":
            setStyleAttribute(this.element, { "zIndex": newProp.zIndex });
            break;
          case "enableRtl":
            this.setEnableRtl();
            break;
          case "position":
          case "relateTo":
            this.refreshPosition();
            break;
          case "offsetX": {
            var x = newProp.offsetX - oldProp.offsetX;
            this.element.style.left = (parseInt(this.element.style.left, 10) + x).toString() + "px";
            break;
          }
          case "offsetY": {
            var y = newProp.offsetY - oldProp.offsetY;
            this.element.style.top = (parseInt(this.element.style.top, 10) + y).toString() + "px";
            break;
          }
          case "content":
            this.setContent();
            break;
          case "actionOnScroll":
            if (newProp.actionOnScroll !== "none") {
              this.wireScrollEvents();
            } else {
              this.unwireScrollEvents();
            }
            break;
        }
      }
    };
    Popup2.prototype.getModuleName = function() {
      return "popup";
    };
    Popup2.prototype.resolveCollision = function() {
      this.checkCollision();
    };
    Popup2.prototype.getPersistData = function() {
      return this.addOnPersist([]);
    };
    Popup2.prototype.destroy = function() {
      if (this.element.classList.contains("e-popup-open")) {
        this.unwireEvents();
      }
      this.element.classList.remove(CLASSNAMES$1.ROOT, CLASSNAMES$1.RTL, CLASSNAMES$1.OPEN, CLASSNAMES$1.CLOSE);
      this.content = null;
      this.relateTo = null;
      destroy();
      _super.prototype.destroy.call(this);
    };
    Popup2.prototype.render = function() {
      this.element.classList.add(CLASSNAMES$1.ROOT);
      var styles = {};
      if (this.zIndex !== 1e3) {
        styles.zIndex = this.zIndex;
      }
      if (this.width !== "auto") {
        styles.width = formatUnit(this.width);
      }
      if (this.height !== "auto") {
        styles.height = formatUnit(this.height);
      }
      setStyleAttribute(this.element, styles);
      this.fixedParent = false;
      this.setEnableRtl();
      this.setContent();
    };
    Popup2.prototype.wireEvents = function() {
      if (Browser.isDevice) {
        EventHandler.add(undefined, "orientationchange", this.orientationOnChange, this);
      }
      if (this.actionOnScroll !== "none") {
        this.wireScrollEvents();
      }
    };
    Popup2.prototype.wireScrollEvents = function() {
      if (this.getRelateToElement()) {
        for (var _i = 0, _a = this.getScrollableParent(this.getRelateToElement()); _i < _a.length; _i++) {
          var parent_1 = _a[_i];
          EventHandler.add(parent_1, "scroll", this.scrollRefresh, this);
        }
      }
    };
    Popup2.prototype.unwireEvents = function() {
      if (Browser.isDevice) {
        EventHandler.remove(undefined, "orientationchange", this.orientationOnChange);
      }
      if (this.actionOnScroll !== "none") {
        this.unwireScrollEvents();
      }
    };
    Popup2.prototype.unwireScrollEvents = function() {
      if (this.getRelateToElement()) {
        for (var _i = 0, _a = this.getScrollableParent(this.getRelateToElement()); _i < _a.length; _i++) {
          var parent_2 = _a[_i];
          EventHandler.remove(parent_2, "scroll", this.scrollRefresh);
        }
      }
    };
    Popup2.prototype.getRelateToElement = function() {
      var relateToElement = this.relateTo === "" || isNullOrUndefined(this.relateTo) ? (undefined).body : this.relateTo;
      this.setProperties({ relateTo: relateToElement }, true);
      return typeof this.relateTo === "string" ? (undefined).querySelector(this.relateTo) : this.relateTo;
    };
    Popup2.prototype.scrollRefresh = function(e) {
      if (this.actionOnScroll === "reposition") {
        if (!isNullOrUndefined(this.element) && !(this.element.offsetParent === e.target || this.element.offsetParent && this.element.offsetParent.tagName === "BODY" && e.target.parentElement == null)) {
          this.refreshPosition();
        }
      } else if (this.actionOnScroll === "hide") {
        this.hide();
      }
      if (this.actionOnScroll !== "none") {
        if (this.getRelateToElement()) {
          var targetVisible = this.isElementOnViewport(this.getRelateToElement(), e.target);
          if (!targetVisible && !this.targetInvisibleStatus) {
            this.trigger("targetExitViewport");
            this.targetInvisibleStatus = true;
          } else if (targetVisible) {
            this.targetInvisibleStatus = false;
          }
        }
      }
    };
    Popup2.prototype.isElementOnViewport = function(relateToElement, scrollElement) {
      var scrollParents = this.getScrollableParent(relateToElement);
      for (var parent_3 = 0; parent_3 < scrollParents.length; parent_3++) {
        if (this.isElementVisible(relateToElement, scrollParents[parent_3])) {
          continue;
        } else {
          return false;
        }
      }
      return true;
    };
    Popup2.prototype.isElementVisible = function(relateToElement, scrollElement) {
      var rect = this.checkGetBoundingClientRect(relateToElement);
      if (!rect.height || !rect.width) {
        return false;
      }
      if (!isNullOrUndefined(this.checkGetBoundingClientRect(scrollElement))) {
        var parent_4 = scrollElement.getBoundingClientRect();
        return !(rect.bottom < parent_4.top) && (!(rect.bottom > parent_4.bottom) && (!(rect.right > parent_4.right) && !(rect.left < parent_4.left)));
      } else {
        var win = undefined;
        var windowView = {
          top: win.scrollY,
          left: win.scrollX,
          right: win.scrollX + win.outerWidth,
          bottom: win.scrollY + win.outerHeight
        };
        var off = calculatePosition(relateToElement);
        var ele = {
          top: off.top,
          left: off.left,
          right: off.left + rect.width,
          bottom: off.top + rect.height
        };
        var elementView = {
          top: windowView.bottom - ele.top,
          left: windowView.right - ele.left,
          bottom: ele.bottom - windowView.top,
          right: ele.right - windowView.left
        };
        return elementView.top > 0 && elementView.left > 0 && elementView.right > 0 && elementView.bottom > 0;
      }
    };
    Popup2.prototype.preRender = function() {
    };
    Popup2.prototype.setEnableRtl = function() {
      this.reposition();
      if (this.enableRtl) {
        this.element.classList.add(CLASSNAMES$1.RTL);
      } else {
        this.element.classList.remove(CLASSNAMES$1.RTL);
      }
    };
    Popup2.prototype.setContent = function() {
      if (!isNullOrUndefined(this.content)) {
        this.element.innerHTML = "";
        if (typeof this.content === "string") {
          this.element.textContent = this.content;
        } else {
          var relateToElem = this.getRelateToElement();
          var props2 = this.content.props;
          if (!relateToElem.classList.contains("e-dropdown-btn") || isNullOrUndefined(props2)) {
            this.element.appendChild(this.content);
          }
        }
      }
    };
    Popup2.prototype.orientationOnChange = function() {
      var _this = this;
      setTimeout(function() {
        _this.refreshPosition();
      }, 200);
    };
    Popup2.prototype.refreshPosition = function(target, collision) {
      if (!isNullOrUndefined(target)) {
        this.checkFixedParent(target);
      }
      this.reposition();
      if (!collision) {
        this.checkCollision();
      }
    };
    Popup2.prototype.reposition = function() {
      var pos;
      var position;
      var relateToElement = this.getRelateToElement();
      if (typeof this.position.X === "number" && typeof this.position.Y === "number") {
        pos = { left: this.position.X, top: this.position.Y };
      } else if (typeof this.position.X === "string" && typeof this.position.Y === "number" || typeof this.position.X === "number" && typeof this.position.Y === "string") {
        var parentDisplay = undefined;
        var display = this.element.style.display;
        this.element.style.display = "block";
        if (this.element.classList.contains("e-dlg-modal")) {
          parentDisplay = this.element.parentElement.style.display;
          this.element.parentElement.style.display = "block";
        }
        position = this.getAnchorPosition(relateToElement, this.element, this.position, this.offsetX, this.offsetY);
        if (typeof this.position.X === "string") {
          pos = { left: position.left, top: this.position.Y };
        } else {
          pos = { left: this.position.X, top: position.top };
        }
        this.element.style.display = display;
        if (this.element.classList.contains("e-dlg-modal")) {
          this.element.parentElement.style.display = parentDisplay;
        }
      } else if (relateToElement) {
        var height = this.element.clientHeight;
        var display = this.element.style.display;
        this.element.style.display = "block";
        pos = this.getAnchorPosition(relateToElement, this.element, this.position, this.offsetX, this.offsetY, height);
        this.element.style.display = display;
      } else {
        pos = { left: 0, top: 0 };
      }
      if (!isNullOrUndefined(pos)) {
        this.element.style.left = pos.left + "px";
        this.element.style.top = pos.top + "px";
      }
    };
    Popup2.prototype.checkGetBoundingClientRect = function(ele) {
      var eleRect;
      try {
        eleRect = ele.getBoundingClientRect();
        return eleRect;
      } catch (error) {
        return null;
      }
    };
    Popup2.prototype.getAnchorPosition = function(anchorEle, ele, position, offsetX, offsetY, height) {
      if (height === undefined) {
        height = 0;
      }
      var eleRect = this.checkGetBoundingClientRect(ele);
      var anchorRect = this.checkGetBoundingClientRect(anchorEle);
      if (isNullOrUndefined(eleRect) || isNullOrUndefined(anchorRect)) {
        return null;
      }
      var anchor = anchorEle;
      var anchorPos = { left: 0, top: 0 };
      if (ele.offsetParent && ele.offsetParent.tagName === "BODY" && anchorEle.tagName === "BODY") {
        anchorPos = calculatePosition(anchorEle);
      } else {
        if (ele.classList.contains("e-dlg-modal") && anchor.tagName !== "BODY") {
          ele = ele.parentElement;
        }
        anchorPos = calculateRelativeBasedPosition(anchor, ele);
      }
      switch (position.X) {
        default:
        case "left":
          break;
        case "center":
          if (ele.classList.contains("e-dlg-modal") && anchor.tagName === "BODY" && this.targetType === "container") {
            anchorPos.left += (undefined).innerWidth / 2 - eleRect.width / 2;
          } else if (this.targetType === "container") {
            anchorPos.left += anchorRect.width / 2 - eleRect.width / 2;
          } else {
            anchorPos.left += anchorRect.width / 2;
          }
          break;
        case "right":
          if (ele.classList.contains("e-dlg-modal") && anchor.tagName === "BODY" && this.targetType === "container") {
            anchorPos.left += (undefined).innerWidth - eleRect.width;
          } else if (this.targetType === "container") {
            var scaleX = 1;
            var tranformElement = getTransformElement(ele);
            if (tranformElement) {
              var transformStyle = getComputedStyle(tranformElement).transform;
              if (transformStyle !== "none") {
                var matrix = new DOMMatrix(transformStyle);
                scaleX = matrix.a;
              }
              var zoomStyle = getComputedStyle(tranformElement).zoom;
              if (zoomStyle !== "none") {
                var bodyZoom = getZoomValue((undefined).body);
                scaleX = bodyZoom * scaleX;
              }
            }
            anchorPos.left += (anchorRect.width - eleRect.width) / scaleX;
          } else {
            anchorPos.left += anchorRect.width;
          }
          break;
      }
      switch (position.Y) {
        default:
        case "top":
          break;
        case "center":
          if (ele.classList.contains("e-dlg-modal") && anchor.tagName === "BODY" && this.targetType === "container") {
            anchorPos.top += (undefined).innerHeight / 2 - eleRect.height / 2;
          } else if (this.targetType === "container") {
            anchorPos.top += anchorRect.height / 2 - eleRect.height / 2;
          } else {
            anchorPos.top += anchorRect.height / 2;
          }
          break;
        case "bottom":
          if (ele.classList.contains("e-dlg-modal") && anchor.tagName === "BODY" && this.targetType === "container") {
            anchorPos.top += (undefined).innerHeight - eleRect.height;
          } else if (this.targetType === "container" && !ele.classList.contains("e-dialog")) {
            anchorPos.top += anchorRect.height - eleRect.height;
          } else if (this.targetType === "container" && ele.classList.contains("e-dialog")) {
            anchorPos.top += anchorRect.height - height;
          } else {
            anchorPos.top += anchorRect.height;
          }
          break;
      }
      anchorPos.left += offsetX;
      anchorPos.top += offsetY;
      return anchorPos;
    };
    Popup2.prototype.callFlip = function(param) {
      var relateToElement = this.getRelateToElement();
      flip(this.element, relateToElement, this.offsetX, this.offsetY, this.position.X, this.position.Y, this.viewPortElement, param, this.fixedParent);
    };
    Popup2.prototype.callFit = function(param) {
      if (isCollide(this.element, this.viewPortElement).length !== 0) {
        if (isNullOrUndefined(this.viewPortElement)) {
          var data = fit(this.element, this.viewPortElement, param);
          if (param.X) {
            this.element.style.left = data.left + "px";
          }
          if (param.Y) {
            this.element.style.top = data.top + "px";
          }
        } else {
          var elementRect2 = this.checkGetBoundingClientRect(this.element);
          var viewPortRect = this.checkGetBoundingClientRect(this.viewPortElement);
          if (isNullOrUndefined(elementRect2) || isNullOrUndefined(viewPortRect)) {
            return null;
          }
          if (param && param.Y === true) {
            if (viewPortRect.top > elementRect2.top) {
              this.element.style.top = "0px";
            } else if (viewPortRect.bottom < elementRect2.bottom) {
              this.element.style.top = parseInt(this.element.style.top, 10) - (elementRect2.bottom - viewPortRect.bottom) + "px";
            }
          }
          if (param && param.X === true) {
            if (viewPortRect.right < elementRect2.right) {
              this.element.style.left = parseInt(this.element.style.left, 10) - (elementRect2.right - viewPortRect.right) + "px";
            } else if (viewPortRect.left > elementRect2.left) {
              this.element.style.left = parseInt(this.element.style.left, 10) + (viewPortRect.left - elementRect2.left) + "px";
            }
          }
        }
      }
    };
    Popup2.prototype.checkCollision = function() {
      var horz = this.collision.X;
      var vert = this.collision.Y;
      if (horz === "none" && vert === "none") {
        return;
      }
      if (horz === "flip" && vert === "flip") {
        this.callFlip({ X: true, Y: true });
      } else if (horz === "fit" && vert === "fit") {
        this.callFit({ X: true, Y: true });
      } else {
        if (horz === "flip") {
          this.callFlip({ X: true, Y: false });
        } else if (vert === "flip") {
          this.callFlip({ Y: true, X: false });
        }
        if (horz === "fit") {
          this.callFit({ X: true, Y: false });
        } else if (vert === "fit") {
          this.callFit({ X: false, Y: true });
        }
      }
    };
    Popup2.prototype.show = function(animationOptions, relativeElement) {
      var _this = this;
      this.wireEvents();
      if (this.zIndex === 1e3 || !isNullOrUndefined(relativeElement)) {
        var zIndexElement = isNullOrUndefined(relativeElement) ? this.element : relativeElement;
        this.zIndex = getZindexPartial(zIndexElement);
        setStyleAttribute(this.element, { "zIndex": this.zIndex });
      }
      animationOptions = !isNullOrUndefined(animationOptions) && typeof animationOptions === "object" ? animationOptions : this.showAnimation;
      if (this.collision.X !== "none" || this.collision.Y !== "none") {
        removeClass([this.element], CLASSNAMES$1.CLOSE);
        addClass([this.element], CLASSNAMES$1.OPEN);
        this.checkCollision();
        removeClass([this.element], CLASSNAMES$1.OPEN);
        addClass([this.element], CLASSNAMES$1.CLOSE);
      }
      if (!isNullOrUndefined(animationOptions)) {
        animationOptions.begin = function() {
          if (!_this.isDestroyed) {
            removeClass([_this.element], CLASSNAMES$1.CLOSE);
            addClass([_this.element], CLASSNAMES$1.OPEN);
          }
        };
        animationOptions.end = function() {
          if (!_this.isDestroyed) {
            _this.trigger("open");
          }
        };
        new Animation$1(animationOptions).animate(this.element);
      } else {
        removeClass([this.element], CLASSNAMES$1.CLOSE);
        addClass([this.element], CLASSNAMES$1.OPEN);
        this.trigger("open");
      }
    };
    Popup2.prototype.hide = function(animationOptions) {
      var _this = this;
      animationOptions = !isNullOrUndefined(animationOptions) && typeof animationOptions === "object" ? animationOptions : this.hideAnimation;
      if (!isNullOrUndefined(animationOptions)) {
        animationOptions.end = function() {
          if (!_this.isDestroyed) {
            removeClass([_this.element], CLASSNAMES$1.OPEN);
            addClass([_this.element], CLASSNAMES$1.CLOSE);
            _this.trigger("close");
          }
        };
        new Animation$1(animationOptions).animate(this.element);
      } else {
        removeClass([this.element], CLASSNAMES$1.OPEN);
        addClass([this.element], CLASSNAMES$1.CLOSE);
        this.trigger("close");
      }
      this.unwireEvents();
    };
    Popup2.prototype.getScrollableParent = function(element2) {
      this.checkFixedParent(element2);
      return getScrollableParent(element2, this.fixedParent);
    };
    Popup2.prototype.checkFixedParent = function(element2) {
      var parent = element2.parentElement;
      while (parent && parent.tagName !== "HTML") {
        var parentStyle = getComputedStyle(parent);
        if ((parentStyle.position === "fixed" || parentStyle.position === "sticky") && !isNullOrUndefined(this.element) && this.element.offsetParent && this.element.offsetParent.tagName === "BODY" && getComputedStyle(this.element.offsetParent).overflow !== "hidden") {
          this.element.style.top = (undefined).scrollY > parseInt(this.element.style.top, 10) ? formatUnit((undefined).scrollY - parseInt(this.element.style.top, 10)) : formatUnit(parseInt(this.element.style.top, 10) - (undefined).scrollY);
          this.element.style.position = "fixed";
          this.fixedParent = true;
        }
        parent = parent.parentElement;
        if (!isNullOrUndefined(this.element) && isNullOrUndefined(this.element.offsetParent) && parentStyle.position === "fixed" && this.element.style.position === "fixed") {
          this.fixedParent = true;
        }
      }
    };
    __decorate$f([
      Property("auto")
    ], Popup2.prototype, "height", undefined);
    __decorate$f([
      Property("auto")
    ], Popup2.prototype, "width", undefined);
    __decorate$f([
      Property(null)
    ], Popup2.prototype, "content", undefined);
    __decorate$f([
      Property("container")
    ], Popup2.prototype, "targetType", undefined);
    __decorate$f([
      Property(null)
    ], Popup2.prototype, "viewPortElement", undefined);
    __decorate$f([
      Property({ X: "none", Y: "none" })
    ], Popup2.prototype, "collision", undefined);
    __decorate$f([
      Property("")
    ], Popup2.prototype, "relateTo", undefined);
    __decorate$f([
      Complex({}, PositionData)
    ], Popup2.prototype, "position", undefined);
    __decorate$f([
      Property(0)
    ], Popup2.prototype, "offsetX", undefined);
    __decorate$f([
      Property(0)
    ], Popup2.prototype, "offsetY", undefined);
    __decorate$f([
      Property(1e3)
    ], Popup2.prototype, "zIndex", undefined);
    __decorate$f([
      Property(false)
    ], Popup2.prototype, "enableRtl", undefined);
    __decorate$f([
      Property("reposition")
    ], Popup2.prototype, "actionOnScroll", undefined);
    __decorate$f([
      Property(null)
    ], Popup2.prototype, "showAnimation", undefined);
    __decorate$f([
      Property(null)
    ], Popup2.prototype, "hideAnimation", undefined);
    __decorate$f([
      Event()
    ], Popup2.prototype, "open", undefined);
    __decorate$f([
      Event()
    ], Popup2.prototype, "close", undefined);
    __decorate$f([
      Event()
    ], Popup2.prototype, "targetExitViewport", undefined);
    Popup2 = __decorate$f([
      NotifyPropertyChanges
    ], Popup2);
    return Popup2;
  }(Component)
);
function getScrollableParent(element2, fixedParent2) {
  var eleStyle = getComputedStyle(element2);
  var scrollParents = [];
  var overflowRegex = /(auto|scroll)/;
  var parent = element2.parentElement;
  while (parent && parent.tagName !== "HTML") {
    var parentStyle = getComputedStyle(parent);
    if (!(eleStyle.position === "absolute" && parentStyle.position === "static") && overflowRegex.test(parentStyle.overflow + parentStyle.overflowY + parentStyle.overflowX)) {
      scrollParents.push(parent);
    }
    parent = parent.parentElement;
  }
  if (!fixedParent2) {
    scrollParents.push(undefined);
  }
  return scrollParents;
}
function getZindexPartial(element2) {
  var parent = element2.parentElement;
  var parentZindex = [];
  while (parent) {
    if (parent.tagName !== "BODY") {
      var index = (undefined).defaultView.getComputedStyle(parent, null).getPropertyValue("z-index");
      var position = (undefined).defaultView.getComputedStyle(parent, null).getPropertyValue("position");
      if (index !== "auto" && position !== "static") {
        parentZindex.push(index);
      }
      parent = parent.parentElement;
    } else {
      break;
    }
  }
  var childrenZindex = [];
  for (var i = 0; i < (undefined).body.children.length; i++) {
    if (!element2.isEqualNode((undefined).body.children[i])) {
      var index = (undefined).defaultView.getComputedStyle((undefined).body.children[i], null).getPropertyValue("z-index");
      var position = (undefined).defaultView.getComputedStyle((undefined).body.children[i], null).getPropertyValue("position");
      if (index !== "auto" && position !== "static") {
        childrenZindex.push(index);
      }
    }
  }
  childrenZindex.push("999");
  var siblingsZindex = [];
  if (!isNullOrUndefined(element2.parentElement) && element2.parentElement.tagName !== "BODY") {
    var childNodes = [].slice.call(element2.parentElement.children);
    for (var i = 0; i < childNodes.length; i++) {
      if (!element2.isEqualNode(childNodes[i])) {
        var index = (undefined).defaultView.getComputedStyle(childNodes[i], null).getPropertyValue("z-index");
        var position = (undefined).defaultView.getComputedStyle(childNodes[i], null).getPropertyValue("position");
        if (index !== "auto" && position !== "static") {
          siblingsZindex.push(index);
        }
      }
    }
  }
  var finalValue = parentZindex.concat(childrenZindex, siblingsZindex);
  var currentZindexValue = Math.max.apply(Math, finalValue) + 1;
  return currentZindexValue > 2147483647 ? 2147483647 : currentZindexValue;
}
function wrapperInitialize(createElement2, tag, type, element2, WRAPPER, role) {
  var input = element2;
  if (element2.tagName === tag) {
    var ejInstance = getValue("ej2_instances", element2);
    input = createElement2("input", { attrs: { "type": type } });
    var props2 = ["change", "cssClass", "label", "labelPosition", "id"];
    for (var index = 0, len = element2.attributes.length; index < len; index++) {
      if (props2.indexOf(element2.attributes[index].nodeName) === -1) {
        input.setAttribute(element2.attributes[index].nodeName, element2.attributes[index].nodeValue);
      }
    }
    attributes(element2, { "class": WRAPPER });
    element2.appendChild(input);
    element2.classList.add(role);
    element2.classList.remove(role);
    setValue("ej2_instances", ejInstance, input);
    deleteObject(element2, "ej2_instances");
  }
  return input;
}
function getTextNode(element2) {
  var node;
  var childnode = element2.childNodes;
  for (var i = 0; i < childnode.length; i++) {
    node = childnode[i];
    if (node.nodeType === 3) {
      return node;
    }
  }
  return null;
}
function createCheckBox(createElement2, enableRipple, options) {
  if (enableRipple === undefined) {
    enableRipple = false;
  }
  if (options === undefined) {
    options = {};
  }
  var wrapper = createElement2("div", { className: "e-checkbox-wrapper e-css" });
  if (options.cssClass) {
    addClass([wrapper], options.cssClass.split(" "));
  }
  if (options.enableRtl) {
    wrapper.classList.add("e-rtl");
  }
  if (enableRipple) {
    var rippleSpan = createElement2("span", { className: "e-ripple-container" });
    rippleEffect(rippleSpan, { isCenterRipple: true, duration: 400 });
    wrapper.appendChild(rippleSpan);
  }
  var frameSpan = createElement2("span", { className: "e-frame e-icons" });
  if (options.checked) {
    frameSpan.classList.add("e-check");
  }
  wrapper.appendChild(frameSpan);
  if (options.label) {
    var labelSpan = createElement2("span", { className: "e-label" });
    if (options.disableHtmlEncode) {
      labelSpan.textContent = options.label;
    } else {
      labelSpan.innerHTML = options.label;
    }
    wrapper.appendChild(labelSpan);
  }
  return wrapper;
}
function rippleMouseHandler(e, rippleSpan) {
  if (rippleSpan) {
    var event_1 = (undefined).createEvent("MouseEvents");
    event_1.initEvent(e.type, false, true);
    rippleSpan.dispatchEvent(event_1);
  }
}
function setHiddenInput(proxy, wrap) {
  if (proxy.element.getAttribute("ejs-for")) {
    wrap.appendChild(proxy.createElement("input", {
      attrs: { "name": proxy.name || proxy.element.name, "value": "false", "type": "hidden" }
    }));
  }
}
var __extends$e = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate$e = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var IconPosition;
(function(IconPosition2) {
  IconPosition2["Left"] = "Left";
  IconPosition2["Right"] = "Right";
  IconPosition2["Top"] = "Top";
  IconPosition2["Bottom"] = "Bottom";
})(IconPosition || (IconPosition = {}));
var cssClassName = {
  RTL: "e-rtl",
  BUTTON: "e-btn",
  PRIMARY: "e-primary",
  ICONBTN: "e-icon-btn"
};
var Button = (
  /** @class */
  function(_super) {
    __extends$e(Button2, _super);
    function Button2(options, element2) {
      return _super.call(this, options, element2) || this;
    }
    Button2.prototype.preRender = function() {
    };
    Button2.prototype.render = function() {
      this.initialize();
      this.removeRippleEffect = rippleEffect(this.element, { selector: "." + cssClassName.BUTTON });
      this.renderComplete();
    };
    Button2.prototype.initialize = function() {
      if (this.cssClass) {
        addClass([this.element], this.cssClass.replace(/\s+/g, " ").trim().split(" "));
      }
      if (this.isPrimary) {
        this.element.classList.add(cssClassName.PRIMARY);
      }
      {
        if (this.content) {
          var tempContent = this.enableHtmlSanitizer ? SanitizeHtmlHelper.sanitize(this.content) : this.content;
          this.element.innerHTML = tempContent;
        }
        this.setIconCss();
      }
      if (this.enableRtl) {
        this.element.classList.add(cssClassName.RTL);
      }
      if (this.disabled) {
        this.controlStatus(this.disabled);
      } else {
        this.wireEvents();
      }
    };
    Button2.prototype.controlStatus = function(disabled) {
      this.element.disabled = disabled;
    };
    Button2.prototype.setIconCss = function() {
      if (this.iconCss) {
        var span = this.createElement("span", { className: "e-btn-icon " + this.iconCss });
        if (!this.element.textContent.trim()) {
          this.element.classList.add(cssClassName.ICONBTN);
        } else {
          span.classList.add("e-icon-" + this.iconPosition.toLowerCase());
          if (this.iconPosition === "Top" || this.iconPosition === "Bottom") {
            this.element.classList.add("e-" + this.iconPosition.toLowerCase() + "-icon-btn");
          }
        }
        var node = this.element.childNodes[0];
        if (node && (this.iconPosition === "Left" || this.iconPosition === "Top")) {
          this.element.insertBefore(span, node);
        } else {
          this.element.appendChild(span);
        }
      }
    };
    Button2.prototype.wireEvents = function() {
      if (this.isToggle) {
        EventHandler.add(this.element, "click", this.btnClickHandler, this);
      }
    };
    Button2.prototype.unWireEvents = function() {
      if (this.isToggle) {
        EventHandler.remove(this.element, "click", this.btnClickHandler);
      }
    };
    Button2.prototype.btnClickHandler = function() {
      if (this.element.classList.contains("e-active")) {
        this.element.classList.remove("e-active");
      } else {
        this.element.classList.add("e-active");
      }
    };
    Button2.prototype.destroy = function() {
      var classList2 = [
        cssClassName.PRIMARY,
        cssClassName.RTL,
        cssClassName.ICONBTN,
        "e-success",
        "e-info",
        "e-danger",
        "e-warning",
        "e-flat",
        "e-outline",
        "e-small",
        "e-bigger",
        "e-active",
        "e-round",
        "e-top-icon-btn",
        "e-bottom-icon-btn"
      ];
      if (this.cssClass) {
        classList2 = classList2.concat(this.cssClass.split(/\s+/).filter(function(c) {
          return c.length > 0;
        }));
      }
      _super.prototype.destroy.call(this);
      removeClass([this.element], classList2);
      if (!this.element.getAttribute("class")) {
        this.element.removeAttribute("class");
      }
      if (this.disabled) {
        this.element.removeAttribute("disabled");
      }
      if (this.content) {
        this.element.innerHTML = this.element.innerHTML.replace(this.content, "");
      }
      var span = this.element.querySelector("span.e-btn-icon");
      if (span) {
        detach(span);
      }
      this.unWireEvents();
    };
    Button2.prototype.getModuleName = function() {
      return "btn";
    };
    Button2.prototype.getPersistData = function() {
      return this.addOnPersist([]);
    };
    Button2.Inject = function() {
    };
    Button2.prototype.onPropertyChanged = function(newProp, oldProp) {
      var span = this.element.querySelector("span.e-btn-icon");
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "isPrimary":
            if (newProp.isPrimary) {
              this.element.classList.add(cssClassName.PRIMARY);
            } else {
              this.element.classList.remove(cssClassName.PRIMARY);
            }
            break;
          case "disabled":
            this.controlStatus(newProp.disabled);
            break;
          case "iconCss": {
            span = this.element.querySelector("span.e-btn-icon");
            if (span) {
              if (newProp.iconCss) {
                span.className = "e-btn-icon " + newProp.iconCss;
                if (this.element.textContent.trim()) {
                  if (this.iconPosition === "Left") {
                    span.classList.add("e-icon-left");
                  } else {
                    span.classList.add("e-icon-right");
                  }
                }
              } else {
                detach(span);
              }
            } else {
              this.setIconCss();
            }
            break;
          }
          case "iconPosition":
            removeClass([this.element], ["e-top-icon-btn", "e-bottom-icon-btn"]);
            span = this.element.querySelector("span.e-btn-icon");
            if (span) {
              detach(span);
            }
            this.setIconCss();
            break;
          case "cssClass":
            if (oldProp.cssClass) {
              removeClass([this.element], oldProp.cssClass.split(/\s+/).filter(function(c) {
                return c.length > 0;
              }));
            }
            if (newProp.cssClass) {
              addClass([this.element], newProp.cssClass.replace(/\s+/g, " ").trim().split(" "));
            }
            break;
          case "enableRtl":
            if (newProp.enableRtl) {
              this.element.classList.add(cssClassName.RTL);
            } else {
              this.element.classList.remove(cssClassName.RTL);
            }
            break;
          case "content": {
            var node = getTextNode(this.element);
            if (!node) {
              this.element.classList.remove(cssClassName.ICONBTN);
            }
            {
              if (this.enableHtmlSanitizer) {
                newProp.content = SanitizeHtmlHelper.sanitize(newProp.content);
              }
              this.element.innerHTML = newProp.content;
              this.setIconCss();
            }
            break;
          }
          case "isToggle":
            if (newProp.isToggle) {
              EventHandler.add(this.element, "click", this.btnClickHandler, this);
            } else {
              EventHandler.remove(this.element, "click", this.btnClickHandler);
              removeClass([this.element], ["e-active"]);
            }
            break;
        }
      }
    };
    Button2.prototype.click = function() {
      this.element.click();
    };
    Button2.prototype.focusIn = function() {
      this.element.focus();
    };
    __decorate$e([
      Property("Left")
    ], Button2.prototype, "iconPosition", undefined);
    __decorate$e([
      Property("")
    ], Button2.prototype, "iconCss", undefined);
    __decorate$e([
      Property(false)
    ], Button2.prototype, "disabled", undefined);
    __decorate$e([
      Property(false)
    ], Button2.prototype, "isPrimary", undefined);
    __decorate$e([
      Property("")
    ], Button2.prototype, "cssClass", undefined);
    __decorate$e([
      Property("")
    ], Button2.prototype, "content", undefined);
    __decorate$e([
      Property(false)
    ], Button2.prototype, "isToggle", undefined);
    __decorate$e([
      Property()
    ], Button2.prototype, "locale", undefined);
    __decorate$e([
      Property(true)
    ], Button2.prototype, "enableHtmlSanitizer", undefined);
    __decorate$e([
      Event()
    ], Button2.prototype, "created", undefined);
    Button2 = __decorate$e([
      NotifyPropertyChanges
    ], Button2);
    return Button2;
  }(Component)
);
var elementClass = ["north-west", "north", "north-east", "west", "east", "south-west", "south", "south-east"];
var RESIZE_HANDLER = "e-resize-handle";
var FOCUSED_HANDLER = "e-focused-handle";
var DIALOG_RESIZABLE = "e-dlg-resizable";
var RESTRICT_LEFT = ["e-restrict-left"];
var RESIZE_WITHIN_VIEWPORT = "e-resize-viewport";
var dialogBorderResize = ["north", "west", "east", "south"];
var targetElement;
var selectedHandler;
var originalWidth = 0;
var originalHeight = 0;
var originalX = 0;
var originalY = 0;
var originalMouseX = 0;
var originalMouseY = 0;
var minHeight;
var maxHeight;
var minWidth;
var maxWidth;
var containerElement;
var resizeStart = null;
var resize = null;
var resizeEnd = null;
var resizeWestWidth;
var setLeft = true;
var previousWidth = 0;
var setWidth = true;
function createResize(args) {
  resizeStart = args.resizeBegin;
  resize = args.resizing;
  resizeEnd = args.resizeComplete;
  targetElement = getDOMElement(args.element);
  containerElement = getDOMElement(args.boundary);
  var directions = args.direction.split(" ");
  for (var i = 0; i < directions.length; i++) {
    if (dialogBorderResize.indexOf(directions[i]) >= 0 && directions[i]) {
      setBorderResizeElm(directions[i]);
    } else if (directions[i].trim() !== "") {
      var resizeHandler = createElement("div", { className: "e-icons " + RESIZE_HANDLER + " e-" + directions[i] });
      targetElement.appendChild(resizeHandler);
    }
  }
  minHeight = args.minHeight;
  minWidth = args.minWidth;
  maxWidth = args.maxWidth;
  maxHeight = args.maxHeight;
  if (args.proxy && args.proxy.element && args.proxy.element.classList.contains("e-dialog")) {
    wireEvents(args.proxy);
  } else {
    wireEvents();
  }
}
function setBorderResizeElm(direction) {
  calculateValues();
  var borderBottom = createElement("span", {
    attrs: {
      "unselectable": "on",
      "contenteditable": "false"
    }
  });
  borderBottom.setAttribute("class", "e-dialog-border-resize e-" + direction);
  if (direction === "south") {
    borderBottom.style.height = "2px";
    borderBottom.style.width = "100%";
    borderBottom.style.bottom = "0px";
    borderBottom.style.left = "0px";
  }
  if (direction === "north") {
    borderBottom.style.height = "2px";
    borderBottom.style.width = "100%";
    borderBottom.style.top = "0px";
    borderBottom.style.left = "0px";
  }
  if (direction === "east") {
    borderBottom.style.height = "100%";
    borderBottom.style.width = "2px";
    borderBottom.style.right = "0px";
    borderBottom.style.top = "0px";
  }
  if (direction === "west") {
    borderBottom.style.height = "100%";
    borderBottom.style.width = "2px";
    borderBottom.style.left = "0px";
    borderBottom.style.top = "0px";
  }
  targetElement.appendChild(borderBottom);
}
function getDOMElement(element2) {
  var domElement;
  if (!isNullOrUndefined(element2)) {
    if (typeof element2 === "string") {
      domElement = (undefined).querySelector(element2);
    } else {
      domElement = element2;
    }
  }
  return domElement;
}
function wireEvents(args) {
  var context = args || this;
  var resizers = targetElement.querySelectorAll("." + RESIZE_HANDLER);
  for (var i = 0; i < resizers.length; i++) {
    selectedHandler = resizers[i];
    EventHandler.add(selectedHandler, "mousedown", onMouseDown, context);
    var eventName = Browser.info.name === "msie" ? "pointerdown" : "touchstart";
    EventHandler.add(selectedHandler, eventName, onTouchStart, context);
  }
  var borderResizers = targetElement.querySelectorAll(".e-dialog-border-resize");
  if (!isNullOrUndefined(borderResizers)) {
    for (var i = 0; i < borderResizers.length; i++) {
      selectedHandler = borderResizers[i];
      EventHandler.add(selectedHandler, "mousedown", onMouseDown, context);
      var eventName = Browser.info.name === "msie" ? "pointerdown" : "touchstart";
      EventHandler.add(selectedHandler, eventName, onTouchStart, context);
    }
  }
}
function getEventType(e) {
  return e.indexOf("mouse") > -1 ? "mouse" : "touch";
}
function onMouseDown(e) {
  e.preventDefault();
  targetElement = e.target.parentElement;
  calculateValues();
  originalMouseX = e.pageX;
  originalMouseY = e.pageY;
  e.target.classList.add(FOCUSED_HANDLER);
  if (!isNullOrUndefined(resizeStart)) {
    var proxy_1 = this;
    if (resizeStart(e, proxy_1) === true) {
      return;
    }
  }
  if (this.targetEle && targetElement && targetElement.querySelector("." + DIALOG_RESIZABLE)) {
    containerElement = this.target === "body" ? null : this.targetEle;
    maxWidth = this.targetEle.clientWidth;
    maxHeight = this.targetEle.clientHeight;
  }
  var target = isNullOrUndefined(containerElement) ? undefined : containerElement;
  EventHandler.add(target, "mousemove", onMouseMove, this);
  EventHandler.add(undefined, "mouseup", onMouseUp, this);
  for (var i = 0; i < RESTRICT_LEFT.length; i++) {
    if (targetElement.classList.contains(RESTRICT_LEFT[i])) {
      setLeft = false;
    } else {
      setLeft = true;
    }
  }
}
function onMouseUp(e) {
  var touchMoveEvent = Browser.info.name === "msie" ? "pointermove" : "touchmove";
  var touchEndEvent = Browser.info.name === "msie" ? "pointerup" : "touchend";
  var target = isNullOrUndefined(containerElement) ? undefined : containerElement;
  var eventName = Browser.info.name === "msie" ? "pointerdown" : "touchstart";
  EventHandler.remove(target, "mousemove", onMouseMove);
  EventHandler.remove(target, touchMoveEvent, onMouseMove);
  EventHandler.remove(target, eventName, onMouseMove);
  if (!isNullOrUndefined((undefined).body.querySelector("." + FOCUSED_HANDLER))) {
    (undefined).body.querySelector("." + FOCUSED_HANDLER).classList.remove(FOCUSED_HANDLER);
  }
  if (!isNullOrUndefined(resizeEnd)) {
    var proxy_2 = this;
    resizeEnd(e, proxy_2);
  }
  EventHandler.remove(undefined, "mouseup", onMouseUp);
  EventHandler.remove(undefined, touchEndEvent, onMouseUp);
}
function calculateValues() {
  originalWidth = parseFloat(getComputedStyle(targetElement, null).getPropertyValue("width").replace("px", ""));
  originalHeight = parseFloat(getComputedStyle(targetElement, null).getPropertyValue("height").replace("px", ""));
  originalX = targetElement.getBoundingClientRect().left;
  originalY = targetElement.getBoundingClientRect().top;
}
function onTouchStart(e) {
  targetElement = e.target.parentElement;
  calculateValues();
  var dialogResizeElement = targetElement.classList.contains("e-dialog");
  if ((e.target.classList.contains(RESIZE_HANDLER) || e.target.classList.contains("e-dialog-border-resize")) && dialogResizeElement) {
    e.target.classList.add(FOCUSED_HANDLER);
  }
  var coordinates = e.touches ? e.changedTouches[0] : e;
  originalMouseX = coordinates.pageX;
  originalMouseY = coordinates.pageY;
  if (!isNullOrUndefined(resizeStart)) {
    var proxy_3 = this;
    if (resizeStart(e, proxy_3) === true) {
      return;
    }
  }
  var touchMoveEvent = Browser.info.name === "msie" ? "pointermove" : "touchmove";
  var touchEndEvent = Browser.info.name === "msie" ? "pointerup" : "touchend";
  var target = isNullOrUndefined(containerElement) ? undefined : containerElement;
  EventHandler.add(target, touchMoveEvent, onMouseMove, this);
  EventHandler.add(undefined, touchEndEvent, onMouseUp, this);
}
function onMouseMove(e) {
  if (e.target.classList.contains(RESIZE_HANDLER) && e.target.classList.contains(FOCUSED_HANDLER)) {
    selectedHandler = e.target;
  } else if (!isNullOrUndefined((undefined).body.querySelector("." + FOCUSED_HANDLER))) {
    selectedHandler = (undefined).body.querySelector("." + FOCUSED_HANDLER);
  }
  if (!isNullOrUndefined(selectedHandler)) {
    var resizeTowards = "";
    for (var i = 0; i < elementClass.length; i++) {
      if (selectedHandler.classList.contains("e-" + elementClass[i])) {
        resizeTowards = elementClass[i];
      }
    }
    if (!isNullOrUndefined(resize)) {
      var proxy_4 = this;
      resize(e, proxy_4);
    }
    switch (resizeTowards) {
      case "south":
        resizeSouth(e);
        break;
      case "north":
        resizeNorth(e);
        break;
      case "west":
        resizeWest(e);
        break;
      case "east":
        resizeEast(e);
        break;
      case "south-east":
        resizeSouth(e);
        resizeEast(e);
        break;
      case "south-west":
        resizeSouth(e);
        resizeWest(e);
        break;
      case "north-east":
        resizeNorth(e);
        resizeEast(e);
        break;
      case "north-west":
        resizeNorth(e);
        resizeWest(e);
        break;
    }
  }
}
function getClientRectValues(element2) {
  return element2.getBoundingClientRect();
}
function resizeSouth(e) {
  var documentHeight = (undefined).documentElement.clientHeight;
  var calculateValue = false;
  var coordinates = e.touches ? e.changedTouches[0] : e;
  var currentpageY = coordinates.pageY;
  var targetRectValues = getClientRectValues(targetElement);
  var containerRectValues;
  if (!isNullOrUndefined(containerElement)) {
    containerRectValues = getClientRectValues(containerElement);
  }
  if (!isNullOrUndefined(containerElement)) {
    calculateValue = true;
  } else if (isNullOrUndefined(containerElement) && (documentHeight - currentpageY >= 0 || targetRectValues.top < 0)) {
    calculateValue = true;
  }
  var calculatedHeight = originalHeight + (currentpageY - originalMouseY);
  calculatedHeight = calculatedHeight > minHeight ? calculatedHeight : minHeight;
  var containerTop = 0;
  if (!isNullOrUndefined(containerElement)) {
    containerTop = containerRectValues.top;
  }
  var borderValue = isNullOrUndefined(containerElement) ? 0 : containerElement.offsetHeight - containerElement.clientHeight;
  var topWithoutborder = targetRectValues.top - containerTop - borderValue / 2;
  topWithoutborder = topWithoutborder < 0 ? 0 : topWithoutborder;
  if (targetRectValues.top > 0 && topWithoutborder + calculatedHeight > maxHeight) {
    calculateValue = false;
    if (targetElement.classList.contains(RESIZE_WITHIN_VIEWPORT)) {
      return;
    }
    targetElement.style.height = maxHeight - parseInt(topWithoutborder.toString(), 10) + "px";
    return;
  }
  var targetTop = 0;
  if (calculateValue) {
    if (targetRectValues.top < 0 && documentHeight + (targetRectValues.height + targetRectValues.top) > 0) {
      targetTop = targetRectValues.top;
      if (calculatedHeight + targetTop <= 30) {
        calculatedHeight = targetRectValues.height - (targetRectValues.height + targetRectValues.top) + 30;
      }
    }
    if (calculatedHeight + targetRectValues.top >= maxHeight) {
      targetElement.style.height = targetRectValues.height + (documentHeight - (targetRectValues.height + targetRectValues.top)) + "px";
    }
    var calculatedTop = isNullOrUndefined(containerElement) ? targetTop : topWithoutborder;
    if (calculatedHeight >= minHeight && calculatedHeight + calculatedTop <= maxHeight) {
      targetElement.style.height = calculatedHeight + "px";
    }
  }
}
function resizeNorth(e) {
  var calculateValue = false;
  var boundaryRectValues;
  var pageY = getEventType(e.type) === "mouse" ? e.pageY : e.touches[0].pageY;
  var targetRectValues = getClientRectValues(targetElement);
  var borderValue = isNullOrUndefined(containerElement) ? 0 : containerElement.offsetHeight - containerElement.clientHeight;
  if (!isNullOrUndefined(containerElement)) {
    boundaryRectValues = getClientRectValues(containerElement);
  }
  if (!isNullOrUndefined(containerElement) && targetRectValues.top - boundaryRectValues.top > 0) {
    calculateValue = true;
  } else if (isNullOrUndefined(containerElement) && pageY > 0) {
    calculateValue = true;
  } else if (!isNullOrUndefined(containerElement) && Math.floor(targetRectValues.top - boundaryRectValues.top + targetRectValues.height + (boundaryRectValues.bottom - targetRectValues.bottom)) - borderValue <= maxHeight) {
    calculateValue = true;
  }
  var currentHeight = originalHeight - (pageY - originalMouseY);
  if (calculateValue) {
    if (currentHeight >= minHeight && currentHeight <= maxHeight) {
      var containerTop = 0;
      if (!isNullOrUndefined(containerElement)) {
        containerTop = boundaryRectValues.top;
      }
      var top_1 = originalY - containerTop + (pageY - originalMouseY);
      top_1 = top_1 > 0 ? top_1 : 1;
      targetElement.style.height = currentHeight + "px";
      targetElement.style.top = top_1 + "px";
    }
  }
}
function resizeWest(e) {
  var documentWidth = (undefined).documentElement.clientWidth;
  var calculateValue = false;
  var rectValues;
  if (!isNullOrUndefined(containerElement)) {
    rectValues = getClientRectValues(containerElement);
  }
  var pageX = getEventType(e.type) === "mouse" ? e.pageX : e.touches[0].pageX;
  var targetRectValues = getClientRectValues(targetElement);
  var borderValue = isNullOrUndefined(containerElement) ? 0 : containerElement.offsetWidth - containerElement.clientWidth;
  var left = isNullOrUndefined(containerElement) ? 0 : rectValues.left;
  var containerWidth = isNullOrUndefined(containerElement) ? 0 : rectValues.width;
  if (isNullOrUndefined(resizeWestWidth)) {
    if (!isNullOrUndefined(containerElement)) {
      resizeWestWidth = targetRectValues.left - left - borderValue / 2 + targetRectValues.width;
      resizeWestWidth = resizeWestWidth + (containerWidth - borderValue - resizeWestWidth);
    } else {
      resizeWestWidth = documentWidth;
    }
  }
  if (!isNullOrUndefined(containerElement) && Math.floor(targetRectValues.left - rectValues.left + targetRectValues.width + (rectValues.right - targetRectValues.right)) - borderValue <= maxWidth) {
    calculateValue = true;
  } else if (isNullOrUndefined(containerElement) && pageX >= 0) {
    calculateValue = true;
  }
  var calculatedWidth = originalWidth - (pageX - originalMouseX);
  if (setLeft) {
    calculatedWidth = calculatedWidth > resizeWestWidth ? resizeWestWidth : calculatedWidth;
  }
  if (calculateValue) {
    if (calculatedWidth >= minWidth && calculatedWidth <= maxWidth) {
      var containerLeft = 0;
      if (!isNullOrUndefined(containerElement)) {
        containerLeft = rectValues.left;
      }
      var left_1 = originalX - containerLeft + (pageX - originalMouseX);
      left_1 = left_1 > 0 ? left_1 : 1;
      if (calculatedWidth !== previousWidth && setWidth) {
        targetElement.style.width = calculatedWidth + "px";
      }
      if (setLeft) {
        targetElement.style.left = left_1 + "px";
        if (left_1 === 1) {
          setWidth = false;
        } else {
          setWidth = true;
        }
      }
    }
  }
  previousWidth = calculatedWidth;
}
function resizeEast(e) {
  var documentWidth = (undefined).documentElement.clientWidth;
  var calculateValue = false;
  var containerRectValues;
  if (!isNullOrUndefined(containerElement)) {
    containerRectValues = getClientRectValues(containerElement);
  }
  var coordinates = e.touches ? e.changedTouches[0] : e;
  var pageX = coordinates.pageX;
  var targetRectValues = getClientRectValues(targetElement);
  if (!isNullOrUndefined(containerElement) && (targetRectValues.left - containerRectValues.left + targetRectValues.width <= maxWidth || targetRectValues.right - containerRectValues.left >= targetRectValues.width)) {
    calculateValue = true;
  } else if (isNullOrUndefined(containerElement) && documentWidth - pageX > 0) {
    calculateValue = true;
  }
  var calculatedWidth = originalWidth + (pageX - originalMouseX);
  var containerLeft = 0;
  if (!isNullOrUndefined(containerElement)) {
    containerLeft = containerRectValues.left;
  }
  if (targetRectValues.left - containerLeft + calculatedWidth > maxWidth) {
    calculateValue = false;
    if (targetElement.classList.contains(RESIZE_WITHIN_VIEWPORT)) {
      return;
    }
    targetElement.style.width = maxWidth - (targetRectValues.left - containerLeft) + "px";
  }
  if (calculateValue) {
    if (calculatedWidth >= minWidth && calculatedWidth <= maxWidth) {
      targetElement.style.width = calculatedWidth + "px";
    }
  }
}
function setMinHeight(minimumHeight) {
  minHeight = minimumHeight;
}
function setMaxWidth(value) {
  maxWidth = value;
}
function setMaxHeight(value) {
  maxHeight = value;
}
function removeResize() {
  var handlers = targetElement.querySelectorAll("." + RESIZE_HANDLER);
  for (var i = 0; i < handlers.length; i++) {
    detach(handlers[i]);
  }
  var borderResizers = targetElement.querySelectorAll(".e-dialog-border-resize");
  if (!isNullOrUndefined(borderResizers)) {
    for (var i = 0; i < borderResizers.length; i++) {
      detach(borderResizers[i]);
    }
  }
}
function resizeDestroy() {
  targetElement = null;
  selectedHandler = null;
  containerElement = null;
  resizeWestWidth = null;
  resizeStart = null;
  resize = null;
  resizeEnd = null;
}
var __extends$d = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate$d = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ButtonProps = (
  /** @class */
  function(_super) {
    __extends$d(ButtonProps2, _super);
    function ButtonProps2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$d([
      Property(true)
    ], ButtonProps2.prototype, "isFlat", undefined);
    __decorate$d([
      Property()
    ], ButtonProps2.prototype, "buttonModel", undefined);
    __decorate$d([
      Property("Button")
    ], ButtonProps2.prototype, "type", undefined);
    __decorate$d([
      Event()
    ], ButtonProps2.prototype, "click", undefined);
    return ButtonProps2;
  }(ChildProperty)
);
var AnimationSettings = (
  /** @class */
  function(_super) {
    __extends$d(AnimationSettings2, _super);
    function AnimationSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$d([
      Property("Fade")
    ], AnimationSettings2.prototype, "effect", undefined);
    __decorate$d([
      Property(400)
    ], AnimationSettings2.prototype, "duration", undefined);
    __decorate$d([
      Property(0)
    ], AnimationSettings2.prototype, "delay", undefined);
    return AnimationSettings2;
  }(ChildProperty)
);
var ROOT$2 = "e-dialog";
var RTL$4 = "e-rtl";
var DLG_HEADER_CONTENT = "e-dlg-header-content";
var DLG_HEADER = "e-dlg-header";
var DLG_FOOTER_CONTENT = "e-footer-content";
var MODAL_DLG = "e-dlg-modal";
var DLG_CONTENT = "e-dlg-content";
var DLG_CLOSE_ICON = "e-icon-dlg-close";
var DLG_OVERLAY = "e-dlg-overlay";
var DLG_TARGET = "e-dlg-target";
var DLG_CONTAINER = "e-dlg-container";
var SCROLL_DISABLED = "e-scroll-disabled";
var DLG_PRIMARY_BUTTON = "e-primary";
var ICON$1 = "e-icons";
var POPUP_ROOT$1 = "e-popup";
var DEVICE$1 = "e-device";
var FULLSCREEN = "e-dlg-fullscreen";
var DLG_CLOSE_ICON_BTN = "e-dlg-closeicon-btn";
var DLG_HIDE = "e-popup-close";
var DLG_SHOW = "e-popup-open";
var DLG_UTIL_DEFAULT_TITLE = "Information";
var DLG_UTIL_ROOT = "e-scroll-disabled";
var DLG_UTIL_ALERT = "e-alert-dialog";
var DLG_UTIL_CONFIRM = "e-confirm-dialog";
var DLG_RESIZABLE = "e-dlg-resizable";
var DLG_RESTRICT_LEFT_VALUE = "e-restrict-left";
var DLG_RESTRICT_WIDTH_VALUE = "e-resize-viewport";
var DLG_REF_ELEMENT = "e-dlg-ref-element";
var DLG_USER_ACTION_CLOSED = "user action";
var DLG_CLOSE_ICON_CLOSED = "close icon";
var DLG_ESCAPE_CLOSED = "escape";
var DLG_OVERLAYCLICK_CLOSED = "overlayClick";
var DLG_DRAG = "e-draggable";
var Dialog = (
  /** @class */
  function(_super) {
    __extends$d(Dialog2, _super);
    function Dialog2(options, element2) {
      var _this = _super.call(this, options, element2) || this;
      _this.needsID = true;
      return _this;
    }
    Dialog2.prototype.render = function() {
      this.initialize();
      this.initRender();
      this.wireEvents();
      if (this.width === "100%") {
        this.element.style.width = "";
      }
      if (this.minHeight !== "") {
        this.element.style.minHeight = formatUnit(this.minHeight);
      }
      if (this.enableResize) {
        this.setResize();
        if (this.isModal) {
          this.isModelResize = true;
        }
        if (this.animationSettings.effect === "None") {
          this.getMinHeight();
        }
      }
      this.renderComplete();
    };
    Dialog2.prototype.initializeValue = function() {
      this.dlgClosedBy = DLG_USER_ACTION_CLOSED;
    };
    Dialog2.prototype.preRender = function() {
      var _this = this;
      this.initializeValue();
      this.headerContent = null;
      this.allowMaxHeight = true;
      this.preventVisibility = true;
      this.clonedEle = this.element.cloneNode(true);
      this.closeIconClickEventHandler = function(event) {
        _this.dlgClosedBy = DLG_CLOSE_ICON_CLOSED;
        _this.hide(event);
      };
      this.dlgOverlayClickEventHandler = function(event) {
        _this.dlgClosedBy = DLG_OVERLAYCLICK_CLOSED;
        event.preventFocus = false;
        _this.trigger("overlayClick", event, function(overlayClickEventArgs) {
          if (!overlayClickEventArgs.preventFocus) {
            _this.focusContent();
          }
          _this.dlgClosedBy = DLG_USER_ACTION_CLOSED;
        });
      };
      var localeText = { close: "Close" };
      this.l10n = new L10n("dialog", localeText, this.locale);
      this.checkPositionData();
      if (isNullOrUndefined(this.target)) {
        var prevOnChange = this.isProtectedOnChange;
        this.isProtectedOnChange = true;
        this.target = (undefined).body;
        this.isProtectedOnChange = prevOnChange;
      }
    };
    Dialog2.prototype.updatePersistData = function() {
      if (this.enablePersistence) {
        this.setProperties({
          width: parseFloat(this.element.style.width),
          height: parseFloat(this.element.style.height),
          position: { X: parseFloat(this.dragObj.element.style.left), Y: parseFloat(this.dragObj.element.style.top) }
        }, true);
      }
    };
    Dialog2.prototype.isNumberValue = function(value) {
      var isNumber = /^[-+]?\d*\.?\d+$/.test(value);
      return isNumber;
    };
    Dialog2.prototype.checkPositionData = function() {
      if (!isNullOrUndefined(this.position)) {
        if (!isNullOrUndefined(this.position.X) && typeof this.position.X !== "number") {
          var isNumber = this.isNumberValue(this.position.X);
          if (isNumber) {
            var prevOnChange = this.isProtectedOnChange;
            this.isProtectedOnChange = true;
            this.position.X = parseFloat(this.position.X);
            this.isProtectedOnChange = prevOnChange;
          }
        }
        if (!isNullOrUndefined(this.position.Y) && typeof this.position.Y !== "number") {
          var isNumber = this.isNumberValue(this.position.Y);
          if (isNumber) {
            var prevOnChange = this.isProtectedOnChange;
            this.isProtectedOnChange = true;
            this.position.Y = parseFloat(this.position.Y);
            this.isProtectedOnChange = prevOnChange;
          }
        }
      }
    };
    Dialog2.prototype.getEle = function(list, selector) {
      var element2 = undefined;
      for (var i = 0; i < list.length; i++) {
        if (list[i].classList.contains(selector)) {
          element2 = list[i];
          break;
        }
      }
      return element2;
    };
    Dialog2.prototype.getMinHeight = function() {
      var computedHeaderHeight = "0px";
      var computedFooterHeight = "0px";
      if (!isNullOrUndefined(this.element.querySelector("." + DLG_HEADER_CONTENT))) {
        computedHeaderHeight = getComputedStyle(this.headerContent).height;
      }
      var footerEle = this.getEle(this.element.children, DLG_FOOTER_CONTENT);
      if (!isNullOrUndefined(footerEle)) {
        computedFooterHeight = getComputedStyle(footerEle).height;
      }
      var headerHeight = parseInt(computedHeaderHeight.slice(0, computedHeaderHeight.indexOf("p")), 10);
      var footerHeight = parseInt(computedFooterHeight.slice(0, computedFooterHeight.indexOf("p")), 10);
      setMinHeight(headerHeight + 30 + (isNaN(footerHeight) ? 0 : footerHeight));
      return headerHeight + 30 + footerHeight;
    };
    Dialog2.prototype.onResizeStart = function(args, dialogObj) {
      dialogObj.trigger("resizeStart", args);
      if (!args.cancel && this.isModelResize && !isNullOrUndefined(this.dlgContainer) && this.dlgContainer.classList.contains("e-dlg-" + this.position.X + "-" + this.position.Y)) {
        this.setPopupPosition();
        this.dlgContainer.classList.remove("e-dlg-" + this.position.X + "-" + this.position.Y);
        var targetType = this.getTargetContainer(this.target);
        if (targetType instanceof Element) {
          var computedStyle = (undefined).getComputedStyle(targetType);
          if (computedStyle.getPropertyValue("direction") === "rtl") {
            this.element.style.position = "absolute";
          } else {
            this.element.style.position = "relative";
          }
        } else {
          this.element.style.position = "relative";
        }
        if (this.element.classList.contains(DLG_RESTRICT_LEFT_VALUE)) {
          this.element.classList.remove(DLG_RESTRICT_LEFT_VALUE);
        }
        this.isModelResize = false;
      }
      return args.cancel;
    };
    Dialog2.prototype.onResizing = function(args, dialogObj) {
      dialogObj.trigger("resizing", args);
    };
    Dialog2.prototype.onResizeComplete = function(args, dialogObj) {
      dialogObj.trigger("resizeStop", args);
      this.updatePersistData();
    };
    Dialog2.prototype.setResize = function() {
      if (this.enableResize) {
        this.element.classList.add(DLG_RESIZABLE);
        var computedHeight = getComputedStyle(this.element).minHeight;
        var computedWidth = getComputedStyle(this.element).minWidth;
        var direction = "";
        for (var i = 0; i < this.resizeHandles.length; i++) {
          if (this.resizeHandles[i] === "All") {
            direction = "south north east west north-east north-west south-east south-west";
            break;
          } else {
            var directionValue = "";
            switch (this.resizeHandles[i].toString()) {
              case "SouthEast":
                directionValue = "south-east";
                break;
              case "SouthWest":
                directionValue = "south-west";
                break;
              case "NorthEast":
                directionValue = "north-east";
                break;
              case "NorthWest":
                directionValue = "north-west";
                break;
              default:
                directionValue = this.resizeHandles[i].toString();
                break;
            }
            direction += directionValue.toLocaleLowerCase() + " ";
          }
        }
        if (this.enableRtl && direction.trim() === "south-east") {
          direction = "south-west";
        } else if (this.enableRtl && direction.trim() === "south-west") {
          direction = "south-east";
        }
        if (this.isModal && this.enableRtl) {
          this.element.classList.add(DLG_RESTRICT_LEFT_VALUE);
        } else if (this.isModal && this.target === (undefined).body) {
          this.element.classList.add(DLG_RESTRICT_WIDTH_VALUE);
        }
        createResize({
          element: this.element,
          direction,
          minHeight: parseInt(computedHeight.slice(0, computedWidth.indexOf("p")), 10),
          maxHeight: this.targetEle.clientHeight,
          minWidth: parseInt(computedWidth.slice(0, computedWidth.indexOf("p")), 10),
          maxWidth: this.targetEle.clientWidth,
          boundary: this.target === (undefined).body ? null : this.targetEle,
          resizeBegin: this.onResizeStart.bind(this),
          resizeComplete: this.onResizeComplete.bind(this),
          resizing: this.onResizing.bind(this),
          proxy: this
        });
        this.wireWindowResizeEvent();
      } else {
        removeResize();
        this.unWireWindowResizeEvent();
        if (this.isModal) {
          this.element.classList.remove(DLG_RESTRICT_LEFT_VALUE);
        } else {
          this.element.classList.remove(DLG_RESTRICT_WIDTH_VALUE);
        }
        this.element.classList.remove(DLG_RESIZABLE);
      }
    };
    Dialog2.prototype.getFocusElement = function(target) {
      var value = 'input,select,textarea,button:enabled,a,[contenteditable="true"],[tabindex]';
      var items = target.querySelectorAll(value);
      return { element: items[items.length - 1] };
    };
    Dialog2.prototype.keyDown = function(event) {
      var _this = this;
      if (event.keyCode === 9) {
        if (this.isModal) {
          var buttonObj = undefined;
          if (!isNullOrUndefined(this.btnObj)) {
            buttonObj = this.btnObj[this.btnObj.length - 1];
          }
          if (isNullOrUndefined(this.btnObj) && !isNullOrUndefined(this.ftrTemplateContent)) {
            buttonObj = this.getFocusElement(this.ftrTemplateContent);
          }
          if (isNullOrUndefined(this.btnObj) && isNullOrUndefined(this.ftrTemplateContent) && !isNullOrUndefined(this.contentEle)) {
            buttonObj = this.getFocusElement(this.contentEle);
          }
          if (!isNullOrUndefined(buttonObj) && (undefined).activeElement === buttonObj.element && !event.shiftKey) {
            event.preventDefault();
            this.focusableElements(this.element).focus();
          }
          if ((undefined).activeElement === this.focusableElements(this.element) && event.shiftKey) {
            event.preventDefault();
            if (!isNullOrUndefined(buttonObj)) {
              buttonObj.element.focus();
            }
          }
        }
      }
      var element2 = (undefined).activeElement;
      var isTagName = ["input", "textarea"].indexOf(element2.tagName.toLowerCase()) > -1;
      var isContentEdit = false;
      if (!isTagName) {
        isContentEdit = element2.hasAttribute("contenteditable") && element2.getAttribute("contenteditable") === "true";
      }
      if (event.keyCode === 27 && this.closeOnEscape) {
        this.dlgClosedBy = DLG_ESCAPE_CLOSED;
        var query = (undefined).querySelector(".e-popup-open:not(.e-dialog)");
        if (!(!isNullOrUndefined(query) && !query.classList.contains("e-toolbar-pop") && !query.classList.contains("e-slider-tooltip"))) {
          this.hide(event);
        }
      }
      if (event.keyCode === 13 && !event.ctrlKey && element2.tagName.toLowerCase() !== "textarea" && isTagName && !isNullOrUndefined(this.primaryButtonEle) || event.keyCode === 13 && event.ctrlKey && (element2.tagName.toLowerCase() === "textarea" || isContentEdit) && !isNullOrUndefined(this.primaryButtonEle)) {
        var buttonIndex_1;
        var firstPrimary = this.buttons.some(function(data, index) {
          buttonIndex_1 = index;
          var buttonModel = data.buttonModel;
          return !isNullOrUndefined(buttonModel) && buttonModel.isPrimary === true;
        });
        if (firstPrimary && typeof this.buttons[buttonIndex_1].click === "function" && !this.primaryButtonEle.disabled) {
          setTimeout(function() {
            _this.buttons[buttonIndex_1].click.call(_this, event);
          });
        }
      }
    };
    Dialog2.prototype.initialize = function() {
      if (!isNullOrUndefined(this.target)) {
        this.targetEle = typeof this.target === "string" ? (undefined).querySelector(this.target) : this.target;
      }
      if (!this.isBlazorServerRender()) {
        addClass([this.element], ROOT$2);
      }
      if (Browser.isDevice) {
        addClass([this.element], DEVICE$1);
      }
      if (!this.isBlazorServerRender()) {
        this.setCSSClass();
      }
      this.setMaxHeight();
    };
    Dialog2.prototype.initRender = function() {
      var _this = this;
      this.initialRender = true;
      if (!this.isBlazorServerRender()) {
        attributes(this.element, { role: "dialog" });
      }
      if (this.zIndex === 1e3) {
        this.setzIndex(this.element, false);
        this.calculatezIndex = true;
      } else {
        this.calculatezIndex = false;
      }
      this.setTargetContent();
      if (this.header !== "" && !isNullOrUndefined(this.header)) {
        this.setHeader();
      }
      this.renderCloseIcon();
      this.setContent();
      if (this.footerTemplate !== "" && !isNullOrUndefined(this.footerTemplate)) {
        this.setFooterTemplate();
      } else if (!isNullOrUndefined(this.buttons[0]) && !isNullOrUndefined(this.buttons[0].buttonModel)) {
        this.setButton();
      }
      if (this.allowDragging && !isNullOrUndefined(this.headerContent)) {
        this.setAllowDragging();
      }
      attributes(this.element, { "aria-modal": this.isModal ? "true" : "false" });
      if (this.isModal) {
        this.setIsModal();
      }
      if (this.element.classList.contains(DLG_UTIL_ALERT) !== true && this.element.classList.contains(DLG_UTIL_CONFIRM) !== true && !isNullOrUndefined(this.element.parentElement)) {
        var parentEle = this.isModal ? this.dlgContainer.parentElement : this.element.parentElement;
        this.refElement = this.createElement("div", { className: DLG_REF_ELEMENT });
        parentEle.insertBefore(this.refElement, this.isModal ? this.dlgContainer : this.element);
      }
      if (!isNullOrUndefined(this.targetEle)) {
        if (this.isModal) {
          this.targetEle.appendChild(this.dlgContainer);
        } else {
          this.targetEle.appendChild(this.element);
        }
      }
      this.popupObj = new Popup(this.element, {
        height: this.height,
        width: this.width,
        zIndex: this.zIndex,
        relateTo: this.target,
        actionOnScroll: "none",
        enableRtl: this.enableRtl,
        // eslint-disable-next-line
        open: function(event) {
          var eventArgs = {
            container: _this.isModal ? _this.dlgContainer : _this.element,
            element: _this.element,
            target: _this.target,
            preventFocus: false
          };
          if (_this.enableResize) {
            _this.resetResizeIcon();
          }
          _this.trigger("open", eventArgs, function(openEventArgs) {
            if (!openEventArgs.preventFocus) {
              _this.focusContent();
            }
          });
        },
        // eslint-disable-next-line
        close: function(event) {
          if (_this.isModal) {
            addClass([_this.dlgOverlay], "e-fade");
          }
          _this.unBindEvent(_this.element);
          if (_this.isModal) {
            _this.dlgContainer.style.display = "none";
          }
          _this.trigger("close", _this.closeArgs);
          var activeEle = (undefined).activeElement;
          if (!isNullOrUndefined(activeEle) && !isNullOrUndefined(activeEle.blur)) {
            activeEle.blur();
          }
          if (!isNullOrUndefined(_this.storeActiveElement) && !isNullOrUndefined(_this.storeActiveElement.focus)) {
            _this.storeActiveElement.focus();
          }
        }
      });
      this.positionChange();
      this.setEnableRTL();
      if (!this.isBlazorServerRender()) {
        addClass([this.element], DLG_HIDE);
        if (this.isModal) {
          this.setOverlayZindex();
        }
      }
      if (this.visible) {
        this.show();
        if (this.isModal) {
          var targetType = this.getTargetContainer(this.target);
          if (targetType instanceof Element) {
            var computedStyle = (undefined).getComputedStyle(targetType);
            if (computedStyle.getPropertyValue("direction") === "rtl") {
              this.setPopupPosition();
            }
          }
        }
      } else {
        if (this.isModal) {
          this.dlgOverlay.style.display = "none";
        }
      }
      this.initialRender = false;
    };
    Dialog2.prototype.getTargetContainer = function(targetValue) {
      var targetElement2 = null;
      if (typeof targetValue === "string") {
        if (targetValue.startsWith("#")) {
          targetElement2 = (undefined).getElementById(targetValue.substring(1));
        } else if (targetValue.startsWith(".")) {
          var elements = (undefined).getElementsByClassName(targetValue.substring(1));
          targetElement2 = elements.length > 0 ? elements[0] : null;
        } else {
          if (!(targetValue instanceof HTMLElement) && targetValue !== (undefined).body) {
            targetElement2 = (undefined).querySelector(targetValue);
          }
        }
      } else if (targetValue instanceof HTMLElement) {
        targetElement2 = targetValue;
      }
      return targetElement2;
    };
    Dialog2.prototype.resetResizeIcon = function() {
      var dialogConHeight = this.getMinHeight();
      if (this.targetEle.offsetHeight < dialogConHeight) {
        var className = this.enableRtl ? "e-south-west" : "e-south-east";
        var resizeIcon = this.element.querySelector("." + className);
        if (!isNullOrUndefined(resizeIcon)) {
          resizeIcon.style.bottom = "-" + dialogConHeight.toString() + "px";
        }
      }
    };
    Dialog2.prototype.setOverlayZindex = function(zIndexValue) {
      var zIndex;
      if (isNullOrUndefined(zIndexValue)) {
        zIndex = parseInt(this.element.style.zIndex, 10) ? parseInt(this.element.style.zIndex, 10) : this.zIndex;
      } else {
        zIndex = zIndexValue;
      }
      this.dlgOverlay.style.zIndex = (zIndex - 1).toString();
      this.dlgContainer.style.zIndex = zIndex.toString();
    };
    Dialog2.prototype.positionChange = function() {
      if (this.isModal) {
        if (!isNaN(parseFloat(this.position.X)) && !isNaN(parseFloat(this.position.Y))) {
          this.setPopupPosition();
        } else if (!isNaN(parseFloat(this.position.X)) && isNaN(parseFloat(this.position.Y)) || isNaN(parseFloat(this.position.X)) && !isNaN(parseFloat(this.position.Y))) {
          this.setPopupPosition();
        } else {
          this.element.style.top = "0px";
          this.element.style.left = "0px";
          this.dlgContainer.classList.add("e-dlg-" + this.position.X + "-" + this.position.Y);
        }
      } else {
        this.setPopupPosition();
      }
    };
    Dialog2.prototype.setPopupPosition = function() {
      this.popupObj.setProperties({
        position: {
          X: this.position.X,
          Y: this.position.Y
        }
      });
    };
    Dialog2.prototype.setAllowDragging = function() {
      var _this = this;
      var handleContent = "." + DLG_HEADER_CONTENT;
      if (!this.element.classList.contains(DLG_DRAG)) {
        this.dragObj = new Draggable(this.element, {
          clone: false,
          isDragScroll: true,
          abort: ".e-dlg-closeicon-btn",
          handle: handleContent,
          dragStart: function(event) {
            _this.trigger("dragStart", event, function(dragEventArgs) {
            });
          },
          dragStop: function(event) {
            if (_this.isModal) {
              _this.IsDragStop = true;
              if (!isNullOrUndefined(_this.position)) {
                _this.dlgContainer.classList.remove("e-dlg-" + _this.position.X + "-" + _this.position.Y);
              }
              var targetType = _this.getTargetContainer(_this.target);
              if (targetType instanceof Element) {
                var computedStyle = (undefined).getComputedStyle(targetType);
                if (computedStyle.getPropertyValue("direction") === "rtl") {
                  _this.element.style.position = "absolute";
                } else {
                  _this.element.style.position = "relative";
                }
              } else {
                _this.element.style.position = "relative";
              }
            }
            _this.trigger("dragStop", event);
            _this.isModelResize = false;
            _this.element.classList.remove(DLG_RESTRICT_LEFT_VALUE);
            _this.updatePersistData();
          },
          drag: function(event) {
            _this.trigger("drag", event);
          }
        });
        if (!isNullOrUndefined(this.targetEle)) {
          this.dragObj.dragArea = this.targetEle;
        }
      }
    };
    Dialog2.prototype.setButton = function() {
      if (!this.isBlazorServerRender()) {
        this.buttonContent = [];
        this.btnObj = [];
        for (var i = 0; i < this.buttons.length; i++) {
          if (isNullOrUndefined(this.buttons[i].buttonModel)) {
            continue;
          }
          var buttonType = !isNullOrUndefined(this.buttons[i].type) ? this.buttons[i].type.toLowerCase() : "button";
          var btn = this.createElement("button", { className: this.cssClass, attrs: { type: buttonType, tabindex: "0" } });
          this.buttonContent.push(btn.outerHTML);
        }
        this.setFooterTemplate();
      }
      var footerBtn;
      for (var i = 0, childNodes = this.element.children; i < childNodes.length; i++) {
        if (childNodes[i].classList.contains(DLG_FOOTER_CONTENT)) {
          footerBtn = childNodes[i].querySelectorAll("button");
        }
      }
      for (var i = 0; i < this.buttons.length; i++) {
        if (isNullOrUndefined(this.buttons[i].buttonModel)) {
          continue;
        }
        if (!this.isBlazorServerRender()) {
          this.btnObj[i] = new Button(this.buttons[i].buttonModel);
        }
        if (!isNullOrUndefined(this.ftrTemplateContent) && footerBtn.length > 0) {
          if (typeof this.buttons[i].click === "function") {
            EventHandler.add(footerBtn[i], "click", this.buttons[i].click, this);
          }
          if (typeof this.buttons[i].click === "object") {
            EventHandler.add(footerBtn[i], "click", this.buttonClickHandler.bind(this, i), this);
          }
        }
        if (!this.isBlazorServerRender() && !isNullOrUndefined(this.ftrTemplateContent)) {
          this.btnObj[i].appendTo(this.ftrTemplateContent.children[i]);
          if (this.buttons[i].isFlat) {
            this.btnObj[i].element.classList.add("e-flat");
          }
          this.primaryButtonEle = this.element.getElementsByClassName("e-primary")[0];
        }
      }
    };
    Dialog2.prototype.buttonClickHandler = function(index) {
      this.trigger("buttons[" + index + "].click", {});
    };
    Dialog2.prototype.setContent = function() {
      this.contentEle = this.createElement("div", { className: DLG_CONTENT, id: this.element.id + "_dialog-content" });
      if (this.headerEle) {
        attributes(this.element, { "aria-describedby": this.element.id + "_title " + this.element.id + "_dialog-content" });
      } else {
        attributes(this.element, { "aria-describedby": this.element.id + "_dialog-content" });
      }
      if (this.innerContentElement) {
        this.contentEle.appendChild(this.innerContentElement);
      } else if (!isNullOrUndefined(this.content) && this.content !== "" || !this.initialRender) {
        if (typeof this.content === "string" && true) {
          this.setTemplate(this.content, this.contentEle, "content");
        } else if (this.content instanceof HTMLElement) {
          this.contentEle.appendChild(this.content);
        } else {
          this.setTemplate(this.content, this.contentEle, "content");
        }
      }
      if (!isNullOrUndefined(this.headerContent)) {
        this.element.insertBefore(this.contentEle, this.element.children[1]);
      } else {
        this.element.insertBefore(this.contentEle, this.element.children[0]);
      }
      if (this.height === "auto") {
        if (!this.isBlazorServerRender() && Browser.isIE && this.element.style.width === "" && !isNullOrUndefined(this.width)) {
          this.element.style.width = formatUnit(this.width);
        }
        this.setMaxHeight();
      }
    };
    Dialog2.prototype.setTemplate = function(template, toElement, prop) {
      var templateFn;
      var templateProps;
      if (toElement.classList.contains(DLG_HEADER)) {
        templateProps = this.element.id + "header";
      } else if (toElement.classList.contains(DLG_FOOTER_CONTENT)) {
        templateProps = this.element.id + "footerTemplate";
      } else {
        templateProps = this.element.id + "content";
      }
      if (!isNullOrUndefined(template.outerHTML)) {
        toElement.appendChild(template);
      } else if (typeof template === "string" || typeof template !== "string" || isBlazor()) {
        if (typeof template === "string") {
          template = this.sanitizeHelper(template);
        }
        if (this.isVue || typeof template !== "string") {
          templateFn = compile$1(template);
        } else {
          toElement.innerHTML = template;
        }
      }
      var fromElements = [];
      if (!isNullOrUndefined(templateFn)) {
        var isString = true;
        for (var _i = 0, _a = templateFn({}, this, prop, templateProps, isString); _i < _a.length; _i++) {
          var item = _a[_i];
          fromElements.push(item);
        }
        append([].slice.call(fromElements), toElement);
      }
    };
    Dialog2.prototype.sanitizeHelper = function(value) {
      if (this.enableHtmlSanitizer) {
        var dialogItem = SanitizeHtmlHelper.beforeSanitize();
        var beforeEvent = {
          cancel: false,
          helper: null
        };
        extend(dialogItem, dialogItem, beforeEvent);
        this.trigger("beforeSanitizeHtml", dialogItem);
        if (dialogItem.cancel && !isNullOrUndefined(dialogItem.helper)) {
          value = dialogItem.helper(value);
        } else if (!dialogItem.cancel) {
          value = SanitizeHtmlHelper.serializeValue(dialogItem, value);
        }
      }
      return value;
    };
    Dialog2.prototype.setMaxHeight = function() {
      if (!this.allowMaxHeight) {
        return;
      }
      var display = this.element.style.display;
      this.element.style.display = "none";
      this.element.style.maxHeight = !isNullOrUndefined(this.target) && this.targetEle.offsetHeight < (undefined).innerHeight ? this.targetEle.offsetHeight - 20 + "px" : (undefined).innerHeight - 20 + "px";
      this.element.style.display = display;
      if (Browser.isIE && this.height === "auto" && !isNullOrUndefined(this.contentEle) && this.element.offsetHeight < this.contentEle.offsetHeight) {
        this.element.style.height = "inherit";
      }
    };
    Dialog2.prototype.setEnableRTL = function() {
      if (!this.isBlazorServerRender()) {
        if (this.enableRtl) {
          addClass([this.element], RTL$4);
        } else {
          removeClass([this.element], RTL$4);
        }
      }
      if (!isNullOrUndefined(this.element.querySelector(".e-resize-handle"))) {
        removeResize();
        this.setResize();
      }
    };
    Dialog2.prototype.setTargetContent = function() {
      var _this = this;
      if (isNullOrUndefined(this.content) || this.content === "") {
        var isContent = this.element.innerHTML.replace(/\s|<(\/?|\/?)(!--!--)>/g, "") !== "";
        if (this.element.children.length > 0 || isContent) {
          this.innerContentElement = (undefined).createDocumentFragment();
          [].slice.call(this.element.childNodes).forEach(function(el) {
            if (el.nodeType !== 8) {
              _this.innerContentElement.appendChild(el);
            }
          });
        }
      }
    };
    Dialog2.prototype.setHeader = function() {
      if (this.headerEle) {
        this.headerEle.innerHTML = "";
      } else {
        this.headerEle = this.createElement("div", { id: this.element.id + "_title", className: DLG_HEADER });
      }
      this.createHeaderContent();
      this.headerContent.appendChild(this.headerEle);
      this.setTemplate(this.header, this.headerEle, "header");
      attributes(this.element, { "aria-describedby": this.element.id + "_title" });
      attributes(this.element, { "aria-labelledby": this.element.id + "_dialog-header" });
      this.element.insertBefore(this.headerContent, this.element.children[0]);
      if (this.allowDragging && !isNullOrUndefined(this.headerContent)) {
        this.setAllowDragging();
      }
    };
    Dialog2.prototype.setFooterTemplate = function() {
      if (this.ftrTemplateContent) {
        this.ftrTemplateContent.innerHTML = "";
      } else {
        this.ftrTemplateContent = this.createElement("div", {
          className: DLG_FOOTER_CONTENT
        });
      }
      if (this.footerTemplate !== "" && !isNullOrUndefined(this.footerTemplate)) {
        this.setTemplate(this.footerTemplate, this.ftrTemplateContent, "footerTemplate");
      } else {
        this.ftrTemplateContent.innerHTML = this.buttonContent.join("");
      }
      this.element.appendChild(this.ftrTemplateContent);
    };
    Dialog2.prototype.createHeaderContent = function() {
      if (isNullOrUndefined(this.headerContent)) {
        this.headerContent = this.createElement("div", { id: this.element.id + "_dialog-header", className: DLG_HEADER_CONTENT });
      }
    };
    Dialog2.prototype.renderCloseIcon = function() {
      if (this.showCloseIcon) {
        this.closeIcon = this.createElement("button", { className: DLG_CLOSE_ICON_BTN, attrs: { type: "button" } });
        this.closeIconBtnObj = new Button({ cssClass: "e-flat", iconCss: DLG_CLOSE_ICON + " " + ICON$1 });
        this.closeIconTitle();
        if (!isNullOrUndefined(this.headerContent)) {
          prepend([this.closeIcon], this.headerContent);
        } else {
          this.createHeaderContent();
          prepend([this.closeIcon], this.headerContent);
          this.element.insertBefore(this.headerContent, this.element.children[0]);
        }
        this.closeIconBtnObj.appendTo(this.closeIcon);
      }
    };
    Dialog2.prototype.closeIconTitle = function() {
      this.l10n.setLocale(this.locale);
      var closeIconTitle = this.l10n.getConstant("close");
      this.closeIcon.setAttribute("title", closeIconTitle);
      this.closeIcon.setAttribute("aria-label", closeIconTitle);
    };
    Dialog2.prototype.setCSSClass = function(oldCSSClass) {
      if (oldCSSClass) {
        removeClass([this.element], oldCSSClass.split(" "));
        if (this.isModal && !isNullOrUndefined(this.dlgContainer)) {
          removeClass([this.dlgContainer], oldCSSClass.split(" "));
        }
      }
      if (this.cssClass) {
        addClass([this.element], this.cssClass.split(" "));
        if (this.isModal && !isNullOrUndefined(this.dlgContainer)) {
          addClass([this.dlgContainer], this.cssClass.split(" "));
        }
      }
    };
    Dialog2.prototype.setIsModal = function() {
      this.dlgContainer = this.createElement("div", { className: DLG_CONTAINER });
      this.setCSSClass();
      this.element.classList.remove(DLG_SHOW);
      this.element.parentNode.insertBefore(this.dlgContainer, this.element);
      this.dlgContainer.appendChild(this.element);
      addClass([this.element], MODAL_DLG);
      this.dlgOverlay = this.createElement("div", { className: DLG_OVERLAY });
      this.dlgOverlay.style.zIndex = (this.zIndex - 1).toString();
      this.dlgContainer.appendChild(this.dlgOverlay);
    };
    Dialog2.prototype.getValidFocusNode = function(items) {
      var node;
      for (var u = 0; u < items.length; u++) {
        node = items[u];
        if ((node.clientHeight > 0 || node.tagName.toLowerCase() === "a" && node.hasAttribute("href")) && node.tabIndex > -1 && !node.disabled && !this.disableElement(node, '[disabled],[aria-disabled="true"],[type="hidden"]')) {
          return node;
        } else {
          node = null;
        }
      }
      return node;
    };
    Dialog2.prototype.focusableElements = function(content) {
      if (!isNullOrUndefined(content)) {
        var value = 'input,select,textarea,button,a,[contenteditable="true"],[tabindex]';
        var items = content.querySelectorAll(value);
        return this.getValidFocusNode(items);
      }
      return null;
    };
    Dialog2.prototype.getAutoFocusNode = function(container) {
      var node = container.querySelector("." + DLG_CLOSE_ICON_BTN);
      var value = "[autofocus]";
      var items = container.querySelectorAll(value);
      var validNode = this.getValidFocusNode(items);
      if (!isNullOrUndefined(validNode)) {
        node = validNode;
      } else {
        validNode = this.focusableElements(this.contentEle);
        if (!isNullOrUndefined(validNode)) {
          return node = validNode;
        } else if (!isNullOrUndefined(this.primaryButtonEle)) {
          return this.element.querySelector("." + DLG_PRIMARY_BUTTON);
        }
      }
      return node;
    };
    Dialog2.prototype.disableElement = function(element2, t) {
      var elementMatch = element2 ? element2.matches || element2.webkitMatchesSelector || element2.msGetRegionContent : null;
      if (elementMatch) {
        for (; element2; element2 = element2.parentNode) {
          if (element2 instanceof Element && elementMatch.call(element2, t)) {
            return element2;
          }
        }
      }
      return null;
    };
    Dialog2.prototype.focusContent = function() {
      var element2 = this.getAutoFocusNode(this.element);
      var node = !isNullOrUndefined(element2) ? element2 : this.element;
      var userAgent = Browser.userAgent;
      if (userAgent.indexOf("MSIE ") > 0 || userAgent.indexOf("Trident/") > 0) {
        this.element.focus();
      }
      node.focus();
      this.unBindEvent(this.element);
      this.bindEvent(this.element);
    };
    Dialog2.prototype.bindEvent = function(element2) {
      EventHandler.add(element2, "keydown", this.keyDown, this);
    };
    Dialog2.prototype.unBindEvent = function(element2) {
      EventHandler.remove(element2, "keydown", this.keyDown);
    };
    Dialog2.prototype.updateSanitizeContent = function() {
      if (!this.isBlazorServerRender()) {
        this.contentEle.innerHTML = this.sanitizeHelper(this.content);
      }
    };
    Dialog2.prototype.isBlazorServerRender = function() {
      return isBlazor();
    };
    Dialog2.prototype.getModuleName = function() {
      return "dialog";
    };
    Dialog2.prototype.onPropertyChanged = function(newProp, oldProp) {
      if (!this.element.classList.contains(ROOT$2)) {
        return;
      }
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "content":
            if (!isNullOrUndefined(this.content) && this.content !== "") {
              if (this.isBlazorServerRender()) {
                this.contentEle = this.element.querySelector(".e-dlg-content");
              }
              if (!isNullOrUndefined(this.contentEle) && this.contentEle.getAttribute("role") !== "dialog") {
                if (!this.isBlazorServerRender()) {
                  this.contentEle.innerHTML = "";
                }
                if (typeof this.content === "function") {
                  this.clearTemplate(["content"]);
                  detach(this.contentEle);
                  this.contentEle = null;
                  this.setContent();
                } else {
                  if (typeof this.content === "string") {
                    this.updateSanitizeContent();
                  } else {
                    this.contentEle.appendChild(this.content);
                  }
                }
                this.setMaxHeight();
              } else {
                this.setContent();
              }
            } else if (!isNullOrUndefined(this.contentEle)) {
              detach(this.contentEle);
              this.contentEle = null;
            }
            break;
          case "header":
            if (this.header === "" || isNullOrUndefined(this.header)) {
              if (this.headerEle) {
                detach(this.headerEle);
                this.headerEle = null;
              }
            } else {
              this.setHeader();
            }
            break;
          case "footerTemplate":
            if (this.footerTemplate === "" || isNullOrUndefined(this.footerTemplate)) {
              if (!this.ftrTemplateContent) {
                return;
              }
              detach(this.ftrTemplateContent);
              this.ftrTemplateContent = null;
              this.buttons = [{}];
            } else {
              this.setFooterTemplate();
              this.buttons = [{}];
            }
            break;
          case "showCloseIcon":
            if (this.element.getElementsByClassName(DLG_CLOSE_ICON).length > 0) {
              if (!this.showCloseIcon && (this.header === "" || isNullOrUndefined(this.header))) {
                detach(this.headerContent);
                this.headerContent = null;
              } else if (!this.showCloseIcon) {
                detach(this.closeIcon);
              }
            } else {
              this.renderCloseIcon();
              this.wireEvents();
            }
            break;
          case "locale":
            if (this.showCloseIcon) {
              this.closeIconTitle();
            }
            break;
          case "visible":
            if (this.visible) {
              this.show();
            } else {
              this.hide();
            }
            break;
          case "isModal":
            this.updateIsModal();
            break;
          case "height":
            setStyleAttribute(this.element, { "height": formatUnit(newProp.height) });
            this.updatePersistData();
            break;
          case "width":
            setStyleAttribute(this.element, { "width": formatUnit(newProp.width) });
            this.updatePersistData();
            break;
          case "zIndex":
            this.popupObj.zIndex = this.zIndex;
            if (this.isModal) {
              this.setOverlayZindex(this.zIndex);
            }
            if (this.element.style.zIndex !== this.zIndex.toString()) {
              this.calculatezIndex = false;
            }
            break;
          case "cssClass":
            this.setCSSClass(oldProp.cssClass);
            break;
          case "buttons": {
            this.unWireButtonEvents();
            this.destroyButtons();
            if (!isNullOrUndefined(this.ftrTemplateContent)) {
              detach(this.ftrTemplateContent);
              this.ftrTemplateContent = null;
            }
            this.footerTemplate = "";
            this.setButton();
            break;
          }
          case "allowDragging":
            if (this.allowDragging && !isNullOrUndefined(this.headerContent)) {
              this.setAllowDragging();
            } else {
              this.dragObj.destroy();
            }
            break;
          case "target":
            this.setTarget(newProp.target);
            break;
          case "position":
            this.checkPositionData();
            if (this.isModal) {
              var positionX = this.position.X;
              var positionY = this.position.Y;
              if (!isNullOrUndefined(oldProp.position)) {
                if (!isNullOrUndefined(oldProp.position.X)) {
                  positionX = oldProp.position.X;
                }
                if (!isNullOrUndefined(oldProp.position.Y)) {
                  positionY = oldProp.position.Y;
                }
              }
              if (this.dlgContainer.classList.contains("e-dlg-" + positionX + "-" + positionY)) {
                this.dlgContainer.classList.remove("e-dlg-" + positionX + "-" + positionY);
              }
            }
            this.positionChange();
            this.updatePersistData();
            break;
          case "enableRtl":
            this.setEnableRTL();
            break;
          case "enableResize":
            this.setResize();
            this.isModelResize = this.enableResize && this.isModal;
            if (this.enableResize && this.dialogOpen) {
              this.resetResizeIcon();
            }
            break;
          case "minHeight":
            if (this.minHeight !== "") {
              this.element.style.minHeight = formatUnit(this.minHeight);
            }
            break;
        }
      }
    };
    Dialog2.prototype.setTarget = function(target) {
      this.popupObj.relateTo = target;
      this.target = target;
      this.targetEle = typeof this.target === "string" ? (undefined).querySelector(this.target) : this.target;
      if (this.dragObj) {
        this.dragObj.dragArea = this.targetEle;
      }
      this.setMaxHeight();
      if (this.isModal) {
        this.updateIsModal();
      }
      if (this.enableResize) {
        this.setResize();
      }
      if (!isNullOrUndefined(this.targetEle)) {
        if (this.isModal && !isNullOrUndefined(this.dlgContainer)) {
          this.targetEle.appendChild(this.dlgContainer);
        } else if (!isNullOrUndefined(this.element)) {
          this.targetEle.appendChild(this.element);
        }
      }
    };
    Dialog2.prototype.updateIsModal = function() {
      this.element.setAttribute("aria-modal", this.isModal ? "true" : "false");
      if (this.isModal) {
        if (isNullOrUndefined(this.dlgOverlay)) {
          this.setIsModal();
          this.element.style.top = "0px";
          this.element.style.left = "0px";
          if (!isNullOrUndefined(this.targetEle)) {
            this.targetEle.appendChild(this.dlgContainer);
          }
        }
      } else {
        removeClass([this.element], MODAL_DLG);
        removeClass([(undefined).body], [DLG_TARGET, SCROLL_DISABLED]);
        detach(this.dlgOverlay);
        while (this.dlgContainer.firstChild) {
          this.dlgContainer.parentElement.insertBefore(this.dlgContainer.firstChild, this.dlgContainer);
        }
        this.dlgContainer.parentElement.removeChild(this.dlgContainer);
      }
      if (this.visible) {
        this.show();
      }
      this.positionChange();
      if (this.isModal && this.dlgOverlay) {
        EventHandler.add(this.dlgOverlay, "click", this.dlgOverlayClickEventHandler, this);
      }
    };
    Dialog2.prototype.setzIndex = function(zIndexElement, setPopupZindex) {
      var prevOnChange = this.isProtectedOnChange;
      this.isProtectedOnChange = true;
      var currentzIndex = getZindexPartial(zIndexElement);
      this.zIndex = currentzIndex > this.zIndex ? currentzIndex : this.zIndex;
      this.isProtectedOnChange = prevOnChange;
      if (setPopupZindex) {
        this.popupObj.zIndex = this.zIndex;
      }
    };
    Dialog2.prototype.windowResizeHandler = function() {
      setMaxWidth(this.targetEle.clientWidth);
      setMaxHeight(this.targetEle.clientHeight);
      this.setMaxHeight();
    };
    Dialog2.prototype.getPersistData = function() {
      return this.addOnPersist(["width", "height", "position"]);
    };
    Dialog2.prototype.removeAllChildren = function(element2) {
      while (element2.children[0]) {
        this.removeAllChildren(element2.children[0]);
        element2.removeChild(element2.children[0]);
      }
    };
    Dialog2.prototype.destroy = function() {
      if (this.isDestroyed) {
        return;
      }
      var classArray = [RTL$4, MODAL_DLG, DLG_RESIZABLE, DLG_RESTRICT_LEFT_VALUE, FULLSCREEN, DEVICE$1];
      var attrs = ["role", "aria-modal", "aria-labelledby", "aria-describedby", "aria-grabbed", "tabindex", "style"];
      removeClass([this.targetEle], [DLG_TARGET, SCROLL_DISABLED]);
      if (!isNullOrUndefined(this.element) && this.element.classList.contains(FULLSCREEN)) {
        removeClass([(undefined).body], [DLG_TARGET, SCROLL_DISABLED]);
      }
      if (this.isModal) {
        removeClass([!isNullOrUndefined(this.targetEle) ? this.targetEle : (undefined).body], SCROLL_DISABLED);
      }
      this.unWireEvents();
      this.unWireButtonEvents();
      this.destroyButtons();
      if (!isNullOrUndefined(this.closeIconBtnObj)) {
        this.closeIconBtnObj.destroy();
      }
      if (!isNullOrUndefined(this.dragObj)) {
        this.dragObj.destroy();
      }
      if (!isNullOrUndefined(this.popupObj.element) && this.popupObj.element.classList.contains(POPUP_ROOT$1)) {
        this.popupObj.destroy();
      }
      removeClass([this.element], classArray);
      if (!isNullOrUndefined(this.cssClass) && this.cssClass !== "") {
        removeClass([this.element], this.cssClass.split(" "));
      }
      if (!isNullOrUndefined(this.refElement) && !isNullOrUndefined(this.refElement.parentElement)) {
        this.refElement.parentElement.insertBefore(this.isModal ? this.dlgContainer : this.element, this.refElement);
        detach(this.refElement);
        this.refElement = undefined;
      }
      if (this.isModal) {
        detach(this.dlgOverlay);
        this.dlgContainer.parentNode.insertBefore(this.element, this.dlgContainer);
        detach(this.dlgContainer);
      }
      this.element.innerHTML = this.clonedEle.innerHTML;
      for (var i = 0; i < attrs.length; i++) {
        this.element.removeAttribute(attrs[i]);
      }
      this.ftrTemplateContent = null;
      this.headerContent = null;
      if (!this.isReact && !this.isVue && !isNullOrUndefined(this.contentEle)) {
        this.removeAllChildren(this.contentEle);
      }
      this.contentEle = null;
      resizeDestroy();
      _super.prototype.destroy.call(this);
      if (this.isReact) {
        this.clearTemplate();
      }
    };
    Dialog2.prototype.wireWindowResizeEvent = function() {
      this.boundWindowResizeHandler = this.windowResizeHandler.bind(this);
      (undefined).addEventListener("resize", this.boundWindowResizeHandler);
    };
    Dialog2.prototype.unWireWindowResizeEvent = function() {
      (undefined).removeEventListener("resize", this.boundWindowResizeHandler);
      this.boundWindowResizeHandler = null;
    };
    Dialog2.prototype.wireEvents = function() {
      if (this.showCloseIcon) {
        EventHandler.add(this.closeIcon, "click", this.closeIconClickEventHandler, this);
      }
      if (this.isModal && this.dlgOverlay) {
        EventHandler.add(this.dlgOverlay, "click", this.dlgOverlayClickEventHandler, this);
      }
    };
    Dialog2.prototype.unWireEvents = function() {
      if (this.showCloseIcon) {
        EventHandler.remove(this.closeIcon, "click", this.closeIconClickEventHandler);
      }
      if (this.isModal) {
        EventHandler.remove(this.dlgOverlay, "click", this.dlgOverlayClickEventHandler);
      }
    };
    Dialog2.prototype.refreshPosition = function() {
      this.popupObj.refreshPosition();
      if (this.element.classList.contains(MODAL_DLG)) {
        this.positionChange();
      }
    };
    Dialog2.prototype.getDimension = function() {
      var dialogWidth = this.element.offsetWidth;
      var dialogHeight = this.element.offsetHeight;
      return { width: dialogWidth, height: dialogHeight };
    };
    Dialog2.prototype.show = function(isFullScreen) {
      var _this = this;
      if (!this.element.classList.contains(ROOT$2)) {
        return;
      }
      if (!this.element.classList.contains(DLG_SHOW) || !isNullOrUndefined(isFullScreen)) {
        if (!isNullOrUndefined(isFullScreen)) {
          this.fullScreen(isFullScreen);
        }
        var eventArgs_1 = {
          cancel: false,
          element: this.element,
          container: this.isModal ? this.dlgContainer : this.element,
          target: this.target,
          maxHeight: this.element.style.maxHeight
        };
        this.trigger("beforeOpen", eventArgs_1, function(beforeOpenArgs) {
          if (!beforeOpenArgs.cancel) {
            if (_this.element.style.maxHeight !== eventArgs_1.maxHeight) {
              _this.allowMaxHeight = false;
              _this.element.style.maxHeight = eventArgs_1.maxHeight;
            }
            if (_this.enableResize && _this.boundWindowResizeHandler == null && !_this.initialRender) {
              _this.wireWindowResizeEvent();
            }
            _this.storeActiveElement = (undefined).activeElement;
            _this.element.tabIndex = -1;
            if (_this.isModal && !isNullOrUndefined(_this.dlgOverlay)) {
              _this.dlgOverlay.style.display = "block";
              _this.dlgContainer.style.display = "flex";
              removeClass([_this.dlgOverlay], "e-fade");
              if (!isNullOrUndefined(_this.targetEle)) {
                if (_this.targetEle === (undefined).body) {
                  _this.dlgContainer.style.position = "fixed";
                } else {
                  _this.dlgContainer.style.position = "absolute";
                }
                _this.dlgOverlay.style.position = "absolute";
                var targetType = _this.getTargetContainer(_this.target);
                if (targetType instanceof Element) {
                  var computedStyle = (undefined).getComputedStyle(targetType);
                  if (computedStyle.getPropertyValue("direction") === "rtl") {
                    _this.element.style.position = "absolute";
                  } else {
                    _this.element.style.position = "relative";
                  }
                } else {
                  _this.element.style.position = "relative";
                }
                addClass([_this.targetEle], [DLG_TARGET, SCROLL_DISABLED]);
              } else {
                addClass([(undefined).body], [DLG_TARGET, SCROLL_DISABLED]);
              }
            }
            var openAnimation = {
              name: _this.animationSettings.effect === "None" && animationMode === "Enable" ? "ZoomIn" : _this.animationSettings.effect + "In",
              duration: _this.animationSettings.duration,
              delay: _this.animationSettings.delay
            };
            var zIndexElement = _this.isModal ? _this.element.parentElement : _this.element;
            if (_this.calculatezIndex) {
              _this.setzIndex(zIndexElement, true);
              setStyleAttribute(_this.element, { "zIndex": _this.zIndex });
              if (_this.isModal) {
                _this.setOverlayZindex(_this.zIndex);
              }
            }
            _this.animationSettings.effect === "None" && animationMode === "Enable" ? _this.popupObj.show(openAnimation) : _this.animationSettings.effect === "None" ? _this.popupObj.show() : _this.popupObj.show(openAnimation);
            if (_this.isModal) {
              var targetType = _this.getTargetContainer(_this.target);
              if (targetType instanceof Element) {
                var computedStyle = (undefined).getComputedStyle(targetType);
                if (computedStyle.getPropertyValue("direction") === "rtl" && !_this.IsDragStop) {
                  _this.setPopupPosition();
                }
              }
            }
            _this.dialogOpen = true;
            var prevOnChange = _this.isProtectedOnChange;
            _this.isProtectedOnChange = true;
            _this.visible = true;
            _this.preventVisibility = true;
            _this.isProtectedOnChange = prevOnChange;
          }
        });
      }
      if (this.isReact) {
        this.renderReactTemplates();
      }
    };
    Dialog2.prototype.hide = function(event) {
      var _this = this;
      if (!this.element.classList.contains(ROOT$2)) {
        return;
      }
      if (this.preventVisibility) {
        var eventArgs = {
          cancel: false,
          isInteracted: event ? true : false,
          element: this.element,
          target: this.target,
          container: this.isModal ? this.dlgContainer : this.element,
          event,
          closedBy: this.dlgClosedBy
        };
        this.closeArgs = eventArgs;
        this.trigger("beforeClose", eventArgs, function(beforeCloseArgs) {
          if (!beforeCloseArgs.cancel) {
            if (_this.enableResize) {
              _this.unWireWindowResizeEvent();
            }
            var closeAnimation = {
              name: _this.animationSettings.effect === "None" && animationMode === "Enable" ? "ZoomOut" : _this.animationSettings.effect + "Out",
              duration: _this.animationSettings.duration,
              delay: _this.animationSettings.delay
            };
            if (_this.animationSettings.effect === "None" && animationMode === "Enable") ;
            else if (_this.animationSettings.effect === "None") {
              _this.popupObj.hide();
            } else {
              _this.popupObj.hide(closeAnimation);
            }
            setTimeout(function() {
              if (_this.isModal) {
                if (!isNullOrUndefined(_this.targetEle) && _this.targetEle.classList.contains(DLG_TARGET) && _this.targetEle.classList.contains(SCROLL_DISABLED)) {
                  removeClass([_this.targetEle], [DLG_TARGET, SCROLL_DISABLED]);
                }
              }
              if ((undefined).body.classList.contains(DLG_TARGET) && (undefined).body.classList.contains(SCROLL_DISABLED)) {
                removeClass([(undefined).body], [DLG_TARGET, SCROLL_DISABLED]);
              }
            }, _this.animationSettings.duration + _this.animationSettings.delay);
            _this.dialogOpen = false;
            var prevOnChange = _this.isProtectedOnChange;
            _this.isProtectedOnChange = true;
            _this.visible = false;
            _this.preventVisibility = false;
            _this.isProtectedOnChange = prevOnChange;
          }
          _this.dlgClosedBy = DLG_USER_ACTION_CLOSED;
        });
      }
    };
    Dialog2.prototype.fullScreen = function(args) {
      this.element.offsetTop;
      this.element.offsetLeft;
      if (args) {
        if (!this.isModal) {
          this.element.style.top = (undefined).scrollingElement.scrollTop + "px";
        }
        addClass([this.element], FULLSCREEN);
        var display = this.element.style.display;
        this.element.style.display = "none";
        this.element.style.maxHeight = !isNullOrUndefined(this.target) ? this.targetEle.offsetHeight + "px" : (undefined).innerHeight + "px";
        this.element.style.display = display;
        addClass([(undefined).body], [DLG_TARGET, SCROLL_DISABLED]);
        if (this.allowDragging && !isNullOrUndefined(this.dragObj)) {
          this.dragObj.destroy();
        }
      } else {
        removeClass([this.element], FULLSCREEN);
        removeClass([(undefined).body], [DLG_TARGET, SCROLL_DISABLED]);
        if (this.allowDragging && !isNullOrUndefined(this.headerContent)) {
          this.setAllowDragging();
        }
      }
      return args;
    };
    Dialog2.prototype.getButtons = function(index) {
      if (!isNullOrUndefined(index)) {
        return this.btnObj[index];
      }
      return this.btnObj;
    };
    Dialog2.prototype.unWireButtonEvents = function() {
      if (this.buttons.length > 0 && this.footerTemplate === "" && this.ftrTemplateContent) {
        for (var i = 0; i < this.buttons.length; i++) {
          if (this.buttons[i].click && typeof this.buttons[i].click === "function" && this.ftrTemplateContent.children[i]) {
            EventHandler.remove(this.ftrTemplateContent.children[i], "click", this.buttons[i].click);
          }
        }
      }
    };
    Dialog2.prototype.destroyButtons = function() {
      if (!isNullOrUndefined(this.btnObj)) {
        for (var i = 0; i < this.btnObj.length; i++) {
          if (this.btnObj[i] && !this.btnObj[i].isDestroyed) {
            this.btnObj[i].destroy();
          }
        }
      }
    };
    __decorate$d([
      Property("")
    ], Dialog2.prototype, "content", undefined);
    __decorate$d([
      Property(true)
    ], Dialog2.prototype, "enableHtmlSanitizer", undefined);
    __decorate$d([
      Property(false)
    ], Dialog2.prototype, "enablePersistence", undefined);
    __decorate$d([
      Property(false)
    ], Dialog2.prototype, "showCloseIcon", undefined);
    __decorate$d([
      Property(false)
    ], Dialog2.prototype, "isModal", undefined);
    __decorate$d([
      Property("")
    ], Dialog2.prototype, "header", undefined);
    __decorate$d([
      Property(true)
    ], Dialog2.prototype, "visible", undefined);
    __decorate$d([
      Property(false)
    ], Dialog2.prototype, "enableResize", undefined);
    __decorate$d([
      Property(["South-East"])
    ], Dialog2.prototype, "resizeHandles", undefined);
    __decorate$d([
      Property("auto")
    ], Dialog2.prototype, "height", undefined);
    __decorate$d([
      Property("")
    ], Dialog2.prototype, "minHeight", undefined);
    __decorate$d([
      Property("100%")
    ], Dialog2.prototype, "width", undefined);
    __decorate$d([
      Property("")
    ], Dialog2.prototype, "cssClass", undefined);
    __decorate$d([
      Property(1e3)
    ], Dialog2.prototype, "zIndex", undefined);
    __decorate$d([
      Property(null)
    ], Dialog2.prototype, "target", undefined);
    __decorate$d([
      Property("")
    ], Dialog2.prototype, "footerTemplate", undefined);
    __decorate$d([
      Property(false)
    ], Dialog2.prototype, "allowDragging", undefined);
    __decorate$d([
      Collection([{}], ButtonProps)
    ], Dialog2.prototype, "buttons", undefined);
    __decorate$d([
      Property(true)
    ], Dialog2.prototype, "closeOnEscape", undefined);
    __decorate$d([
      Complex({}, AnimationSettings)
    ], Dialog2.prototype, "animationSettings", undefined);
    __decorate$d([
      Complex({ X: "center", Y: "center" }, PositionData)
    ], Dialog2.prototype, "position", undefined);
    __decorate$d([
      Event()
    ], Dialog2.prototype, "created", undefined);
    __decorate$d([
      Event()
    ], Dialog2.prototype, "open", undefined);
    __decorate$d([
      Event()
    ], Dialog2.prototype, "beforeSanitizeHtml", undefined);
    __decorate$d([
      Event()
    ], Dialog2.prototype, "beforeOpen", undefined);
    __decorate$d([
      Event()
    ], Dialog2.prototype, "close", undefined);
    __decorate$d([
      Event()
    ], Dialog2.prototype, "beforeClose", undefined);
    __decorate$d([
      Event()
    ], Dialog2.prototype, "dragStart", undefined);
    __decorate$d([
      Event()
    ], Dialog2.prototype, "dragStop", undefined);
    __decorate$d([
      Event()
    ], Dialog2.prototype, "drag", undefined);
    __decorate$d([
      Event()
    ], Dialog2.prototype, "overlayClick", undefined);
    __decorate$d([
      Event()
    ], Dialog2.prototype, "resizeStart", undefined);
    __decorate$d([
      Event()
    ], Dialog2.prototype, "resizing", undefined);
    __decorate$d([
      Event()
    ], Dialog2.prototype, "resizeStop", undefined);
    __decorate$d([
      Event()
    ], Dialog2.prototype, "destroyed", undefined);
    Dialog2 = __decorate$d([
      NotifyPropertyChanges
    ], Dialog2);
    return Dialog2;
  }(Component)
);
var DialogUtility;
(function(DialogUtility2) {
  function alert(args) {
    var dialogElement = createElement("div", { "className": DLG_UTIL_ALERT });
    (undefined).body.appendChild(dialogElement);
    var alertDialogObj;
    var okButtonModel = [{
      buttonModel: { isPrimary: true, content: "OK" },
      click: function() {
        this.hide();
      }
    }];
    if (typeof args === "string") {
      alertDialogObj = createDialog({
        content: args,
        position: { X: "center", Y: "top" },
        isModal: true,
        header: DLG_UTIL_DEFAULT_TITLE,
        buttons: okButtonModel
      }, dialogElement);
    } else {
      alertDialogObj = createDialog(alertOptions(args), dialogElement);
    }
    alertDialogObj.close = function() {
      if (args && args.close) {
        args.close.apply(alertDialogObj);
      }
      alertDialogObj.destroy();
      if (alertDialogObj.element.classList.contains("e-dlg-modal")) {
        alertDialogObj.element.parentElement.remove();
        alertDialogObj.target.classList.remove(DLG_UTIL_ROOT);
      } else {
        alertDialogObj.element.remove();
      }
    };
    return alertDialogObj;
  }
  DialogUtility2.alert = alert;
  function confirm(args) {
    var dialogElement = createElement("div", { "className": DLG_UTIL_CONFIRM });
    (undefined).body.appendChild(dialogElement);
    var confirmDialogObj;
    var okCancelButtonModel = [{
      buttonModel: { isPrimary: true, content: "OK" },
      click: function() {
        this.hide();
      }
    }, {
      buttonModel: { content: "Cancel" },
      click: function() {
        this.hide();
      }
    }];
    if (typeof args === "string") {
      confirmDialogObj = createDialog({
        position: { X: "center", Y: "top" },
        content: args,
        isModal: true,
        header: DLG_UTIL_DEFAULT_TITLE,
        buttons: okCancelButtonModel
      }, dialogElement);
    } else {
      confirmDialogObj = createDialog(confirmOptions(args), dialogElement);
    }
    confirmDialogObj.close = function() {
      if (args && args.close) {
        args.close.apply(confirmDialogObj);
      }
      confirmDialogObj.destroy();
      if (confirmDialogObj.element.classList.contains("e-dlg-modal")) {
        confirmDialogObj.element.parentElement.remove();
        confirmDialogObj.target.classList.remove(DLG_UTIL_ROOT);
      } else {
        confirmDialogObj.element.remove();
      }
    };
    return confirmDialogObj;
  }
  DialogUtility2.confirm = confirm;
  function createDialog(options, element2) {
    var dialogObject = new Dialog(options);
    dialogObject.appendTo(element2);
    return dialogObject;
  }
  function alertOptions(option) {
    var options = {};
    options.buttons = [];
    options = formOptions(options, option);
    options = setAlertButtonModel(options, option);
    return options;
  }
  function confirmOptions(option) {
    var options = {};
    options.buttons = [];
    options = formOptions(options, option);
    options = setConfirmButtonModel(options, option);
    return options;
  }
  function formOptions(options, option) {
    options.header = !isNullOrUndefined(option.title) ? option.title : null;
    options.content = !isNullOrUndefined(option.content) ? option.content : "";
    options.isModal = !isNullOrUndefined(option.isModal) ? option.isModal : true;
    options.showCloseIcon = !isNullOrUndefined(option.showCloseIcon) ? option.showCloseIcon : false;
    options.allowDragging = !isNullOrUndefined(option.isDraggable) ? option.isDraggable : false;
    options.closeOnEscape = !isNullOrUndefined(option.closeOnEscape) ? option.closeOnEscape : false;
    options.position = !isNullOrUndefined(option.position) ? option.position : { X: "center", Y: "top" };
    options.animationSettings = !isNullOrUndefined(option.animationSettings) ? option.animationSettings : { effect: "Fade", duration: 400, delay: 0 };
    options.cssClass = !isNullOrUndefined(option.cssClass) ? option.cssClass : "";
    options.zIndex = !isNullOrUndefined(option.zIndex) ? option.zIndex : 1e3;
    options.open = !isNullOrUndefined(option.open) ? option.open : null;
    options.width = !isNullOrUndefined(option.width) ? option.width : "auto";
    options.height = !isNullOrUndefined(option.height) ? option.height : "auto";
    return options;
  }
  function setAlertButtonModel(options, option) {
    var alertButtonModel = [{
      buttonModel: { isPrimary: true, content: "OK" },
      click: function() {
        this.hide();
      }
    }];
    if (!isNullOrUndefined(option.okButton)) {
      options.buttons[0] = formButtonModel(options.buttons[0], option.okButton, alertButtonModel[0]);
    } else {
      options.buttons = alertButtonModel;
    }
    return options;
  }
  function setConfirmButtonModel(options, option) {
    var okButtonModel = {
      buttonModel: { isPrimary: true, content: "OK" },
      click: function() {
        this.hide();
      }
    };
    var cancelButtonModel = {
      buttonModel: { content: "Cancel" },
      click: function() {
        this.hide();
      }
    };
    if (!isNullOrUndefined(option.okButton)) {
      options.buttons[0] = formButtonModel(options.buttons[0], option.okButton, okButtonModel);
    } else {
      options.buttons[0] = okButtonModel;
    }
    if (!isNullOrUndefined(option.cancelButton)) {
      options.buttons[1] = formButtonModel(options.buttons[1], option.cancelButton, cancelButtonModel);
    } else {
      options.buttons[1] = cancelButtonModel;
    }
    return options;
  }
  function formButtonModel(buttonModel, option, buttonPropModel) {
    var buttonProps = buttonPropModel;
    if (!isNullOrUndefined(option.text)) {
      buttonProps.buttonModel.content = option.text;
    }
    if (!isNullOrUndefined(option.icon)) {
      buttonProps.buttonModel.iconCss = option.icon;
    }
    if (!isNullOrUndefined(option.cssClass)) {
      buttonProps.buttonModel.cssClass = option.cssClass;
    }
    if (!isNullOrUndefined(option.click)) {
      buttonProps.click = option.click;
    }
    if (!isNullOrUndefined(option.isFlat)) {
      buttonProps.isFlat = option.isFlat;
    }
    return buttonProps;
  }
})(DialogUtility || (DialogUtility = {}));
var __extends$c = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate$c = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var TOUCHEND_HIDE_DELAY = 1500;
var TAPHOLD_THRESHOLD = 500;
var SHOW_POINTER_TIP_GAP = 0;
var HIDE_POINTER_TIP_GAP = 8;
var MOUSE_TRAIL_GAP = 2;
var POINTER_ADJUST = 2;
var ROOT$1 = "e-tooltip";
var RTL$3 = "e-rtl";
var DEVICE = "e-bigger";
var ICON = "e-icons";
var CLOSE = "e-tooltip-close";
var TOOLTIP_WRAP = "e-tooltip-wrap";
var CONTENT = "e-tip-content";
var ARROW_TIP = "e-arrow-tip";
var ARROW_TIP_OUTER = "e-arrow-tip-outer";
var ARROW_TIP_INNER = "e-arrow-tip-inner";
var TIP_BOTTOM = "e-tip-bottom";
var TIP_TOP = "e-tip-top";
var TIP_LEFT = "e-tip-left";
var TIP_RIGHT = "e-tip-right";
var POPUP_ROOT = "e-popup";
var POPUP_OPEN = "e-popup-open";
var POPUP_CLOSE = "e-popup-close";
var POPUP_LIB = "e-lib";
var HIDE_POPUP = "e-hidden";
var POPUP_CONTAINER = "e-tooltip-popup-container";
var Animation = (
  /** @class */
  function(_super) {
    __extends$c(Animation2, _super);
    function Animation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$c([
      Property({ effect: "FadeIn", duration: 150, delay: 0 })
    ], Animation2.prototype, "open", undefined);
    __decorate$c([
      Property({ effect: "FadeOut", duration: 150, delay: 0 })
    ], Animation2.prototype, "close", undefined);
    return Animation2;
  }(ChildProperty)
);
var Tooltip = (
  /** @class */
  function(_super) {
    __extends$c(Tooltip2, _super);
    function Tooltip2(options, element2) {
      var _this = _super.call(this, options, element2) || this;
      _this.mouseMoveEvent = null;
      _this.mouseMoveTarget = null;
      _this.containerElement = null;
      _this.isBodyContainer = true;
      return _this;
    }
    Tooltip2.prototype.initialize = function() {
      this.formatPosition();
      addClass([this.element], ROOT$1);
    };
    Tooltip2.prototype.formatPosition = function() {
      var _a, _b;
      if (!this.position) {
        return;
      }
      if (this.position.indexOf("Top") === 0 || this.position.indexOf("Bottom") === 0) {
        _a = this.position.split(/(?=[A-Z])/), this.tooltipPositionY = _a[0], this.tooltipPositionX = _a[1];
      } else {
        _b = this.position.split(/(?=[A-Z])/), this.tooltipPositionX = _b[0], this.tooltipPositionY = _b[1];
      }
    };
    Tooltip2.prototype.renderArrow = function() {
      this.setTipClass(this.position);
      var tip = this.createElement("div", { className: ARROW_TIP + " " + this.tipClass });
      tip.appendChild(this.createElement("div", { className: ARROW_TIP_OUTER + " " + this.tipClass }));
      tip.appendChild(this.createElement("div", { className: ARROW_TIP_INNER + " " + this.tipClass }));
      this.tooltipEle.appendChild(tip);
    };
    Tooltip2.prototype.setTipClass = function(position) {
      if (position.indexOf("Right") === 0) {
        this.tipClass = TIP_LEFT;
      } else if (position.indexOf("Bottom") === 0) {
        this.tipClass = TIP_TOP;
      } else if (position.indexOf("Left") === 0) {
        this.tipClass = TIP_RIGHT;
      } else {
        this.tipClass = TIP_BOTTOM;
      }
    };
    Tooltip2.prototype.renderPopup = function(target) {
      var elePos = this.mouseTrail ? { top: 0, left: 0 } : this.getTooltipPosition(target);
      this.tooltipEle.classList.remove(POPUP_LIB);
      this.popupObj = new Popup(this.tooltipEle, {
        height: this.height,
        width: this.width,
        position: { X: elePos.left, Y: elePos.top },
        enableRtl: this.enableRtl,
        open: this.openPopupHandler.bind(this),
        close: this.closePopupHandler.bind(this)
      });
    };
    Tooltip2.prototype.getScalingFactor = function(target) {
      if (!target) {
        return { x: 1, y: 1 };
      }
      var scalingFactors = { x: 1, y: 1 };
      var elementsWithTransform = target.closest('[style*="transform: scale"]');
      if (elementsWithTransform && elementsWithTransform !== this.tooltipEle && elementsWithTransform.contains(this.tooltipEle)) {
        var computedStyle = (undefined).getComputedStyle(elementsWithTransform);
        var transformValue = computedStyle.getPropertyValue("transform");
        var matrixValues = transformValue.match(/matrix\(([^)]+)\)/)[1].split(",").map(parseFloat);
        scalingFactors.x = matrixValues[0];
        scalingFactors.y = matrixValues[3];
      }
      return scalingFactors;
    };
    Tooltip2.prototype.getTooltipPosition = function(target) {
      this.tooltipEle.style.display = "block";
      var parentWithZoomStyle = this.element.closest('[style*="zoom"]');
      if (parentWithZoomStyle) {
        if (!parentWithZoomStyle.contains(this.tooltipEle)) {
          this.tooltipEle.style.zoom = getComputedStyle(parentWithZoomStyle).zoom;
        }
      }
      var pos = calculatePosition(target, this.tooltipPositionX, this.tooltipPositionY, !this.isBodyContainer, this.isBodyContainer ? null : this.containerElement.getBoundingClientRect());
      var scalingFactors = this.getScalingFactor(target);
      var offsetPos = this.calculateTooltipOffset(this.position, scalingFactors.x, scalingFactors.y);
      var collisionPosition = this.calculateElementPosition(pos, offsetPos);
      var collisionLeft = collisionPosition[0];
      var collisionTop = collisionPosition[1];
      var elePos = this.collisionFlipFit(target, collisionLeft, collisionTop);
      elePos.left = elePos.left / scalingFactors.x;
      elePos.top = elePos.top / scalingFactors.y;
      this.tooltipEle.style.display = "";
      return elePos;
    };
    Tooltip2.prototype.windowResize = function() {
      this.reposition(this.findTarget());
    };
    Tooltip2.prototype.reposition = function(target) {
      if (this.popupObj && target) {
        var elePos = this.getTooltipPosition(target);
        this.popupObj.position = { X: elePos.left, Y: elePos.top };
        this.popupObj.dataBind();
      }
    };
    Tooltip2.prototype.openPopupHandler = function() {
      if (!this.mouseTrail && this.needTemplateReposition()) {
        this.reposition(this.findTarget());
      }
      this.trigger("afterOpen", this.tooltipEventArgs);
      this.tooltipEventArgs = null;
    };
    Tooltip2.prototype.closePopupHandler = function() {
      if (this.isReact && !(this.opensOn === "Click" || typeof this.content === "function")) {
        this.clearTemplate(["content"]);
      }
      this.clear();
      var tooltipAfterCloseEventArgs = {
        type: this.tooltipEventArgs.event ? this.tooltipEventArgs.event.type : null,
        cancel: false,
        target: this.tooltipEventArgs.target,
        event: this.tooltipEventArgs.event ? this.tooltipEventArgs.event : null,
        element: this.tooltipEle,
        isInteracted: !isNullOrUndefined(this.tooltipEventArgs.event)
      };
      this.trigger("afterClose", tooltipAfterCloseEventArgs);
      tooltipAfterCloseEventArgs = null;
    };
    Tooltip2.prototype.calculateTooltipOffset = function(position, xScalingFactor, yScalingFactor) {
      if (xScalingFactor === undefined) {
        xScalingFactor = 1;
      }
      if (yScalingFactor === undefined) {
        yScalingFactor = 1;
      }
      var pos = { top: 0, left: 0 };
      var tipWidth;
      var tipHeight;
      var tooltipEleWidth;
      var tooltipEleHeight;
      var arrowEle;
      var tipAdjust;
      var tipHeightAdjust;
      var tipWidthAdjust;
      if (xScalingFactor !== 1 || yScalingFactor !== 1) {
        var tooltipEleRect = this.tooltipEle.getBoundingClientRect();
        var arrowEleRect = undefined;
        tooltipEleWidth = Math.round(tooltipEleRect.width);
        tooltipEleHeight = Math.round(tooltipEleRect.height);
        arrowEle = select("." + ARROW_TIP, this.tooltipEle);
        if (arrowEle) {
          arrowEleRect = arrowEle.getBoundingClientRect();
        }
        tipWidth = arrowEle ? Math.round(arrowEleRect.width) : 0;
        tipHeight = arrowEle ? Math.round(arrowEleRect.height) : 0;
        tipAdjust = this.showTipPointer ? SHOW_POINTER_TIP_GAP : HIDE_POINTER_TIP_GAP;
        tipHeightAdjust = tipHeight / 2 + POINTER_ADJUST + (tooltipEleHeight - this.tooltipEle.clientHeight * yScalingFactor);
        tipWidthAdjust = tipWidth / 2 + POINTER_ADJUST + (tooltipEleWidth - this.tooltipEle.clientWidth * xScalingFactor);
      } else {
        tooltipEleWidth = this.tooltipEle.offsetWidth;
        tooltipEleHeight = this.tooltipEle.offsetHeight;
        arrowEle = select("." + ARROW_TIP, this.tooltipEle);
        tipWidth = arrowEle ? arrowEle.offsetWidth : 0;
        tipHeight = arrowEle ? arrowEle.offsetHeight : 0;
        tipAdjust = this.showTipPointer ? SHOW_POINTER_TIP_GAP : HIDE_POINTER_TIP_GAP;
        tipHeightAdjust = tipHeight / 2 + POINTER_ADJUST + (this.tooltipEle.offsetHeight - this.tooltipEle.clientHeight);
        tipWidthAdjust = tipWidth / 2 + POINTER_ADJUST + (this.tooltipEle.offsetWidth - this.tooltipEle.clientWidth);
      }
      if (this.mouseTrail) {
        tipAdjust += MOUSE_TRAIL_GAP;
      }
      switch (position) {
        case "RightTop":
          pos.left += tipWidth + tipAdjust;
          pos.top -= tooltipEleHeight - tipHeightAdjust;
          break;
        case "RightCenter":
          pos.left += tipWidth + tipAdjust;
          pos.top -= tooltipEleHeight / 2;
          break;
        case "RightBottom":
          pos.left += tipWidth + tipAdjust;
          pos.top -= tipHeightAdjust;
          break;
        case "BottomRight":
          pos.top += tipHeight + tipAdjust;
          pos.left -= tipWidthAdjust;
          break;
        case "BottomCenter":
          pos.top += tipHeight + tipAdjust;
          pos.left -= tooltipEleWidth / 2;
          break;
        case "BottomLeft":
          pos.top += tipHeight + tipAdjust;
          pos.left -= tooltipEleWidth - tipWidthAdjust;
          break;
        case "LeftBottom":
          pos.left -= tipWidth + tooltipEleWidth + tipAdjust;
          pos.top -= tipHeightAdjust;
          break;
        case "LeftCenter":
          pos.left -= tipWidth + tooltipEleWidth + tipAdjust;
          pos.top -= tooltipEleHeight / 2;
          break;
        case "LeftTop":
          pos.left -= tipWidth + tooltipEleWidth + tipAdjust;
          pos.top -= tooltipEleHeight - tipHeightAdjust;
          break;
        case "TopLeft":
          pos.top -= tooltipEleHeight + tipHeight + tipAdjust;
          pos.left -= tooltipEleWidth - tipWidthAdjust;
          break;
        case "TopRight":
          pos.top -= tooltipEleHeight + tipHeight + tipAdjust;
          pos.left -= tipWidthAdjust;
          break;
        default:
          pos.top -= tooltipEleHeight + tipHeight + tipAdjust;
          pos.left -= tooltipEleWidth / 2;
          break;
      }
      pos.left += this.offsetX;
      pos.top += this.offsetY;
      return pos;
    };
    Tooltip2.prototype.updateTipPosition = function(position) {
      var selEle = selectAll("." + ARROW_TIP + ",." + ARROW_TIP_OUTER + ",." + ARROW_TIP_INNER, this.tooltipEle);
      var removeList = [TIP_BOTTOM, TIP_TOP, TIP_LEFT, TIP_RIGHT];
      removeClass(selEle, removeList);
      this.setTipClass(position);
      addClass(selEle, this.tipClass);
    };
    Tooltip2.prototype.adjustArrow = function(target, position, tooltipPositionX, tooltipPositionY) {
      var arrowEle = select("." + ARROW_TIP, this.tooltipEle);
      if (this.showTipPointer === false || arrowEle === null) {
        return;
      }
      this.updateTipPosition(position);
      var leftValue;
      var topValue;
      this.tooltipEle.style.display = "block";
      var tooltipWidth = this.tooltipEle.clientWidth;
      var tooltipHeight = this.tooltipEle.clientHeight;
      var arrowInnerELe = select("." + ARROW_TIP_INNER, this.tooltipEle);
      var tipWidth = arrowEle.offsetWidth;
      var tipHeight = arrowEle.offsetHeight;
      this.tooltipEle.style.display = "";
      if (this.tipClass === TIP_BOTTOM || this.tipClass === TIP_TOP) {
        if (this.tipClass === TIP_BOTTOM) {
          topValue = "99.9%";
          arrowInnerELe.style.top = "-" + (tipHeight - 2) + "px";
        } else {
          topValue = -(tipHeight - 1) + "px";
          arrowInnerELe.style.top = "-" + (tipHeight - 6) + "px";
        }
        if (target) {
          var tipPosExclude = tooltipPositionX !== "Center" || tooltipWidth > target.offsetWidth || this.mouseTrail;
          if (tipPosExclude && tooltipPositionX === "Left" || !tipPosExclude && this.tipPointerPosition === "End") {
            leftValue = tooltipWidth - tipWidth - POINTER_ADJUST + "px";
          } else if (tipPosExclude && tooltipPositionX === "Right" || !tipPosExclude && this.tipPointerPosition === "Start") {
            leftValue = POINTER_ADJUST + "px";
          } else if (tipPosExclude && (this.tipPointerPosition === "End" || this.tipPointerPosition === "Start")) {
            leftValue = this.tipPointerPosition === "End" ? target.offsetWidth + (this.tooltipEle.offsetWidth - target.offsetWidth) / 2 - tipWidth / 2 - POINTER_ADJUST + "px" : (this.tooltipEle.offsetWidth - target.offsetWidth) / 2 - tipWidth / 2 + POINTER_ADJUST + "px";
          } else {
            leftValue = tooltipWidth / 2 - tipWidth / 2 + "px";
          }
        }
      } else {
        if (this.tipClass === TIP_RIGHT) {
          leftValue = "99.9%";
          arrowInnerELe.style.left = "-" + (tipWidth - 2) + "px";
        } else {
          leftValue = -(tipWidth - 1) + "px";
          arrowInnerELe.style.left = -tipWidth + (tipWidth - 2) + "px";
        }
        var tipPosExclude = tooltipPositionY !== "Center" || tooltipHeight > target.offsetHeight || this.mouseTrail;
        if (tipPosExclude && tooltipPositionY === "Top" || !tipPosExclude && this.tipPointerPosition === "End") {
          topValue = tooltipHeight - tipHeight - POINTER_ADJUST + "px";
        } else if (tipPosExclude && tooltipPositionY === "Bottom" || !tipPosExclude && this.tipPointerPosition === "Start") {
          topValue = POINTER_ADJUST + "px";
        } else {
          topValue = tooltipHeight / 2 - tipHeight / 2 + "px";
        }
      }
      arrowEle.style.top = topValue;
      arrowEle.style.left = leftValue;
    };
    Tooltip2.prototype.renderContent = function(target) {
      var _this = this;
      var tooltipContent = select("." + CONTENT, this.tooltipEle);
      if (this.cssClass) {
        addClass([this.tooltipEle], this.cssClass.split(" "));
      }
      if (target && !isNullOrUndefined(target.getAttribute("title"))) {
        target.setAttribute("data-content", target.getAttribute("title"));
        target.removeAttribute("title");
      }
      if (!isNullOrUndefined(this.content)) {
        tooltipContent.innerHTML = "";
        if (this.content instanceof HTMLElement) {
          tooltipContent.appendChild(this.content);
        } else if (typeof this.content === "string") {
          if (this.isAngular) {
            this.setProperties({ content: SanitizeHtmlHelper.sanitize(this.content) }, true);
          } else {
            this.content = this.enableHtmlSanitizer ? SanitizeHtmlHelper.sanitize(this.content) : this.content;
          }
          if (this.enableHtmlParse) {
            var tempFunction = compile$1(this.content);
            var tempArr = tempFunction({}, this, "content", this.element.id + "content", undefined, undefined, tooltipContent, this.root);
            if (tempArr) {
              append(tempArr, tooltipContent);
            }
          } else {
            tooltipContent["textContent"] = this.content;
          }
        } else {
          var templateFunction = compile$1(this.content);
          var tempArr = templateFunction({}, this, "content", this.element.id + "content", undefined, undefined, tooltipContent);
          if (tempArr) {
            if (this.isAngular) {
              setTimeout(function() {
                _this.reposition(target);
              }, 1);
            }
            append(tempArr, tooltipContent);
          }
          this.renderReactTemplates();
        }
      } else {
        if (target && !isNullOrUndefined(target.getAttribute("data-content"))) {
          tooltipContent.innerHTML = target.getAttribute("data-content");
        }
      }
    };
    Tooltip2.prototype.renderCloseIcon = function() {
      if (!this.isSticky) {
        var existingCloseIcon = this.tooltipEle.querySelector("." + ICON + "." + CLOSE);
        if (existingCloseIcon) {
          remove(existingCloseIcon);
        }
        return;
      }
      var tipClose = this.createElement("div", { className: ICON + " " + CLOSE, attrs: { role: "button", "aria-label": "Press escape to close the Tooltip" } });
      this.tooltipEle.appendChild(tipClose);
      EventHandler.add(tipClose, Browser.touchStartEvent, this.onStickyClose, this);
    };
    Tooltip2.prototype.addDescribedBy = function(target, id) {
      var describedby = (target.getAttribute("aria-describedby") || "").split(/\s+/);
      if (describedby.indexOf(id) < 0) {
        describedby.push(id);
      }
      attributes(target, { "aria-describedby": describedby.join(" ").trim(), "data-tooltip-id": id });
    };
    Tooltip2.prototype.removeDescribedBy = function(target) {
      var id = target.getAttribute("data-tooltip-id");
      var describedby = (target.getAttribute("aria-describedby") || "").split(/\s+/);
      var index = describedby.indexOf(id);
      if (index !== -1) {
        describedby.splice(index, 1);
      }
      target.removeAttribute("data-tooltip-id");
      var orgdescribedby = describedby.join(" ").trim();
      if (orgdescribedby) {
        target.setAttribute("aria-describedby", orgdescribedby);
      } else {
        target.removeAttribute("aria-describedby");
      }
    };
    Tooltip2.prototype.tapHoldHandler = function(evt) {
      clearTimeout(this.autoCloseTimer);
      this.targetHover(evt.originalEvent);
    };
    Tooltip2.prototype.touchEndHandler = function() {
      var _this = this;
      if (this.isSticky) {
        return;
      }
      var close = function() {
        _this.close();
      };
      this.autoCloseTimer = setTimeout(close, TOUCHEND_HIDE_DELAY);
    };
    Tooltip2.prototype.targetClick = function(e) {
      var target;
      if (this.target) {
        target = closest(e.target, this.target);
      } else {
        target = this.element;
      }
      if (isNullOrUndefined(target)) {
        return;
      }
      var mouseEvent = e;
      if (target.getAttribute("data-tooltip-id") === null) {
        if (!(mouseEvent.type === "mousedown" && mouseEvent.button === 2)) {
          this.targetHover(e);
        }
      } else if (!this.isSticky) {
        this.hideTooltip(this.animation.close, e, target);
      }
    };
    Tooltip2.prototype.targetHover = function(e) {
      var target;
      if (this.target) {
        target = closest(e.target, this.target);
      } else {
        target = this.element;
      }
      if (isNullOrUndefined(target) || target.getAttribute("data-tooltip-id") !== null && this.closeDelay === 0) {
        return;
      }
      if (!isNullOrUndefined(this.tooltipEle) && this.tooltipEle.getAttribute("e-animation-id")) {
        Animation$1.stop(this.tooltipEle);
        this.clear();
      }
      var targetList = [].slice.call(selectAll('[data-tooltip-id= "' + this.ctrlId + '_content"]', undefined));
      for (var _i = 0, targetList_1 = targetList; _i < targetList_1.length; _i++) {
        var target_1 = targetList_1[_i];
        this.restoreElement(target_1);
      }
      this.showTooltip(target, this.animation.open, e);
    };
    Tooltip2.prototype.mouseMoveBeforeOpen = function(e) {
      this.mouseMoveEvent = e;
    };
    Tooltip2.prototype.mouseMoveBeforeRemove = function() {
      if (this.mouseMoveTarget) {
        EventHandler.remove(this.mouseMoveTarget, "mousemove touchstart", this.mouseMoveBeforeOpen);
      }
    };
    Tooltip2.prototype.showTooltip = function(target, showAnimation, e) {
      var _this = this;
      clearTimeout(this.showTimer);
      clearTimeout(this.hideTimer);
      if (this.openDelay && this.mouseTrail) {
        this.mouseMoveBeforeRemove();
        this.mouseMoveTarget = target;
        EventHandler.add(this.mouseMoveTarget, "mousemove touchstart", this.mouseMoveBeforeOpen, this);
      }
      this.tooltipEventArgs = {
        type: e ? e.type : null,
        cancel: false,
        target,
        event: e ? e : null,
        element: this.tooltipEle,
        isInteracted: !isNullOrUndefined(e)
      };
      var observeCallback = function(beforeRenderArgs) {
        _this.beforeRenderCallback(beforeRenderArgs, target, e, showAnimation);
      };
      this.trigger("beforeRender", this.tooltipEventArgs, observeCallback.bind(this));
    };
    Tooltip2.prototype.beforeRenderCallback = function(beforeRenderArgs, target, e, showAnimation) {
      if (beforeRenderArgs.cancel) {
        this.isHidden = true;
        this.clear();
        this.mouseMoveBeforeRemove();
      } else {
        this.isHidden = false;
        if (isNullOrUndefined(this.tooltipEle)) {
          this.ctrlId = this.element.getAttribute("id") ? getUniqueID(this.element.getAttribute("id")) : getUniqueID("tooltip");
          this.tooltipEle = this.createElement("div", {
            className: TOOLTIP_WRAP + " " + POPUP_ROOT + " " + POPUP_LIB,
            attrs: {
              role: "tooltip",
              "aria-hidden": "false",
              "id": this.ctrlId + "_content"
            }
          });
          this.tooltipEle.style.width = formatUnit(this.width);
          this.tooltipEle.style.height = formatUnit(this.height);
          this.tooltipEle.style.position = "absolute";
          this.tooltipBeforeRender(target, this);
          this.tooltipAfterRender(target, e, showAnimation, this);
        } else {
          if (target) {
            this.adjustArrow(target, this.position, this.tooltipPositionX, this.tooltipPositionY);
            this.addDescribedBy(target, this.ctrlId + "_content");
            this.renderContent(target);
            Animation$1.stop(this.tooltipEle);
            this.reposition(target);
            this.tooltipAfterRender(target, e, showAnimation, this);
          }
        }
      }
    };
    Tooltip2.prototype.appendContainer = function(ctrlObj) {
      if (typeof this.container == "string") {
        if (this.container === "body") {
          this.containerElement = (undefined).body;
        } else {
          this.isBodyContainer = false;
          this.containerElement = select(this.container, undefined);
        }
      } else if (this.container instanceof HTMLElement) {
        this.containerElement = this.container;
        this.isBodyContainer = this.containerElement.tagName === "BODY";
      }
      if (!this.isBodyContainer) {
        addClass([this.containerElement], POPUP_CONTAINER);
      }
      this.containerElement.appendChild(ctrlObj.tooltipEle);
    };
    Tooltip2.prototype.tooltipBeforeRender = function(target, ctrlObj) {
      if (target) {
        if (Browser.isDevice) {
          addClass([ctrlObj.tooltipEle], DEVICE);
        }
        if (ctrlObj.width !== "auto") {
          ctrlObj.tooltipEle.style.maxWidth = formatUnit(ctrlObj.width);
        }
        ctrlObj.tooltipEle.appendChild(ctrlObj.createElement("div", { className: CONTENT }));
        this.appendContainer(ctrlObj);
        removeClass([ctrlObj.tooltipEle], HIDE_POPUP);
        ctrlObj.addDescribedBy(target, ctrlObj.ctrlId + "_content");
        ctrlObj.renderContent(target);
        addClass([ctrlObj.tooltipEle], POPUP_OPEN);
        if (ctrlObj.showTipPointer) {
          ctrlObj.renderArrow();
        }
        ctrlObj.renderCloseIcon();
        ctrlObj.renderPopup(target);
        ctrlObj.adjustArrow(target, ctrlObj.position, ctrlObj.tooltipPositionX, ctrlObj.tooltipPositionY);
        Animation$1.stop(ctrlObj.tooltipEle);
        ctrlObj.reposition(target);
      }
    };
    Tooltip2.prototype.tooltipAfterRender = function(target, e, showAnimation, ctrlObj) {
      if (target) {
        removeClass([ctrlObj.tooltipEle], POPUP_OPEN);
        addClass([ctrlObj.tooltipEle], POPUP_CLOSE);
        ctrlObj.tooltipEventArgs = {
          type: e ? e.type : null,
          cancel: false,
          target,
          event: e ? e : null,
          element: ctrlObj.tooltipEle,
          isInteracted: !isNullOrUndefined(e)
        };
        if (ctrlObj.needTemplateReposition() && !ctrlObj.mouseTrail && (showAnimation.effect === "None" || showAnimation.effect === "FadeIn" || // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.isReact && typeof ctrlObj.content != "string")) {
          ctrlObj.tooltipEle.style.display = "none";
        }
        var observeCallback = function(observedArgs) {
          ctrlObj.beforeOpenCallback(observedArgs, target, showAnimation, e);
        };
        ctrlObj.trigger("beforeOpen", ctrlObj.tooltipEventArgs, observeCallback.bind(ctrlObj));
      }
    };
    Tooltip2.prototype.beforeOpenCallback = function(observedArgs, target, showAnimation, e) {
      var _this = this;
      if (observedArgs.cancel) {
        this.isHidden = true;
        this.clear();
        this.mouseMoveBeforeRemove();
        this.restoreElement(target);
      } else {
        var openAnimation_1 = {
          name: showAnimation.effect === "None" && animationMode === "Enable" ? "FadeIn" : this.animation.open.effect,
          duration: showAnimation.duration,
          delay: showAnimation.delay,
          timingFunction: "easeOut"
        };
        if (showAnimation.effect === "None") {
          openAnimation_1 = undefined;
        }
        if (this.openDelay > 0) {
          var show = function() {
            if (_this.mouseTrail) {
              EventHandler.add(target, "mousemove touchstart mouseenter", _this.onMouseMove, _this);
            }
            if (_this.popupObj) {
              _this.popupObj.show(openAnimation_1, target);
              if (_this.mouseMoveEvent && _this.mouseTrail) {
                _this.onMouseMove(_this.mouseMoveEvent);
              }
            }
          };
          this.showTimer = setTimeout(show, this.openDelay);
        } else {
          if (this.popupObj) {
            this.popupObj.show(openAnimation_1, target);
          }
        }
      }
      if (e) {
        this.wireMouseEvents(e, target);
      }
    };
    Tooltip2.prototype.needTemplateReposition = function() {
      var tooltip = this;
      return !isNullOrUndefined(tooltip.viewContainerRef) && typeof tooltip.viewContainerRef !== "string" || this.isReact;
    };
    Tooltip2.prototype.checkCollision = function(target, x, y) {
      var elePos = {
        left: x,
        top: y,
        position: this.position,
        horizontal: this.tooltipPositionX,
        vertical: this.tooltipPositionY
      };
      var affectedPos = isCollide(this.tooltipEle, this.checkCollideTarget(), x, y);
      if (affectedPos.length > 0) {
        elePos.horizontal = affectedPos.indexOf("left") >= 0 ? "Right" : affectedPos.indexOf("right") >= 0 ? "Left" : this.tooltipPositionX;
        elePos.vertical = affectedPos.indexOf("top") >= 0 ? "Bottom" : affectedPos.indexOf("bottom") >= 0 ? "Top" : this.tooltipPositionY;
      }
      return elePos;
    };
    Tooltip2.prototype.calculateElementPosition = function(pos, offsetPos) {
      return [
        this.isBodyContainer ? pos.left + offsetPos.left : pos.left - this.containerElement.getBoundingClientRect().left + offsetPos.left + (undefined).pageXOffset + this.containerElement.scrollLeft,
        this.isBodyContainer ? pos.top + offsetPos.top : pos.top - this.containerElement.getBoundingClientRect().top + offsetPos.top + (undefined).pageYOffset + this.containerElement.scrollTop
      ];
    };
    Tooltip2.prototype.collisionFlipFit = function(target, x, y) {
      var elePos = this.checkCollision(target, x, y);
      var newpos = elePos.position;
      if (this.tooltipPositionY !== elePos.vertical) {
        newpos = this.position.indexOf("Bottom") === 0 || this.position.indexOf("Top") === 0 ? elePos.vertical + this.tooltipPositionX : this.tooltipPositionX + elePos.vertical;
      }
      if (this.tooltipPositionX !== elePos.horizontal) {
        if (newpos.indexOf("Left") === 0) {
          elePos.vertical = newpos === "LeftTop" || newpos === "LeftCenter" ? "Top" : "Bottom";
          newpos = elePos.vertical + "Left";
        }
        if (newpos.indexOf("Right") === 0) {
          elePos.vertical = newpos === "RightTop" || newpos === "RightCenter" ? "Top" : "Bottom";
          newpos = elePos.vertical + "Right";
        }
        elePos.horizontal = this.tooltipPositionX;
      }
      this.tooltipEventArgs = {
        type: null,
        cancel: false,
        target,
        event: null,
        element: this.tooltipEle,
        collidedPosition: newpos
      };
      this.trigger("beforeCollision", this.tooltipEventArgs);
      if (this.tooltipEventArgs.cancel) {
        newpos = this.position;
      } else {
        var elePosVertical = elePos.vertical;
        var elePosHorizontal = elePos.horizontal;
        if (elePos.position !== newpos) {
          var pos = calculatePosition(target, elePosHorizontal, elePosVertical, !this.isBodyContainer, this.isBodyContainer ? null : this.containerElement.getBoundingClientRect());
          this.adjustArrow(target, newpos, elePosHorizontal, elePosVertical);
          var scalingFactors = this.getScalingFactor(target);
          var offsetPos = this.calculateTooltipOffset(newpos, scalingFactors.x, scalingFactors.y);
          offsetPos.top -= this.getOffSetPosition("TopBottom", newpos, this.offsetY);
          offsetPos.left -= this.getOffSetPosition("RightLeft", newpos, this.offsetX);
          elePos.position = newpos;
          var elePosition = this.calculateElementPosition(pos, offsetPos);
          elePos.left = elePosition[0];
          elePos.top = elePosition[1];
        } else {
          this.adjustArrow(target, newpos, elePosHorizontal, elePosVertical);
        }
      }
      var eleOffset = { left: elePos.left, top: elePos.top };
      var position = this.isBodyContainer ? fit(this.tooltipEle, this.checkCollideTarget(), { X: true, Y: this.windowCollision }, eleOffset) : eleOffset;
      this.tooltipEle.style.display = "block";
      var arrowEle = select("." + ARROW_TIP, this.tooltipEle);
      if (this.showTipPointer && arrowEle != null && (newpos.indexOf("Bottom") === 0 || newpos.indexOf("Top") === 0)) {
        var arrowleft = parseInt(arrowEle.style.left, 10) - (position.left - elePos.left);
        if (arrowleft < 0) {
          arrowleft = 0;
        } else if (arrowleft + arrowEle.offsetWidth > this.tooltipEle.clientWidth) {
          arrowleft = this.tooltipEle.clientWidth - arrowEle.offsetWidth;
        }
        arrowEle.style.left = arrowleft.toString() + "px";
      }
      this.tooltipEle.style.display = "";
      eleOffset.left = position.left;
      eleOffset.top = position.top;
      return eleOffset;
    };
    Tooltip2.prototype.getOffSetPosition = function(positionString, newPos, offsetType) {
      return positionString.indexOf(this.position.split(/(?=[A-Z])/)[0]) !== -1 && positionString.indexOf(newPos.split(/(?=[A-Z])/)[0]) !== -1 ? 2 * offsetType : 0;
    };
    Tooltip2.prototype.checkCollideTarget = function() {
      return !this.windowCollision && this.target ? this.element : null;
    };
    Tooltip2.prototype.hideTooltip = function(hideAnimation, e, targetElement2) {
      var _this = this;
      if (this.closeDelay > 0) {
        clearTimeout(this.hideTimer);
        clearTimeout(this.showTimer);
        var hide = function() {
          if (_this.closeDelay && _this.tooltipEle && _this.isTooltipOpen) {
            return;
          }
          _this.tooltipHide(hideAnimation, e, targetElement2);
        };
        this.hideTimer = setTimeout(hide, this.closeDelay);
      } else {
        this.tooltipHide(hideAnimation, e, targetElement2);
      }
    };
    Tooltip2.prototype.tooltipHide = function(hideAnimation, e, targetElement2) {
      var _this = this;
      var target;
      if (e) {
        target = this.target ? targetElement2 || e.target : this.element;
      } else {
        target = select('[data-tooltip-id= "' + this.ctrlId + '_content"]', undefined);
      }
      this.tooltipEventArgs = {
        type: e ? e.type : null,
        cancel: false,
        target,
        event: e ? e : null,
        element: this.tooltipEle,
        isInteracted: !isNullOrUndefined(e)
      };
      this.trigger("beforeClose", this.tooltipEventArgs, function(observedArgs) {
        if (!observedArgs.cancel) {
          _this.mouseMoveBeforeRemove();
          _this.popupHide(hideAnimation, target, e);
        } else {
          _this.isHidden = false;
        }
      });
    };
    Tooltip2.prototype.popupHide = function(hideAnimation, target, e) {
      if (target && e) {
        this.restoreElement(target);
      }
      this.isHidden = true;
      var closeAnimation = {
        name: hideAnimation.effect === "None" && animationMode === "Enable" ? "FadeOut" : this.animation.close.effect,
        duration: hideAnimation.duration,
        delay: hideAnimation.delay,
        timingFunction: "easeIn"
      };
      if (hideAnimation.effect === "None") {
        closeAnimation = undefined;
      }
      if (this.popupObj) {
        this.popupObj.hide(closeAnimation);
      }
    };
    Tooltip2.prototype.restoreElement = function(target) {
      this.unwireMouseEvents(target);
      if (!isNullOrUndefined(target.getAttribute("data-content"))) {
        target.setAttribute("title", target.getAttribute("data-content"));
        target.removeAttribute("data-content");
      }
      this.removeDescribedBy(target);
    };
    Tooltip2.prototype.clear = function() {
      var target = this.findTarget();
      if (target) {
        this.restoreElement(target);
      }
      if (this.tooltipEle) {
        removeClass([this.tooltipEle], POPUP_CLOSE);
        addClass([this.tooltipEle], POPUP_OPEN);
      }
      if (this.isHidden) {
        if (this.popupObj) {
          this.popupObj.destroy();
        }
        if (this.tooltipEle) {
          remove(this.tooltipEle);
        }
        this.tooltipEle = null;
        this.popupObj = null;
      }
    };
    Tooltip2.prototype.tooltipHover = function() {
      if (this.tooltipEle) {
        this.isTooltipOpen = true;
      }
    };
    Tooltip2.prototype.tooltipMouseOut = function(e) {
      this.isTooltipOpen = false;
      this.hideTooltip(this.animation.close, e, this.findTarget());
    };
    Tooltip2.prototype.onMouseOut = function(e) {
      var enteredElement = e.relatedTarget;
      if (enteredElement && !this.mouseTrail) {
        var checkForTooltipElement = closest(enteredElement, "." + TOOLTIP_WRAP + "." + POPUP_LIB + "." + POPUP_ROOT);
        if (checkForTooltipElement) {
          EventHandler.add(checkForTooltipElement, "mouseleave", this.tooltipElementMouseOut, this);
        } else {
          this.hideTooltip(this.animation.close, e, this.findTarget());
          if (this.closeDelay === 0 && (this.animation.close.effect === "None" || this.isReact && typeof this.content != "string")) {
            this.clear();
          }
        }
      } else {
        this.hideTooltip(this.animation.close, e, this.findTarget());
        this.clear();
      }
      if (this.popupObj && !this.popupObj.element.classList.contains(POPUP_OPEN)) {
        this.clear();
      }
    };
    Tooltip2.prototype.tooltipElementMouseOut = function(e) {
      this.hideTooltip(this.animation.close, e, this.findTarget());
      EventHandler.remove(this.element, "mouseleave", this.tooltipElementMouseOut);
      this.clear();
    };
    Tooltip2.prototype.onStickyClose = function() {
      this.close();
    };
    Tooltip2.prototype.onMouseMove = function(event) {
      var eventPageX = 0;
      var eventPageY = 0;
      if (event.type.indexOf("touch") > -1) {
        event.preventDefault();
        eventPageX = event.touches[0].pageX;
        eventPageY = event.touches[0].pageY;
      } else {
        eventPageX = event.pageX;
        eventPageY = event.pageY;
      }
      if (isNullOrUndefined(this.tooltipEle)) {
        return;
      }
      Animation$1.stop(this.tooltipEle);
      removeClass([this.tooltipEle], POPUP_CLOSE);
      addClass([this.tooltipEle], POPUP_OPEN);
      this.adjustArrow(event.target, this.position, this.tooltipPositionX, this.tooltipPositionY);
      var scalingFactors = this.getScalingFactor(event.target);
      var pos = this.calculateTooltipOffset(this.position, scalingFactors.x, scalingFactors.y);
      var x = eventPageX + pos.left + this.offsetX;
      var y = eventPageY + pos.top + this.offsetY;
      var elePos = this.checkCollision(event.target, x, y);
      if (this.tooltipPositionX !== elePos.horizontal || this.tooltipPositionY !== elePos.vertical) {
        var newpos = this.position.indexOf("Bottom") === 0 || this.position.indexOf("Top") === 0 ? elePos.vertical + elePos.horizontal : elePos.horizontal + elePos.vertical;
        elePos.position = newpos;
        this.adjustArrow(event.target, elePos.position, elePos.horizontal, elePos.vertical);
        var colpos = this.calculateTooltipOffset(elePos.position, scalingFactors.x, scalingFactors.y);
        elePos.left = eventPageX + colpos.left - this.offsetX;
        elePos.top = eventPageY + colpos.top - this.offsetY;
      }
      this.tooltipEle.style.left = elePos.left + "px";
      this.tooltipEle.style.top = elePos.top + "px";
    };
    Tooltip2.prototype.keyDown = function(event) {
      if (this.tooltipEle && event.keyCode === 27) {
        this.close();
      }
    };
    Tooltip2.prototype.touchEnd = function(e) {
      if (this.tooltipEle && closest(e.target, "." + ROOT$1) === null && !this.isSticky) {
        this.close();
      }
    };
    Tooltip2.prototype.scrollHandler = function(e) {
      if (this.tooltipEle && !this.isSticky) {
        if (!closest(e.target, "." + TOOLTIP_WRAP + "." + POPUP_LIB + "." + POPUP_ROOT) && !this.isSticky) {
          this.close();
        }
      }
    };
    Tooltip2.prototype.render = function() {
      this.initialize();
      this.wireEvents(this.opensOn);
      this.renderComplete();
    };
    Tooltip2.prototype.preRender = function() {
      this.tipClass = TIP_BOTTOM;
      this.tooltipPositionX = "Center";
      this.tooltipPositionY = "Top";
      this.isHidden = true;
    };
    Tooltip2.prototype.wireEvents = function(trigger) {
      var triggerList = this.getTriggerList(trigger);
      for (var _i = 0, triggerList_1 = triggerList; _i < triggerList_1.length; _i++) {
        var opensOn = triggerList_1[_i];
        if (opensOn === "Custom") {
          return;
        }
        if (opensOn === "Focus") {
          this.wireFocusEvents();
        }
        if (opensOn === "Click") {
          EventHandler.add(this.element, Browser.touchStartEvent, this.targetClick, this);
        }
        if (opensOn === "Hover") {
          if (Browser.isDevice) {
            this.touchModule = new Touch(this.element, {
              tapHoldThreshold: TAPHOLD_THRESHOLD,
              tapHold: this.tapHoldHandler.bind(this)
            });
            EventHandler.add(this.element, Browser.touchEndEvent, this.touchEndHandler, this);
          } else {
            EventHandler.add(this.element, "mouseover", this.targetHover, this);
          }
        }
      }
      this.windowResizeBound = this.windowResize.bind(this);
      this.keyDownBound = this.keyDown.bind(this);
      this.touchEndBound = this.touchEnd.bind(this);
      this.scrollWheelBound = this.scrollHandler.bind(this);
      (undefined).addEventListener("wheel", this.scrollWheelBound);
      (undefined).addEventListener("scroll", this.scrollWheelBound);
      (undefined).addEventListener("touchend", this.touchEndBound);
      (undefined).addEventListener("keydown", this.keyDownBound);
      (undefined).addEventListener("resize", this.windowResizeBound);
    };
    Tooltip2.prototype.getTriggerList = function(trigger) {
      if (!trigger) {
        return [];
      }
      if (trigger === "Auto") {
        trigger = Browser.isDevice ? "Hover" : "Hover Focus";
      }
      return trigger.split(" ");
    };
    Tooltip2.prototype.wireFocusEvents = function() {
      if (!isNullOrUndefined(this.target)) {
        var targetList = [].slice.call(selectAll(this.target, this.element));
        this.targetsList = targetList;
        if (!isNullOrUndefined(this.targetsList) && this.targetsList.length > 0) {
          for (var _i = 0, targetList_2 = targetList; _i < targetList_2.length; _i++) {
            var target = targetList_2[_i];
            EventHandler.add(target, "focus", this.targetHover, this);
          }
        } else {
          EventHandler.add(this.element, "focusin", this.targetHover, this);
        }
      } else {
        EventHandler.add(this.element, "focusin", this.targetHover, this);
      }
    };
    Tooltip2.prototype.wireMouseEvents = function(e, target) {
      if (this.tooltipEle) {
        if (!this.isSticky) {
          if (e.type === "focus") {
            EventHandler.add(target, "blur", this.onMouseOut, this);
          }
          if (e.type === "focusin") {
            EventHandler.add(target, "focusout", this.onMouseOut, this);
          }
          if (e.type === "mouseover") {
            EventHandler.add(target, "mouseleave", this.onMouseOut, this);
          }
          if (this.closeDelay) {
            EventHandler.add(this.tooltipEle, "mouseenter", this.tooltipHover, this);
            EventHandler.add(this.tooltipEle, "mouseleave", this.tooltipMouseOut, this);
          }
        }
        if (this.mouseTrail && this.openDelay === 0) {
          EventHandler.add(target, "mousemove touchstart mouseenter", this.onMouseMove, this);
        }
      }
    };
    Tooltip2.prototype.unwireEvents = function(trigger) {
      var triggerList = this.getTriggerList(trigger);
      for (var _i = 0, triggerList_2 = triggerList; _i < triggerList_2.length; _i++) {
        var opensOn = triggerList_2[_i];
        if (opensOn === "Custom") {
          return;
        }
        if (opensOn === "Focus") {
          this.unwireFocusEvents();
        }
        if (opensOn === "Click") {
          EventHandler.remove(this.element, Browser.touchStartEvent, this.targetClick);
        }
        if (opensOn === "Hover") {
          if (Browser.isDevice) {
            if (this.touchModule) {
              this.touchModule.destroy();
            }
            EventHandler.remove(this.element, Browser.touchEndEvent, this.touchEndHandler);
          } else {
            EventHandler.remove(this.element, "mouseover", this.targetHover);
          }
        }
      }
      (undefined).removeEventListener("touchend", this.touchEndBound);
      this.touchEndBound = null;
      (undefined).removeEventListener("wheel", this.scrollWheelBound);
      (undefined).removeEventListener("scroll", this.scrollWheelBound);
      this.scrollWheelBound = null;
      (undefined).removeEventListener("resize", this.windowResizeBound);
      this.windowResizeBound = null;
      (undefined).removeEventListener("keydown", this.keyDownBound);
      this.keyDownBound = null;
    };
    Tooltip2.prototype.unwireFocusEvents = function() {
      if (!isNullOrUndefined(this.target)) {
        var targetList = [].slice.call(selectAll(this.target, this.element));
        if (!isNullOrUndefined(this.targetsList) && this.targetsList.length > 0) {
          for (var _i = 0, targetList_3 = targetList; _i < targetList_3.length; _i++) {
            var target = targetList_3[_i];
            EventHandler.remove(target, "focus", this.targetHover);
          }
        } else {
          EventHandler.remove(this.element, "focusin", this.targetHover);
        }
      } else {
        EventHandler.remove(this.element, "focusin", this.targetHover);
      }
    };
    Tooltip2.prototype.unwireMouseEvents = function(target) {
      if (!this.isSticky) {
        var triggerList = this.getTriggerList(this.opensOn);
        for (var _i = 0, triggerList_3 = triggerList; _i < triggerList_3.length; _i++) {
          var opensOn = triggerList_3[_i];
          if (opensOn === "Focus") {
            EventHandler.remove(target, "blur", this.onMouseOut);
            EventHandler.remove(target, "focusout", this.onMouseOut);
          }
          if (opensOn === "Hover" && !Browser.isDevice) {
            EventHandler.remove(target, "mouseleave", this.onMouseOut);
          }
        }
        if (this.closeDelay) {
          EventHandler.remove(target, "mouseenter", this.tooltipHover);
          EventHandler.remove(target, "mouseleave", this.tooltipMouseOut);
        }
      }
      if (this.mouseTrail) {
        EventHandler.remove(target, "mousemove touchstart mouseenter", this.onMouseMove);
      }
    };
    Tooltip2.prototype.findTarget = function() {
      var target = select('[data-tooltip-id= "' + this.ctrlId + '_content"]', undefined);
      return target;
    };
    Tooltip2.prototype.getModuleName = function() {
      return "tooltip";
    };
    Tooltip2.prototype.getPersistData = function() {
      return this.addOnPersist([]);
    };
    Tooltip2.prototype.onPropertyChanged = function(newProp, oldProp) {
      var targetElement2 = this.findTarget();
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "width":
            if (this.tooltipEle && targetElement2) {
              this.tooltipEle.style.width = this.tooltipEle.style.maxWidth = formatUnit(newProp.width);
              this.reposition(targetElement2);
            }
            break;
          case "height":
            if (this.tooltipEle && targetElement2) {
              this.tooltipEle.style.height = formatUnit(newProp.height);
              this.reposition(targetElement2);
            }
            break;
          case "content":
            if (this.tooltipEle) {
              this.renderContent();
            }
            break;
          case "opensOn":
            this.unwireEvents(oldProp.opensOn);
            this.wireEvents(newProp.opensOn);
            break;
          case "position":
            this.formatPosition();
            if (this.tooltipEle && targetElement2) {
              var arrowInnerELe = select("." + ARROW_TIP_INNER, this.tooltipEle);
              if (arrowInnerELe) {
                arrowInnerELe.style.top = arrowInnerELe.style.left = null;
              }
              this.reposition(targetElement2);
            }
            break;
          case "tipPointerPosition":
            if (this.tooltipEle && targetElement2) {
              this.reposition(targetElement2);
            }
            break;
          case "offsetX":
            if (this.tooltipEle) {
              var x = newProp.offsetX - oldProp.offsetX;
              this.tooltipEle.style.left = (parseInt(this.tooltipEle.style.left, 10) + x).toString() + "px";
            }
            break;
          case "offsetY":
            if (this.tooltipEle) {
              var y = newProp.offsetY - oldProp.offsetY;
              this.tooltipEle.style.top = (parseInt(this.tooltipEle.style.top, 10) + y).toString() + "px";
            }
            break;
          case "cssClass":
            if (this.tooltipEle) {
              if (oldProp.cssClass) {
                removeClass([this.tooltipEle], oldProp.cssClass.split(" "));
              }
              if (newProp.cssClass) {
                addClass([this.tooltipEle], newProp.cssClass.split(" "));
              }
            }
            break;
          case "enableRtl":
            if (this.tooltipEle) {
              if (this.enableRtl) {
                addClass([this.tooltipEle], RTL$3);
              } else {
                removeClass([this.tooltipEle], RTL$3);
              }
            }
            break;
          case "isSticky":
            if (this.tooltipEle && targetElement2) {
              this.renderCloseIcon();
              this.reposition(targetElement2);
            }
            break;
          case "container":
            if (!isNullOrUndefined(this.containerElement)) {
              removeClass([this.containerElement], POPUP_CONTAINER);
            }
            this.container = newProp.container;
            if (this.tooltipEle && targetElement2) {
              this.appendContainer(this);
              this.reposition(targetElement2);
            }
        }
      }
    };
    Tooltip2.prototype.open = function(element2, animation) {
      if (isNullOrUndefined(animation)) {
        animation = this.animation.open;
      }
      if (isNullOrUndefined(element2)) {
        element2 = this.element;
      }
      if (element2.style.display === "none") {
        return;
      }
      this.showTooltip(element2, animation);
    };
    Tooltip2.prototype.close = function(animation) {
      if (!animation) {
        animation = this.animation.close;
      }
      this.hideTooltip(animation);
    };
    Tooltip2.prototype.refresh = function(target) {
      if (this.tooltipEle) {
        this.renderContent(target);
      }
      if (this.popupObj && target) {
        this.reposition(target);
      }
      if (!isNullOrUndefined(this.targetsList) && !isNullOrUndefined(this.target)) {
        var target_2 = selectAll(this.target, this.element);
        if (target_2.length !== this.targetsList.length) {
          this.unwireEvents(this.opensOn);
          this.wireEvents(this.opensOn);
        }
      }
    };
    Tooltip2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      if (this.tooltipEle) {
        remove(this.tooltipEle);
      }
      if (this.popupObj) {
        this.popupObj.destroy();
      }
      destroy();
      removeClass([this.element], ROOT$1);
      this.unwireEvents(this.opensOn);
      this.unwireMouseEvents(this.element);
      this.tooltipEle = null;
      this.popupObj = null;
      var currentTarget = selectAll('[data-tooltip-id= "' + this.ctrlId + '_content"]', this.element);
      for (var _i = 0, currentTarget_1 = currentTarget; _i < currentTarget_1.length; _i++) {
        var target = currentTarget_1[_i];
        this.restoreElement(target);
      }
      this.containerElement = null;
      this.tipClass = null;
      this.tooltipPositionX = null;
      this.tooltipPositionY = null;
      this.ctrlId = null;
      this.tooltipEventArgs = null;
      this.touchModule = null;
      this.mouseMoveEvent = null;
      this.mouseMoveTarget = null;
      this.containerElement = null;
      this.targetsList = null;
    };
    __decorate$c([
      Property("auto")
    ], Tooltip2.prototype, "width", undefined);
    __decorate$c([
      Property("auto")
    ], Tooltip2.prototype, "height", undefined);
    __decorate$c([
      Property()
    ], Tooltip2.prototype, "content", undefined);
    __decorate$c([
      Property("body")
    ], Tooltip2.prototype, "container", undefined);
    __decorate$c([
      Property()
    ], Tooltip2.prototype, "target", undefined);
    __decorate$c([
      Property("TopCenter")
    ], Tooltip2.prototype, "position", undefined);
    __decorate$c([
      Property(0)
    ], Tooltip2.prototype, "offsetX", undefined);
    __decorate$c([
      Property(0)
    ], Tooltip2.prototype, "offsetY", undefined);
    __decorate$c([
      Property(true)
    ], Tooltip2.prototype, "showTipPointer", undefined);
    __decorate$c([
      Property(true)
    ], Tooltip2.prototype, "enableHtmlParse", undefined);
    __decorate$c([
      Property(false)
    ], Tooltip2.prototype, "windowCollision", undefined);
    __decorate$c([
      Property("Auto")
    ], Tooltip2.prototype, "tipPointerPosition", undefined);
    __decorate$c([
      Property("Auto")
    ], Tooltip2.prototype, "opensOn", undefined);
    __decorate$c([
      Property(false)
    ], Tooltip2.prototype, "mouseTrail", undefined);
    __decorate$c([
      Property(false)
    ], Tooltip2.prototype, "isSticky", undefined);
    __decorate$c([
      Complex({}, Animation)
    ], Tooltip2.prototype, "animation", undefined);
    __decorate$c([
      Property(0)
    ], Tooltip2.prototype, "openDelay", undefined);
    __decorate$c([
      Property(0)
    ], Tooltip2.prototype, "closeDelay", undefined);
    __decorate$c([
      Property()
    ], Tooltip2.prototype, "cssClass", undefined);
    __decorate$c([
      Property(true)
    ], Tooltip2.prototype, "enableHtmlSanitizer", undefined);
    __decorate$c([
      Property("")
    ], Tooltip2.prototype, "htmlAttributes", undefined);
    __decorate$c([
      Event()
    ], Tooltip2.prototype, "beforeRender", undefined);
    __decorate$c([
      Event()
    ], Tooltip2.prototype, "beforeOpen", undefined);
    __decorate$c([
      Event()
    ], Tooltip2.prototype, "afterOpen", undefined);
    __decorate$c([
      Event()
    ], Tooltip2.prototype, "beforeClose", undefined);
    __decorate$c([
      Event()
    ], Tooltip2.prototype, "afterClose", undefined);
    __decorate$c([
      Event()
    ], Tooltip2.prototype, "beforeCollision", undefined);
    __decorate$c([
      Event()
    ], Tooltip2.prototype, "created", undefined);
    __decorate$c([
      Event()
    ], Tooltip2.prototype, "destroyed", undefined);
    Tooltip2 = __decorate$c([
      NotifyPropertyChanges
    ], Tooltip2);
    return Tooltip2;
  }(Component)
);
var globalTimeOut = {};
var DEFT_MAT_WIDTH = 30;
var DEFT_MAT3_WIDTH = 30;
var DEFT_FAB_WIDTH = 30;
var DEFT_FLUENT_WIDTH = 30;
var DEFT_FLUENT2_WIDTH = 30;
var DEFT_BOOT_WIDTH = 30;
var DEFT_BOOT4_WIDTH = 36;
var DEFT_BOOT5_WIDTH = 36;
var CLS_SHOWSPIN = "e-spin-show";
var CLS_HIDESPIN = "e-spin-hide";
var CLS_MATERIALSPIN = "e-spin-material";
var CLS_MATERIAL3SPIN = "e-spin-material3";
var CLS_TAILWIND3SPIN = "e-spin-tailwind3";
var CLS_FABRICSPIN = "e-spin-fabric";
var CLS_FLUENTSPIN = "e-spin-fluent";
var CLS_FLUENT2SPIN = "e-spin-fluent2";
var CLS_TAILWINDSPIN = "e-spin-tailwind";
var CLS_BOOTSPIN = "e-spin-bootstrap";
var CLS_BOOT4SPIN = "e-spin-bootstrap4";
var CLS_BOOT5SPIN = "e-spin-bootstrap5";
var CLS_HIGHCONTRASTSPIN = "e-spin-high-contrast";
var CLS_SPINWRAP = "e-spinner-pane";
var CLS_SPININWRAP = "e-spinner-inner";
var CLS_SPINCIRCLE = "e-path-circle";
var CLS_SPINARC = "e-path-arc";
var CLS_SPINLABEL = "e-spin-label";
var CLS_SPINTEMPLATE = "e-spin-template";
var spinTemplate = null;
var spinCSSClass = null;
function createSpinner(args, internalCreateElement) {
  var _a;
  if (!args.target) {
    return;
  }
  var radius;
  var makeElement = !isNullOrUndefined(internalCreateElement) ? internalCreateElement : createElement;
  var container = create_spinner_container(args.target, makeElement);
  if (!isNullOrUndefined(args.cssClass)) {
    var classNames2 = args.cssClass.split(" ").filter(function(className) {
      return className.trim() !== "";
    });
    (_a = container.wrap.classList).add.apply(_a, classNames2);
  }
  if (!isNullOrUndefined(args.template) || !isNullOrUndefined(spinTemplate)) {
    var template = !isNullOrUndefined(args.template) ? args.template : spinTemplate;
    container.wrap.classList.add(CLS_SPINTEMPLATE);
    replaceContent(container.wrap, template, spinCSSClass);
  } else {
    var theme = !isNullOrUndefined(args.type) ? args.type : getTheme(container.wrap);
    var width = !isNullOrUndefined(args.width) ? args.width : undefined;
    radius = calculateRadius(width, theme);
    setTheme(theme, container.wrap, radius, makeElement);
    if (!isNullOrUndefined(args.label)) {
      createLabel(container.inner_wrap, args.label, makeElement);
    }
  }
  container.wrap.classList.add(CLS_HIDESPIN);
  container = null;
}
function createLabel(container, label, makeElement) {
  var labelEle = makeElement("div", {});
  labelEle.classList.add(CLS_SPINLABEL);
  labelEle.innerHTML = label;
  container.appendChild(labelEle);
  return labelEle;
}
function createMaterialSpinner(container, radius, makeElement) {
  var uniqueID2 = random_generator();
  globalTimeOut["" + uniqueID2] = { timeOut: 0, type: "Material", radius };
  create_material_element(container, uniqueID2, makeElement, CLS_MATERIALSPIN);
  mat_calculate_attributes(radius, container, "Material", CLS_MATERIALSPIN);
}
function createTailwind3Spinner(container, radius, makeElement) {
  var uniqueID2 = random_generator();
  globalTimeOut["" + uniqueID2] = { timeOut: 0, type: "Tailwind3", radius };
  create_material_element(container, uniqueID2, makeElement, CLS_TAILWIND3SPIN);
  mat_calculate_attributes(radius, container, "Tailwind3", CLS_TAILWIND3SPIN);
}
function createMaterial3Spinner(container, radius, makeElement) {
  var uniqueID2 = random_generator();
  globalTimeOut["" + uniqueID2] = { timeOut: 0, type: "Material3", radius };
  create_material_element(container, uniqueID2, makeElement, CLS_MATERIAL3SPIN);
  mat_calculate_attributes(radius, container, "Material3", CLS_MATERIAL3SPIN);
}
function createBootstrap4Spinner(container, radius, makeElement) {
  var uniqueID2 = random_generator();
  globalTimeOut["" + uniqueID2] = { timeOut: 0, type: "Bootstrap4", radius };
  create_material_element(container, uniqueID2, makeElement, CLS_BOOT4SPIN);
  mat_calculate_attributes(radius, container, "Bootstrap4", CLS_BOOT4SPIN);
}
function createBootstrap5Spinner(container, radius, makeElement) {
  var uniqueID2 = random_generator();
  globalTimeOut["" + uniqueID2] = { timeOut: 0, type: "Bootstrap5", radius };
  create_material_element(container, uniqueID2, makeElement, CLS_BOOT5SPIN);
  mat_calculate_attributes(radius, container, "Bootstrap5", CLS_BOOT5SPIN);
}
function startMatAnimate(container, uniqueID2, radius) {
  var globalObject = {};
  var timeOutVar = 0;
  globalTimeOut["" + uniqueID2].timeOut = 0;
  globalObject["" + uniqueID2] = globalVariables(uniqueID2, radius, 0, 0);
  var spinnerInfo = { uniqueID: uniqueID2, container, globalInfo: globalObject, timeOutVar };
  animateMaterial(spinnerInfo);
}
function createFabricSpinner(container, radius, makeElement) {
  var uniqueID2 = random_generator();
  globalTimeOut["" + uniqueID2] = { timeOut: 0, type: "Fabric", radius };
  create_fabric_element(container, uniqueID2, CLS_FABRICSPIN);
  fb_calculate_attributes(radius, container, CLS_FABRICSPIN);
}
function createFluentSpinner(container, radius, makeElement) {
  var uniqueID2 = random_generator();
  globalTimeOut["" + uniqueID2] = { timeOut: 0, type: "Fluent", radius };
  create_fabric_element(container, uniqueID2, CLS_FLUENTSPIN);
  fb_calculate_attributes(radius, container, CLS_FLUENTSPIN);
}
function createFluent2Spinner(container, radius, makeElement) {
  var uniqueID2 = random_generator();
  globalTimeOut["" + uniqueID2] = { timeOut: 0, type: "Fluent2", radius };
  create_fabric_element(container, uniqueID2, CLS_FLUENT2SPIN);
  fb_calculate_attributes(radius, container, CLS_FLUENT2SPIN);
}
function createTailwindSpinner(container, radius, makeElement) {
  var uniqueID2 = random_generator();
  globalTimeOut["" + uniqueID2] = { timeOut: 0, type: "Tailwind", radius };
  create_fabric_element(container, uniqueID2, CLS_TAILWINDSPIN);
  fb_calculate_attributes(radius, container, CLS_TAILWINDSPIN);
}
function createHighContrastSpinner(container, radius, makeElement) {
  var uniqueID2 = random_generator();
  globalTimeOut["" + uniqueID2] = { timeOut: 0, type: "HighContrast", radius };
  create_fabric_element(container, uniqueID2, CLS_HIGHCONTRASTSPIN);
  fb_calculate_attributes(radius, container, CLS_HIGHCONTRASTSPIN);
}
function getTheme(container) {
  var theme = (undefined).getComputedStyle(container, ":after").getPropertyValue("content");
  return theme.replace(/['"]+/g, "");
}
function setTheme(theme, container, radius, makeElement) {
  var innerContainer = container.querySelector("." + CLS_SPININWRAP);
  var svg = innerContainer.querySelector("svg");
  if (!isNullOrUndefined(svg)) {
    innerContainer.removeChild(svg);
  }
  switch (theme) {
    case "Material":
      createMaterialSpinner(innerContainer, radius, makeElement);
      break;
    case "Material3":
      createMaterial3Spinner(innerContainer, radius, makeElement);
      break;
    case "Fabric":
      createFabricSpinner(innerContainer, radius);
      break;
    case "Fluent":
      createFluentSpinner(innerContainer, radius);
      break;
    case "Fluent2":
      createFluent2Spinner(innerContainer, radius);
      break;
    case "Bootstrap":
      createBootstrapSpinner(innerContainer, radius);
      break;
    case "HighContrast":
      createHighContrastSpinner(innerContainer, radius);
      break;
    case "Bootstrap4":
      createBootstrap4Spinner(innerContainer, radius, makeElement);
      break;
    case "Bootstrap5":
      createBootstrap5Spinner(innerContainer, radius, makeElement);
      break;
    case "Tailwind":
    case "Tailwind-dark":
      createTailwindSpinner(innerContainer, radius);
      break;
    case "Tailwind3":
      createTailwind3Spinner(innerContainer, radius, makeElement);
      break;
  }
}
function createBootstrapSpinner(innerContainer, radius, makeElement) {
  var uniqueID2 = random_generator();
  globalTimeOut["" + uniqueID2] = { timeOut: 0, type: "Bootstrap", radius };
  create_bootstrap_element(innerContainer, uniqueID2);
  boot_calculate_attributes(innerContainer, radius);
}
function create_bootstrap_element(innerContainer, uniqueID2, makeElement) {
  var svgBoot = (undefined).createElementNS("http://www.w3.org/2000/svg", "svg");
  var viewBoxValue = 64;
  var trans = 32;
  var defaultRadius = 2;
  svgBoot.setAttribute("id", uniqueID2);
  svgBoot.setAttribute("class", CLS_BOOTSPIN);
  svgBoot.setAttribute("viewBox", "0 0 " + viewBoxValue + " " + viewBoxValue);
  innerContainer.insertBefore(svgBoot, innerContainer.firstChild);
  for (var item = 0; item <= 7; item++) {
    var bootCircle = (undefined).createElementNS("http://www.w3.org/2000/svg", "circle");
    bootCircle.setAttribute("class", CLS_SPINCIRCLE + "_" + item);
    bootCircle.setAttribute("r", defaultRadius + "");
    bootCircle.setAttribute("transform", "translate(" + trans + "," + trans + ")");
    svgBoot.appendChild(bootCircle);
  }
}
function boot_calculate_attributes(innerContainer, radius) {
  var svg = innerContainer.querySelector("svg.e-spin-bootstrap");
  var x = 0;
  var y = 0;
  var rad = 24;
  svg.style.width = svg.style.height = radius + "px";
  var startArc = 90;
  for (var item = 0; item <= 7; item++) {
    var start = defineArcPoints(x, y, rad, startArc);
    var circleEle = svg.querySelector("." + CLS_SPINCIRCLE + "_" + item);
    circleEle.setAttribute("cx", start.x + "");
    circleEle.setAttribute("cy", start.y + "");
    startArc = startArc >= 360 ? 0 : startArc;
    startArc = startArc + 45;
  }
}
function generateSeries(begin, stop) {
  var series = [];
  var start = begin;
  var end = stop;
  var increment = false;
  var count = 1;
  formSeries(start);
  function formSeries(i) {
    series.push(i);
    if (i !== end || count === 1) {
      if (i <= start && i > 1 && !increment) {
        i = parseFloat((i - 0.2).toFixed(2));
      } else if (i === 1) {
        i = 7;
        i = parseFloat((i + 0.2).toFixed(2));
        increment = true;
      } else if (i < 8 && increment) {
        i = parseFloat((i + 0.2).toFixed(2));
        if (i === 8) {
          increment = false;
        }
      } else if (i <= 8 && !increment) {
        i = parseFloat((i - 0.2).toFixed(2));
      }
      ++count;
      formSeries(i);
    }
  }
  return series;
}
function animateBootstrap(innerContainer) {
  var svg = innerContainer.querySelector("svg.e-spin-bootstrap");
  var id = svg.getAttribute("id");
  for (var i = 1; i <= 8; i++) {
    var circleEle = innerContainer.getElementsByClassName("e-path-circle_" + (i === 8 ? 0 : i))[0];
    rotation(circleEle, i, i, generateSeries(i, i), id);
  }
  function rotation(circle, start, end, series, id2) {
    var count = 0;
    boot_animate(start);
    function boot_animate(radius) {
      if (globalTimeOut["" + id2].isAnimate) {
        ++count;
        circle.setAttribute("r", radius + "");
        if (count >= series.length) {
          count = 0;
        }
        globalTimeOut[id2].timeOut = setTimeout(boot_animate.bind(null, series[count]), 18);
      }
    }
  }
}
function replaceContent(container, template, cssClass) {
  if (!isNullOrUndefined(cssClass)) {
    container.classList.add(cssClass);
  }
  var inner = container.querySelector(".e-spinner-inner");
  inner.innerHTML = template;
}
function calculateRadius(width, theme) {
  var defaultSize;
  switch (theme) {
    case "Material":
      defaultSize = DEFT_MAT_WIDTH;
      break;
    case "Material3":
      defaultSize = DEFT_MAT3_WIDTH;
      break;
    case "Fabric":
      defaultSize = DEFT_FAB_WIDTH;
      break;
    case "Tailwind":
    case "Tailwind-dark":
    case "Tailwind3":
      defaultSize = DEFT_FAB_WIDTH;
      break;
    case "Fluent":
      defaultSize = DEFT_FLUENT_WIDTH;
      break;
    case "Fluent2":
      defaultSize = DEFT_FLUENT2_WIDTH;
      break;
    case "Bootstrap4":
      defaultSize = DEFT_BOOT4_WIDTH;
      break;
    case "Bootstrap5":
      defaultSize = DEFT_BOOT5_WIDTH;
      break;
    default:
      defaultSize = DEFT_BOOT_WIDTH;
  }
  width = width ? parseFloat(width + "") : defaultSize;
  return theme === "Bootstrap" ? width : width / 2;
}
function globalVariables(id, radius, count, previousId) {
  return {
    radius,
    count,
    previousId
  };
}
function random_generator() {
  var random = "";
  var combine = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  for (var i = 0; i < 5; i++) {
    random += combine.charAt(Math.floor(Math.random() * combine.length));
  }
  return random;
}
function create_fabric_element(innerCon, uniqueID2, themeClass, makeElement) {
  var svgFabric = (undefined).createElementNS("http://www.w3.org/2000/svg", "svg");
  svgFabric.setAttribute("id", uniqueID2);
  svgFabric.setAttribute("class", themeClass);
  var fabricCirclePath = (undefined).createElementNS("http://www.w3.org/2000/svg", "path");
  fabricCirclePath.setAttribute("class", CLS_SPINCIRCLE);
  var fabricCircleArc = (undefined).createElementNS("http://www.w3.org/2000/svg", "path");
  fabricCircleArc.setAttribute("class", CLS_SPINARC);
  innerCon.insertBefore(svgFabric, innerCon.firstChild);
  svgFabric.appendChild(fabricCirclePath);
  svgFabric.appendChild(fabricCircleArc);
}
function create_material_element(innerContainer, uniqueID2, makeElement, cls) {
  var svgMaterial = (undefined).createElementNS("http://www.w3.org/2000/svg", "svg");
  var matCirclePath = (undefined).createElementNS("http://www.w3.org/2000/svg", "path");
  svgMaterial.setAttribute("class", cls);
  svgMaterial.setAttribute("id", uniqueID2);
  matCirclePath.setAttribute("class", CLS_SPINCIRCLE);
  innerContainer.insertBefore(svgMaterial, innerContainer.firstChild);
  svgMaterial.appendChild(matCirclePath);
}
function create_spinner_container(target, makeElement) {
  var spinnerContainer = makeElement("div", {});
  var spinnerInnerContainer = makeElement("div", {});
  spinnerContainer.classList.add(CLS_SPINWRAP);
  spinnerInnerContainer.classList.add(CLS_SPININWRAP);
  spinnerInnerContainer.setAttribute("aria-disabled", "true");
  target.appendChild(spinnerContainer);
  spinnerContainer.appendChild(spinnerInnerContainer);
  return { wrap: spinnerContainer, inner_wrap: spinnerInnerContainer };
}
function animateMaterial(spinnerInfo) {
  var start = 1;
  var end = 149;
  var duration = 1333;
  var max = 75;
  createCircle(start, end, easeAnimation, duration, spinnerInfo.globalInfo[spinnerInfo.uniqueID].count, max, spinnerInfo);
  spinnerInfo.globalInfo[spinnerInfo.uniqueID].count = ++spinnerInfo.globalInfo[spinnerInfo.uniqueID].count % 4;
}
function createCircle(start, end, easing, duration, count, max, spinnerInfo) {
  var id = ++spinnerInfo.globalInfo[spinnerInfo.uniqueID].previousId;
  var startTime = (/* @__PURE__ */ new Date()).getTime();
  var change = end - start;
  var diameter = getSize(spinnerInfo.globalInfo[spinnerInfo.uniqueID].radius * 2 + "");
  var strokeSize = getStrokeSize(diameter);
  var rotate = -90 * (spinnerInfo.globalInfo[spinnerInfo.uniqueID].count || 0);
  mat_animation(spinnerInfo);
  function mat_animation(spinnerInfo2) {
    var currentTime = Math.max(0, Math.min((/* @__PURE__ */ new Date()).getTime() - startTime, duration));
    updatePath(easing(currentTime, start, change, duration), spinnerInfo2.container);
    if (id === spinnerInfo2.globalInfo[spinnerInfo2.uniqueID].previousId && currentTime < duration) {
      globalTimeOut[spinnerInfo2.uniqueID].timeOut = setTimeout(mat_animation.bind(null, spinnerInfo2), 1);
    } else {
      animateMaterial(spinnerInfo2);
    }
  }
  function updatePath(value, container) {
    if (!isNullOrUndefined(container.querySelector("svg.e-spin-material")) || !isNullOrUndefined(container.querySelector("svg.e-spin-material3")) || !isNullOrUndefined(container.querySelector("svg.e-spin-tailwind3"))) {
      var svg = undefined;
      if (!isNullOrUndefined(container.querySelector("svg.e-spin-material")) && !isNullOrUndefined(container.querySelector("svg.e-spin-material").querySelector("path.e-path-circle"))) {
        svg = container.querySelector("svg.e-spin-material");
      } else if (!isNullOrUndefined(container.querySelector("svg.e-spin-material3")) && !isNullOrUndefined(container.querySelector("svg.e-spin-material3").querySelector("path.e-path-circle"))) {
        svg = container.querySelector("svg.e-spin-material3");
      } else if (!isNullOrUndefined(container.querySelector("svg.e-spin-tailwind3")) && !isNullOrUndefined(container.querySelector("svg.e-spin-tailwind3").querySelector("path.e-path-circle"))) {
        svg = container.querySelector("svg.e-spin-tailwind3");
      }
      if (!isNullOrUndefined(svg)) {
        var path = svg.querySelector("path.e-path-circle");
        path.setAttribute("stroke-dashoffset", getDashOffset(diameter, strokeSize, value, max) + "");
        path.setAttribute("transform", "rotate(" + rotate + " " + diameter / 2 + " " + diameter / 2 + ")");
      }
    }
  }
}
function mat_calculate_attributes(radius, container, type, cls) {
  var diameter = radius * 2;
  var svg = container.querySelector("svg." + cls);
  var path = svg.querySelector("path.e-path-circle");
  var strokeSize = getStrokeSize(diameter);
  var transformOrigin = diameter / 2 + "px";
  svg.setAttribute("viewBox", "0 0 " + diameter + " " + diameter);
  svg.style.width = svg.style.height = diameter + "px";
  svg.style.transformOrigin = transformOrigin + " " + transformOrigin + " " + transformOrigin;
  path.setAttribute("d", drawArc(diameter, strokeSize));
  if (type === "Material" || type === "Material3" || type === "Fluent2" || type === "Tailwind3") {
    path.setAttribute("stroke-width", strokeSize + "");
    path.setAttribute("stroke-dasharray", (diameter - strokeSize) * Math.PI * 0.75 + "");
    path.setAttribute("stroke-dashoffset", getDashOffset(diameter, strokeSize, 1, 75) + "");
  }
}
function getSize(value) {
  var parsed = parseFloat(value);
  return parsed;
}
function drawArc(diameter, strokeSize) {
  var radius = diameter / 2;
  var offset = strokeSize / 2;
  return "M" + radius + "," + offset + "A" + (radius - offset) + "," + (radius - offset) + " 0 1 1 " + offset + "," + radius;
}
function getStrokeSize(diameter) {
  return 10 / 100 * diameter;
}
function getDashOffset(diameter, strokeSize, value, max) {
  return (diameter - strokeSize) * Math.PI * (3 * max / 100 - value / 100);
}
function easeAnimation(current, start, change, duration) {
  var timestamp = (current /= duration) * current;
  var timecount = timestamp * current;
  return start + change * (6 * timecount * timestamp + -15 * timestamp * timestamp + 10 * timecount);
}
function fb_calculate_attributes(radius, innerConainer, trgClass) {
  var centerX = radius;
  var centerY = radius;
  var diameter = radius * 2;
  var startArc = 315;
  var endArc = 45;
  var svg = innerConainer.querySelector("." + trgClass);
  var circle = svg.querySelector(".e-path-circle");
  var path = svg.querySelector(".e-path-arc");
  var transformOrigin = diameter / 2 + "px";
  circle.setAttribute("d", defineCircle(centerX, centerY, radius));
  path.setAttribute("d", defineArc(centerX, centerY, radius, startArc, endArc));
  svg.setAttribute("viewBox", "0 0 " + diameter + " " + diameter);
  svg.style.transformOrigin = transformOrigin + " " + transformOrigin + " " + transformOrigin;
  svg.style.width = svg.style.height = diameter + "px";
}
function defineArcPoints(centerX, centerY, radius, angle) {
  var radians = (angle - 90) * Math.PI / 180;
  return {
    x: centerX + radius * Math.cos(radians),
    y: centerY + radius * Math.sin(radians)
  };
}
function defineArc(x, y, radius, startArc, endArc) {
  var start = defineArcPoints(x, y, radius, endArc);
  var end = defineArcPoints(x, y, radius, startArc);
  var d = [
    "M",
    start.x,
    start.y,
    "A",
    radius,
    radius,
    0,
    0,
    0,
    end.x,
    end.y
  ].join(" ");
  return d;
}
function defineCircle(x, y, radius) {
  var d = [
    "M",
    x,
    y,
    "m",
    -radius,
    0,
    "a",
    radius,
    radius,
    0,
    1,
    0,
    radius * 2,
    0,
    "a",
    radius,
    radius,
    0,
    1,
    0,
    -radius * 2,
    0
  ].join(" ");
  return d;
}
function showSpinner(container) {
  showHideSpinner(container, false);
  container = null;
}
function showHideSpinner(container, isHide) {
  var spinnerWrap;
  if (container) {
    if (container.classList.contains(CLS_SPINWRAP)) {
      spinnerWrap = container;
    } else {
      var spinWrapCollection = container.querySelectorAll("." + CLS_SPINWRAP);
      if (Browser.isIE) {
        for (var i = 0; i < spinWrapCollection.length; i++) {
          if (spinWrapCollection[i].parentElement && spinWrapCollection[i].parentElement === container) {
            spinnerWrap = spinWrapCollection[i];
            break;
          }
        }
      } else {
        spinnerWrap = Array.from(spinWrapCollection).find(function(wrap) {
          return wrap.parentElement === container;
        }) || null;
      }
    }
  }
  if (container && spinnerWrap) {
    var inner = spinnerWrap.querySelector("." + CLS_SPININWRAP);
    var spinCheck = isHide ? !spinnerWrap.classList.contains(CLS_SPINTEMPLATE) && !spinnerWrap.classList.contains(CLS_HIDESPIN) : !spinnerWrap.classList.contains(CLS_SPINTEMPLATE) && !spinnerWrap.classList.contains(CLS_SHOWSPIN);
    if (spinCheck) {
      var svgEle = spinnerWrap.querySelector("svg");
      if (isNullOrUndefined(svgEle)) {
        return;
      }
      var id = svgEle.getAttribute("id");
      globalTimeOut["" + id].isAnimate = !isHide;
      switch (globalTimeOut["" + id].type) {
        case "Material":
        case "Material3":
        case "Tailwind3":
          if (isHide) {
            clearTimeout(globalTimeOut[id].timeOut);
          } else {
            startMatAnimate(inner, id, globalTimeOut[id].radius);
          }
          break;
        case "Bootstrap":
          if (isHide) {
            clearTimeout(globalTimeOut[id].timeOut);
          } else {
            animateBootstrap(inner);
          }
          break;
      }
    }
    if (isHide) {
      classList(spinnerWrap, [CLS_HIDESPIN], [CLS_SHOWSPIN]);
    } else {
      classList(spinnerWrap, [CLS_SHOWSPIN], [CLS_HIDESPIN]);
    }
    container = null;
  }
}
function hideSpinner(container) {
  showHideSpinner(container, true);
  container = null;
}
var __awaiter = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : new P(function(resolve2) {
        resolve2(result.value);
      }).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
};
var __generator = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : undefined, done: true };
  }
};
var Draw = (
  /** @class */
  function() {
    function Draw2(parent) {
      this.isInitialLoading = false;
      this.fileName = "";
      this.isErrorImage = false;
      this.isShapeTextInserted = false;
      this.isRotateZoom = false;
      this.tempStrokeSettings = { strokeColor: "#fff", fillColor: "", strokeWidth: null, outlineColor: "", radius: null, outlineWidth: null };
      this.tempTextSettings = { text: "Enter Text", fontFamily: "", fontSize: null, fontRatio: null, bold: false, italic: false, underline: false };
      this.tempAdjValue = "";
      this.tempFilter = "";
      this.tempUndoRedoStep = 0;
      this.tempFreehandCounter = 0;
      this.tempCurrFhdIndex = 0;
      this.tempZoomFactor = null;
      this.isCancelAction = false;
      this.rotatedFlipCropSel = false;
      this.zoomCrop = { width: 0, height: 0 };
      this.isImageEdited = false;
      this.isFileChanged = false;
      this.isNewPath = false;
      this.isResizeSelect = false;
      this.arrowDimension = {
        bar: { width: 10, height: 32, ratioX: null, ratioY: null },
        arrow: { width: 24, height: 24, ratioX: null, ratioY: null },
        arrowSolid: { width: 32, height: 32, ratioX: null, ratioY: null },
        circle: { width: 10, height: 10, ratioX: null, ratioY: null },
        square: { width: 20, height: 20, ratioX: null, ratioY: null }
      };
      this.origDim = { width: 0, height: 0 };
      this.isImageApply = false;
      this.imgCanvasPoints = [];
      this.isCropSelect = false;
      this.isDownScale = false;
      this.preventStraightening = false;
      this.tempObjColl = [];
      this.tempPointColl = {};
      this.imageBackgroundColor = "";
      this.allowRedactStraighten = true;
      this.isNullExtension = true;
      this.isRedactStraighten = false;
      this.parent = parent;
      this.addEventListener();
    }
    Draw2.prototype.destroy = function() {
      if (this.parent.isDestroyed) {
        return;
      }
      this.removeEventListener();
    };
    Draw2.prototype.addEventListener = function() {
      this.parent.on("draw", this.draw, this);
      this.parent.on("destroyed", this.destroy, this);
    };
    Draw2.prototype.removeEventListener = function() {
      this.parent.off("draw", this.draw);
      this.parent.off("destroyed", this.destroy);
    };
    Draw2.prototype.draw = function(args) {
      this.updatePrivateVariables();
      switch (args.prop) {
        case "drawObject":
          this.drawObject(args.value["canvas"], args.value["obj"], args.value["isCropRatio"], args.value["points"], args.value["isPreventDrag"], args.value["saveContext"], args.value["isPreventSelection"]);
          break;
        case "updateActiveObject":
          this.updateActiveObject(args.value["actPoint"], args.value["obj"], args.value["isMouseMove"], args.value["x"], args.value["y"]);
          break;
        case "clearOuterCanvas":
          this.clearOuterCanvas(args.value["context"]);
          break;
        case "setDestPoints":
          this.setDestPoints();
          break;
        case "updateCurrTransState":
          this.updateCurrTransState(args.value["type"], args.value["isPreventDestination"], args.value["isRotatePan"]);
          break;
        case "currTransState":
          this.currTransState(args.value["type"], args.value["isPreventDestination"], args.value["context"], args.value["isPreventCircleCrop"]);
          break;
        case "setTransform":
          this.setTransform(args.value["context"], args.value["value"], args.value["isReverse"]);
          break;
        case "render-image":
          this.renderImage(args.value["isMouseWheel"], args.value["isPreventClearRect"], args.value["isFrame"], args.value["isStraighten"]);
          break;
        case "draw-image-to-canvas":
          this.drawImgToCanvas(args.value["dimension"]);
          break;
        case "update-canvas":
          this.updateCanvas();
          break;
        case "performCancel":
          this.performCancel(args.value["isContextualToolbar"], args.value["isUndoRedo"], args.value["isFinalCancel"]);
          break;
        case "updateFlipPan":
          this.updateFlipPan(args.value["tempSelectionObj"]);
          break;
        case "select":
          this.select(args.value["type"], args.value["startX"], args.value["startY"], args.value["width"], args.value["height"]);
          break;
        case "callUpdateCurrTransState":
          this.callUpdateCurrTransState();
          break;
        case "resetPanPoints":
          this.resetPanPoints();
          break;
        case "setClientTransDim":
          this.setClientTransDim(args.value["isPreventDimension"]);
          break;
        case "redrawImgWithObj":
          this.redrawImgWithObj();
          break;
        case "setCurrentObj":
          this.setCurrentObj(args.value["obj"], args.value["isUndoRedo"], args.value["isCircleCrop"]);
          break;
        case "performPointZoom":
          this.performPointZoom(args.value["x"], args.value["y"], args.value["type"], args.value["isResize"]);
          break;
        case "open":
          this.open(args.value["data"]);
          break;
        case "isInitialLoading":
          this.isInitialLoading = args.value["isInitialLoading"];
          break;
        case "isInitialLoaded":
          this.getInitialLoaded(args.value["object"]);
          break;
        case "fileSelect":
          this.fileSelect(args.value["inputElement"], args.value["args"]);
          break;
        case "getFileName":
          args.value["obj"]["fileName"] = this.fileName;
          args.value["obj"]["fileType"] = this.fileType;
          break;
        case "getErrorImage":
          args.value["obj"]["isErrorImage"] = this.isErrorImage;
          break;
        case "getInitialZoomValue":
          args.value["obj"]["initialZoomValue"] = this.initZoomValue;
          break;
        case "setShapeTextInsert":
          this.isShapeTextInserted = args.value["bool"];
          break;
        case "resetCurrentSelectionPoint":
          this.currSelPoint = null;
          break;
        case "setRotateZoom":
          this.isRotateZoom = args.value["isRotateZoom"];
          break;
        case "setTempStrokeSettings":
          this.tempStrokeSettings = args.value["tempStrokeSettings"];
          break;
        case "setTempTextSettings":
          this.tempTextSettings = args.value["tempTextSettings"];
          break;
        case "setTempAdjustmentValue":
          this.tempAdjValue = args.value["tempAdjustmentValue"];
          break;
        case "getTempAdjustmentValue":
          args.value["obj"]["value"] = this.tempAdjValue;
          break;
        case "setTempFilter":
          this.tempFilter = args.value["tempFilter"];
          break;
        case "setTempUndoRedoStep":
          this.tempUndoRedoStep = args.value["tempUndoRedoStep"];
          break;
        case "setTempFreehandCounter":
          this.tempFreehandCounter = args.value["tempFreehandCounter"];
          break;
        case "setTempCurrentFreehandDrawIndex":
          this.tempCurrFhdIndex = args.value["tempCurrentFreehandDrawIndex"];
          break;
        case "setTempZoomFactor":
          this.tempZoomFactor = args.value["tempZoomFactor"];
          break;
        case "setCancelAction":
          this.isCancelAction = args.value["bool"];
          break;
        case "getRotatedFlipCropSelection":
          args.value["bool"]["isSelected"] = this.rotatedFlipCropSel;
          break;
        case "getPrevActObj":
          args.value["obj"]["prevActObj"] = this.prevActObj;
          break;
        case "setPrevActObj":
          this.prevActObj = args.value["prevActObj"];
          break;
        case "setZoomCropWidth":
          this.zoomCrop.width = args.value["width"];
          this.zoomCrop.height = args.value["height"];
          break;
        case "setImageEdited":
          this.isImageEdited = true;
          break;
        case "reset":
          this.reset();
          break;
        case "setNewPath":
          this.isNewPath = args.value["bool"];
          break;
        case "getNewPath":
          args.value["obj"]["isNewPath"] = this.isNewPath;
          break;
        case "getArrowDimension":
          args.value["obj"]["arrowDimension"] = extend({}, this.arrowDimension, {}, true);
          break;
        case "setArrowDimension":
          this.arrowDimension = args.value["arrowDimension"];
          break;
        case "moveToSelectionRange":
          this.moveToSelectionRange(args.value["type"], args.value["activeObj"]);
          break;
        case "setResizeSelect":
          this.isResizeSelect = args.value["bool"];
          break;
        case "applyFrame":
          this.applyFrame(args.value["ctx"], args.value["frame"], args.value["preventImg"]);
          break;
        case "drawImage":
          this.drawImage();
          break;
        case "downScaleImgCanvas":
          this.downScaleImgCanvas(args.value["ctx"], args.value["isImgAnnotation"], args.value["isHFlip"], args.value["isVFlip"]);
          break;
        case "downScale":
          this.downScale(args.value["canvas"], args.value["width"], args.value["height"]);
          break;
        case "resetFrameZoom":
          this.resetFrameZoom(args.value["isOk"]);
          break;
        case "triggerFrameChange":
          args.value["obj"]["frameChangeEventArgs"] = this.triggerFrameChange(args.value["prevFrameSettings"]);
          break;
        case "setImageApply":
          this.isImageApply = args.value["bool"];
          break;
        case "zoomToSel":
          this.zoomToSel(args.value["activeObj"], args.value["isToolbar"]);
          break;
        case "getStraightenActObj":
          args.value["obj"]["activeObj"] = this.straightenActObj;
          break;
        case "setStraightenActObj":
          this.straightenActObj = args.value["activeObj"];
          break;
        case "updateImgCanvasPoints":
          this.updateImgCanvasPoints();
          break;
        case "isLinesIntersect":
          args.value["obj"]["isIntersect"] = this.isLinesIntersect(args.value["obj"]);
          break;
        case "getImageCanvasPoints":
          args.value["obj"]["points"] = this.imgCanvasPoints;
          break;
        case "setDestForStraighten":
          this.setDestForStraighten();
          break;
        case "setTempDestForStraighten":
          this.tempStraightenDestPoints = extend({}, this.straightenDestPoints, {}, true);
          break;
        case "getStraightenInitZoom":
          args.value["obj"]["zoomFactor"] = this.straightenInitZoom;
          break;
        case "setStraightenInitZoom":
          this.straightenInitZoom = args.value["zoomFactor"];
          break;
        case "isPointsInsideImg":
          args.value["obj"]["bool"] = this.checkPointPosition(args.value["x"], args.value["y"], this.imgCanvasPoints[0].x, this.imgCanvasPoints[0].y, this.imgCanvasPoints[1].x, this.imgCanvasPoints[1].y, this.imgCanvasPoints[2].x, this.imgCanvasPoints[2].y, this.imgCanvasPoints[3].x, this.imgCanvasPoints[3].y) !== "inside";
          break;
        case "setIsCropSelect":
          this.isCropSelect = args.value["bool"];
          break;
        case "updateCropSelection":
          this.updateCropSelection();
          break;
        case "updateCropSelObj":
          this.updateCropSelObj();
          break;
        case "redrawDownScale":
          this.redrawDownScale();
          break;
        case "updateFinetune":
          this.updateFinetune();
          break;
        case "isSelOutsideImg":
          args.value["obj"]["bool"] = this.isSelOutsideImg();
          break;
        case "resetStraightenDestPoints":
          this.straightenDestPoints = null;
          break;
        case "checkPointPosition":
          args.value["obj"]["position"] = this.checkPointPosition(args.value["obj"]["x"], args.value["obj"]["y"], args.value["obj"]["x1"], args.value["obj"]["y1"], args.value["obj"]["x2"], args.value["obj"]["y2"], args.value["obj"]["x3"], args.value["obj"]["y3"], args.value["obj"]["x4"], args.value["obj"]["y4"]);
          break;
        case "updateTempObjColl":
          this.tempObjColl = extend([], this.parent.objColl, [], true);
          break;
        case "resetTempObjColl":
          this.tempObjColl = null;
          break;
        case "updateTempPointColl":
          this.tempPointColl = extend({}, this.parent.pointColl, {}, true);
          break;
        case "resetTempPointColl":
          this.tempPointColl = {};
          break;
        case "showDialogPopup":
          this.showDialogPopup();
          break;
        case "imageBackgroundColor":
          this.imageBackgroundColor = args.value["color"];
          break;
        case "getImageBackgroundColor":
          args.value["obj"]["color"] = this.imageBackgroundColor;
          break;
        case "setTempStrokeWidth":
          this.tempStrokeWidth = args.value["strokeWidth"];
          break;
        case "setNullExtension":
          this.isNullExtension = args.value["extension"];
          break;
        case "setRedactStraighten":
          this.isRedactStraighten = args.value["bool"];
          break;
      }
    };
    Draw2.prototype.getModuleName = function() {
      return "draw";
    };
    Draw2.prototype.updatePrivateVariables = function() {
      var parent = this.parent;
      if (parent.lowerCanvas) {
        this.lowerContext = parent.lowerCanvas.getContext("2d");
      }
      if (parent.upperCanvas) {
        this.upperContext = parent.upperCanvas.getContext("2d");
      }
      if (isNullOrUndefined(this.tempZoomFactor)) {
        this.tempZoomFactor = parent.transform.zoomFactor;
      }
      if (this.tempTextSettings.fontFamily === "") {
        this.tempTextSettings.fontFamily = parent.fontFamily.default;
      }
    };
    Draw2.prototype.reset = function() {
      this.isInitialLoading = this.isErrorImage = this.isNewPath = this.isResizeSelect = false;
      this.isShapeTextInserted = false;
      this.isImageApply = false;
      this.isNullExtension = true;
      this.initZoomValue = null;
      this.tempFilter = "";
      this.origDim = { width: 0, height: 0 };
      this.currSelPoint = null;
      this.isRotateZoom = false;
      this.tempAdjValue = "";
      this.tempStrokeSettings = { strokeColor: "#fff", fillColor: "", strokeWidth: null, radius: null, outlineColor: "", outlineWidth: null };
      this.tempTextSettings = { text: "Enter Text", fontFamily: this.parent.fontFamily.default, fontSize: null, fontRatio: null, bold: false, italic: false, underline: false };
      this.tempUndoRedoStep = this.tempFreehandCounter = this.tempCurrFhdIndex = 0;
      this.tempZoomFactor = null;
      this.isCancelAction = false;
      this.rotatedFlipCropSel = false;
      this.prevActObj = null;
      this.tempStraightenDestPoints = null;
      this.arrowDimension = {
        bar: { width: 10, height: 32, ratioX: null, ratioY: null },
        arrow: { width: 24, height: 24, ratioX: null, ratioY: null },
        arrowSolid: { width: 32, height: 32, ratioX: null, ratioY: null },
        circle: { width: 10, height: 10, ratioX: null, ratioY: null },
        square: { width: 20, height: 20, ratioX: null, ratioY: null }
      };
      this.straightenActObj = null;
      this.imgCanvasPoints = [];
      this.straightenInitZoom = null;
      this.allowRedactStraighten = true;
      this.tempObjColl = [];
      this.tempPointColl = {};
      this.imageBackgroundColor = "";
      this.tempStrokeWidth = null;
      this.straightenDestPoints = null;
      this.isCropSelect = this.isDownScale = this.preventStraightening = false;
      this.isRedactStraighten = false;
    };
    Draw2.prototype.redrawDownScale = function() {
      var parent = this.parent;
      if (parent.transform.zoomFactor && parent.transform.zoomFactor < 0) {
        var activeObj = extend({}, parent.activeObj, {}, true);
        parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        this.isDownScale = true;
        this.renderImage();
        this.isDownScale = false;
        if (activeObj.shape) {
          this.drawObject("duplicate", activeObj);
        }
      }
    };
    Draw2.prototype.updateFinetune = function() {
      var parent = this.parent;
      if (parent.transform.zoomFactor && parent.transform.zoomFactor < 0) {
        var filter = this.lowerContext.filter;
        this.lowerContext.filter = "none";
        parent.notify("draw", { prop: "redrawDownScale" });
        var inMemoryContext = parent.inMemoryCanvas.getContext("2d");
        var ctx = this.lowerContext;
        var imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
        parent.inMemoryCanvas.width = imageData.width;
        parent.inMemoryCanvas.height = imageData.height;
        inMemoryContext.putImageData(imageData, 0, 0);
        this.lowerContext.filter = filter;
        parent.notify("draw", { prop: "redrawDownScale" });
      }
    };
    Draw2.prototype.drawImage = function() {
      this.applyFrame(this.lowerContext, this.parent.frameObj.type);
    };
    Draw2.prototype.drawObject = function(canvas, obj, isCropRatio, points, isPreventDrag, saveContext, isPreventSelection) {
      var parent = this.parent;
      var actObj = parent.activeObj;
      var actPoint = parent.activeObj.activePoint;
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      var canvasDraw;
      canvas = canvas.toLowerCase();
      if (canvas === "original") {
        canvasDraw = this.lowerContext;
      } else if (canvas === "duplicate") {
        canvasDraw = this.upperContext;
      } else if (saveContext) {
        canvasDraw = saveContext;
      }
      if (!isPreventDrag && actObj.shape) {
        this.setDragLimit();
      }
      if (parent.currObjType.shape) {
        var splitWords = parent.currObjType.shape.split("-");
        if (splitWords[0].toLowerCase() === "crop" && isCropRatio) {
          this.drawCropRatio();
        }
      }
      actObj = parent.activeObj;
      actPoint = parent.activeObj.activePoint;
      if (isNullOrUndefined(actObj.strokeSettings)) {
        var obj_1 = { strokeSettings: {} };
        parent.notify("shape", { prop: "getStrokeSettings", onPropertyChange: false, value: { obj: obj_1 } });
        actObj.strokeSettings = obj_1["strokeSettings"];
      }
      if (isNullOrUndefined(actObj.strokeSettings.strokeWidth)) {
        actObj.strokeSettings.strokeWidth = 2;
      }
      if (obj) {
        parent.activeObj = extend({}, obj, {}, true);
      }
      if (points && points.startX && points.startY && points.endX && points.endY && points.width && points.height) {
        actPoint.startX = points.startX;
        actPoint.startY = points.startY;
        actPoint.endX = points.endX;
        actPoint.endY = points.endY;
        actPoint.width = points.width;
        actPoint.height = points.height;
      }
      this.updateActiveObject();
      actObj = parent.activeObj;
      actPoint = parent.activeObj.activePoint;
      if (isNullOrUndefined(actPoint.startX) && isNullOrUndefined(actPoint.startY)) {
        return;
      }
      if (parent.currObjType.isText) {
        var obj_2 = { keyHistory: "" };
        parent.notify("shape", { prop: "getKeyHistory", onPropertyChange: false, value: { obj: obj_2 } });
        actObj.keyHistory = obj_2["keyHistory"];
      }
      var isCrop = false;
      if (canvas !== "original") {
        var splitWords = undefined;
        if (actObj.shape) {
          splitWords = actObj.shape.split("-");
          if (splitWords[0] === "crop") {
            isCrop = true;
          }
        }
        if (isCrop) {
          if (points && points.startX && points.startY && points.endX && points.endY && points.width && points.height) {
            actPoint.startX = points.startX;
            actPoint.startY = points.startY;
            actPoint.endX = points.endX;
            actPoint.endY = points.endY;
            actPoint.width = points.width;
            actPoint.height = points.height;
          } else {
            actPoint = actObj.activePoint;
          }
          this.upperContext.fillStyle = "rgb(0, 0, 0, 0.25)";
          this.upperContext.fillRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
          this.upperContext.clearRect(actPoint.startX, actPoint.startY, actPoint.width, actPoint.height);
        }
        if (isNullOrUndefined(isPreventSelection) && (canvasDraw === this.lowerContext || canvasDraw === this.upperContext)) {
          this.rotateContext("initial", canvasDraw);
          this.drawOuterSelection(canvasDraw);
          this.rotateContext("reverse", canvasDraw);
        }
      }
      parent.currObjType.isActiveObj = true;
      var object = { keyHistory: "" };
      parent.notify("shape", { prop: "getKeyHistory", onPropertyChange: false, value: { obj: object } });
      if (obj) {
        this.drawShapeObj(canvas, obj.shape, saveContext, isPreventSelection);
      } else if (object["keyHistory"] !== "" && parent.currObjType.isText) {
        this.drawShapeObj(canvas, "text", saveContext, isPreventSelection);
      } else if (actObj.shape) {
        this.drawShapeObj(canvas, actObj.shape, saveContext, isPreventSelection);
      } else {
        this.drawShapeObj(canvas, undefined, saveContext, isPreventSelection);
      }
      if (canvas === "duplicate" && isCrop && actObj.shape !== "crop-circle" && parent.frameObj.type !== "none") {
        this.applyFrame(this.upperContext, parent.frameObj.type);
        this.drawCornerCircles(this.upperContext);
      }
    };
    Draw2.prototype.rotateContext = function(type, ctx) {
      var parent = this.parent;
      var _a = parent.activeObj, shape = _a.shape, rotatedAngle = _a.rotatedAngle;
      var _b = parent.img, destLeft = _b.destLeft, destTop = _b.destTop, destWidth = _b.destWidth, destHeight = _b.destHeight;
      var _c = parent.activeObj.activePoint, startX = _c.startX, startY = _c.startY, width = _c.width, height = _c.height;
      if (shape === "line" || shape === "arrow") {
        return;
      }
      var rotationAngle = type === "initial" ? rotatedAngle : -rotatedAngle;
      var translateX;
      var translateY;
      if (parent.transform.straighten === 0 && !parent.isCropTab) {
        translateX = startX + width / 2;
        translateY = startY + height / 2;
      } else {
        translateX = destLeft + destWidth / 2;
        translateY = destTop + destHeight / 2;
      }
      ctx.translate(translateX, translateY);
      ctx.rotate(rotationAngle);
      ctx.translate(-translateX, -translateY);
    };
    Draw2.prototype.setDragLimit = function() {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var _a = parent.activeObj, shape = _a.shape, rotatedAngle = _a.rotatedAngle;
      if (actPoint && shape !== "image" && shape !== "line" && rotatedAngle === 0 && parent.activeObj.preventShapeDragOut) {
        var _b = parent.img, destLeft = _b.destLeft, destTop = _b.destTop, destWidth = _b.destWidth, destHeight = _b.destHeight;
        if (actPoint.startX < destLeft) {
          actPoint.startX = destLeft;
          actPoint.endX = Math.min(actPoint.startX + actPoint.width, destLeft + destWidth);
        } else if (actPoint.endX > destLeft + destWidth) {
          actPoint.endX = destLeft + destWidth;
          actPoint.startX = Math.max(actPoint.endX - actPoint.width, destLeft);
        }
        if (actPoint.startY < destTop) {
          actPoint.startY = destTop;
        } else if (actPoint.endY > destTop + destHeight) {
          actPoint.endY = destTop + destHeight;
          actPoint.startY = Math.max(actPoint.endY - actPoint.height, destTop);
        }
        parent.activeObj = this.updateWidthHeight(parent.activeObj);
      }
    };
    Draw2.prototype.drawCropRatio = function() {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var x;
      var y;
      var width;
      var height;
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      if (parent.transform.zoomFactor > 0 && this.currSelPoint) {
        var activeObj = extend({}, parent.activeObj, {}, true);
        this.drawCustomSelection("crop-custom", null, null, null, null);
        if (parent.transform.straighten !== 0) {
          actPoint = parent.activeObj.activePoint;
        }
        if (parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0) {
          width = actPoint.width < actPoint.height ? actPoint.width : actPoint.height;
          height = width;
        } else {
          width = actPoint.width;
          height = actPoint.height;
        }
        parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        parent.activeObj = activeObj;
        parent.currObjType.shape = activeObj.shape;
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        parent.currObjType.isCustomCrop = false;
      } else {
        width = destWidth;
        height = destHeight;
        if (destLeft < 0) {
          width += destLeft;
        }
        if (destTop < 0) {
          height += destTop;
        }
        if (destLeft + destWidth > parent.lowerCanvas.width) {
          width -= destLeft + destWidth - parent.lowerCanvas.width;
        }
        if (destTop + destHeight > parent.lowerCanvas.height) {
          height -= destTop + destHeight - parent.lowerCanvas.height;
        }
      }
      switch (parent.currObjType.shape.toLowerCase()) {
        case "crop-square":
        case "crop-circle":
          parent.notify("selection", { prop: "setDragDirection", onPropertyChange: false, value: { width, height } });
          actPoint = parent.activeObj.activePoint;
          if (parent.lowerCanvas.width < actPoint.endX - actPoint.startX) {
            actPoint.startX = 7.5;
            actPoint.endX = parent.lowerCanvas.width - 7.5;
          }
          if (parent.lowerCanvas.height < actPoint.endY - actPoint.startY) {
            actPoint.startY = 7.5;
            actPoint.endY = parent.lowerCanvas.height - 7.5;
          }
          if (width === destWidth && height === destHeight) {
            actPoint.startX += destLeft;
            actPoint.startY += destTop;
            actPoint.endX += destLeft;
            actPoint.endY += destTop;
          }
          if (parent.lowerCanvas.width > parent.lowerCanvas.height) {
            actPoint.height = actPoint.endY - actPoint.startY;
            actPoint.width = actPoint.height;
            actPoint.endX = actPoint.startX + actPoint.width;
          } else {
            actPoint.width = actPoint.endX - actPoint.startX;
            actPoint.height = actPoint.width;
            actPoint.endY = actPoint.startY + actPoint.height;
          }
          break;
        case "crop-3:2":
          x = 3;
          y = 2;
          break;
        case "crop-4:3":
          x = 4;
          y = 3;
          break;
        case "crop-5:4":
          x = 5;
          y = 4;
          break;
        case "crop-7:5":
          x = 7;
          y = 5;
          break;
        case "crop-16:9":
          x = 16;
          y = 9;
          break;
        case "crop-2:3":
          x = 2;
          y = 3;
          break;
        case "crop-3:4":
          x = 3;
          y = 4;
          break;
        case "crop-4:5":
          x = 4;
          y = 5;
          break;
        case "crop-5:7":
          x = 5;
          y = 7;
          break;
        case "crop-9:16":
          x = 9;
          y = 16;
          break;
        default:
          x = parseInt(parent.currObjType.shape.toLowerCase().split("crop-")[1].split(":")[0]);
          y = parseInt(parent.currObjType.shape.toLowerCase().split("crop-")[1].split(":")[1]);
          break;
      }
      if (x !== undefined && y !== undefined) {
        parent.notify("selection", {
          prop: "calcShapeRatio",
          onPropertyChange: false,
          value: { x, y, imgWidth: width, imgHeight: height }
        });
        if (width === destWidth && height === destHeight) {
          this.updatePoints();
        }
        actPoint = parent.activeObj.activePoint;
      }
      if (actPoint.startX < destLeft) {
        var diff = destLeft - actPoint.startX + 7.5;
        actPoint.startX += diff;
        actPoint.endX += diff;
      }
      if (actPoint.startY < destTop) {
        var diff = destTop - actPoint.startY + 7.5;
        actPoint.startY += diff;
        actPoint.endY += diff;
      }
      parent.activeObj = this.updateWidthHeight(parent.activeObj);
      this.adjToCenter();
      this.enlargeToImg();
      if (parent.transform.straighten !== 0) {
        this.adjToStraighten();
        this.updateActiveObject(parent.activeObj.activePoint, parent.activeObj);
      }
      var object = { isIntersect: null, arr: null };
      var count = 0;
      actPoint = parent.activeObj.activePoint;
      if (parent.transform.straighten !== 0) {
        while (this.isLinesIntersect(object) && count < 100) {
          count++;
          var diff = actPoint.width * 1 / 100;
          actPoint.startX += diff;
          actPoint.endX -= diff;
          diff = actPoint.height * 1 / 100;
          actPoint.startY += diff;
          actPoint.endY -= diff;
          actPoint.width = actPoint.endX - actPoint.startX;
          actPoint.height = actPoint.endY - actPoint.startY;
          this.updateActiveObject(actPoint, parent.activeObj);
        }
      }
      this.straightenInitZoom = parent.transform.zoomFactor;
      this.straightenActObj = extend({}, parent.activeObj, {}, true);
      parent.notify("draw", { prop: "resetStraightenDestPoints" });
      parent.notify("draw", { prop: "setDestForStraighten" });
    };
    Draw2.prototype.adjToCenter = function() {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      var diffX = parent.lowerCanvas.width / 2 - (actPoint.endX - actPoint.width / 2);
      var diffY = parent.lowerCanvas.height / 2 - (actPoint.endY - actPoint.height / 2);
      actPoint.startX += diffX;
      actPoint.endX += diffX;
      actPoint.startY += diffY;
      actPoint.endY += diffY;
      if (actPoint.startX < (destLeft >= 7.5 ? destLeft : 7.5)) {
        var diff = (destLeft >= 7.5 ? destLeft : 0) - actPoint.startX;
        actPoint.startX += diff;
        actPoint.endX += diff;
      } else if (actPoint.endX > destLeft + destWidth) {
        var diff = actPoint.endX - (destLeft + destWidth);
        actPoint.startX -= diff;
        actPoint.endX -= diff;
      }
      if (actPoint.startY < (destTop >= 7.5 ? destTop : 7.5)) {
        var diff = (destTop >= 7.5 ? destTop : 0) - actPoint.startY;
        actPoint.startY += diff;
        actPoint.endY += diff;
      } else if (actPoint.endY > destTop + destHeight) {
        var diff = actPoint.endY - (destTop + destHeight);
        actPoint.startY -= diff;
        actPoint.endY -= diff;
      }
    };
    Draw2.prototype.enlargeToImg = function() {
      var parent = this.parent;
      if (parent.transform.straighten === 0) {
        return;
      }
      if (parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0) {
        var actPoint = parent.activeObj.activePoint;
        var tempActPoint = extend({}, actPoint, {}, true);
        var count = 0;
        while (true) {
          count++;
          var diff = actPoint.width * 5 / 100;
          actPoint.startX -= diff;
          actPoint.endX += diff;
          diff = actPoint.height * 5 / 100;
          actPoint.startY -= diff;
          actPoint.endY += diff;
          actPoint.width = actPoint.endX - actPoint.startX;
          actPoint.height = actPoint.endY - actPoint.startY;
          this.updateActiveObject(actPoint, parent.activeObj);
          var object = { isIntersect: null, arr: null };
          this.updateImgCanvasPoints();
          this.isLinesIntersect(object);
          if (object["arr"][0] || object["arr"][1] || object["arr"][2] || object["arr"][3] || actPoint.startX < 7.5 || actPoint.startY < 7.5 || count === 100) {
            actPoint = extend({}, tempActPoint, {}, true);
            diff = actPoint.width * 1 / 100;
            actPoint.startX += diff;
            actPoint.endX -= diff;
            diff = actPoint.height * 1 / 100;
            actPoint.startY += diff;
            actPoint.endY -= diff;
            actPoint.width = actPoint.endX - actPoint.startX;
            actPoint.height = actPoint.endY - actPoint.startY;
            this.updateActiveObject(actPoint, parent.activeObj);
            break;
          }
          tempActPoint = extend({}, actPoint, {}, true);
        }
      }
    };
    Draw2.prototype.updateActiveObject = function(actPoint, obj, isMouseMove, x, y) {
      var parent = this.parent;
      actPoint = actPoint ? actPoint : extend({}, parent.activeObj.activePoint, {}, true);
      obj = obj ? obj : extend({}, parent.activeObj, {}, true);
      actPoint.width = actPoint.endX - actPoint.startX;
      actPoint.height = actPoint.endY - actPoint.startY;
      var startX = actPoint.startX, startY = actPoint.startY, endX = actPoint.endX, endY = actPoint.endY, width = actPoint.width, height = actPoint.height;
      x = x ? x : 0;
      y = y ? y : 0;
      var horCircleWidth = width / 2;
      var verCircleHeight = height / 2;
      var radius = 7.5;
      obj.horTopLine = {
        startX: startX + x,
        startY: startY - y,
        endX: endX + x,
        endY: endY + y
      };
      obj.horBottomLine = {
        startX: startX - x,
        startY: endY - y,
        endX: endX - x,
        endY: endY + y
      };
      obj.verLeftLine = {
        startX: startX + x,
        startY: startY - y,
        endX: startX - y,
        endY: endY - y
      };
      obj.verRightLine = {
        startX: endX + x,
        startY: startY + y,
        endX: endX - x,
        endY: endY + y
      };
      obj.topLeftCircle = {
        startX,
        startY,
        radius: obj.horTopLine.endX ? radius : 0
      };
      obj.topCenterCircle = {
        startX: startX + horCircleWidth,
        startY,
        radius: obj.horTopLine.endX ? radius : 0
      };
      obj.topRightCircle = {
        startX: endX,
        startY,
        radius: obj.horTopLine.endX ? radius : 0
      };
      obj.centerLeftCircle = {
        startX,
        startY: startY + verCircleHeight,
        radius: obj.horTopLine.endX ? radius : 0
      };
      obj.centerRightCircle = {
        startX: endX,
        startY: startY + verCircleHeight,
        radius: obj.horTopLine.endX ? radius : 0
      };
      obj.bottomLeftCircle = {
        startX,
        startY: endY,
        radius: obj.horTopLine.endX ? radius : 0
      };
      obj.bottomCenterCircle = {
        startX: startX + horCircleWidth,
        startY: endY,
        radius: obj.horTopLine.endX ? radius : 0
      };
      obj.bottomRightCircle = {
        startX: endX,
        startY: endY,
        radius: obj.horTopLine.endX ? radius : 0
      };
      if (obj.rotatedAngle === 0) {
        obj.rotationCirclePoint = {
          x: obj.bottomCenterCircle.startX,
          y: obj.bottomCenterCircle.startY + 25
        };
        obj.rotationCirclePoint.ratioX = (obj.rotationCirclePoint.x - parent.img.destLeft) / parent.img.destWidth;
        obj.rotationCirclePoint.ratioY = (obj.rotationCirclePoint.y - parent.img.destTop) / parent.img.destHeight;
      }
      obj.activePoint = actPoint;
      if (isNullOrUndefined(isMouseMove)) {
        parent.activeObj = extend({}, obj, {}, true);
      }
    };
    Draw2.prototype.drawOuterSelection = function(canvasDraw, isCropCircle) {
      var splitWords;
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var actObj = parent.activeObj;
      canvasDraw.lineWidth = 0.5;
      var tempObj = extend({}, actObj, {}, true);
      if (actObj.shape) {
        splitWords = actObj.shape.split("-");
      }
      if ((splitWords && splitWords[0] === "crop" || actObj.shape === undefined) && !isCropCircle) {
        this.upperContext.fillStyle = "rgb(0, 0, 0, 0.25)";
        this.upperContext.fillRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        this.upperContext.clearRect(actPoint.startX, actPoint.startY, actPoint.width, actPoint.height);
      }
      canvasDraw.strokeStyle = parent.themeColl[parent.theme]["primaryColor"];
      canvasDraw.fillStyle = parent.themeColl[parent.theme]["secondaryColor"];
      if (tempObj.shapeDegree === 0) {
        parent.transform.degree;
      } else {
        parent.transform.degree - tempObj.shapeDegree;
      }
      if (actObj.shape === "arrow" || actObj.shape === "line") {
        canvasDraw.beginPath();
        canvasDraw.moveTo(actPoint.startX, actPoint.startY);
        canvasDraw.lineTo(actPoint.endX, actPoint.endY);
        canvasDraw.stroke();
      } else if (actObj.shape === "path") {
        canvasDraw.beginPath();
        var activeObj = extend({}, parent.activeObj, {}, true);
        if (activeObj.pointColl[0]) {
          canvasDraw.moveTo(activeObj.pointColl[0].x, activeObj.pointColl[0].y);
          if (activeObj.pointColl.length > 1) {
            for (var i = 1, len = activeObj.pointColl.length; i < len; i++) {
              actPoint.endX = activeObj.pointColl[i].x;
              actPoint.endY = activeObj.pointColl[i].y;
              canvasDraw.lineTo(actPoint.endX, actPoint.endY);
            }
          }
        }
        var obj = { shape: null };
        parent.notify("selection", { prop: "getCurrentDrawingShape", value: { obj } });
        if (obj["shape"] === "path") {
          parent.activeObj = actObj = activeObj;
        }
        canvasDraw.lineTo(actPoint.endX, actPoint.endY);
        canvasDraw.stroke();
      } else {
        this.drawCornerCircles(canvasDraw);
      }
      if (parent.selectionSettings.showCircle && (splitWords === undefined || splitWords[0] !== "crop")) {
        var strokeColor = canvasDraw.strokeStyle;
        var fillColor = canvasDraw.fillStyle;
        canvasDraw.strokeStyle = parent.selectionSettings.strokeColor;
        canvasDraw.fillStyle = parent.selectionSettings.fillColor;
        if (actObj.shape === "text") {
          canvasDraw.lineWidth *= 2;
          canvasDraw.beginPath();
          this.drawRotationArcLine(canvasDraw);
          canvasDraw.lineTo(actObj.rotationCirclePoint.x, actObj.rotationCirclePoint.y);
          canvasDraw.stroke();
          canvasDraw.fill();
          canvasDraw.closePath();
          canvasDraw.beginPath();
          canvasDraw.moveTo(actObj.rotationCirclePoint.x, actObj.rotationCirclePoint.y);
          canvasDraw.arc(actObj.rotationCirclePoint.x, actObj.rotationCirclePoint.y, actObj.bottomCenterCircle.radius, 0, 2 * Math.PI);
          canvasDraw.stroke();
          canvasDraw.fill();
          canvasDraw.closePath();
          canvasDraw.lineWidth /= 2;
        } else {
          if (parent.activeObj.shape !== "redact") {
            this.drawCenterCircles(canvasDraw);
          }
        }
        canvasDraw.strokeStyle = strokeColor;
        canvasDraw.fillStyle = fillColor;
      }
      tempObj.rotationCircleLine = actObj.rotationCircleLine;
      parent.activeObj = extend({}, tempObj, {}, true);
    };
    Draw2.prototype.drawArrowHead = function(canvasDraw, isStartHead) {
      var headType = isStartHead ? this.parent.activeObj.start : this.parent.activeObj.end;
      switch (headType) {
        case "arrowSolid":
          isStartHead ? this.arrowSolid(canvasDraw, true) : this.arrowSolid(canvasDraw, false);
          break;
        case "arrow":
          isStartHead ? this.arrow(canvasDraw, true) : this.arrow(canvasDraw, false);
          break;
        case "circleSolid":
          isStartHead ? this.arrowCircleSolid(canvasDraw, true) : this.arrowCircleSolid(canvasDraw, false);
          break;
        case "circle":
          isStartHead ? this.arrowCircle(canvasDraw, true) : this.arrowCircle(canvasDraw, false);
          break;
        case "bar":
          isStartHead ? this.arrowBar(canvasDraw, true) : this.arrowBar(canvasDraw, false);
          break;
        case "square":
        case "squareSolid":
          isStartHead ? this.arrowSquareStart(canvasDraw) : this.arrowSquareEnd(canvasDraw);
          break;
      }
    };
    Draw2.prototype.drawShapeObj = function(canvas, shape, saveContext, isPreventSelection) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var actObj = parent.activeObj;
      var _a = actObj.strokeSettings, strokeColor = _a.strokeColor, fillColor = _a.fillColor, strokeWidth = _a.strokeWidth;
      var currentShape = shape !== undefined ? shape : parent.currObjType.shape;
      parent.currObjType.shape = currentShape;
      var canvasDraw;
      if (canvas.toLowerCase() === "original") {
        canvasDraw = this.lowerContext;
      } else if (canvas.toLowerCase() === "duplicate") {
        canvasDraw = this.upperContext;
      } else if (saveContext) {
        canvasDraw = saveContext;
      }
      var shapeType = parent.currObjType.shape.toLowerCase();
      var shapeColl = ["rectangle", "ellipse", "line", "arrow", "path", "image", "redact"];
      if (shapeColl.indexOf(shapeType) !== -1) {
        actObj.shape = parent.currObjType.shape;
      }
      canvasDraw.strokeStyle = strokeColor;
      if (shape === "text" || shape === "freehanddraw") {
        canvasDraw.fillStyle = strokeColor;
      } else {
        canvasDraw.fillStyle = fillColor;
      }
      var horLineWidth = actPoint.width / 3;
      var verLineHeight = actPoint.height / 3;
      var selectionWidth = actPoint.endX - actPoint.startX;
      var selectionHeight = actPoint.endY - actPoint.startY;
      this.rotateContext("initial", canvasDraw);
      var tempFillStyle = canvasDraw.fillStyle;
      var activeObj;
      switch (parent.currObjType.shape.toLowerCase()) {
        case "rectangle":
          this.drawSquareLines(canvasDraw);
          if (isNullOrUndefined(isPreventSelection) && canvasDraw === this.upperContext) {
            this.drawOuterSelection(canvasDraw);
          }
          break;
        case "redact":
          this.drawRedact(canvasDraw, actObj);
          if (isNullOrUndefined(isPreventSelection) && canvasDraw === this.upperContext) {
            this.drawOuterSelection(canvasDraw);
          }
          parent.currObjType.isRedact = true;
          break;
        case "ellipse":
          selectionWidth = Math.abs(selectionWidth);
          selectionHeight = Math.abs(selectionHeight);
          canvasDraw.beginPath();
          canvasDraw.ellipse(actPoint.startX + selectionWidth / 2, actPoint.startY + selectionHeight / 2, selectionWidth / 2, selectionHeight / 2, 0, 0, 2 * Math.PI, false);
          if (fillColor !== "") {
            canvasDraw.fillStyle = fillColor;
            canvasDraw.fill();
          }
          canvasDraw.ellipse(actPoint.startX + selectionWidth / 2, actPoint.startY + selectionHeight / 2, Math.abs(selectionWidth / 2 - strokeWidth), Math.abs(selectionHeight / 2 - strokeWidth), 0, 0, 2 * Math.PI, false);
          canvasDraw.fillStyle = strokeColor;
          canvasDraw.fill("evenodd");
          canvasDraw.closePath();
          if (isNullOrUndefined(isPreventSelection) && canvasDraw === this.upperContext) {
            this.drawOuterSelection(canvasDraw);
          }
          break;
        case "crop-circle":
          this.shapeCircle(canvasDraw, selectionWidth, selectionHeight);
          break;
        case "line":
          this.shapeLine(canvasDraw, actPoint.startX, actPoint.startY, actPoint.endX, actPoint.endY);
          if (isNullOrUndefined(isPreventSelection) && canvasDraw === this.upperContext) {
            this.drawOuterSelection(canvasDraw);
          }
          break;
        case "arrow":
          if (actObj.shapeDegree === 0) {
            parent.transform.degree;
          } else {
            parent.transform.degree - actObj.shapeDegree;
          }
          canvasDraw.fillStyle = canvasDraw.strokeStyle;
          if (isNullOrUndefined(actObj.triangleDirection)) {
            actObj.triangleDirection = "right";
          }
          if (isNullOrUndefined(actObj.start)) {
            actObj.start = "none";
          }
          if (isNullOrUndefined(actObj.end)) {
            actObj.end = "arrowSolid";
          }
          this.drawArrowHead(canvasDraw, true);
          this.drawArrowHead(canvasDraw, false);
          if (actObj.end === "none" && actObj.start !== "circle" && actObj.start !== "square") {
            this.shapeLine(canvasDraw, actPoint.startX, actPoint.startY, actPoint.endX, actPoint.endY);
          }
          canvasDraw.fillStyle = tempFillStyle;
          if (isNullOrUndefined(isPreventSelection) && canvasDraw === this.upperContext) {
            this.drawOuterSelection(canvasDraw);
          }
          break;
        case "path":
          activeObj = extend({}, parent.activeObj, {}, true);
          if (activeObj.pointColl.length > 1) {
            var obj = { shape: null };
            parent.notify("selection", { prop: "getCurrentDrawingShape", value: { obj } });
            if (obj["shape"] === "path" && parent.isShapeDrawing) {
              var nextPoint = { x: 0, y: 0 };
              for (var i = 0, len = activeObj.pointColl.length; i < len; i++) {
                if (isNullOrUndefined(activeObj.pointColl[i + 1])) {
                  nextPoint.x = activeObj.activePoint.endX;
                  nextPoint.y = activeObj.activePoint.endY;
                } else {
                  nextPoint.x = activeObj.pointColl[i + 1].x;
                  nextPoint.y = activeObj.pointColl[i + 1].y;
                }
                actPoint.startX = activeObj.pointColl[i].x;
                actPoint.startY = activeObj.pointColl[i].y;
                actPoint.endX = nextPoint.x;
                actPoint.endY = nextPoint.y;
                parent.activeObj = this.updateWidthHeight(parent.activeObj);
                this.shapeLine(canvasDraw, actPoint.startX, actPoint.startY, actPoint.endX, actPoint.endY);
                if (Browser.isDevice) {
                  activeObj.activePoint.endX = nextPoint.x;
                  activeObj.activePoint.endY = nextPoint.y;
                }
              }
            } else {
              for (var i = 1, len = activeObj.pointColl.length; i < len; i++) {
                actPoint.startX = activeObj.pointColl[i - 1].x;
                actPoint.startY = activeObj.pointColl[i - 1].y;
                actPoint.endX = activeObj.pointColl[i].x;
                actPoint.endY = activeObj.pointColl[i].y;
                parent.activeObj = this.updateWidthHeight(parent.activeObj);
                this.shapeLine(canvasDraw, actPoint.startX, actPoint.startY, actPoint.endX, actPoint.endY);
              }
            }
            parent.activeObj = actObj = activeObj;
          } else {
            this.shapeLine(canvasDraw, actPoint.startX, actPoint.startY, actPoint.endX, actPoint.endY);
          }
          if (canvasDraw === this.upperContext) {
            this.drawOuterSelection(canvasDraw);
          }
          break;
        case "text":
          this.shapeText(canvasDraw);
          break;
        case "image":
          this.shapeImage(canvasDraw);
          if (isNullOrUndefined(isPreventSelection) && canvasDraw === this.upperContext) {
            this.drawOuterSelection(canvasDraw);
          }
          break;
        case "crop-square":
        case "crop-3:4":
        case "crop-4:3":
        case "crop-6:9":
        case "crop-9:6":
        case "crop-9:16":
        case "crop-16:9":
          if (canvasDraw === this.lowerContext) {
            canvasDraw = this.upperContext;
          }
          this.drawSelection(horLineWidth, verLineHeight);
          parent.currObjType.shape = "";
          break;
        default:
          this.drawSelection(horLineWidth, verLineHeight);
          break;
      }
      this.rotateContext("reverse", canvasDraw);
    };
    Draw2.prototype.updatePoints = function() {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop;
      actPoint.startX += destLeft;
      actPoint.startY += destTop;
      actPoint.endX += destLeft;
      actPoint.endY += destTop;
      parent.activeObj = this.updateWidthHeight(parent.activeObj);
    };
    Draw2.prototype.updateWidthHeight = function(obj) {
      var _a = obj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
      obj.activePoint.width = endX - startX;
      obj.activePoint.height = endY - startY;
      return obj;
    };
    Draw2.prototype.drawCornerCircles = function(canvasDraw) {
      var parent = this.parent;
      var tempObj = parent.activeObj;
      canvasDraw.beginPath();
      canvasDraw.rect(tempObj.activePoint.startX, tempObj.activePoint.startY, tempObj.activePoint.width, tempObj.activePoint.height);
      canvasDraw.stroke();
      canvasDraw.closePath();
      if (parent.selectionSettings.showCircle) {
        var strokeColor = canvasDraw.strokeStyle;
        var fillColor = canvasDraw.fillStyle;
        canvasDraw.strokeStyle = parent.selectionSettings.strokeColor;
        canvasDraw.fillStyle = parent.selectionSettings.fillColor;
        canvasDraw.lineWidth *= 2;
        canvasDraw.beginPath();
        canvasDraw.moveTo(tempObj.topLeftCircle.startX, tempObj.topLeftCircle.startY);
        canvasDraw.arc(tempObj.topLeftCircle.startX, tempObj.topLeftCircle.startY, tempObj.topLeftCircle.radius, 0, 2 * Math.PI);
        canvasDraw.moveTo(tempObj.topRightCircle.startX, tempObj.topRightCircle.startY);
        canvasDraw.arc(tempObj.topRightCircle.startX, tempObj.topRightCircle.startY, tempObj.topRightCircle.radius, 0, 2 * Math.PI);
        canvasDraw.moveTo(tempObj.bottomLeftCircle.startX, tempObj.bottomLeftCircle.startY);
        canvasDraw.arc(tempObj.bottomLeftCircle.startX, tempObj.bottomLeftCircle.startY, tempObj.bottomLeftCircle.radius, 0, 2 * Math.PI);
        canvasDraw.moveTo(tempObj.bottomRightCircle.startX, tempObj.bottomRightCircle.startY);
        canvasDraw.arc(tempObj.bottomRightCircle.startX, tempObj.bottomRightCircle.startY, tempObj.bottomRightCircle.radius, 0, 2 * Math.PI);
        canvasDraw.stroke();
        canvasDraw.fill();
        canvasDraw.closePath();
        canvasDraw.lineWidth /= 2;
        canvasDraw.strokeStyle = strokeColor;
        canvasDraw.fillStyle = fillColor;
      }
    };
    Draw2.prototype.drawCenterCircles = function(canvasDraw) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var actObj = parent.activeObj;
      canvasDraw.lineWidth *= 2;
      canvasDraw.beginPath();
      if (actObj.shape === "arrow" || actObj.shape === "line") {
        canvasDraw.moveTo(actPoint.startX, actPoint.startY);
        canvasDraw.arc(actPoint.startX, actPoint.startY, actObj.topCenterCircle.radius, 0, 2 * Math.PI);
        canvasDraw.moveTo(actPoint.endX, actPoint.endY);
        canvasDraw.arc(actPoint.endX, actPoint.endY, actObj.bottomCenterCircle.radius, 0, 2 * Math.PI);
      } else if (actObj.shape === "path") {
        var activeObj = extend({}, parent.activeObj, {}, true);
        if (activeObj.pointColl.length > 1) {
          for (var i = 1, len = activeObj.pointColl.length; i < len; i++) {
            actPoint.startX = activeObj.pointColl[i - 1].x;
            actPoint.startY = activeObj.pointColl[i - 1].y;
            actPoint.endX = activeObj.pointColl[i].x;
            actPoint.endY = activeObj.pointColl[i].y;
            canvasDraw.moveTo(actPoint.startX, actPoint.startY);
            canvasDraw.arc(actPoint.startX, actPoint.startY, actObj.topCenterCircle.radius, 0, 2 * Math.PI);
            canvasDraw.moveTo(actPoint.endX, actPoint.endY);
            canvasDraw.arc(actPoint.endX, actPoint.endY, actObj.bottomCenterCircle.radius, 0, 2 * Math.PI);
          }
        }
        var obj = { shape: null };
        parent.notify("selection", { prop: "getCurrentDrawingShape", value: { obj } });
        if (obj["shape"] === "path") {
          parent.activeObj = actObj = activeObj;
        }
        canvasDraw.moveTo(actPoint.startX, actPoint.startY);
        canvasDraw.arc(actPoint.startX, actPoint.startY, actObj.topCenterCircle.radius, 0, 2 * Math.PI);
        canvasDraw.moveTo(actPoint.endX, actPoint.endY);
        canvasDraw.arc(actPoint.endX, actPoint.endY, actObj.bottomCenterCircle.radius, 0, 2 * Math.PI);
      } else {
        this.drawRotationArcLine(canvasDraw);
        canvasDraw.lineTo(actObj.rotationCirclePoint.x, actObj.rotationCirclePoint.y);
      }
      canvasDraw.stroke();
      canvasDraw.fill();
      canvasDraw.closePath();
      if (actObj.shape !== "arrow" && actObj.shape !== "line" && actObj.shape !== "path") {
        canvasDraw.beginPath();
        canvasDraw.moveTo(actObj.rotationCirclePoint.x, actObj.rotationCirclePoint.y);
        canvasDraw.arc(actObj.rotationCirclePoint.x, actObj.rotationCirclePoint.y, actObj.bottomCenterCircle.radius, 0, 2 * Math.PI);
        canvasDraw.stroke();
        canvasDraw.fill();
        canvasDraw.closePath();
      }
      canvasDraw.lineWidth /= 2;
    };
    Draw2.prototype.drawRotationArcLine = function(canvasDraw) {
      var parent = this.parent;
      var actObj = parent.activeObj;
      if (isNullOrUndefined(actObj.rotationCircleLine)) {
        actObj.rotationCircleLine = 22.5;
      }
      var degree;
      var isHorizontalflip = false;
      var isVerticalflip = false;
      if (actObj.shapeDegree === 0) {
        degree = parent.transform.degree;
      } else {
        degree = parent.transform.degree - actObj.shapeDegree;
      }
      if (degree < 0) {
        degree = 360 + degree;
      }
      if (actObj.flipObjColl) {
        for (var i = 0, len = actObj.flipObjColl.length; i < len; i++) {
          var flipStr = actObj.flipObjColl[i].toLowerCase();
          if (flipStr === "horizontal") {
            isHorizontalflip = true;
          } else if (flipStr === "vertical") {
            isVerticalflip = true;
          }
        }
      }
      switch (degree) {
        case 0:
        case 360:
          if (isVerticalflip) {
            actObj.rotationCirclePoint = {
              x: actObj.topCenterCircle.startX,
              y: actObj.topCenterCircle.startY - actObj.rotationCircleLine
            };
            canvasDraw.moveTo(actObj.rotationCirclePoint.x, actObj.rotationCirclePoint.y + actObj.rotationCircleLine);
          } else {
            actObj.rotationCirclePoint = {
              x: actObj.bottomCenterCircle.startX,
              y: actObj.bottomCenterCircle.startY + actObj.rotationCircleLine
            };
            canvasDraw.moveTo(actObj.rotationCirclePoint.x, actObj.rotationCirclePoint.y - actObj.rotationCircleLine);
          }
          break;
        case 90:
        case -270:
          if (isHorizontalflip) {
            actObj.rotationCirclePoint = { x: actObj.centerRightCircle.startX + actObj.rotationCircleLine, y: actObj.centerLeftCircle.startY };
            canvasDraw.moveTo(actObj.rotationCirclePoint.x - actObj.rotationCircleLine, actObj.rotationCirclePoint.y);
          } else {
            actObj.rotationCirclePoint = { x: actObj.centerLeftCircle.startX - actObj.rotationCircleLine, y: actObj.centerLeftCircle.startY };
            canvasDraw.moveTo(actObj.rotationCirclePoint.x + actObj.rotationCircleLine, actObj.rotationCirclePoint.y);
          }
          break;
        case 180:
        case -180:
          if (isVerticalflip) {
            actObj.rotationCirclePoint = {
              x: actObj.bottomCenterCircle.startX,
              y: actObj.bottomCenterCircle.startY + actObj.rotationCircleLine
            };
            canvasDraw.moveTo(actObj.rotationCirclePoint.x, actObj.rotationCirclePoint.y - actObj.rotationCircleLine);
          } else {
            actObj.rotationCirclePoint = {
              x: actObj.topCenterCircle.startX,
              y: actObj.topCenterCircle.startY - actObj.rotationCircleLine
            };
            canvasDraw.moveTo(actObj.rotationCirclePoint.x, actObj.rotationCirclePoint.y + actObj.rotationCircleLine);
          }
          break;
        case 270:
        case -90:
          if (isHorizontalflip) {
            actObj.rotationCirclePoint = { x: actObj.centerLeftCircle.startX - actObj.rotationCircleLine, y: actObj.centerLeftCircle.startY };
            canvasDraw.moveTo(actObj.rotationCirclePoint.x + actObj.rotationCircleLine, actObj.rotationCirclePoint.y);
          } else {
            actObj.rotationCirclePoint = { x: actObj.centerRightCircle.startX + actObj.rotationCircleLine, y: actObj.centerLeftCircle.startY };
            canvasDraw.moveTo(actObj.rotationCirclePoint.x - actObj.rotationCircleLine, actObj.rotationCirclePoint.y);
          }
          break;
      }
    };
    Draw2.prototype.drawSquareLines = function(canvasDraw) {
      var splitWords;
      var parent = this.parent;
      var actObj = parent.activeObj;
      var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, width = _a.width, height = _a.height;
      var _b = actObj.strokeSettings, fillColor = _b.fillColor, strokeColor = _b.strokeColor, strokeWidth = _b.strokeWidth, radius = _b.radius;
      if (actObj.shape) {
        splitWords = actObj.shape.split("-");
      }
      if (splitWords[0] === "crop") {
        canvasDraw.strokeStyle = "#fff";
      } else {
        canvasDraw.strokeStyle = strokeColor;
      }
      canvasDraw.beginPath();
      var obj = { width: 0, height: 0 };
      var ratio = { width: 1, height: 1 };
      parent.notify("crop", {
        prop: "calcRatio",
        onPropertyChange: false,
        value: { obj, dimension: { width: canvasDraw.canvas.width, height: canvasDraw.canvas.height } }
      });
      ratio = obj;
      var isTempCanvas = canvasDraw.canvas.id === parent.element.id + "_tempCanvas";
      var zoomFactor = parent.transform.zoomFactor;
      var baseRadius = isTempCanvas ? radius * 10 * ((ratio.width + ratio.height) / 2) : radius * 10;
      var adjustedRadius = baseRadius + baseRadius * zoomFactor;
      if (radius !== null) {
        if (parent.isSafari) {
          this.drawRoundedRect(canvasDraw, startX, startY, width, height, adjustedRadius);
        } else {
          canvasDraw.roundRect(startX, startY, width, height, adjustedRadius);
        }
      } else {
        canvasDraw.rect(startX, startY, width, height);
      }
      if (fillColor !== "") {
        canvasDraw.fillStyle = fillColor;
        canvasDraw.fill();
      }
      if (radius !== null) {
        if (parent.isSafari) {
          this.drawRoundedRect(canvasDraw, startX + strokeWidth, startY + strokeWidth, width - 2 * strokeWidth, height - 2 * strokeWidth, adjustedRadius);
        } else {
          canvasDraw.roundRect(startX + strokeWidth, startY + strokeWidth, width - 2 * strokeWidth, height - 2 * strokeWidth, adjustedRadius);
        }
      } else {
        canvasDraw.rect(startX + strokeWidth, startY + strokeWidth, width - 2 * strokeWidth, height - 2 * strokeWidth);
      }
      canvasDraw.fillStyle = strokeColor;
      canvasDraw.fill("evenodd");
      canvasDraw.closePath();
    };
    Draw2.prototype.drawRoundedRect = function(canvasDraw, startX, startY, width, height, radius) {
      var rectRadius = Math.max(0, Math.min(radius, width / 2, height / 2));
      canvasDraw.moveTo(startX + rectRadius, startY);
      canvasDraw.arcTo(startX + width, startY, startX + width, startY + height, rectRadius);
      canvasDraw.arcTo(startX + width, startY + height, startY, startY + height, rectRadius);
      canvasDraw.arcTo(startX, startY + height, startX, startY, rectRadius);
      canvasDraw.arcTo(startX, startY, startX + width, startY, rectRadius);
      canvasDraw.closePath();
    };
    Draw2.prototype.drawSelection = function(horLineWidth, verLineHeight) {
      var parent = this.parent;
      var actObj = parent.activeObj;
      var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
      this.upperContext.strokeStyle = parent.themeColl[parent.theme]["primaryColor"];
      this.upperContext.beginPath();
      actObj.horTopInnerLine = { startX, startY: startY + verLineHeight, endX, endY: endY + verLineHeight };
      actObj.horBottomInnerLine = { startX, startY: startY + 2 * verLineHeight, endX, endY: endY + 2 * verLineHeight };
      actObj.verLeftInnerLine = {
        startX: startX + horLineWidth,
        startY,
        endX: startX + horLineWidth,
        endY
      };
      actObj.verRightInnerLine = {
        startX: startX + 2 * horLineWidth,
        startY,
        endX: startX + 2 * horLineWidth,
        endY
      };
      this.upperContext.moveTo(actObj.horTopInnerLine.startX, actObj.horTopInnerLine.startY);
      this.upperContext.lineTo(actObj.horTopInnerLine.endX, actObj.horTopInnerLine.startY);
      this.upperContext.moveTo(actObj.horBottomInnerLine.startX, actObj.horBottomInnerLine.startY);
      this.upperContext.lineTo(actObj.horBottomInnerLine.endX, actObj.horBottomInnerLine.startY);
      this.upperContext.moveTo(actObj.verLeftInnerLine.startX, actObj.verLeftInnerLine.startY);
      this.upperContext.lineTo(actObj.verLeftInnerLine.endX, actObj.verLeftInnerLine.endY);
      this.upperContext.moveTo(actObj.verRightInnerLine.startX, actObj.verRightInnerLine.startY);
      this.upperContext.lineTo(actObj.verRightInnerLine.endX, actObj.verRightInnerLine.endY);
      this.upperContext.stroke();
      this.upperContext.closePath();
    };
    Draw2.prototype.shapeCircle = function(canvasDraw, selectionWidth, selectionHeight) {
      var parent = this.parent;
      var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY, width = _a.width;
      canvasDraw.strokeStyle = parent.themeColl[parent.theme]["primaryColor"];
      canvasDraw.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      canvasDraw.fillStyle = "rgb(0, 0, 0, 0.25)";
      canvasDraw.fillRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      var tempWidth = canvasDraw.lineWidth;
      canvasDraw.lineWidth = 2;
      canvasDraw.beginPath();
      canvasDraw.ellipse(parent.activeObj.horTopLine.startX + selectionWidth / 2, parent.activeObj.horTopLine.startY + selectionHeight / 2, selectionWidth / 2, selectionHeight / 2, 0, 0, 2 * Math.PI, false);
      canvasDraw.stroke();
      canvasDraw.closePath();
      canvasDraw.save();
      canvasDraw.beginPath();
      canvasDraw.arc((endX - startX) / 2 + startX, (endY - startY) / 2 + startY, width / 2, 0, Math.PI * 2);
      canvasDraw.closePath();
      canvasDraw.clip();
      canvasDraw.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      canvasDraw.restore();
      canvasDraw.lineWidth = tempWidth;
      this.drawOuterSelection(canvasDraw, true);
      parent.currObjType.shape = "";
    };
    Draw2.prototype.shapeLine = function(canvasDraw, x1, y1, x2, y2) {
      var tempLineWidth = canvasDraw.lineWidth;
      canvasDraw.lineWidth = this.parent.activeObj.strokeSettings.strokeWidth;
      canvasDraw.beginPath();
      canvasDraw.moveTo(x1, y1);
      canvasDraw.lineTo(x2, y2);
      canvasDraw.stroke();
      canvasDraw.lineWidth = tempLineWidth;
    };
    Draw2.prototype.manipulateSaveCtx = function(canvasDraw, x, y) {
      if (canvasDraw !== this.lowerContext && canvasDraw !== this.upperContext) {
        var obj = { width: 0, height: 0 };
        this.parent.notify("crop", {
          prop: "calcRatio",
          onPropertyChange: false,
          value: { obj, dimension: { width: canvasDraw.canvas.width, height: canvasDraw.canvas.height } }
        });
        var ratio = obj;
        if (x) {
          x *= ratio.width;
        }
        if (y) {
          y *= ratio.height;
        }
      }
      return { x, y };
    };
    Draw2.prototype.arrow = function(canvasDraw, start) {
      var parent = this.parent;
      var actObj = parent.activeObj;
      var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
      var strWidth = actObj.strokeSettings.strokeWidth;
      canvasDraw.lineWidth = strWidth;
      var x = this.arrowDimension["arrow"]["width"];
      var y = this.arrowDimension["arrow"]["height"];
      var point = this.manipulateSaveCtx(canvasDraw, x, y);
      x = point.x + strWidth;
      y = point.y + strWidth;
      this.dx = endX - startX;
      this.dy = endY - startY;
      canvasDraw.fillStyle = actObj.strokeSettings.strokeColor;
      var angle = Math.atan2(this.dy, this.dx);
      var isStartArrow = actObj.start === "arrow";
      var isEndArrow = actObj.end === "arrow";
      var isEndCircleOrSquare = actObj.end === "circle" || actObj.end === "square";
      var isStartCircleOrSquare = actObj.start === "circle" || actObj.start === "square";
      if ((start && actObj.triangleDirection === "left" || actObj.triangleDirection === "right") && (isStartArrow && actObj.end === "none" || isStartArrow && !isEndCircleOrSquare && !isStartCircleOrSquare) || !start && (isEndArrow && actObj.start === "none" || !isStartArrow && !isEndCircleOrSquare && !isStartCircleOrSquare)) {
        this.shapeLine(canvasDraw, startX, startY, endX, endY);
      }
      if (start && actObj.triangleDirection === "left" || !start && actObj.triangleDirection === "right") {
        canvasDraw.translate(endX, endY);
        canvasDraw.rotate(angle);
        this.shapeLine(canvasDraw, 0, 0, -x, y / 2);
        this.shapeLine(canvasDraw, 0, 0, -x, -y / 2);
        canvasDraw.rotate(-angle);
        canvasDraw.translate(-endX, -endY);
      } else if (start && actObj.triangleDirection === "right" || !start && actObj.triangleDirection === "left") {
        canvasDraw.translate(startX, startY);
        canvasDraw.rotate(angle);
        this.shapeLine(canvasDraw, 0, 0, x, y / 2);
        this.shapeLine(canvasDraw, 0, 0, x, -y / 2);
        canvasDraw.rotate(-angle);
        canvasDraw.translate(-startX, -startY);
      }
    };
    Draw2.prototype.arrowSolid = function(canvasDraw, start) {
      var parent = this.parent;
      var actObj = parent.activeObj;
      var strWidth = actObj.strokeSettings.strokeWidth;
      var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
      var x = this.arrowDimension["arrowSolid"]["width"];
      var y = this.arrowDimension["arrowSolid"]["height"];
      var point = this.manipulateSaveCtx(canvasDraw, x, y);
      x = point.x + strWidth;
      y = point.y + strWidth;
      this.dx = endX - startX;
      this.dy = endY - startY;
      var angle = Math.atan2(this.dy, this.dx);
      var isStartArrowSolid = actObj.start === "arrowSolid";
      var isEndArrowSolid = actObj.end === "arrowSolid";
      var isEndCircleOrSquare = actObj.end === "circle" || actObj.end === "square";
      var isStartCircleOrSquare = actObj.start === "circle" || actObj.start === "square";
      if (start && (isStartArrowSolid && actObj.end === "none") || isStartArrowSolid && !isEndCircleOrSquare && !isStartCircleOrSquare || !start && (isEndArrowSolid && actObj.start === "none" || !isStartArrowSolid && !isEndCircleOrSquare && !isStartCircleOrSquare)) {
        this.shapeLine(canvasDraw, startX, startY, endX, endY);
      }
      if (start && actObj.triangleDirection === "left" || !start && actObj.triangleDirection === "right") {
        canvasDraw.translate(endX, endY);
        canvasDraw.rotate(angle);
        canvasDraw.beginPath();
        canvasDraw.moveTo(strWidth, 0);
        canvasDraw.lineTo(-x + y / 2, y / 2);
        canvasDraw.lineTo(-x + y / 2, -y / 2);
        canvasDraw.closePath();
        canvasDraw.fill();
        canvasDraw.rotate(-angle);
        canvasDraw.translate(-endX, -endY);
        actObj.rotatedAngle = angle;
      } else if (start && actObj.triangleDirection === "right" || !start && actObj.triangleDirection === "left") {
        canvasDraw.translate(startX, startY);
        canvasDraw.rotate(angle);
        canvasDraw.beginPath();
        canvasDraw.moveTo(0 - strWidth, 0);
        canvasDraw.lineTo(x - y / 2, y / 2);
        canvasDraw.lineTo(x - y / 2, -y / 2);
        canvasDraw.closePath();
        canvasDraw.fill();
        canvasDraw.rotate(-angle);
        canvasDraw.translate(-startX, -startY);
        actObj.rotatedAngle = angle;
      }
    };
    Draw2.prototype.arrowSquareStart = function(canvasDraw) {
      var parent = this.parent;
      var actObj = parent.activeObj;
      var strWidth = actObj.strokeSettings.strokeWidth;
      var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
      var isStartSquare = actObj.start === "square";
      var isEndCircle = actObj.end === "circle";
      var isStartSquareSolid = actObj.start === "squareSolid";
      var isEndCircleSolid = actObj.end === "circleSolid";
      if (isStartSquare && actObj.end === "none" || isStartSquare && !isEndCircle && actObj.start !== "square" || isStartSquareSolid && isEndCircleSolid) {
        this.shapeLine(canvasDraw, startX, startY, endX, endY);
      }
      canvasDraw.lineWidth = strWidth;
      canvasDraw.beginPath();
      canvasDraw.fillStyle = actObj.strokeSettings.strokeColor;
      var x = this.arrowDimension["square"]["width"];
      var y = this.arrowDimension["square"]["height"];
      var point = this.manipulateSaveCtx(canvasDraw, x, y);
      x = point.x + strWidth;
      y = point.y + strWidth;
      this.dx = endX - startX;
      this.dy = endY - startY;
      var angle = Math.atan2(this.dy, this.dx);
      if (actObj.triangleDirection === "left") {
        canvasDraw.translate(endX, endY);
        canvasDraw.rotate(angle);
        if (actObj.start === "squareSolid") {
          canvasDraw.fillRect(-x + y / 2, -y / 2, x, y);
        }
        canvasDraw.strokeRect(-x + y / 2, -y / 2, x, y);
        canvasDraw.rotate(-angle);
        canvasDraw.translate(-endX, -endY);
        this.squareStartIntersectX1 = endX - y / 2 * Math.cos(angle);
        this.squareStartIntersectY1 = endY - y / 2 * Math.sin(angle);
        if (actObj.start === "square" && actObj.end !== "square" && actObj.end !== "circle") {
          this.shapeLine(canvasDraw, startX, startY, this.squareStartIntersectX1, this.squareStartIntersectY1);
        } else if (actObj.start === "square" && actObj.end === "circle") {
          this.shapeLine(canvasDraw, this.endCircleIntersectX1, this.endCircleIntersectY1, this.squareStartIntersectX1, this.squareStartIntersectY1);
        } else if (actObj.start === "squareSolid" && actObj.end === "squareSolid") {
          this.shapeLine(canvasDraw, startX, startY, endX, endY);
        }
      } else if (actObj.triangleDirection === "right") {
        canvasDraw.lineWidth = strWidth;
        canvasDraw.fillStyle = actObj.strokeSettings.strokeColor;
        if (actObj.start === "squareSolid" && actObj.end === "squareSolid") {
          this.shapeLine(canvasDraw, startX, startY, endX, endY);
        }
        canvasDraw.translate(startX, startY);
        canvasDraw.rotate(angle);
        if (actObj.start === "squareSolid") {
          canvasDraw.fillRect(y / 2 - x, -y / 2, x, y);
        }
        canvasDraw.strokeRect(y / 2 - x, -y / 2, x, y);
        canvasDraw.rotate(-angle);
        canvasDraw.translate(-startX, -startY);
        actObj.rotatedAngle = angle;
        this.squareStartIntersectX1 = startX + y / 2 * Math.cos(angle);
        this.squareStartIntersectY1 = startY + y / 2 * Math.sin(angle);
        if (actObj.start === "square" && actObj.end !== "square" && actObj.end !== "circle") {
          this.shapeLine(canvasDraw, endX, endY, this.squareStartIntersectX1, this.squareStartIntersectY1);
        }
        if (actObj.start === "square" && actObj.end === "circle") {
          this.shapeLine(canvasDraw, this.endCircleIntersectX1, this.endCircleIntersectY1, this.squareStartIntersectX1, this.squareStartIntersectY1);
        }
      }
    };
    Draw2.prototype.arrowSquareEnd = function(canvasDraw) {
      var parent = this.parent;
      var actObj = parent.activeObj;
      var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
      var strWidth = actObj.strokeSettings.strokeWidth;
      var x = this.arrowDimension["square"]["width"];
      var y = this.arrowDimension["square"]["height"];
      var point = this.manipulateSaveCtx(canvasDraw, x, y);
      x = point.x + strWidth;
      y = point.y + strWidth;
      this.dx = endX - startX;
      this.dy = endY - startY;
      var angle = Math.atan2(this.dy, this.dx);
      canvasDraw.lineWidth = strWidth;
      if (actObj.triangleDirection === "right") {
        canvasDraw.fillStyle = actObj.strokeSettings.strokeColor;
        if (actObj.end === "squareSolid" && actObj.start === "none") {
          this.shapeLine(canvasDraw, startX, startY, endX, endY);
        }
        canvasDraw.translate(endX, endY);
        canvasDraw.rotate(angle);
        if (actObj.end === "squareSolid") {
          canvasDraw.fillRect(-x + y / 2, -y / 2, x, y);
        }
        canvasDraw.strokeRect(-x + y / 2, -y / 2, x, y);
        canvasDraw.rotate(-angle);
        canvasDraw.translate(-endX, -endY);
        actObj.rotatedAngle = angle;
        this.squareEndIntersectX1 = endX - y / 2 * Math.cos(angle);
        this.squareEndIntersectY1 = endY - y / 2 * Math.sin(angle);
        if (actObj.end === "square" && actObj.start !== "square" && actObj.start !== "circle") {
          this.shapeLine(canvasDraw, startX, startY, this.squareEndIntersectX1, this.squareEndIntersectY1);
        } else if (actObj.start === "circle" && actObj.end === "square") {
          this.shapeLine(canvasDraw, this.squareEndIntersectX1, this.squareEndIntersectY1, this.startCircleIntersectX1, this.startCircleIntersectY1);
        } else if (actObj.start === "square" && actObj.end === "square") {
          this.shapeLine(canvasDraw, this.squareEndIntersectX1, this.squareEndIntersectY1, this.squareStartIntersectX1, this.squareStartIntersectY1);
        }
      } else if (actObj.triangleDirection === "left") {
        canvasDraw.translate(startX, startY);
        canvasDraw.rotate(angle);
        if (actObj.end === "squareSolid") {
          canvasDraw.fillRect(y / 2 - x, -y / 2, x, y);
        }
        canvasDraw.strokeRect(y / 2 - x, -y / 2, x, y);
        canvasDraw.rotate(-angle);
        canvasDraw.translate(-startX, -startY);
        actObj.rotatedAngle = angle;
        this.squareEndIntersectX1 = startX + y / 2 * Math.cos(angle);
        this.squareEndIntersectY1 = startY + y / 2 * Math.sin(angle);
        if (actObj.end === "square" && actObj.start !== "square" && actObj.start !== "circle") {
          this.shapeLine(canvasDraw, endX, endY, this.squareEndIntersectX1, this.squareEndIntersectY1);
        } else if (actObj.start === "circle" && actObj.end === "square") {
          this.shapeLine(canvasDraw, this.squareEndIntersectX1, this.squareEndIntersectY1, this.startCircleIntersectX1, this.startCircleIntersectY1);
        } else if (actObj.start === "square" && actObj.end === "square") {
          this.shapeLine(canvasDraw, this.squareEndIntersectX1, this.squareEndIntersectY1, this.squareStartIntersectX1, this.squareStartIntersectY1);
        } else if (actObj.end === "squareSolid" && actObj.start === "none") {
          this.shapeLine(canvasDraw, startX, startY, endX, endY);
        }
      }
    };
    Draw2.prototype.arrowCircle = function(canvasDraw, start) {
      var parent = this.parent;
      var actObj = parent.activeObj;
      var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
      var strWidth = actObj.strokeSettings.strokeWidth;
      if (start && actObj.triangleDirection === "left" || !start && actObj.triangleDirection === "right") {
        canvasDraw.lineWidth = strWidth;
        var circleRadius = this.arrowDimension["circle"]["width"];
        var point = this.manipulateSaveCtx(canvasDraw, circleRadius, null);
        circleRadius = point.x + strWidth;
        canvasDraw.beginPath();
        canvasDraw.arc(endX, endY, circleRadius, 0, 2 * Math.PI);
        canvasDraw.stroke();
        canvasDraw.closePath();
        this.dx = endX - startX;
        this.dy = endY - startY;
        var a = this.dx * this.dx + this.dy * this.dy;
        var b = 2 * (this.dx * (startX - endX) + this.dy * (startY - endY));
        var c = (startX - endX) * (startX - endX) + (startY - endY) * (startY - endY) - circleRadius * circleRadius;
        var intersect = b * b - 4 * a * c;
        if (intersect >= 0) {
          canvasDraw.fillStyle = actObj.strokeSettings.strokeColor;
          var t2 = (-b - Math.sqrt(intersect)) / (2 * a);
          var intersectionX1 = startX + this.dx * t2;
          var intersectionY1 = startY + this.dy * t2;
          if (start) {
            this.startCircleIntersectX1 = intersectionX1;
            this.startCircleIntersectY1 = intersectionY1;
            this.endCircleIntersectX1 = endX - this.dx * t2;
            this.endCircleIntersectY1 = endY - this.dy * t2;
            canvasDraw.beginPath();
            canvasDraw.fill();
            canvasDraw.beginPath();
            if (actObj.start === "circle" && actObj.end === "circle") {
              this.shapeLine(canvasDraw, this.startCircleIntersectX1, this.startCircleIntersectY1, this.endCircleIntersectX1, this.endCircleIntersectY1);
            } else if (actObj.start === "circle" && actObj.end !== "circle" && actObj.end !== "square") {
              this.shapeLine(canvasDraw, startX, startY, this.startCircleIntersectX1, this.startCircleIntersectY1);
            }
            canvasDraw.stroke();
            canvasDraw.closePath();
          } else {
            this.endCircleIntersectX1 = intersectionX1;
            this.endCircleIntersectY1 = intersectionY1;
            if (actObj.end === "circle" && (actObj.start !== "circle" && actObj.start !== "square")) {
              this.shapeLine(canvasDraw, startX, startY, this.endCircleIntersectX1, this.endCircleIntersectY1);
            }
          }
        }
        var angle = Math.atan2(this.dy, this.dx);
        parent.activeObj.rotatedAngle = angle;
      } else if (start && actObj.triangleDirection === "right" || !start && actObj.triangleDirection === "left") {
        canvasDraw.lineWidth = strWidth;
        var circleRadius = this.arrowDimension["circle"]["width"];
        var point = this.manipulateSaveCtx(canvasDraw, circleRadius, null);
        circleRadius = point.x + strWidth;
        canvasDraw.beginPath();
        canvasDraw.arc(startX, startY, circleRadius, 0, 2 * Math.PI);
        canvasDraw.stroke();
        canvasDraw.closePath();
        this.dx = startX - endX;
        this.dy = startY - endY;
        var a = this.dx * this.dx + this.dy * this.dy;
        var b = 2 * (this.dx * (endX - startX) + this.dy * (endY - startY));
        var c = (endX - startX) * (endX - startX) + (endY - startY) * (endY - startY) - circleRadius * circleRadius;
        var intersect = b * b - 4 * a * c;
        if (intersect >= 0) {
          canvasDraw.fillStyle = actObj.strokeSettings.strokeColor;
          var t2 = (-b - Math.sqrt(intersect)) / (2 * a);
          var intersectionX1 = endX + this.dx * t2;
          var intersectionY1 = endY + this.dy * t2;
          if (start) {
            this.startCircleIntersectX1 = intersectionX1;
            this.startCircleIntersectY1 = intersectionY1;
            this.endCircleIntersectX1 = startX - this.dx * t2;
            this.endCircleIntersectY1 = startY - this.dy * t2;
            if (actObj.start === "circle" && actObj.end === "circle") {
              this.shapeLine(canvasDraw, this.endCircleIntersectX1, this.endCircleIntersectY1, this.startCircleIntersectX1, this.startCircleIntersectY1);
            } else if (actObj.start === "circle" && actObj.end !== "circle" && actObj.end !== "square") {
              this.shapeLine(canvasDraw, endX, endY, this.startCircleIntersectX1, this.startCircleIntersectY1);
            }
          } else {
            this.endCircleIntersectX1 = intersectionX1;
            this.endCircleIntersectY1 = intersectionY1;
            canvasDraw.beginPath();
            canvasDraw.fill();
            canvasDraw.beginPath();
            if (actObj.end === "circle" && (actObj.start !== "circle" && actObj.start !== "square")) {
              this.shapeLine(canvasDraw, endX, endY, this.endCircleIntersectX1, this.endCircleIntersectY1);
            }
          }
        }
        var angle = Math.atan2(this.dy, this.dx);
        parent.activeObj.rotatedAngle = angle;
      }
    };
    Draw2.prototype.arrowCircleSolid = function(canvasDraw, start) {
      var parent = this.parent;
      var actObj = parent.activeObj;
      var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
      var isStartCircleSolid = actObj.start === "circleSolid";
      var strWidth = actObj.strokeSettings.strokeWidth;
      if (start && actObj.triangleDirection === "left" || !start && actObj.triangleDirection === "right") {
        canvasDraw.lineWidth = strWidth;
        canvasDraw.beginPath();
        canvasDraw.fillStyle = actObj.strokeSettings.strokeColor;
        if (start && (isStartCircleSolid && actObj.end === "none") || isStartCircleSolid && actObj.end !== "circle" && actObj.end !== "square" || !start && (actObj.end === "circleSolid" && actObj.start === "none")) {
          this.shapeLine(canvasDraw, startX, startY, endX, endY);
        }
        var circleRadius = this.arrowDimension["circle"]["width"];
        var point = this.manipulateSaveCtx(canvasDraw, circleRadius, null);
        circleRadius = point.x + strWidth;
        this.dx = endX - startX;
        this.dy = endY - startY;
        canvasDraw.save();
        canvasDraw.beginPath();
        canvasDraw.arc(endX, endY, circleRadius, 0, 2 * Math.PI);
        canvasDraw.stroke();
        canvasDraw.fill();
        canvasDraw.closePath();
        actObj.rotatedAngle = Math.atan2(this.dy, this.dx);
      } else if (start && actObj.triangleDirection === "right" || !start && actObj.triangleDirection === "left") {
        canvasDraw.lineWidth = strWidth;
        canvasDraw.beginPath();
        canvasDraw.fillStyle = actObj.strokeSettings.strokeColor;
        if (start && (isStartCircleSolid && actObj.end === "none") || isStartCircleSolid && actObj.end !== "circle" && actObj.end !== "square" || !start && (actObj.end === "circleSolid" && actObj.start === "none")) {
          this.shapeLine(canvasDraw, startX, startY, endX, endY);
        }
        var circleRadius = this.arrowDimension["circle"]["width"];
        var point = this.manipulateSaveCtx(canvasDraw, circleRadius, null);
        circleRadius = point.x + strWidth;
        this.dx = endX - startX;
        this.dy = endY - startY;
        canvasDraw.save();
        canvasDraw.beginPath();
        canvasDraw.arc(startX, startY, circleRadius, 0, 2 * Math.PI);
        canvasDraw.stroke();
        canvasDraw.fill();
        canvasDraw.closePath();
        actObj.rotatedAngle = Math.atan2(this.dy, this.dx);
      }
    };
    Draw2.prototype.arrowBar = function(canvasDraw, start) {
      var parent = this.parent;
      var actObj = parent.activeObj;
      var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
      var strWidth = actObj.strokeSettings.strokeWidth;
      if (start && actObj.triangleDirection === "left" || !start && actObj.triangleDirection === "right") {
        canvasDraw.lineWidth = strWidth;
        canvasDraw.beginPath();
        canvasDraw.fillStyle = actObj.strokeSettings.strokeColor;
        if (start && (actObj.start === "bar" && actObj.end === "none") || actObj.start === "bar" && (actObj.end !== "circle" && actObj.end !== "square") || !start && (actObj.end === "bar" && actObj.start === "none" || actObj.end === "bar" && (actObj.start !== "circle" && actObj.start !== "square"))) {
          this.shapeLine(canvasDraw, startX, startY, endX, endY);
        }
        var x = this.arrowDimension["bar"]["width"];
        var y = this.arrowDimension["bar"]["height"];
        var point = this.manipulateSaveCtx(canvasDraw, x, y);
        x = point.x + strWidth;
        y = point.y + strWidth;
        this.dx = endX - startX;
        this.dy = endY - startY;
        var angle = Math.atan2(this.dy, this.dx);
        canvasDraw.translate(endX, endY);
        canvasDraw.rotate(angle);
        canvasDraw.fillRect(-x + y / 4, -y / 2, x, y);
        canvasDraw.rotate(-angle);
        canvasDraw.translate(-endX, -endY);
        actObj.rotatedAngle = angle;
      } else if (start && actObj.triangleDirection === "right" || !start && actObj.triangleDirection === "left") {
        canvasDraw.lineWidth = strWidth;
        canvasDraw.beginPath();
        canvasDraw.fillStyle = actObj.strokeSettings.strokeColor;
        if (start && (actObj.start === "bar" && actObj.end === "none") || actObj.start === "bar" && (actObj.end !== "circle" && actObj.end !== "square") || !start && (actObj.end === "bar" && actObj.start === "none")) {
          this.shapeLine(canvasDraw, startX, startY, endX, endY);
        }
        var x = this.arrowDimension["bar"]["width"];
        var y = this.arrowDimension["bar"]["height"];
        var point = this.manipulateSaveCtx(canvasDraw, x, y);
        x = point.x + strWidth;
        y = point.y + strWidth;
        this.dx = endX - startX;
        this.dy = endY - startY;
        var angle = Math.atan2(this.dy, this.dx);
        canvasDraw.translate(startX, startY);
        canvasDraw.rotate(angle);
        canvasDraw.fillRect(y / 4 - x, -y / 2, x, y);
        canvasDraw.rotate(-angle);
        canvasDraw.translate(-startX, -startY);
        parent.activeObj.rotatedAngle = angle;
      }
    };
    Draw2.prototype.shapeImage = function(canvasDraw) {
      var parent = this.parent;
      var actObj = parent.activeObj;
      var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, width = _a.width, height = _a.height;
      var ctx = actObj.imageCanvas.getContext("2d");
      if (canvasDraw === this.lowerContext && this.isImageApply) {
        var dimObj = { width: 0, height: 0 };
        parent.notify("transform", { prop: "calcMaxDimension", onPropertyChange: false, value: { width: actObj.imageElement.width, height: actObj.imageElement.height, obj: dimObj, isImgShape: null } });
        if (width < dimObj["width"] / 5 || height < dimObj["height"] / 5) {
          ctx.clearRect(0, 0, actObj.imageCanvas.width, actObj.imageCanvas.height);
          parent.notify("selection", { prop: "applyTransformToImg", onPropertyChange: false, value: { ctx } });
          parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate" } });
          this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
          parent.notify("selection", { prop: "setImageClarity", onPropertyChange: false, value: { bool: false } });
          this.isImageApply = false;
        }
      }
      var imgPoint = { startX: 0, startY: 0, width: 0, height: 0 };
      imgPoint.width = width;
      imgPoint.height = height;
      if (actObj.flipObjColl.length === 4) {
        actObj.flipObjColl = [];
        actObj.shapeFlip = "";
      }
      imgPoint.startX = (width - imgPoint.width) / 2 + startX;
      imgPoint.startY = (height - imgPoint.height) / 2 + startY;
      var temp = canvasDraw.globalAlpha;
      canvasDraw.globalAlpha = actObj.opacity;
      if (actObj.rotateFlipColl && actObj.rotateFlipColl.length > 0) {
        this.rotateImage(canvasDraw);
      } else {
        canvasDraw.drawImage(actObj.imageCanvas, imgPoint.startX, imgPoint.startY, imgPoint.width, imgPoint.height);
      }
      canvasDraw.globalAlpha = temp;
      parent.currObjType.isText = false;
    };
    Draw2.prototype.shapeText = function(canvasDraw) {
      var parent = this.parent;
      var filter = canvasDraw.filter;
      var actObj = parent.activeObj;
      var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, width = _a.width, height = _a.height;
      var rows = actObj.keyHistory.split("\n");
      var _b = actObj.textSettings, fontFamily = _b.fontFamily, bold = _b.bold, italic = _b.italic;
      var fontSize = actObj.textSettings.fontSize;
      var lHeight = fontSize + fontSize * 0.25;
      var lineHeight = (lHeight * rows.length - fontSize * rows.length) / rows.length;
      canvasDraw.filter = "none";
      var tempFill = canvasDraw.fillStyle;
      if (actObj.strokeSettings.fillColor !== "") {
        canvasDraw.fillStyle = actObj.strokeSettings.fillColor;
        canvasDraw.fillRect(actObj.activePoint.startX, actObj.activePoint.startY, actObj.activePoint.width, actObj.activePoint.height);
      }
      canvasDraw.fillStyle = tempFill;
      for (var i = 0; i < rows.length; i++) {
        var text = rows[i];
        var yPoint = (i + 1) * fontSize * 0.85 + i * lineHeight;
        if (parent.transform.degree === -360) {
          parent.transform.degree = 0;
        }
        if (parent.transform.degree === 0 || parent.transform.degree === 180) {
          if (fontSize > height) {
            fontSize = actObj.textSettings.fontSize = height - height * 0.1;
          }
        } else {
          if (fontSize > width) {
            fontSize = actObj.textSettings.fontSize = width - width * 0.1;
          }
        }
        canvasDraw.strokeStyle = actObj.strokeSettings.outlineColor;
        canvasDraw.fillStyle = actObj.strokeSettings.strokeColor;
        var tempWidth = canvasDraw.lineWidth;
        var obj = { width: 0, height: 0 };
        var ratio = { width: 1, height: 1 };
        parent.notify("crop", {
          prop: "calcRatio",
          onPropertyChange: false,
          value: { obj, dimension: { width: canvasDraw.canvas.width, height: canvasDraw.canvas.height } }
        });
        ratio = obj;
        var isTempCanvas = canvasDraw.canvas.id === parent.element.id + "_tempCanvas";
        var baseWidth = Math.max(1, actObj.strokeSettings.outlineWidth / 2);
        if (/^#([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6}|[0-9A-Fa-f]{8})$|^[a-zA-Z]+$/.test(actObj.strokeSettings.outlineColor)) {
          canvasDraw.lineWidth = baseWidth * ((isTempCanvas ? Math.floor((fontSize - 1) / 60) : Math.floor((fontSize - 1) / 16)) * 0.5 + 0.5);
          if (isTempCanvas) {
            canvasDraw.lineWidth *= (ratio.width + ratio.height) / 2;
            if (parent.transform.degree !== 0) {
              canvasDraw.lineWidth /= 1.8;
            }
          }
        } else {
          canvasDraw.lineWidth = 1;
        }
        var textStyle = "";
        if (bold) {
          textStyle = "bold ";
        }
        if (italic) {
          textStyle = "italic ";
        }
        if (bold && italic) {
          textStyle = "italic bold ";
        }
        canvasDraw.font = textStyle + fontSize + "px " + fontFamily;
        if (actObj.flipObjColl.length === 4) {
          actObj.flipObjColl = [];
          actObj.shapeFlip = "";
        }
        if (actObj.rotateFlipColl && actObj.rotateFlipColl.length > 0) {
          this.rotateText(canvasDraw);
        } else {
          canvasDraw.strokeText(text, startX + fontSize * 0.1, startY + yPoint);
          canvasDraw.fillText(text, startX + fontSize * 0.1, startY + yPoint);
        }
        canvasDraw.lineWidth = tempWidth;
      }
      canvasDraw.filter = filter;
      parent.currObjType.isText = false;
      if (this.upperContext === canvasDraw) {
        this.drawOuterSelection(canvasDraw);
      }
    };
    Draw2.prototype.updateActPoint = function(degree, canvasDraw) {
      var parent = this.parent;
      var actObj = parent.activeObj;
      var actPoint = actObj.activePoint;
      if (degree.toLowerCase() === "horizontal") {
        if (actPoint.startX <= canvasDraw.canvas.width / 2) {
          actPoint.startX = canvasDraw.canvas.width / 2 + (canvasDraw.canvas.width / 2 - actPoint.endX);
          actPoint.endX = actPoint.startX + actPoint.width;
          this.updateActiveObject(actPoint, actObj);
          parent.activeObj = actObj;
        } else if (actPoint.startX >= canvasDraw.canvas.width / 2) {
          actPoint.startX = canvasDraw.canvas.width - actPoint.endX;
          actPoint.endX = actPoint.startX + actPoint.width;
          this.updateActiveObject(actPoint, actObj);
          parent.activeObj = actObj;
        }
      } else if (degree.toLowerCase() === "vertical") {
        if (actPoint.startY <= canvasDraw.canvas.height / 2) {
          actPoint.startY = canvasDraw.canvas.height / 2 + (canvasDraw.canvas.height / 2 - actPoint.endY);
          actPoint.endY = actPoint.startY + actPoint.height;
          this.updateActiveObject(actPoint, actObj);
          parent.activeObj = actObj;
        } else if (actPoint.startY >= canvasDraw.canvas.height / 2) {
          actPoint.startY = canvasDraw.canvas.height - actPoint.endY;
          actPoint.endY = actPoint.startY + actPoint.height;
          this.updateActiveObject(actPoint, actObj);
          parent.activeObj = actObj;
        }
      }
      return actPoint;
    };
    Draw2.prototype.rotateImage = function(canvasDraw) {
      var parent = this.parent;
      var degree;
      var actObj = parent.activeObj;
      var tempActiveObj = extend({}, parent.activeObj, null, true);
      if (actObj.shapeDegree === 0) {
        degree = parent.transform.degree;
      } else {
        degree = parent.transform.degree - actObj.shapeDegree;
      }
      if (degree === -450) {
        degree = -90;
      }
      if (degree < 0) {
        degree = 360 + degree;
      }
      var imgPoint = { startX: 0, startY: 0, width: 0, height: 0 };
      imgPoint.width = degree % 90 === 0 && degree % 180 !== 0 ? actObj.activePoint.height : actObj.activePoint.width;
      imgPoint.height = degree % 90 === 0 && degree % 180 !== 0 ? actObj.activePoint.width : actObj.activePoint.height;
      imgPoint.startX = actObj.activePoint.startX;
      imgPoint.startY = actObj.activePoint.startY;
      var startX = imgPoint.startX;
      var startY = imgPoint.startY;
      var tempDegree;
      canvasDraw.save();
      for (var i = 0, len = actObj.rotateFlipColl.length; i < len; i++) {
        var coll = actObj.rotateFlipColl[i];
        if (typeof coll === "number") {
          tempDegree = coll;
          if (tempDegree === -450) {
            tempDegree = -90;
          }
          if (tempDegree < 0) {
            tempDegree = 360 + tempDegree;
          }
          imgPoint.width = tempDegree % 90 === 0 && tempDegree % 180 !== 0 ? actObj.activePoint.height : actObj.activePoint.width;
          imgPoint.height = tempDegree % 90 === 0 && tempDegree % 180 !== 0 ? actObj.activePoint.width : actObj.activePoint.height;
          canvasDraw.translate(canvasDraw.canvas.width / 2, canvasDraw.canvas.height / 2);
          canvasDraw.rotate(Math.PI / 180 * coll);
          canvasDraw.translate(-canvasDraw.canvas.height / 2, -canvasDraw.canvas.width / 2);
          if (tempDegree % 90 === 0 && tempDegree % 270 !== 0 || tempDegree === 0) {
            startY = canvasDraw.canvas.width - (actObj.activePoint.startX + actObj.activePoint.width);
            startY += (actObj.activePoint.width - imgPoint.height) / 2;
            startX = imgPoint.startY;
          } else if (tempDegree % 270 === 0) {
            startX = canvasDraw.canvas.height - (actObj.activePoint.startY + actObj.activePoint.height);
            startX += (actObj.activePoint.height - imgPoint.width) / 2;
            startY = imgPoint.startX;
          }
          imgPoint.startX = startX;
          imgPoint.startY = startY;
          actObj.activePoint.startX = startX;
          actObj.activePoint.startY = startY;
          actObj.activePoint.endX = actObj.activePoint.startX + imgPoint.width;
          actObj.activePoint.endY = actObj.activePoint.startY + imgPoint.height;
          actObj = this.updateWidthHeight(actObj);
        } else {
          if (coll === "horizontal" && degree % 90 === 0 && degree % 180 !== 0) {
            coll = "vertical";
          } else if (coll === "vertical" && degree % 90 === 0 && degree % 180 !== 0) {
            coll = "horizontal";
          }
          if (coll === "horizontal") {
            canvasDraw.translate(canvasDraw.canvas.width, 0);
            canvasDraw.scale(-1, 1);
            actObj.activePoint = this.updateActPoint("horizontal", canvasDraw);
          } else if (coll === "vertical") {
            canvasDraw.translate(0, canvasDraw.canvas.height);
            canvasDraw.scale(1, -1);
            actObj.activePoint = this.updateActPoint("vertical", canvasDraw);
          }
          imgPoint.startX = actObj.activePoint.startX;
          imgPoint.startY = actObj.activePoint.startY;
        }
        imgPoint.startX = actObj.activePoint.startX;
        imgPoint.startY = actObj.activePoint.startY;
        startX = imgPoint.startX;
        startY = imgPoint.startY;
      }
      if (actObj.rotatedAngle !== 0) {
        parent.notify("shape", { prop: "setPointCollForShapeRotation", onPropertyChange: false, value: { obj: actObj } });
      }
      canvasDraw.drawImage(actObj.imageCanvas, imgPoint.startX, imgPoint.startY, imgPoint.width, imgPoint.height);
      canvasDraw.restore();
      parent.activeObj = tempActiveObj;
      if (parent.transform.degree === 360 || parent.transform.degree === -360) {
        parent.transform.degree = 0;
      }
    };
    Draw2.prototype.rotateText = function(canvasDraw) {
      var parent = this.parent;
      var degree;
      var actObj = parent.activeObj;
      var tempActiveObj = extend({}, parent.activeObj, null, true);
      var actPoint = parent.activeObj.activePoint;
      if (actObj.shapeDegree === 0) {
        degree = parent.transform.degree;
      } else {
        degree = parent.transform.degree - actObj.shapeDegree;
      }
      if (degree === -450) {
        degree = -90;
      }
      if (degree < 0) {
        degree = 360 + degree;
      }
      var imgPoint = { startX: 0, startY: 0, width: 0, height: 0 };
      imgPoint.width = degree % 90 === 0 && degree % 180 !== 0 ? actPoint.height : actPoint.width;
      imgPoint.height = degree % 90 === 0 && degree % 180 !== 0 ? actPoint.width : actPoint.height;
      imgPoint.startX = actPoint.startX;
      imgPoint.startY = actPoint.startY;
      var startX = imgPoint.startX;
      var startY = imgPoint.startY;
      var tempDegree;
      canvasDraw.save();
      for (var i = 0, len = actObj.rotateFlipColl.length; i < len; i++) {
        var coll = actObj.rotateFlipColl[i];
        if (typeof coll === "number") {
          tempDegree = coll;
          if (tempDegree === -450) {
            tempDegree = -90;
          }
          if (tempDegree < 0) {
            tempDegree = 360 + tempDegree;
          }
          imgPoint.width = tempDegree % 90 === 0 && tempDegree % 180 !== 0 ? actPoint.height : actPoint.width;
          imgPoint.height = tempDegree % 90 === 0 && tempDegree % 180 !== 0 ? actPoint.width : actPoint.height;
          canvasDraw.translate(canvasDraw.canvas.width / 2, canvasDraw.canvas.height / 2);
          canvasDraw.rotate(Math.PI / 180 * coll);
          canvasDraw.translate(-canvasDraw.canvas.height / 2, -canvasDraw.canvas.width / 2);
          if (tempDegree % 90 === 0 && tempDegree % 270 !== 0 || tempDegree === 0) {
            startY = canvasDraw.canvas.width - actPoint.endX;
            startX = actPoint.startY;
          } else if (tempDegree % 270 === 0) {
            startX = canvasDraw.canvas.height - actPoint.endY;
            startY = actPoint.startX;
          }
          imgPoint.startX = startX;
          imgPoint.startY = startY;
          actPoint.startX = startX;
          actPoint.startY = startY;
          actPoint.endX = actPoint.startX + imgPoint.width;
          actPoint.endY = actPoint.startY + imgPoint.height;
          actObj = this.updateWidthHeight(actObj);
        } else {
          if (coll === "horizontal" && degree % 90 === 0 && degree % 180 !== 0) {
            coll = "vertical";
          } else if (coll === "vertical" && degree % 90 === 0 && degree % 180 !== 0) {
            coll = "horizontal";
          }
          if (coll === "horizontal") {
            canvasDraw.translate(canvasDraw.canvas.width, 0);
            canvasDraw.scale(-1, 1);
          } else if (coll === "vertical") {
            canvasDraw.translate(0, canvasDraw.canvas.height);
            canvasDraw.scale(1, -1);
          }
          actObj.activePoint = actPoint = this.updateActPoint(coll, canvasDraw);
          imgPoint.startX = actPoint.startX;
          imgPoint.startY = actPoint.startY;
        }
        imgPoint.startX = actPoint.startX;
        imgPoint.startY = actPoint.startY;
        startX = imgPoint.startX;
        startY = imgPoint.startY;
      }
      if (actObj.rotatedAngle !== 0) {
        parent.notify("shape", { prop: "setPointCollForShapeRotation", onPropertyChange: false, value: { obj: actObj } });
      }
      startY += actObj.textSettings.fontSize * 0.4;
      this.textFlipDegree(canvasDraw, startX, startY);
      canvasDraw.restore();
      parent.activeObj = tempActiveObj;
      if (parent.transform.degree === 360 || parent.transform.degree === -360) {
        parent.transform.degree = 0;
      }
    };
    Draw2.prototype.textFlipDegree = function(canvasDraw, startX, startY) {
      var parent = this.parent;
      var actObj = parent.activeObj;
      var rows = actObj.keyHistory.split("\n");
      var fontSize = actObj.textSettings.fontSize;
      var lineHeight = (fontSize * rows.length - fontSize * rows.length) / rows.length;
      var yPoint = fontSize * 0.85 + lineHeight;
      for (var i = 0, len = rows.length; i < len; i++) {
        var text = rows[i];
        if (i > 0) {
          if (i === 1) {
            yPoint -= fontSize * 0.85;
          }
          yPoint += fontSize + fontSize * 0.15;
        }
        canvasDraw.strokeText(text, startX + fontSize * 0.15, startY + yPoint + (i > 0 ? fontSize * 0.25 : -fontSize * 0.35));
        canvasDraw.fillText(text, startX + fontSize * 0.15, startY + yPoint + (i > 0 ? fontSize * 0.25 : -fontSize * 0.35));
      }
    };
    Draw2.prototype.clearOuterCanvas = function(context) {
      var parent = this.parent;
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      var left = destLeft > 0 ? destLeft : 0;
      var top = destTop > 0 ? destTop : 0;
      context.clearRect(0, 0, left, parent.lowerCanvas.height);
      context.clearRect(destLeft + destWidth, 0, parent.lowerCanvas.width - (destLeft + destWidth), parent.lowerCanvas.height);
      context.clearRect(0, 0, parent.lowerCanvas.width, top);
      context.clearRect(0, destTop + destHeight, parent.lowerCanvas.width, parent.lowerCanvas.height - (destTop + destHeight));
      if (parent.transform.currFlipState !== "") {
        parent.img.destLeft = destLeft;
        parent.img.destTop = destTop;
      }
    };
    Draw2.prototype.setDestPoints = function() {
      var maxDimension;
      var parent = this.parent;
      var _a = parent.transform, degree = _a.degree, zoomFactor = _a.zoomFactor;
      if (degree % 90 === 0 && degree % 180 !== 0) {
        var obj = { width: 0, height: 0 };
        parent.notify("transform", {
          prop: "calcMaxDimension",
          onPropertyChange: false,
          value: { width: parent.img.srcHeight, height: parent.img.srcWidth, obj, isImgShape: null }
        });
        maxDimension = obj;
        if (this.isRotateZoom) {
          maxDimension.width += maxDimension.width * zoomFactor;
          maxDimension.height += maxDimension.height * zoomFactor;
          parent.img.destWidth = maxDimension.height;
          parent.img.destHeight = maxDimension.width;
        }
        parent.img.destLeft = (parent.lowerCanvas.clientWidth - maxDimension.height) / 2;
        parent.img.destTop = (parent.lowerCanvas.clientHeight - maxDimension.width) / 2;
        parent.img.destWidth = maxDimension.height;
        parent.img.destHeight = maxDimension.width;
      } else {
        var obj = { width: 0, height: 0 };
        parent.notify("transform", {
          prop: "calcMaxDimension",
          onPropertyChange: false,
          value: { width: parent.img.srcWidth, height: parent.img.srcHeight, obj, isImgShape: null }
        });
        maxDimension = obj;
        if (this.isRotateZoom) {
          maxDimension.width += maxDimension.width * zoomFactor;
          maxDimension.height += maxDimension.height * zoomFactor;
          parent.img.destWidth = maxDimension.width;
          parent.img.destHeight = maxDimension.height;
        }
        parent.img.destLeft = (parent.lowerCanvas.clientWidth - maxDimension.width) / 2;
        if (degree === 0) {
          parent.img.destTop = (parent.lowerCanvas.clientHeight - maxDimension.height + 1) / 2;
        } else {
          parent.img.destTop = (parent.lowerCanvas.clientHeight - maxDimension.height) / 2;
        }
        parent.img.destWidth = maxDimension.width;
        parent.img.destHeight = maxDimension.height;
      }
    };
    Draw2.prototype.updateCurrTransState = function(type, isPreventDestination, isRotatePan, isStraighten) {
      var parent = this.parent;
      var destLeft = parent.img.destLeft;
      var destTop = parent.img.destTop;
      if (type === "initial") {
        this.lowerContext.setTransform(1, 0, 0, 1, 0, 0);
        if (isNullOrUndefined(isPreventDestination)) {
          this.setDestPoints();
        }
      }
      if (parent.isCircleCrop || parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle") {
        this.currTransState(type, true, null, isRotatePan);
        if (parent.transform.degree === 0 && parent.transform.currFlipState === "" && parent.transform.straighten === 0 && isNullOrUndefined(isStraighten)) {
          parent.img.destLeft = destLeft;
          parent.img.destTop = destTop;
        }
        if (isRotatePan) {
          parent.img.destLeft += parent.panPoint.totalPannedClientPoint.x;
          parent.img.destTop += parent.panPoint.totalPannedClientPoint.y;
        }
        parent.notify("crop", {
          prop: "cropCircle",
          onPropertyChange: false,
          value: { context: this.lowerContext, isSave: null, isFlip: null }
        });
        if (isRotatePan) {
          parent.img.destLeft -= parent.panPoint.totalPannedClientPoint.x;
          parent.img.destTop -= parent.panPoint.totalPannedClientPoint.y;
        }
      } else {
        this.currTransState(type, null, null, isRotatePan);
        if (parent.transform.degree === 0 && parent.transform.currFlipState === "" && parent.transform.straighten === 0 && isNullOrUndefined(isStraighten)) {
          parent.img.destLeft = destLeft;
          parent.img.destTop = destTop;
        }
      }
    };
    Draw2.prototype.currTransState = function(type, isPreventDimension, context, isPreventCircleCrop) {
      var parent = this.parent;
      context = context ? context : this.lowerContext;
      if (type === "initial") {
        this.setTransformColl(context, type);
      } else if (type === "reverse") {
        this.setTransformColl(context, type);
        this.setClientTransDim(isPreventDimension);
        if (parent.isCircleCrop || parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle" && isNullOrUndefined(isPreventCircleCrop)) {
          if (isPreventCircleCrop) {
            parent.img.destLeft += parent.panPoint.totalPannedClientPoint.x;
            parent.img.destTop += parent.panPoint.totalPannedClientPoint.y;
          }
          parent.notify("crop", {
            prop: "cropCircle",
            onPropertyChange: false,
            value: { context: this.lowerContext, isSave: null, isFlip: null }
          });
          if (isPreventCircleCrop) {
            parent.img.destLeft -= parent.panPoint.totalPannedClientPoint.x;
            parent.img.destTop -= parent.panPoint.totalPannedClientPoint.y;
          }
        }
      }
    };
    Draw2.prototype.setTransformColl = function(context, type) {
      var parent = this.parent;
      if (type === "initial") {
        for (var i = 0, len = parent.rotateFlipColl.length; i < len; i++) {
          this.setTransform(context, parent.rotateFlipColl[i]);
        }
      } else if (type === "reverse") {
        for (var i = parent.rotateFlipColl.length - 1; i >= 0; i--) {
          this.setTransform(context, parent.rotateFlipColl[i], true);
        }
      }
    };
    Draw2.prototype.setTransform = function(context, value, isReverse) {
      var parent = this.parent;
      if (isReverse && value === 90) {
        value = -90;
      } else if (isReverse && value === -90) {
        value = 90;
      }
      if (value === "horizontal" && parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0) {
        value = "vertical";
      } else if (value === "vertical" && parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0) {
        value = "horizontal";
      }
      parent.notify("transform", { prop: "setReverseRotate", onPropertyChange: false, value: { bool: true } });
      parent.notify("transform", { prop: "setReverseFlip", onPropertyChange: false, value: { isReverseFlip: true } });
      if (isNullOrUndefined(isReverse)) {
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
      }
      switch (value) {
        case 90:
        case -90:
          context.translate(context.canvas.width / 2, context.canvas.height / 2);
          context.rotate(Math.PI / 180 * value);
          context.translate(-context.canvas.width / 2, -context.canvas.height / 2);
          break;
        case "horizontal":
          context.translate(context.canvas.width, 0);
          context.scale(-1, 1);
          break;
        case "vertical":
          context.translate(0, context.canvas.height);
          context.scale(1, -1);
          break;
      }
      parent.notify("transform", { prop: "setReverseRotate", onPropertyChange: false, value: { bool: false } });
      parent.notify("transform", { prop: "setReverseFlip", onPropertyChange: false, value: { isReverseFlip: false } });
    };
    Draw2.prototype.drawImgToCanvas = function(maxDimension) {
      var parent = this.parent;
      this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      parent.img.destWidth = maxDimension.width;
      parent.img.destHeight = maxDimension.height;
      if (this.isInitialLoading) {
        parent.notify("filter", { prop: "initFilter", onPropertyChange: false });
        this.isInitialLoading = false;
      }
      var temp = this.lowerContext.filter;
      this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      this.drawImage();
      if (parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle" || parent.isCircleCrop) {
        parent.notify("crop", {
          prop: "cropCircle",
          onPropertyChange: false,
          value: { context: this.lowerContext, isSave: null, isFlip: null }
        });
      }
      this.lowerContext.filter = temp;
    };
    Draw2.prototype.renderImage = function(isMouseWheel, isPreventClearRect, isFrame, isStraighten) {
      var parent = this.parent;
      parent.notify("shape", { prop: "applyActObj", onPropertyChange: false, value: { isMouseDown: null } });
      if (isNullOrUndefined(isPreventClearRect)) {
        this.upperContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      }
      if (isMouseWheel) {
        this.setTransformColl(this.lowerContext, "initial");
      } else {
        if (parent.transform.zoomFactor !== 0) {
          this.isRotateZoom = true;
        }
        this.updateCurrTransState("initial", null, null, isStraighten);
      }
      parent.notify("transform", { prop: "setDestPointsForFlipState", onPropertyChange: false });
      this.drawImage();
      parent.notify("transform", { prop: "setDestPointsForFlipState", onPropertyChange: false });
      if (isMouseWheel) {
        this.setTransformColl(this.lowerContext, "reverse");
      } else {
        this.updateCurrTransState("reverse", null, null, isStraighten);
        this.isRotateZoom = false;
      }
      if (isFrame) {
        parent.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
        });
      } else {
        parent.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "iterate", pen: "iterate", isPreventApply: null }
        });
      }
      this.clearOuterCanvas(this.lowerContext);
      if (parent.isCircleCrop || parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle") {
        parent.notify("crop", {
          prop: "cropCircle",
          onPropertyChange: false,
          value: { context: this.lowerContext, isSave: null, isFlip: null }
        });
      }
    };
    Draw2.prototype.imageOnLoad = function(src) {
      var _this = this;
      var parent = this.parent;
      var proxy = this;
      parent.baseImg.src = src;
      parent.baseImg.onload = function() {
        parent.imgSrc = src;
        if (!parent.isUndoRedo) {
          parent.notify("filter", { prop: "update-finetunes", onPropertyChange: false });
        }
        proxy.lowerContext.drawImage(parent.baseImg, 0, 0, proxy.parent.lowerCanvas.width, proxy.parent.lowerCanvas.height);
        var isCropped = false;
        var isSameDimension = false;
        if (parent.isImageUpdated) {
          var _a = parent.img, srcWidth = _a.srcWidth, srcHeight = _a.srcHeight;
          var _b = parent.baseImgCanvas, width = _b.width, height = _b.height;
          isCropped = srcWidth !== width || srcHeight !== height;
          isSameDimension = parent.baseImg.width === width && parent.baseImg.height === height;
        }
        hideSpinner(parent.element);
        parent.element.style.opacity = "1";
        proxy.updateBaseImgCanvas();
        var fileOpened = { fileName: _this.fileName, fileType: _this.fileType, isValidImage: true };
        proxy.updateCanvas(isCropped, isSameDimension);
        if (parent.currObjType.isUndoZoom) {
          parent.currObjType.isUndoZoom = false;
          proxy.parent.lowerCanvas.style.display = "block";
        }
        parent.isUndoRedo = _this.isErrorImage = false;
        if (Browser.isDevice) {
          parent.notify("toolbar", { prop: "destroy-top-toolbar", onPropertyChange: false });
          parent.notify("toolbar", { prop: "destroy-bottom-toolbar", onPropertyChange: false });
          var eventargs = {
            isApplyBtn: false,
            isDevice: Browser.isDevice,
            isOkBtn: null,
            isResize: null,
            isFrame: null,
            isMainToolbar: true
          };
          parent.notify("toolbar", { prop: "init-main-toolbar", onPropertyChange: false, value: eventargs });
          parent.notify("toolbar", { prop: "create-bottom-toolbar", onPropertyChange: false });
        } else {
          parent.notify("toolbar", { prop: "destroy-top-toolbar", onPropertyChange: false });
          var eventargs = { isApplyBtn: false, isDevice: false, isOkBtn: null };
          parent.notify("toolbar", { prop: "init-main-toolbar", onPropertyChange: false, value: eventargs });
        }
        if (parent.isImageLoaded && parent.element.style.opacity !== "0.5") {
          parent.trigger("fileOpened", fileOpened);
          var action = { action: "file-open", actionEventArgs: fileOpened };
          parent.triggerEditCompleteEvent(action);
        }
      };
      parent.baseImg.onerror = function() {
        hideSpinner(parent.element);
        proxy.isErrorImage = true;
        proxy.errorLoading();
      };
    };
    Draw2.prototype.errorLoading = function() {
      var parent = this.parent;
      var fileOpened = { fileName: null, fileType: null, isValidImage: false };
      parent.trigger("fileOpened", fileOpened);
    };
    Draw2.prototype.updateBaseImgCanvas = function() {
      var parent = this.parent;
      parent.baseImgCanvas.width = parent.baseImg.width;
      parent.baseImgCanvas.height = parent.baseImg.height;
      parent.baseImgCanvas.getContext("2d").drawImage(parent.baseImg, 0, 0);
    };
    Draw2.prototype.updateCanvas = function(isCropped, isSameDimension) {
      var parent = this.parent;
      if (!parent.isImageUpdated || !isCropped) {
        parent.img.srcWidth = parent.baseImgCanvas.width;
        parent.img.srcHeight = parent.baseImgCanvas.height;
      } else if (!isSameDimension && isCropped) {
        parent.img.srcLeft = 0;
        parent.img.srcTop = 0;
        parent.img.srcWidth = parent.baseImgCanvas.width;
        parent.img.srcHeight = parent.baseImgCanvas.height;
        parent.currSelectionPoint = null;
        parent.cropObj = {
          cropZoom: 0,
          defaultZoom: 0,
          totalPannedPoint: { x: 0, y: 0 },
          totalPannedClientPoint: { x: 0, y: 0 },
          totalPannedInternalPoint: { x: 0, y: 0 },
          tempFlipPanPoint: { x: 0, y: 0 },
          activeObj: {},
          rotateFlipColl: [],
          degree: 0,
          currFlipState: "",
          straighten: 0,
          destPoints: { startX: 0, startY: 0, width: 0, height: 0 },
          srcPoints: { startX: 0, startY: 0, width: 0, height: 0 },
          filter: "",
          isBrightAdjust: false,
          zoomFactor: 0,
          previousZoomValue: 0,
          aspectWidth: null,
          aspectHeight: null,
          frame: "none",
          straightenZoom: 0,
          adjustmentLevel: {
            brightness: 0,
            contrast: 0,
            hue: 0,
            opacity: 100,
            saturation: 0,
            blur: 0,
            exposure: 0,
            transparency: 100,
            sharpen: false,
            bw: false
          },
          currentFilter: ""
        };
      }
      var obj = { width: 0, height: 0 };
      parent.notify("transform", {
        prop: "calcMaxDimension",
        onPropertyChange: false,
        value: { width: parent.img.srcWidth, height: parent.img.srcHeight, obj, isImgShape: null }
      });
      var maxDimension = obj;
      parent.img.destLeft = (parent.lowerCanvas.clientWidth - maxDimension.width) / 2;
      parent.img.destTop = (parent.lowerCanvas.clientHeight - maxDimension.height + 1) / 2;
      this.drawImgToCanvas(maxDimension);
      this.origDim.width = parent.img.destWidth;
      this.origDim.height = parent.img.destHeight;
      this.zoomCrop.width = parent.img.destWidth;
      this.zoomCrop.height = parent.img.destHeight;
      parent.notify("transform", {
        prop: "setCropDimension",
        onPropertyChange: false,
        value: { width: parent.img.destWidth, height: parent.img.destHeight }
      });
      var point = {
        startX: parent.img.destLeft,
        startY: parent.img.destTop,
        width: parent.img.destWidth,
        height: parent.img.destHeight
      };
      parent.notify("crop", { prop: "setCropDestPoints", onPropertyChange: false, value: { point } });
      var temp = this.lowerContext.filter;
      this.lowerContext.filter = "none";
      parent.notify("shape", {
        prop: "drawAnnotations",
        onPropertyChange: false,
        value: { ctx: this.lowerContext, shape: "iterate", pen: "zoom", isPreventApply: null }
      });
      this.lowerContext.filter = temp;
      if (parent.img.destWidth > 0 && parent.img.destHeight > 0) {
        parent.isImageLoaded = true;
      }
      if (parent.isUndoRedo) {
        if (parent.transform.currFlipState !== "") {
          parent.notify("transform", {
            prop: "flipImage",
            onPropertyChange: false,
            value: { direction: parent.toPascalCase(parent.transform.currFlipState) }
          });
        }
      }
      if (parent.disabled) {
        parent.element.setAttribute("class", "e-disabled");
      }
      if (parent.zoomSettings.zoomFactor !== 1 || parent.zoomSettings.zoomPoint) {
        parent.zoom(parent.zoomSettings.zoomFactor, parent.zoomSettings.zoomPoint);
      }
      if (isNullOrUndefined(this.initZoomValue)) {
        this.initZoomValue = parent.zoomSettings.zoomFactor;
      }
      this.isImageEdited = false;
    };
    Draw2.prototype.resetFrameZoom = function(isOk) {
      var parent = this.parent;
      if (!isNullOrUndefined(parent.tempFrameZoomLevel)) {
        var temp = parent.tempFrameZoomLevel;
        parent.tempFrameZoomLevel = null;
        parent.notify("transform", { prop: "resetZoom", onPropertyChange: false });
        parent.notify("transform", {
          prop: "zoomAction",
          onPropertyChange: false,
          value: { zoomFactor: temp, zoomPoint: null, isResize: true }
        });
        var obj = parent.cancelCropSelection;
        if (isOk && obj) {
          obj.previousObj.frameObj = extend({}, parent.frameObj, null, true);
          obj.currentObj.frameObj = extend({}, parent.frameObj, null, true);
          obj.previousObj.frame = obj.currentObj.frame = parent.frameObj.type;
        }
        this.updateCropSelObj();
        parent.cancelCropSelection = null;
      }
    };
    Draw2.prototype.performCancel = function(isContextualToolbar, isUndoRedo, isFinalCancel) {
      var parent = this.parent;
      if (isFinalCancel) {
        parent.noPushUndo = false;
      }
      var straightenObj = { bool: parent.isStraightening };
      isContextualToolbar = isContextualToolbar ? isContextualToolbar : false;
      var obj = { bool: false };
      parent.allowDownScale = true;
      parent.notify("selection", { prop: "getFreehandDrawEditing", onPropertyChange: false, value: { obj } });
      if (isNullOrUndefined(isUndoRedo) && JSON.stringify(parent.frameObj) !== JSON.stringify(parent.tempFrameObj)) {
        extend(parent.frameObj, parent.tempFrameObj);
        this.renderImage(null, null, true);
      }
      this.resetFrameZoom(false);
      var editCompleteArgs = { action: "" };
      if (obj["bool"]) {
        editCompleteArgs["action"] = "freehand-draw";
        parent.notify("freehand-draw", { prop: "cancelFhd", onPropertyChange: false });
        parent.notify("toolbar", { prop: "destroy-qa-toolbar", onPropertyChange: false });
        parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
      } else if (parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block") {
        editCompleteArgs["action"] = "text-editing";
        parent.textArea.style.display = "none";
        parent.textArea.value = "";
        parent.textArea.style.transform = "";
        if (this.prevActObj) {
          parent.activeObj = this.prevActObj;
          this.prevActObj = null;
        } else {
          parent.activeObj.strokeSettings = this.tempStrokeSettings;
          parent.activeObj.textSettings = this.tempTextSettings;
        }
        parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "cancel" } });
        if (this.isShapeTextInserted) {
          parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        }
        parent.notify("shape", { prop: "applyActObj", onPropertyChange: false, value: { isMouseDown: true } });
        parent.notify("toolbar", { prop: "refresh-main-toolbar", onPropertyChange: false });
        parent.notify("selection", { prop: "setTempActObj", onPropertyChange: false, value: { obj: parent.activeObj } });
        if (parent.drawingShape) {
          parent.enableShapeDrawing(parent.toPascalCase(parent.drawingShape), true);
        }
      } else if ((!parent.activeObj.shape || parent.activeObj.shape !== "redact") && ((!Browser.isDevice || Browser.isDevice && !straightenObj["bool"]) && (undefined).querySelector("#" + parent.element.id + "_sliderWrapper") || parent.currObjType.isFiltered)) {
        editCompleteArgs["action"] = parent.isFinetuneBtnClick ? "fine-tune" : "filter";
        this.lowerContext.filter = this.tempAdjValue;
        parent.canvasFilter = this.tempAdjValue;
        parent.notify("filter", { prop: "setAdjustmentValue", onPropertyChange: false, value: { adjustmentValue: this.tempAdjValue } });
        parent.initialAdjustmentValue = this.tempAdjValue;
        if (this.lowerContext.filter.split(" ").length > 1 && this.lowerContext.filter.split(" ")[0].split("(")[1].split(")")[0] === "1") {
          parent.notify("filter", { prop: "setBrightnessAdjusted", onPropertyChange: false, value: { isBrightnessAdjusted: false } });
        }
        parent.currentFilter = this.tempFilter;
        parent.notify("filter", { prop: "setBevelFilter", onPropertyChange: false, value: { bevelFilter: this.lowerContext.filter } });
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        this.redrawImgWithObj();
        parent.currObjType.isFiltered = false;
        var obj_3 = { tempAdjustmentLevel: null };
        parent.notify("filter", { prop: "getTempAdjustmentLevel", onPropertyChange: false, value: { obj: obj_3 } });
        parent.notify("filter", {
          prop: "setAdjustmentLevel",
          onPropertyChange: false,
          value: { adjustmentLevel: extend({}, obj_3["tempAdjustmentLevel"], {}, true) }
        });
        parent.notify("undo-redo", { prop: "setUndoRedoStep", onPropertyChange: false, value: { step: this.tempUndoRedoStep } });
        parent.upperCanvas.style.cursor = parent.cursor = "default";
        parent.currObjType.isCustomCrop = false;
        this.tempStrokeSettings = { strokeColor: "#fff", fillColor: "", strokeWidth: null, radius: null, outlineColor: "", outlineWidth: null };
        this.clearOuterCanvas(this.lowerContext);
        if (parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle" || parent.isCircleCrop) {
          parent.notify("crop", {
            prop: "cropCircle",
            onPropertyChange: false,
            value: { context: this.lowerContext, isSave: null, isFlip: null }
          });
        }
        var eventargs = { type: "main", isApplyBtn: null, isCropping: null, isZooming: null };
        parent.element.querySelector(".e-contextual-toolbar-wrapper").classList.add("e-hide");
        parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: eventargs });
        if (parent.activeObj.shape && parent.activeObj.shape === "image") {
          parent.notify("toolbar", { prop: "destroy-qa-toolbar", onPropertyChange: false });
        }
        parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "cancel" } });
        parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        if (parent.drawingShape) {
          parent.drawingShape = null;
          parent.notify("selection", { prop: "setCurrentDrawingShape", onPropertyChange: false, value: { value: "" } });
        }
      } else {
        if ((!parent.activeObj.shape || parent.activeObj.shape !== "redact") && isContextualToolbar && (!Browser.isDevice || Browser.isDevice && !straightenObj["bool"])) {
          var eventargs = { type: "main", isApplyBtn: null, isCropping: null, isZooming: null };
          parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: eventargs });
        } else {
          this.cancelItems(editCompleteArgs);
          if (parent.transform.zoomFactor > 0) {
            parent.togglePan = true;
            parent.notify("selection", { prop: "setDragCanvas", value: { bool: true } });
          } else {
            parent.togglePan = false;
            parent.notify("selection", { prop: "setDragCanvas", value: { bool: false } });
          }
        }
      }
      this.isShapeTextInserted = false;
      this.isNewPath = false;
      parent.notify("toolbar", { prop: "refresh-dropdown-btn", value: { isDisabled: false } });
      parent.notify("toolbar", { prop: "setCurrentToolbar", value: { type: "main" } });
      if (isFinalCancel) {
        parent.noPushUndo = false;
      }
      parent.drawingShape = null;
      parent.notify("draw", { prop: "resetTempObjColl" });
      parent.notify("draw", { prop: "resetTempPointColl" });
      parent.isMaskImage = parent.isFinetuneBtnClick = false;
      var actionArgs = { action: "cancel", actionEventArgs: editCompleteArgs };
      parent.triggerEditCompleteEvent(actionArgs);
    };
    Draw2.prototype.cancelItems = function(editCompleteArgs) {
      var parent = this.parent;
      var isCropSelection = false;
      var id = parent.element.id;
      var ascpectIcon = parent.element.querySelector("#" + id + "_aspectratio");
      var nonAspectIcon = parent.element.querySelector("#" + id + "_nonaspectratio");
      var splitWords;
      var shapes = ["rectangle", "ellipse", "line", "arrow", "path", "image", "redact"];
      if (parent.activeObj.shape !== undefined) {
        splitWords = parent.activeObj.shape.split("-");
      }
      if (splitWords === undefined && parent.currObjType.isCustomCrop) {
        isCropSelection = true;
      } else if (splitWords !== undefined && splitWords[0] === "crop") {
        isCropSelection = true;
      }
      if (isCropSelection && parent.isCropTab) {
        parent.isCropTab = false;
        parent.transform.zoomFactor = parent.transform.defaultZoomFactor;
      }
      if (parent.isResize) {
        if (ascpectIcon || nonAspectIcon || parent.currentToolbar === "resize-toolbar") {
          editCompleteArgs["action"] = "resize";
          var obj = { width: null, height: null };
          parent.notify("selection", { prop: "getNumTextValue", onPropertyChange: false, value: { obj } });
          var point = { x: obj["width"], y: obj["height"] };
          var aspectRatioElement = parent.element.querySelector("#" + parent.element.id + "_aspectratio");
          var blrAspRatElem = parent.element.querySelector(".e-ie-toolbar-aspect-ratio-btn");
          if (point && point.x && point.y && !isNullOrUndefined(parent.aspectWidth)) {
            if (aspectRatioElement || blrAspRatElem && !blrAspRatElem.classList.contains("e-hidden")) {
              parent.notify("transform", { prop: "resizeImage", value: { width: parent.aspectWidth, height: parent.aspectHeight } });
            } else {
              var bool = parent.currObjType.isUndoAction;
              parent.currObjType.isUndoAction = false;
              parent.notify("transform", { prop: "resizeCrop", value: { width: parent.aspectWidth, height: parent.aspectHeight } });
              parent.currObjType.isUndoAction = bool;
            }
          }
          var obj1 = { prevCropObj: parent.prevCropObj };
          var obj2 = { prevObj: parent.prevObj };
          parent.notify("toolbar", { prop: "getPrevCropObj", onPropertyChange: false, value: { obj: obj1 } });
          parent.notify("toolbar", { prop: "getPrevObj", onPropertyChange: false, value: { obj: obj2 } });
          if (obj1["prevCropObj"] && obj2["prevObj"]) {
            parent.objColl = [];
            parent.pointColl = [];
            parent.freehandCounter = 0;
            parent.cropObj = extend({}, obj1["prevCropObj"], {}, true);
            this.setCurrentObj(obj2["prevObj"]);
            parent.objColl = obj2["prevObj"]["objColl"];
            parent.pointColl = obj2["prevObj"]["pointColl"];
            parent.freehandCounter = parent.pointColl.length;
            parent.transform.straighten = 0;
            parent.notify("shape", {
              prop: "drawAnnotations",
              onPropertyChange: false,
              value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
            });
            var currObj = parent.currSelectionPoint ? extend({}, parent.currSelectionPoint, {}, true) : null;
            parent.notify("transform", {
              prop: "zoomAction",
              onPropertyChange: false,
              value: { zoomFactor: -parent.transform.zoomFactor, zoomPoint: null, isResize: true }
            });
            parent.notify("transform", {
              prop: "zoomAction",
              onPropertyChange: false,
              value: { zoomFactor: obj2["prevObj"]["defaultZoom"], zoomPoint: null, isResize: true }
            });
            parent.currSelectionPoint = currObj;
            if (obj2["prevObj"].zoomFactor) {
              parent.setProperties({ zoomSettings: { zoomFactor: obj2["prevObj"].zoomFactor } }, true);
            }
            parent.notify("transform", {
              prop: "setPreviousZoomValue",
              onPropertyChange: false,
              value: { previousZoomValue: parent.zoomSettings.zoomFactor }
            });
          }
          parent.isResize = false;
          parent.notify("transform", { prop: "setResizedImgAngle", onPropertyChange: false, value: { angle: null } });
          var temp = parent.isCropTab;
          parent.isCropTab = false;
          this.updateCropSelObj();
          parent.cancelCropSelection = null;
          parent.isCropTab = temp;
        }
      }
      switch (true) {
        case parent.togglePen:
          editCompleteArgs["action"] = "freehand-draw";
          this.cancelPen();
          break;
        case parent.activeObj.shape === "text":
          editCompleteArgs["action"] = "text";
          this.cancelText();
          break;
        case shapes.indexOf(parent.activeObj.shape) !== -1:
          editCompleteArgs["action"] = parent.activeObj.shape;
          this.cancelShape();
          parent.currObjType.isRedact = false;
          break;
        case isCropSelection:
          editCompleteArgs["action"] = "crop-selection";
          this.cancelSelection();
          break;
        default:
          parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
          this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
          parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "cancel" } });
          break;
      }
      parent.notify("selection", { prop: "setCurrentDrawingShape", onPropertyChange: false, value: { value: "" } });
      parent.upperCanvas.style.cursor = parent.cursor = "default";
      parent.currObjType.isCustomCrop = false;
      this.tempStrokeSettings = { strokeColor: "#fff", fillColor: "", strokeWidth: null, radius: null, outlineColor: "", outlineWidth: null };
      var eventargs = { type: "main", isApplyBtn: null, isCropping: false, isZooming: null };
      parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: eventargs });
    };
    Draw2.prototype.cancelPen = function() {
      var parent = this.parent;
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      parent.togglePen = false;
      parent.upperCanvas.style.cursor = parent.cursor = "default";
      var tempPointsColl = extend([], parent.pointColl, [], true);
      parent.pointColl = {};
      for (var i = 0; i < this.tempFreehandCounter; i++) {
        parent.pointColl[i] = tempPointsColl[i];
      }
      parent.freehandCounter = this.tempFreehandCounter;
      parent.notify("freehand-draw", { prop: "setCurrentFreehandDrawIndex", value: { value: this.tempCurrFhdIndex } });
      parent.activeObj.strokeSettings = this.tempStrokeSettings;
      parent.notify("shape", { prop: "setStrokeSettings", value: {
        strokeSettings: parent.activeObj.strokeSettings,
        strokeColor: null,
        fillColor: null,
        strokeWidth: null,
        radius: null
      } });
      parent.notify("freehand-draw", { prop: "setPenStrokeWidth", onPropertyChange: false, value: { value: this.tempStrokeWidth } });
      parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "cancel" } });
      parent.notify("selection", { prop: "setFreehandDrawCustomized", value: { isFreehandDrawCustomized: false } });
      parent.objColl = extend([], this.tempObjColl, [], true);
      parent.pointColl = extend([], this.tempPointColl, [], true);
      parent.freehandCounter = parent.pointColl.length;
      this.tempPointColl = {};
      this.renderImage();
      parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok", isCancel: true } });
    };
    Draw2.prototype.cancelText = function() {
      var parent = this.parent;
      parent.notify("shape", {
        prop: "setTextSettings",
        onPropertyChange: false,
        value: { textSettings: this.tempTextSettings, fontFamily: null, fontSize: null }
      });
      parent.notify("shape", {
        prop: "setStrokeSettings",
        value: { strokeSettings: this.tempStrokeSettings, strokeColor: null, fillColor: null, strokeWidth: null, radius: null }
      });
      if (isNullOrUndefined(parent.activeObj.currIndex)) {
        parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      } else {
        var object = { appliedUndoRedoColl: [] };
        parent.notify("undo-redo", { prop: "getAppliedUndoRedoColl", value: { obj: object } });
        var len = object["appliedUndoRedoColl"].length;
        var appliedColl = object["appliedUndoRedoColl"][len - 1];
        if (this.prevActObj && appliedColl && appliedColl.currentObjColl.length && appliedColl.currentObjColl[appliedColl.currentObjColl.length - 1].currIndex === this.prevActObj.currIndex) {
          parent.activeObj = this.prevActObj;
          this.prevActObj = null;
        } else {
          parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
          this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        }
      }
      parent.notify("toolbar", { prop: "destroy-qa-toolbar", onPropertyChange: false });
      this.tempTextSettings = {
        text: "Enter Text",
        fontFamily: parent.fontFamily.default,
        fontSize: null,
        fontRatio: null,
        bold: false,
        italic: false,
        underline: false
      };
      parent.objColl = extend([], this.tempObjColl, [], true);
      parent.pointColl = extend([], this.tempPointColl, [], true);
      this.renderImage();
      this.tempObjColl = [];
      parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok", isCancel: true } });
    };
    Draw2.prototype.cancelShape = function() {
      var parent = this.parent;
      parent.notify("shape", {
        prop: "setStrokeSettings",
        value: { strokeSettings: this.tempStrokeSettings, strokeColor: null, fillColor: null, strokeWidth: null, radius: null }
      });
      if (isNullOrUndefined(parent.activeObj.currIndex)) {
        parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      } else if (this.isNewPath) {
        parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        this.renderImage();
      } else {
        var object = { appliedUndoRedoColl: [] };
        parent.notify("undo-redo", { prop: "getAppliedUndoRedoColl", value: { obj: object } });
        var obj = undefined;
        for (var i = 0, iLen = object["appliedUndoRedoColl"].length; i < iLen; i++) {
          var currObjColl = object["appliedUndoRedoColl"][i].currentObjColl;
          for (var j = 0, jLen = currObjColl.length; j < jLen; j++) {
            if (this.prevActObj && this.prevActObj.currIndex && currObjColl[j].currIndex === this.prevActObj.currIndex) {
              obj = currObjColl[0];
              break;
            }
          }
        }
        if (this.prevActObj && obj) {
          parent.activeObj = this.prevActObj;
          this.prevActObj = null;
          parent.notify("selection", { prop: "redrawShape", onPropertyChange: false, value: { obj: parent.activeObj } });
          parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "cancel" } });
          parent.notify("shape", { prop: "applyActObj", onPropertyChange: false, value: { isMouseDown: true } });
        } else {
          parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
          this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        }
        var undoRedoObj = { undoRedoStep: null };
        parent.notify("undo-redo", { prop: "getUndoRedoStep", value: { obj: undoRedoObj } });
        if (object["appliedUndoRedoColl"][undoRedoObj["undoRedoStep"] - 1]) {
          parent.objColl = extend([], object["appliedUndoRedoColl"][undoRedoObj["undoRedoStep"] - 1].currentObjColl, [], true);
        } else {
          parent.objColl = [];
        }
        this.renderImage();
      }
      parent.currObjType.isDragging = false;
      parent.notify("toolbar", { prop: "destroy-qa-toolbar", onPropertyChange: false });
      parent.objColl = extend([], this.tempObjColl, [], true);
      parent.pointColl = extend([], this.tempPointColl, [], true);
      this.renderImage();
      this.tempObjColl = [];
      parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok", isCancel: true } });
    };
    Draw2.prototype.cancelSelection = function() {
      var parent = this.parent;
      if (parent.cancelCropSelection) {
        var obj = { value: parent.tempStraighten };
        parent.transform.straighten = obj["value"];
        parent.straightenBaseImageCanvas();
        parent.notify("freehand-draw", { prop: "resetStraightenPoint" });
        parent.notify("draw", { prop: "render-image", value: { isMouseWheel: false } });
        parent.notify("draw", { prop: "setStraightenActObj", value: { activeObj: parent.activeObj } });
        parent.notify("crop", { prop: "resizeWrapper" });
        this.updateCropSelObj();
        if (this.tempStraightenDestPoints && JSON.stringify(this.tempStraightenDestPoints) !== JSON.stringify(this.straightenDestPoints)) {
          this.straightenDestPoints = extend({}, this.tempStraightenDestPoints, {}, true);
        }
      }
    };
    Draw2.prototype.updateCropSelObj = function() {
      var parent = this.parent;
      if (parent.cancelCropSelection) {
        parent.cropObj = extend({}, parent.cancelCropSelection.previousCropObj, {}, true);
        parent.afterCropActions = parent.cancelCropSelection.previousObj.afterCropActions;
        parent.notify("undo-redo", { prop: "undoDefault", onPropertyChange: false, value: { obj: parent.cancelCropSelection } });
        parent.currSelectionPoint = extend({}, parent.cancelCropSelection.previousCropObj.activeObj, true);
        if (parent.currSelectionPoint && isNullOrUndefined(parent.currSelectionPoint.shape)) {
          parent.currSelectionPoint = null;
        }
        this.clearOuterCanvas(this.lowerContext);
        if (parent.isCircleCrop || parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle") {
          parent.notify("crop", {
            prop: "cropCircle",
            onPropertyChange: false,
            value: { context: this.lowerContext, isSave: null, isFlip: null }
          });
        }
      }
    };
    Draw2.prototype.updateCropSelection = function() {
      var parent = this.parent;
      var object = { currObj: {} };
      parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
      var currentObj = object["currObj"];
      currentObj.objColl = extend([], parent.objColl, [], true);
      currentObj.pointColl = extend([], parent.pointColl, [], true);
      currentObj.afterCropActions = extend([], parent.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      parent.notify("freehand-draw", {
        prop: "getSelPointColl",
        onPropertyChange: false,
        value: { obj: selPointCollObj }
      });
      currentObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
      parent.cancelCropSelection = {
        operation: "cropTransform",
        previousObj: currentObj,
        currentObj,
        previousObjColl: currentObj.objColl,
        currentObjColl: currentObj.objColl,
        previousPointColl: currentObj.pointColl,
        currentPointColl: currentObj.pointColl,
        previousSelPointColl: currentObj.selPointColl,
        currentSelPointColl: currentObj.selPointColl,
        previousCropObj: extend({}, parent.cropObj, {}, true),
        currentCropObj: extend({}, parent.cropObj, {}, true),
        previousText: null,
        currentText: null,
        filter: null,
        isCircleCrop: parent.isCircleCrop
      };
    };
    Draw2.prototype.updateFlipPan = function(tempSelectionObj) {
      var parent = this.parent;
      if (parent.transform.currFlipState !== "") {
        var temp = this.lowerContext.filter;
        parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        parent.notify("transform", { prop: "rotatedFlip", onPropertyChange: false });
        this.lowerContext.filter = "none";
        parent.notify("freehand-draw", {
          prop: "freehandRedraw",
          onPropertyChange: false,
          value: { context: this.lowerContext, points: null }
        });
        this.lowerContext.filter = temp;
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        if (tempSelectionObj) {
          this.drawObject("duplicate", tempSelectionObj);
        }
      }
    };
    Draw2.prototype.select = function(type, startX, startY, width, height) {
      var parent = this.parent;
      type = type.toLowerCase();
      if (!parent.disabled && parent.isImageLoaded) {
        parent.allowDownScale = false;
        var object = { currObj: {} };
        parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
        var previousObj = object["currObj"];
        previousObj.objColl = extend([], parent.objColl, [], true);
        previousObj.pointColl = extend([], parent.pointColl, [], true);
        previousObj.afterCropActions = parent.afterCropActions;
        var selPointCollObj = { selPointColl: null };
        parent.notify("freehand-draw", {
          prop: "getSelPointColl",
          onPropertyChange: false,
          value: { obj: selPointCollObj }
        });
        previousObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
        parent.notify("crop", { prop: "setPreviousCropCurrentObj", onPropertyChange: false, value: { obj: previousObj } });
        if (parent.transform.zoomFactor > 0 && parent.activeObj.shape && parent.activeObj.shape.split("-")[0] === "crop" && isNullOrUndefined(this.currSelPoint)) {
          this.currSelPoint = extend({}, parent.activeObj, {}, true);
        }
        var isPrevent = false;
        var splitWords = undefined;
        if (parent.activeObj.shape !== undefined) {
          splitWords = parent.activeObj.shape.split("-");
        }
        if (splitWords === undefined && parent.currObjType.isCustomCrop) {
          isPrevent = true;
        } else if (splitWords !== undefined && splitWords[0] === "crop") {
          isPrevent = true;
        }
        var obj = { currObj: {} };
        parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object: obj } });
        var prevObj = obj["currObj"];
        prevObj.objColl = extend([], parent.objColl, [], true);
        prevObj.pointColl = extend([], parent.pointColl, [], true);
        prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
        parent.notify("shape", {
          prop: "redrawActObj",
          onPropertyChange: false,
          value: { x: null, y: null, isMouseDown: null }
        });
        parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        parent.notify("shape", { prop: "setKeyHistory", onPropertyChange: false, value: { keyHistory: "" } });
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        parent.upperCanvas.style.display = "block";
        if (parent.currSelectionPoint || parent.transform.defaultZoomFactor !== 0 || parent.transform.degree !== 0 && parent.panPoint.totalPannedInternalPoint.x !== 0 && parent.panPoint.totalPannedInternalPoint.y !== 0 && !isPrevent) {
          parent.isCircleCrop = false;
          if (parent.transform.defaultZoomFactor !== 0 && !this.isResizeSelect) {
            var isCropTab = parent.isCropTab;
            parent.isCropTab = false;
            parent.notify("transform", { prop: "resetZoom", onPropertyChange: false });
            parent.isCropTab = isCropTab;
            this.resetPanPoints();
          }
          parent.notify("freehand-draw", { prop: "updateFHDColl", onPropertyChange: false });
          parent.isCropTab = true;
          parent.isCircleCrop = false;
          if (!this.isResizeSelect) {
            parent.notify("crop", { prop: "setCurrSelPoints", onPropertyChange: false, value: { isSetDimension: true } });
          }
          parent.transform.zoomFactor = parent.transform.cropZoomFactor;
          if (isNullOrUndefined(parent.cropObj.activeObj.shape)) {
            parent.currObjType.shape = "crop-" + type;
            this.drawNewSelection(type, startX, startY, width, height);
          }
        } else {
          if (!this.isCropSelect) {
            parent.notify("crop", {
              prop: "adjustStraightenForShapes",
              onPropertyChange: false,
              value: { type: "reverse", isInitialRotated: true }
            });
            parent.notify("freehand-draw", { prop: "updateFHDColl", onPropertyChange: false });
            this.renderImage();
          } else {
            this.isCropSelect = false;
          }
          if (type === "custom") {
            parent.currObjType.shape = "";
          }
          this.drawNewSelection(type, startX, startY, width, height);
        }
      }
    };
    Draw2.prototype.drawNewSelection = function(type, startX, startY, width, height) {
      var parent = this.parent;
      var points;
      var cropShape = "crop-" + type.toLowerCase();
      if (cropShape === "crop-custom") {
        if (parent.currObjType.shape === "" || parent.currObjType.shape === "crop-custom") {
          this.drawCustomSelection("crop-custom", startX, startY, width, height);
          this.adjToStraighten();
          this.updateSelectionInsert();
          if (parent.isStraightening) {
            this.straightenActObj = extend({}, parent.activeObj, {}, true);
            this.straightenInitZoom = parent.transform.zoomFactor;
          }
        }
      } else if (cropShape === "crop-canvas") {
        parent.upperCanvas.style.display = "block";
        parent.notify("selection", { prop: "setDragCanvas", value: { bool: true } });
      } else {
        parent.currObjType.isCustomCrop = false;
        parent.currObjType.shape = cropShape;
        if (width && height) {
          points = {
            startX,
            startY,
            endX: startX + width,
            endY: startY + height,
            width,
            height
          };
        } else if (width && cropShape === "crop-circle") {
          points = {
            startX,
            startY,
            endX: startX + width,
            endY: startY + width,
            width,
            height: width
          };
        }
        parent.activeObj.shape = cropShape;
        this.updateSelectionInsert(points);
      }
    };
    Draw2.prototype.updateSelectionInsert = function(points) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var obj = { shapeSettingsObj: {} };
      parent.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj } });
      var selectionSettings = {
        type: parent.getSelectionType(obj["shapeSettingsObj"]["type"]),
        startX: obj["shapeSettingsObj"]["startX"],
        startY: obj["shapeSettingsObj"]["startY"],
        width: obj["shapeSettingsObj"]["width"],
        height: obj["shapeSettingsObj"]["height"]
      };
      var selectionChangingArgs = {
        action: "insert",
        previousSelectionSettings: selectionSettings,
        currentSelectionSettings: selectionSettings
      };
      parent.trigger("selectionChanging", selectionChangingArgs);
      parent.editCompleteArgs = selectionChangingArgs;
      parent.notify("shape", {
        prop: "updSelChangeEventArgs",
        onPropertyChange: false,
        value: { selectionSettings: selectionChangingArgs.currentSelectionSettings }
      });
      if (selectionChangingArgs.currentSelectionSettings.type === "Custom") {
        this.drawObject("duplicate", parent.activeObj, null, null, true);
      } else {
        if (actPoint.startX !== 0 || actPoint.startY !== 0 || actPoint.width !== 0 || actPoint.height !== 0) {
          points = {
            startX: actPoint.startX,
            startY: actPoint.startY,
            endX: actPoint.endX,
            endY: actPoint.endY,
            width: actPoint.width,
            height: actPoint.height
          };
        }
        this.drawObject("duplicate", null, true, points);
      }
    };
    Draw2.prototype.drawCustomSelection = function(cropShape, startX, startY, width, height) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      parent.currObjType.isCustomCrop = true;
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      parent.currObjType.shape = parent.activeObj.shape = cropShape.toLowerCase();
      if (!isNullOrUndefined(startX) && !isNullOrUndefined(startY) && !isNullOrUndefined(width) && !isNullOrUndefined(height)) {
        actPoint.startX = startX;
        actPoint.startY = startY;
        actPoint.endX = startX + width;
        actPoint.endY = startY + height;
        actPoint.width = width;
        actPoint.height = height;
      } else if (width && height) {
        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
        actPoint.width = width;
        actPoint.height = height;
        actPoint.startX = destLeft + (destWidth / 2 - width / 2);
        actPoint.startY = destTop + (destHeight / 2 - height / 2);
      } else {
        if (isNullOrUndefined(parent.transform.zoomFactor) || parent.transform.zoomFactor === 0) {
          var _b = parent.img, destLeft_1 = _b.destLeft, destTop_1 = _b.destTop, destWidth_1 = _b.destWidth, destHeight_1 = _b.destHeight;
          var lowerCanvasWidth_1 = parent.lowerCanvas.width;
          var lowerCanvasHeight_1 = parent.lowerCanvas.height;
          var activePoint_1 = actPoint;
          if (destLeft_1 >= 0 && destTop_1 >= 0) {
            activePoint_1.startX = destLeft_1;
            activePoint_1.startY = destTop_1;
            activePoint_1.endX = destLeft_1 + destWidth_1;
            activePoint_1.endY = destTop_1 + destHeight_1;
          } else if (destLeft_1 >= 0) {
            activePoint_1.startX = destLeft_1;
            activePoint_1.startY = 7.5;
            activePoint_1.endX = destLeft_1 + destWidth_1;
            activePoint_1.endY = lowerCanvasHeight_1 - 15;
          } else if (destTop_1 >= 0) {
            activePoint_1.startX = 7.5;
            activePoint_1.startY = destTop_1;
            activePoint_1.endX = lowerCanvasWidth_1 - 15;
            activePoint_1.endY = destTop_1 + destHeight_1;
          } else {
            activePoint_1.startX = 7.5;
            activePoint_1.startY = 7.5;
            activePoint_1.endX = lowerCanvasWidth_1 - 15;
            activePoint_1.endY = lowerCanvasHeight_1 - 15;
          }
        } else {
          var _c = parent.img, destLeft_2 = _c.destLeft, destTop_2 = _c.destTop, destWidth_2 = _c.destWidth, destHeight_2 = _c.destHeight;
          var lowerCanvasWidth_2 = parent.lowerCanvas.width;
          var lowerCanvasHeight_2 = parent.lowerCanvas.height;
          var activePoint_2 = actPoint;
          activePoint_2.startX = Math.max(destLeft_2 > 0 ? destLeft_2 : 7.5, destLeft_2);
          activePoint_2.startY = Math.max(destTop_2 > 0 ? destTop_2 : 7.5, destTop_2);
          activePoint_2.endX = Math.min(destLeft_2 + destWidth_2 + 15 < lowerCanvasWidth_2 ? destLeft_2 + destWidth_2 - 15 : lowerCanvasWidth_2 - 15, destLeft_2 + destWidth_2);
          activePoint_2.endY = Math.min(destTop_2 + destHeight_2 + 15 < lowerCanvasHeight_2 ? destTop_2 + destHeight_2 - 15 : lowerCanvasHeight_2 - 15, destTop_2 + destHeight_2);
        }
        var _d = parent.img, destLeft = _d.destLeft, destTop = _d.destTop, destWidth = _d.destWidth, destHeight = _d.destHeight;
        var lowerCanvasWidth = parent.lowerCanvas.clientWidth;
        var lowerCanvasHeight = parent.lowerCanvas.clientHeight;
        var activePoint = actPoint;
        activePoint.startX = Math.max(activePoint.startX, destLeft);
        activePoint.startY = Math.max(activePoint.startY, destTop);
        activePoint.endX = Math.min(activePoint.endX, destLeft + destWidth);
        activePoint.endY = Math.min(activePoint.endY, destTop + destHeight);
        if (parent.transform.straighten > 0) {
          if (this.imgCanvasPoints[0].x > activePoint.startX) {
            activePoint.startX = this.imgCanvasPoints[0].x;
          }
          if (this.imgCanvasPoints[0].y > activePoint.startY) {
            activePoint.startY = this.imgCanvasPoints[0].y;
          }
          if (this.imgCanvasPoints[2].x < activePoint.endX) {
            activePoint.endX = this.imgCanvasPoints[2].x;
          }
          if (this.imgCanvasPoints[2].y < activePoint.endY) {
            activePoint.endY = this.imgCanvasPoints[2].x;
          }
        } else if (parent.transform.straighten < 0) {
          if (this.imgCanvasPoints[3].x > activePoint.startX) {
            activePoint.startX = this.imgCanvasPoints[3].x;
          }
          if (this.imgCanvasPoints[3].y < activePoint.startY) {
            activePoint.startY = this.imgCanvasPoints[3].y;
          }
          if (this.imgCanvasPoints[1].x < activePoint.endX) {
            activePoint.endX = this.imgCanvasPoints[1].x;
          }
          if (this.imgCanvasPoints[1].y > activePoint.endY) {
            activePoint.endY = this.imgCanvasPoints[1].x;
          }
        }
        if (activePoint.startX === destLeft && destLeft + destWidth > lowerCanvasWidth) {
          activePoint.endX = lowerCanvasWidth - 15;
        }
        if (activePoint.startY === destTop && destTop + destHeight > lowerCanvasHeight) {
          activePoint.endY = lowerCanvasHeight - 15;
        }
        if (parent.activeObj.activePoint.startX > parent.activeObj.activePoint.endX) {
          var temp = parent.activeObj.activePoint.startX;
          parent.activeObj.activePoint.startX = parent.activeObj.activePoint.endX;
          parent.activeObj.activePoint.endX = temp;
        }
        if (parent.activeObj.activePoint.startY > parent.activeObj.activePoint.endY) {
          var temp = parent.activeObj.activePoint.startY;
          parent.activeObj.activePoint.startY = parent.activeObj.activePoint.endY;
          parent.activeObj.activePoint.endY = temp;
        }
        parent.activeObj = this.updateWidthHeight(parent.activeObj);
        this.updateActiveObject(actPoint, parent.activeObj);
        this.adjActObj();
      }
      this.updateSelectionInsert();
    };
    Draw2.prototype.adjToStraighten = function() {
      var parent = this.parent;
      if (parent.transform.straighten !== 0 && parent.isStraightening) {
        var actPoint = parent.activeObj.activePoint;
        actPoint.startX += 7.5;
        actPoint.startY += 7.5;
        actPoint.endX -= 7.5;
        actPoint.endY -= 7.5;
        parent.activeObj = this.updateWidthHeight(parent.activeObj);
      }
    };
    Draw2.prototype.adjActObj = function() {
      var parent = this.parent;
      if (parent.transform.straighten === 0) {
        return;
      }
      var actPoint = parent.activeObj.activePoint;
      var tempActPoint = extend({}, actPoint, {}, true);
      var count = 0;
      while (true) {
        count++;
        var object = { isIntersect: null, arr: null };
        parent.notify("draw", { prop: "updateImgCanvasPoints", onPropertyChange: false });
        parent.notify("draw", { prop: "isLinesIntersect", onPropertyChange: false, value: { obj: object } });
        if (object["arr"][0] || object["arr"][1] || object["arr"][2] || object["arr"][3] || count === 100) {
          actPoint = extend({}, tempActPoint, {}, true);
          break;
        }
        tempActPoint = extend({}, actPoint, {}, true);
        actPoint.startX -= 5;
        actPoint.endX += 5;
        actPoint.width = actPoint.endX - actPoint.startX;
        this.updateActiveObject(actPoint, parent.activeObj);
      }
    };
    Draw2.prototype.callUpdateCurrTransState = function() {
      var parent = this.parent;
      var tempObjColl = extend([], parent.objColl, [], true);
      var tempActiveObj = extend({}, parent.activeObj, {}, true);
      parent.objColl = [];
      parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      this.isRotateZoom = true;
      this.updateCurrTransState("initial");
      this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      if (parent.transform.degree === 0 && parent.rotateFlipColl.length > 0) {
        parent.img.destLeft += parent.panPoint.totalPannedPoint.x;
        parent.img.destTop += parent.panPoint.totalPannedPoint.y;
      }
      parent.img.destLeft += parent.panPoint.totalPannedInternalPoint.x;
      parent.img.destTop += parent.panPoint.totalPannedInternalPoint.y;
      var temp = this.lowerContext.filter;
      if (parent.transform.degree === 0) {
        parent.notify("transform", { prop: "setDestPointsForFlipState", onPropertyChange: false });
      }
      this.drawImage();
      this.updateCurrTransState("reverse");
      if (parent.transform.degree === 0 && parent.rotateFlipColl.length > 0) {
        parent.img.destLeft += parent.panPoint.totalPannedPoint.x;
        parent.img.destTop += parent.panPoint.totalPannedPoint.y;
      }
      this.isRotateZoom = false;
      parent.objColl = tempObjColl;
      var tempTogglePen = parent.togglePen;
      parent.togglePen = false;
      this.lowerContext.filter = "none";
      var widthObj = { penStrokeWidth: null };
      parent.notify("freehand-draw", { prop: "getPenStrokeWidth", onPropertyChange: false, value: { obj: widthObj } });
      parent.notify("shape", {
        prop: "drawAnnotations",
        onPropertyChange: false,
        value: { ctx: this.lowerContext, shape: "iterate", pen: "iterate", isPreventApply: null }
      });
      parent.notify("freehand-draw", { prop: "setPenStrokeWidth", onPropertyChange: false, value: { value: widthObj["penStrokeWidth"] } });
      parent.img.destLeft += parent.panPoint.totalPannedInternalPoint.x;
      parent.img.destTop += parent.panPoint.totalPannedInternalPoint.y;
      parent.img.destLeft -= parent.panPoint.totalPannedInternalPoint.x;
      parent.img.destTop -= parent.panPoint.totalPannedInternalPoint.y;
      parent.togglePen = tempTogglePen;
      this.lowerContext.filter = temp;
      parent.activeObj = tempActiveObj;
    };
    Draw2.prototype.resetPanPoints = function() {
      this.parent.panPoint.totalPannedPoint = { x: 0, y: 0 };
      this.parent.panPoint.totalPannedClientPoint = { x: 0, y: 0 };
      this.parent.panPoint.totalPannedInternalPoint = { x: 0, y: 0 };
    };
    Draw2.prototype.setClientTransDim = function(isPreventDimension) {
      var parent = this.parent;
      if (parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0) {
        parent.img.destLeft = (parent.lowerCanvas.clientWidth - parent.img.destHeight) / 2;
        parent.img.destTop = (parent.lowerCanvas.clientHeight - parent.img.destWidth + 1) / 2;
        var temp = parent.img.destWidth;
        parent.img.destWidth = parent.img.destHeight;
        parent.img.destHeight = temp;
      } else {
        if (isNullOrUndefined(isPreventDimension)) {
          parent.img.destLeft = (parent.lowerCanvas.clientWidth - parent.img.destWidth) / 2;
          parent.img.destTop = (parent.lowerCanvas.clientHeight - parent.img.destHeight + 1) / 2;
        }
      }
    };
    Draw2.prototype.redrawImgWithObj = function() {
      var parent = this.parent;
      var obj = { canvasFilter: parent.canvasFilter };
      this.lowerContext.filter = obj["canvasFilter"];
      if (parent.rotateFlipColl.length !== 0) {
        var totalPannedInternalPoint = extend({}, parent.panPoint.totalPannedInternalPoint, {}, true);
        var destPoints = {
          startX: parent.img.destLeft,
          startY: parent.img.destTop,
          width: parent.img.destWidth,
          height: parent.img.destHeight
        };
        this.callUpdateCurrTransState();
        parent.panPoint.totalPannedInternalPoint = totalPannedInternalPoint;
        parent.img.destLeft = destPoints.startX;
        parent.img.destTop = destPoints.startY;
        parent.img.destWidth = destPoints.width;
        parent.img.destHeight = destPoints.height;
      } else {
        this.callUpdateCurrTransState();
      }
      if (parent.isCircleCrop) {
        parent.notify("crop", {
          prop: "cropCircle",
          onPropertyChange: false,
          value: { context: this.lowerContext, isSave: null, isFlip: null }
        });
      }
    };
    Draw2.prototype.setCurrentObj = function(obj, isUndoRedo, isCircleCropped) {
      var parent = this.parent;
      var isObj = obj ? true : false;
      if (!isObj) {
        parent.cropObj.aspectWidth = parent.aspectWidth;
        parent.cropObj.aspectHeight = parent.aspectHeight;
        parent.cropObj.frame = parent.frameObj.type;
      }
      obj = obj ? obj : parent.cropObj;
      parent.transform.cropZoomFactor = obj.cropZoom;
      parent.transform.defaultZoomFactor = obj.defaultZoom;
      this.straightenInitZoom = obj.straightenZoom;
      if (!isObj) {
        parent.transform.zoomFactor = obj.cropZoom;
      } else {
        if (obj.activeObj.shape && obj.activeObj.shape.split("-")[0] === "crop") {
          parent.transform.zoomFactor = obj.cropZoom;
        } else {
          parent.transform.zoomFactor = obj.defaultZoom;
        }
      }
      parent.setProperties({ zoomSettings: { zoomFactor: obj.zoomFactor } }, true);
      parent.notify("transform", { prop: "setPreviousZoomValue", onPropertyChange: false, value: { previousZoomValue: obj.previousZoomValue } });
      parent.panPoint.totalPannedPoint = extend({}, obj.totalPannedPoint, {}, true);
      parent.panPoint.totalPannedClientPoint = extend({}, obj.totalPannedClientPoint, {}, true);
      parent.panPoint.totalPannedInternalPoint = extend({}, obj.totalPannedInternalPoint, {}, true);
      var point = extend({}, obj.tempFlipPanPoint, {}, true);
      parent.notify("crop", { prop: "setTempFlipPanPoint", onPropertyChange: false, value: { point } });
      parent.rotateFlipColl = extend([], obj.rotateFlipColl, [], true);
      parent.transform.degree = obj.degree;
      parent.frameObj.type = obj.frame;
      parent.transform.currFlipState = obj.currFlipState;
      parent.notify("filter", { prop: "setAdjustmentLevel", onPropertyChange: false, value: { adjustmentLevel: obj.adjustmentLevel } });
      parent.notify("filter", { prop: "setTempAdjVal" });
      parent.currentFilter = obj.currentFilter;
      parent.notify("filter", { prop: "setTempFilVal" });
      if (parent.transform.straighten !== obj.straighten || isUndoRedo) {
        parent.transform.straighten = obj.straighten;
        parent.straightenBaseImageCanvas();
      }
      parent.img = {
        destLeft: obj.destPoints.startX,
        destTop: obj.destPoints.startY,
        destWidth: obj.destPoints.width,
        destHeight: obj.destPoints.height,
        srcLeft: obj.srcPoints.startX,
        srcTop: obj.srcPoints.startY,
        srcWidth: obj.srcPoints.width,
        srcHeight: obj.srcPoints.height
      };
      parent.aspectWidth = obj.aspectWidth;
      parent.aspectHeight = obj.aspectHeight;
      if (obj.afterCropActions) {
        parent.afterCropActions = obj.afterCropActions;
      }
      this.lowerContext.filter = obj.filter;
      parent.notify("filter", { prop: "setBrightnessAdjusted", onPropertyChange: false, value: { isBrightnessAdjusted: obj.isBrightAdjust } });
      parent.notify("draw", { prop: "imageBackgroundColor", onPropertyChange: false, value: { color: obj.bgColor } });
      var isCircleCrop = parent.isCircleCrop;
      var currSelectionPoint;
      if (isNullOrUndefined(parent.currSelectionPoint)) {
        currSelectionPoint = null;
      } else {
        currSelectionPoint = extend({}, parent.currSelectionPoint, {}, true);
        parent.currSelectionPoint = null;
      }
      parent.isCircleCrop = false;
      if (isCircleCropped) {
        parent.frameObj.type = "none";
      }
      this.drawCropSelectionImage(obj, false);
      if (parent.transform.degree !== 0) {
        if (parent.transform.currFlipState === "") {
          parent.notify("transform", {
            prop: "rotatePan",
            onPropertyChange: false,
            value: { isCropSelection: null, isDefaultZoom: null }
          });
        } else {
          parent.notify("transform", { prop: "drawPannedImage", value: { xDiff: 0, yDiff: 0 } });
        }
        parent.img.destLeft = obj.destPoints.startX;
        parent.img.destTop = obj.destPoints.startY;
        parent.panPoint.totalPannedClientPoint = extend({}, obj.totalPannedClientPoint, {}, true);
        parent.panPoint.totalPannedInternalPoint = extend({}, obj.totalPannedInternalPoint, {}, true);
      }
      parent.activeObj = extend({}, obj.activeObj, {}, true);
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      if (parent.activeObj.activePoint.width !== 0 && parent.activeObj.activePoint.height !== 0) {
        this.drawObject("duplicate", null, null, null, true);
      }
      var activeObj = extend({}, obj.activeObj, {}, true);
      var isAfterCropAction = false;
      if (parent.afterCropActions.length > 0) {
        var object = { collection: parent.afterCropActions };
        parent.notify("shape", {
          prop: "alignRotateFlipColl",
          onPropertyChange: false,
          value: { collection: parent.afterCropActions, isRotateFlipCollection: null, obj: object }
        });
        parent.afterCropActions = object["collection"];
      }
      var afterCropActions = extend([], parent.afterCropActions, [], true);
      if (!isObj && afterCropActions.length > 0) {
        isAfterCropAction = true;
        for (var i = 0, len = afterCropActions.length; i < len; i++) {
          if (afterCropActions[i] === "horizontalflip" || afterCropActions[i] === "verticalflip") {
            parent.activeObj = extend({}, currSelectionPoint, {}, true);
            this.rotatedFlipCropSel = true;
          }
          parent.notify("transform", { prop: "updateTransform", onPropertyChange: false, value: { text: afterCropActions[i] } });
        }
        activeObj = extend({}, parent.activeObj, {}, true);
        this.resetPanPoints();
        parent.activeObj = activeObj;
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        if (parent.activeObj.activePoint.width !== 0 && parent.activeObj.activePoint.height !== 0) {
          this.drawObject("duplicate", null, null, null, true);
        }
        if (obj.degree !== parent.transform.degree) {
          parent.transform.cropZoomFactor = null;
          parent.transform.zoomFactor = 0;
        }
        parent.notify("freehand-draw", { prop: "updateFHDColl", onPropertyChange: false });
        if (this.rotatedFlipCropSel) {
          this.rotatedFlipCropSel = false;
        }
      }
      parent.afterCropActions = afterCropActions;
      if (!this.isCancelAction && !isAfterCropAction) {
        parent.notify("freehand-draw", { prop: "updateFHDColl", onPropertyChange: false });
        parent.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
        });
        parent.img.destLeft = obj.destPoints.startX;
        parent.img.destTop = obj.destPoints.startY;
      }
      parent.activeObj = activeObj;
      parent.isCircleCrop = isCircleCrop;
      if (isNullOrUndefined(currSelectionPoint)) {
        parent.currSelectionPoint = null;
      } else {
        parent.currSelectionPoint = extend({}, currSelectionPoint, {}, true);
        if (parent.currSelectionPoint && isNullOrUndefined(parent.currSelectionPoint.shape)) {
          parent.currSelectionPoint = null;
        }
      }
    };
    Draw2.prototype.drawCropSelectionImage = function(obj, isObj) {
      var parent = this.parent;
      var temp = this.lowerContext.filter;
      parent.clearContext(this.lowerContext);
      parent.clearContext(this.upperContext);
      this.lowerContext.setTransform(1, 0, 0, 1, 0, 0);
      if (isObj) {
        this.updateCurrTransState("initial");
      } else {
        this.setTransformColl(this.lowerContext, "initial");
      }
      parent.notify("transform", { prop: "setDestPointsForFlipState", onPropertyChange: false });
      this.drawImage();
      if (isObj) {
        this.updateCurrTransState("reverse");
      } else {
        this.setTransformColl(this.lowerContext, "reverse");
      }
      parent.img.destLeft = parent.cropObj.destPoints.startX;
      parent.img.destTop = parent.cropObj.destPoints.startY;
      var activeObj = extend({}, obj.activeObj, {}, true);
      this.lowerContext.filter = "none";
      parent.img = {
        destLeft: obj.destPoints.startX,
        destTop: obj.destPoints.startY,
        destWidth: obj.destPoints.width,
        destHeight: obj.destPoints.height,
        srcLeft: obj.srcPoints.startX,
        srcTop: obj.srcPoints.startY,
        srcWidth: obj.srcPoints.width,
        srcHeight: obj.srcPoints.height
      };
      if (obj.activeObj.activePoint.width !== 0 && obj.activeObj.activePoint.height !== 0) {
        var destPoints = {
          startX: parent.img.destLeft,
          startY: parent.img.destTop,
          width: parent.img.destWidth,
          height: parent.img.destHeight
        };
        parent.img.destLeft = obj.activeObj.activePoint.startX;
        parent.img.destTop = obj.activeObj.activePoint.startY;
        parent.img.destWidth = obj.activeObj.activePoint.width;
        parent.img.destHeight = obj.activeObj.activePoint.height;
        parent.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
        });
        parent.img.destLeft = destPoints.startX;
        parent.img.destTop = destPoints.startY;
        parent.img.destWidth = destPoints.width;
        parent.img.destHeight = destPoints.height;
      }
      parent.activeObj = activeObj;
      this.lowerContext.filter = temp;
    };
    Draw2.prototype.performPointZoom = function(x, y, type, isResize, value) {
      var parent = this.parent;
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      var isCropSelection = false;
      if (parent.activeObj.shape && parent.activeObj.shape.indexOf("crop-") > -1) {
        isCropSelection = true;
      }
      if (parent.element.querySelector(".e-contextual-toolbar-wrapper") && !isCropSelection) {
        if (!parent.element.querySelector(".e-contextual-toolbar-wrapper").classList.contains("e-hide")) {
          parent.okBtn();
          parent.element.querySelector(".e-contextual-toolbar-wrapper").classList.add("e-hide");
        }
      }
      var ratioX = (x - destLeft) / destWidth;
      var ratioY = (y - destTop) / destHeight;
      var isUndoRedo = parent.isUndoRedo;
      parent.isUndoRedo = true;
      parent.setProperties({ zoomSettings: { zoomPoint: { x, y } } }, true);
      var zoomValue = value ? value : type === "zoomIn" ? 0.1 : -0.1;
      parent.notify("transform", {
        prop: "zoomAction",
        onPropertyChange: false,
        value: { zoomFactor: zoomValue, zoomPoint: null, isResize }
      });
      parent.isUndoRedo = isUndoRedo;
      this.panToPoint(x, y, ratioX, ratioY);
    };
    Draw2.prototype.panToPoint = function(x, y, ratioX, ratioY) {
      var parent = this.parent;
      if (parent.transform.zoomFactor > 0) {
        var destLeft = parent.img.destLeft;
        var destTop = parent.img.destTop;
        var activeObj = extend({}, parent.activeObj, {}, true);
        if (parent.transform.degree === 0) {
          parent.img.destLeft = x - ratioX * parent.img.destWidth;
          parent.img.destTop = y - ratioY * parent.img.destHeight;
          this.drawZoomPanImage(parent.img.destLeft - destLeft, parent.img.destTop - destTop);
        } else {
          var isCropTab = parent.isCropTab;
          parent.isCropTab = true;
          var objColl = extend([], parent.objColl, [], true);
          var pointColl = extend([], parent.pointColl, [], true);
          var straightenObj = { straightenPoint: null };
          parent.notify("freehand-draw", {
            prop: "getStraightenPoint",
            onPropertyChange: false,
            value: { obj: straightenObj }
          });
          parent.objColl = [];
          parent.pointColl = [];
          parent.freehandCounter = 0;
          parent.notify("freehand-draw", {
            prop: "setStraightenPoint",
            onPropertyChange: false,
            value: { x: null, y: null, ratioX: null, ratioY: null }
          });
          var object = { selPointColl: null };
          parent.notify("freehand-draw", {
            prop: "getSelPointColl",
            onPropertyChange: false,
            value: { obj: object }
          });
          var cropSelPointColl = object["selPointColl"];
          parent.notify("freehand-draw", {
            prop: "setSelPointColl",
            onPropertyChange: false,
            value: { obj: { selPointColl: [] } }
          });
          parent.panPoint.currentPannedPoint = {
            x: x - ratioX * parent.img.destWidth - destLeft,
            y: y - ratioY * parent.img.destHeight - destTop
          };
          parent.notify("transform", {
            prop: "rotatePan",
            onPropertyChange: false,
            value: { isCropSelection: null, isDefaultZoom: null }
          });
          parent.isCropTab = isCropTab;
          parent.objColl = objColl;
          parent.pointColl = pointColl;
          parent.freehandCounter = parent.pointColl.length;
          if (straightenObj["straightenPoint"]["x"] && straightenObj["straightenPoint"]["y"]) {
            parent.notify("freehand-draw", {
              prop: "setStraightenPoint",
              onPropertyChange: false,
              value: {
                x: straightenObj["straightenPoint"]["x"],
                y: straightenObj["straightenPoint"]["y"],
                ratioX: straightenObj["straightenPoint"]["ratioX"],
                ratioY: straightenObj["straightenPoint"]["ratioY"]
              }
            });
          }
          parent.notify("freehand-draw", {
            prop: "setSelPointColl",
            onPropertyChange: false,
            value: { obj: { selPointColl: cropSelPointColl } }
          });
          parent.notify("shape", {
            prop: "drawAnnotations",
            onPropertyChange: false,
            value: {
              ctx: this.lowerContext,
              shape: "pan",
              pen: "pan",
              x: parent.panPoint.currentPannedPoint.x,
              y: parent.panPoint.currentPannedPoint.y,
              panRegion: ""
            }
          });
        }
        this.adjustPanning(activeObj);
        var isActObj = false;
        for (var i = 0; i < parent.objColl.length; i++) {
          if (JSON.stringify(activeObj.activePoint) === JSON.stringify(parent.objColl[i].activePoint)) {
            isActObj = true;
            break;
          }
        }
        if (!isActObj) {
          parent.activeObj = activeObj;
        }
        if (parent.activeObj.activePoint.width !== 0 && parent.activeObj.activePoint.height !== 0) {
          this.drawObject("duplicate", null, null, null, true);
        }
      }
    };
    Draw2.prototype.adjustPanning = function(activeObj) {
      var parent = this.parent;
      var _a = activeObj.activePoint, startX = _a.startX, startY = _a.startY, width = _a.width, height = _a.height;
      if (width !== 0 && height !== 0) {
        var _b = parent.img, destLeft = _b.destLeft, destTop = _b.destTop, destWidth = _b.destWidth, destHeight = _b.destHeight;
        var point = { x: 0, y: 0 };
        if (destLeft > startX) {
          point.x = destLeft - startX;
        } else if (destLeft + destWidth < startX + width) {
          point.x = destLeft + destWidth - (startX + width);
        }
        if (destTop > startY) {
          point.y = destTop - startY;
        } else if (destTop + destHeight < startY + height) {
          point.y = destTop + destHeight - (startY + height);
        }
        if (parent.transform.degree === 0) {
          parent.img.destLeft -= point.x;
          parent.img.destTop -= point.y;
          this.drawZoomPanImage(parent.img.destLeft - destLeft, parent.img.destTop - destTop);
        } else {
          var isCropTab = parent.isCropTab;
          parent.isCropTab = true;
          var objColl = extend([], parent.objColl, [], true);
          var pointColl = extend([], parent.pointColl, [], true);
          parent.objColl = [];
          parent.pointColl = [];
          parent.freehandCounter = 0;
          var object = { selPointColl: null };
          parent.notify("freehand-draw", {
            prop: "getSelPointColl",
            onPropertyChange: false,
            value: { obj: object }
          });
          var cropSelPointColl = object["selPointColl"];
          parent.notify("freehand-draw", {
            prop: "setSelPointColl",
            onPropertyChange: false,
            value: { obj: { selPointColl: [] } }
          });
          parent.img.destLeft -= point.x;
          parent.img.destTop -= point.y;
          parent.panPoint.currentPannedPoint = { x: parent.img.destLeft - destLeft, y: parent.img.destTop - destTop };
          parent.notify("transform", {
            prop: "rotatePan",
            onPropertyChange: false,
            value: { isCropSelection: null, isDefaultZoom: null }
          });
          parent.isCropTab = isCropTab;
          parent.objColl = objColl;
          parent.pointColl = pointColl;
          parent.freehandCounter = parent.pointColl.length;
          parent.notify("freehand-draw", {
            prop: "setSelPointColl",
            onPropertyChange: false,
            value: { obj: { selPointColl: cropSelPointColl } }
          });
          parent.notify("shape", {
            prop: "drawAnnotations",
            onPropertyChange: false,
            value: {
              ctx: this.lowerContext,
              shape: "pan",
              pen: "pan",
              x: parent.panPoint.currentPannedPoint.x,
              y: parent.panPoint.currentPannedPoint.y,
              panRegion: ""
            }
          });
        }
      }
    };
    Draw2.prototype.panToSel = function() {
      var parent = this.parent;
      var activeObj = extend({}, parent.activeObj, {}, true);
      var _a = activeObj.activePoint, startX = _a.startX, startY = _a.startY, width = _a.width, height = _a.height;
      this.allowRedactStraighten = true;
      var straightenObj = { straightenPoint: null };
      parent.notify("freehand-draw", {
        prop: "getStraightenPoint",
        onPropertyChange: false,
        value: { obj: straightenObj }
      });
      if (straightenObj["straightenPoint"]["x"] && straightenObj["straightenPoint"]["y"]) {
        var panX = startX + width / 2 - straightenObj["straightenPoint"]["x"];
        var panY = startY + height / 2 - straightenObj["straightenPoint"]["y"];
        if (parent.transform.degree === 0) {
          parent.img.destLeft += panX;
          parent.img.destTop += panY;
          parent.notify("transform", { prop: "drawPannImage", value: { point: { x: panX, y: panY } } });
        } else {
          parent.panPoint.currentPannedPoint = { x: panX, y: panY };
          parent.notify("transform", { prop: "drawPannedImage", value: { xDiff: panX, yDiff: panY } });
          parent.panPoint.currentPannedPoint = { x: 0, y: 0 };
          parent.notify("transform", { prop: "setTempPanMove", value: { point: null } });
        }
        parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate", obj: activeObj } });
        var _b = parent.img, destLeft_3 = _b.destLeft, destTop_3 = _b.destTop, destWidth_3 = _b.destWidth, destHeight_3 = _b.destHeight;
        var points = this.imgCanvasPoints;
        points.forEach(function(point) {
          point.x = point.ratioX * destWidth_3 + destLeft_3;
          point.y = point.ratioY * destHeight_3 + destTop_3;
        });
        this.imgCanvasPoints = points;
        var count = 0;
        if (parent.transform.straighten === 3 && !this.preventStraightening) {
          this.preventStraightening = true;
          var temp = parent.prevStraightenedDegree;
          parent.prevStraightenedDegree = parent.transform.straighten;
          parent.setStraighten(0);
          parent.setStraighten(3);
          parent.prevStraightenedDegree = temp;
          this.preventStraightening = false;
        }
        while (this.isLinesIntersect() && parent.transform.straighten !== 0 && parent.transform.straighten !== 360 && count < 100) {
          count++;
          this.performPointZoom(parent.activeObj.activePoint.startX + parent.activeObj.activePoint.width / 2, parent.activeObj.activePoint.startY + parent.activeObj.activePoint.height / 2, "zoomIn", false, 0.025);
          this.updateImgCanvasPoints();
        }
      }
    };
    Draw2.prototype.drawZoomPanImage = function(x, y) {
      var parent = this.parent;
      parent.notify("shape", {
        prop: "drawAnnotations",
        onPropertyChange: false,
        value: { ctx: this.lowerContext, shape: "pan", pen: "pan", x, y, panRegion: "" }
      });
      this.renderImage(true);
      var obj = { width: 0, height: 0 };
      parent.notify("transform", {
        prop: "calcMaxDimension",
        onPropertyChange: false,
        value: { width: parent.img.srcWidth, height: parent.img.srcHeight, obj, isImgShape: null }
      });
      var maxDimension = obj;
      maxDimension.width += maxDimension.width * parent.transform.zoomFactor;
      maxDimension.height += maxDimension.height * parent.transform.zoomFactor;
      parent.panPoint.totalPannedPoint.x += x;
      parent.panPoint.totalPannedPoint.y += y;
      parent.notify("crop", { prop: "setTempFlipPanPoint", onPropertyChange: false, value: { point: { x: 0, y: 0 } } });
    };
    Draw2.prototype.openNewImage = function() {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      var inMemoryContext = parent.inMemoryCanvas.getContext("2d");
      showSpinner(parent.element);
      parent.element.style.opacity = "0.5";
      var toolbar = (undefined).querySelector("#" + id + "_currPos");
      if (toolbar) {
        toolbar.style.display = "none";
      }
      var obj = { defToolbarItems: null };
      parent.notify("toolbar", { prop: "getDefToolbarItems", value: { obj } });
      if (obj["defToolbarItems"] && obj["defToolbarItems"].length === 0 && isNullOrUndefined((undefined).getElementById(id + "_toolbar")) && parent.element.querySelector("#" + id + "_toolbarArea")) {
        var height = parent.element.querySelector("#" + id + "_toolbarArea").clientHeight;
        parent.notify("toolbar", { prop: "setToolbarHeight", value: { height } });
      }
      parent.reset();
      parent.update();
      parent.transform.degree = 0;
      parent.transform.zoomFactor = 0;
      parent.isImageLoaded = false;
      parent.currSelectionPoint = null;
      var type = typeof this.openURL;
      if (type === "string") {
        var fileName = this.openURL.split(".");
        if (fileName.length > 1) {
          fileName = fileName[fileName.length - 2].split("/");
          this.fileName = fileName[fileName.length - 1];
        } else {
          this.fileName = "ImageEditor";
        }
        this.fileType = this.getFileExtensionFromURL(this.openURL);
        if (this.fileType) {
          this.fileType = parent.toPascalCase(this.fileType);
          var fileType = this.fileType.toLowerCase();
          if (fileType === "jpg" || fileType === "jpeg") {
            this.fileType = "Jpeg";
            fileType = "jpeg";
          }
          if (fileType !== "jpeg" && fileType !== "png" && fileType !== "svg" && fileType !== "webp") {
            this.fileType = null;
          }
        }
        this.imageOnLoad(this.openURL);
        if (typeof this.openURL !== "string" || this.openURL.indexOf("localhost") === -1) {
          this.getImageSizeFromURL(this.openURL.toString(), function(imageSizeMB) {
            if (imageSizeMB !== null) {
              _this.parent.notify("toolbar", { prop: "setInitialSize", value: { value: +imageSizeMB } });
            }
          });
        }
      } else {
        this.fileName = "ImageEditor";
        this.fileType = null;
        parent.lowerCanvas = (undefined).querySelector("#" + id + "_lowerCanvas");
        parent.upperCanvas = (undefined).querySelector("#" + id + "_upperCanvas");
        this.lowerContext = parent.lowerCanvas.getContext("2d");
        this.upperContext = parent.upperCanvas.getContext("2d");
        parent.clearContext(this.lowerContext);
        parent.clearContext(this.upperContext);
        parent.clearContext(inMemoryContext);
        parent.inMemoryCanvas.width = this.openURL.width;
        parent.inMemoryCanvas.height = this.openURL.height;
        inMemoryContext.putImageData(this.openURL, 0, 0);
        parent.baseImg.src = parent.inMemoryCanvas.toDataURL();
      }
    };
    Draw2.prototype.getImageSizeFromURL = function(imageUrl, callback) {
      return __awaiter(this, undefined, undefined, function() {
        var response, contentLength, imageSizeMB, ex_1;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              _a.trys.push([0, 2, , 3]);
              return [4, fetch(imageUrl, { method: "HEAD" })];
            case 1:
              response = _a.sent();
              contentLength = parseInt(response.headers.get("content-length") || "0", 10);
              imageSizeMB = contentLength;
              callback(imageSizeMB);
              return [3, 3];
            case 2:
              ex_1 = _a.sent();
              console.log(ex_1.message);
              return [3, 3];
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Draw2.prototype.dlgBtnClick = function() {
      this.parent.export();
      this.applyDialogOption();
    };
    Draw2.prototype.dlgCloseBtnClick = function() {
      this.applyDialogOption();
    };
    Draw2.prototype.applyDialogOption = function() {
      var parent = this.parent;
      if (this.isFileChanged) {
        parent.isImageLoaded = this.isFileChanged = false;
        parent.reset();
        this.checkToolbarTemplate(this.inputElem, this.openURL);
      } else {
        this.reset();
        this.openNewImage();
      }
      getComponent((undefined).getElementById(parent.element.id + "_dialog"), "dialog").destroy();
      this.isImageEdited = false;
    };
    Draw2.prototype.showDialogPopup = function() {
      var parent = this.parent;
      var headerObj = { key: "ConfirmDialogHeader" };
      parent.notify("toolbar", { prop: "getLocaleText", onPropertyChange: false, value: { obj: headerObj } });
      var contentObj = { key: "ConfirmDialogContent" };
      parent.notify("toolbar", { prop: "getLocaleText", onPropertyChange: false, value: { obj: contentObj } });
      var yesObj = { key: "Yes" };
      parent.notify("toolbar", { prop: "getLocaleText", onPropertyChange: false, value: { obj: yesObj } });
      var noObj = { key: "No" };
      parent.notify("toolbar", { prop: "getLocaleText", onPropertyChange: false, value: { obj: noObj } });
      parent.element.querySelector("#" + parent.element.id + "_dialog").style.display = "block";
      var dialog = new Dialog({
        header: headerObj["value"],
        closeOnEscape: true,
        content: "<span>" + contentObj["value"] + "</span>",
        target: (undefined).getElementById("target"),
        width: "285px",
        isModal: true,
        animationSettings: { effect: "Zoom" },
        close: this.dlgCloseBtnClick.bind(this),
        buttons: [
          {
            click: this.dlgCloseBtnClick.bind(this),
            buttonModel: { content: noObj["value"], iconCss: "e-icons e-close" }
          },
          {
            click: this.dlgBtnClick.bind(this),
            buttonModel: { content: yesObj["value"], isPrimary: true, iconCss: "e-icons e-check" }
          }
        ]
      });
      dialog.appendTo("#" + parent.element.id + "_dialog");
    };
    Draw2.prototype.restoreOldImage = function() {
      var _this = this;
      var parent = this.parent;
      var dropArea = (undefined).getElementById(this.parent.element.id + "_dropArea");
      var extension = parent.getExtensionArray();
      var openURLType = typeof this.openURL;
      if (openURLType !== "string") {
        this.openImageData(dropArea);
        return;
      }
      var fileType = this.getFileExtensionFromURL(this.openURL);
      if (fileType) {
        fileType = fileType.toLowerCase();
        fileType = fileType === "jpg" || fileType === "jpeg" ? "jpeg" : fileType;
      }
      var isAllowedFileType = (fileType ? extension.indexOf(fileType) > -1 || fileType === "jpeg" && (parent.uploadSettings.allowedExtensions.indexOf("jpg") > -1 || parent.uploadSettings.allowedExtensions.indexOf("jpeg") > -1) : false) || this.isNullExtension;
      if (this.openURL.indexOf("data:image/") > -1 && this.openURL.indexOf("base64") > -1 || this.openURL.indexOf("blob") > -1) {
        this.openImageData(dropArea, true);
      } else if (parent.uploadSettings.minFileSize || parent.uploadSettings.maxFileSize) {
        this.getImageSizeFromURL(this.openURL.toString(), function(imageSizeMB) {
          var isInvalidSize = parent.uploadSettings.minFileSize && imageSizeMB < parent.uploadSettings.minFileSize || parent.uploadSettings.maxFileSize && imageSizeMB > parent.uploadSettings.maxFileSize;
          _this.handleFileSize(!isAllowedFileType || isInvalidSize, dropArea, !isAllowedFileType);
        });
      } else {
        this.handleFileSize(!isAllowedFileType, dropArea, !isAllowedFileType);
      }
    };
    Draw2.prototype.handleFileSize = function(isError2, dropArea, fileTypeError) {
      var parent = this.parent;
      if (isError2) {
        this.errorLoading();
        parent.showDialogPopup("unsupported", fileTypeError);
        if (dropArea && !parent.isImageLoaded) {
          dropArea.style.display = "block";
        }
      } else {
        if (dropArea) {
          dropArea.style.display = "none";
        }
        if (this.parent.isImageLoaded) {
          this.reset();
        }
        this.openNewImage();
      }
    };
    Draw2.prototype.openImageData = function(dropArea, isBase64) {
      var parent = this.parent;
      var proxy = this;
      var canvas = parent.createElement("canvas");
      var ctx = canvas.getContext("2d");
      if (!parent.uploadSettings.minFileSize && !parent.uploadSettings.maxFileSize) {
        this.handleFileSize(false, dropArea, false);
        return;
      }
      if (isBase64) {
        var img_1 = new Image();
        img_1.src = this.openURL;
        img_1.onload = function() {
          ctx.canvas.width = img_1.width;
          ctx.canvas.height = img_1.height;
          ctx.drawImage(img_1, 0, 0);
          proxy.getImageSize(canvas, dropArea);
        };
      } else {
        canvas.width = this.openURL.width;
        canvas.height = this.openURL.height;
        ctx.putImageData(this.openURL, 0, 0);
        this.getImageSize(canvas, dropArea);
      }
    };
    Draw2.prototype.getImageSize = function(canvas, dropArea) {
      var parent = this.parent;
      canvas.toBlob(function(blob) {
        if (parent.uploadSettings.minFileSize && blob.size < parent.uploadSettings.minFileSize || parent.uploadSettings.maxFileSize && blob.size > parent.uploadSettings.maxFileSize) {
          this.handleFileSize(true, dropArea, false);
        } else {
          this.handleFileSize(false, dropArea, false);
        }
      }.bind(this), "image/jpeg", 1);
    };
    Draw2.prototype.open = function(data) {
      if (!this.parent.disabled) {
        this.openURL = data;
        this.restoreOldImage();
      }
    };
    Draw2.prototype.getInitialLoaded = function(object) {
      object["isInitialLoaded"] = this.isInitialLoading;
    };
    Draw2.prototype.getFileExtensionFromURL = function(url) {
      var lastDotIndex = url.lastIndexOf(".");
      if (lastDotIndex !== -1) {
        return url.slice(lastDotIndex + 1).toLowerCase();
      } else if (url.indexOf("base64") !== -1) {
        return url.slice(url.indexOf("/") + 1, url.indexOf(";")).toLowerCase();
      }
      return null;
    };
    Draw2.prototype.fileSelect = function(inputElement, args) {
      var parent = this.parent;
      var dropArea = (undefined).getElementById(parent.element.id + "_dropArea");
      if (dropArea) {
        dropArea.style.display = "none";
      }
      if (!parent.disabled) {
        var filesData = undefined;
        var fileData = undefined;
        if (args.target) {
          filesData = args.target.files[0];
          fileData = filesData;
        } else {
          filesData = fileData = args.filesData[0].rawFile;
        }
        var fileExtension = undefined;
        if (fileData.name) {
          var fileExtensionArray = fileData.name.split(".");
          fileExtension = fileExtensionArray[fileExtensionArray.length - 1].toLowerCase();
        }
        var extension = parent.getExtensionArray();
        var isJPG = (fileExtension === "jpg" || fileExtension === "jpeg") && (parent.uploadSettings.allowedExtensions.indexOf("jpg") > -1 || parent.uploadSettings.allowedExtensions.indexOf("jpeg") > -1);
        if (fileExtension && (extension.indexOf(fileExtension) === -1 && !isJPG) || (parent.uploadSettings.minFileSize && fileData.size < parent.uploadSettings.minFileSize || parent.uploadSettings.maxFileSize && fileData.size > parent.uploadSettings.maxFileSize)) {
          this.errorLoading();
          return;
        }
        showSpinner(parent.element);
        parent.element.style.opacity = "0.5";
        this.inputElem = inputElement;
        fileExtension = fileData.name && fileData.name.split(".")[1];
        if (fileExtension) {
          var fileType = parent.toPascalCase(fileExtension);
          if (fileType === "JPG" || fileType === "Jpg") {
            this.fileType = "Jpeg";
          } else {
            this.fileType = fileType;
          }
        } else {
          this.fileType = null;
        }
        var URL_1 = (undefined).URL;
        var url = URL_1.createObjectURL(filesData);
        this.openURL = url;
        if (parent.isImageLoaded && !parent.isChangesSaved && (this.isImageEdited || parent.pointColl.length > 0 || parent.objColl.length > 0)) {
          this.isFileChanged = true;
          this.showDialogPopup();
        } else {
          this.checkToolbarTemplate(inputElement, url);
        }
      }
    };
    Draw2.prototype.checkToolbarTemplate = function(inputElement, url) {
      var parent = this.parent;
      if (isNullOrUndefined(parent.toolbarTemplate)) {
        parent.reset();
        parent.update();
      }
      this.fileName = inputElement.value.split("\\")[inputElement.value.split("\\").length - 1];
      this.fileName = this.fileName.split(".")[0];
      this.imageOnLoad(url.toString());
      inputElement.value = "";
    };
    Draw2.prototype.moveToSelectionRange = function(type, activeObj) {
      var parent = this.parent;
      if (parent.activeObj.shape) {
        var isRotated = false;
        for (var i = 0, len = parent.rotateFlipColl.length; i < len; i++) {
          var degree = parent.rotateFlipColl[i];
          if (degree === 90 || degree === -90) {
            isRotated = true;
            break;
          }
        }
        if (isRotated) {
          if (parent.transform.degree === 0) {
            return;
          }
          var zoomFactor = parent.transform.zoomFactor;
          parent.objColl.push(parent.activeObj);
          parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
          var currObj = parent.objColl[parent.objColl.length - 1];
          if (type === "rotateleft" || type === "rotateright") {
            if (parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0) {
              if (currObj.activePoint.width < activeObj.activePoint.height) {
                for (var i = 2; i < parent.zoomSettings.maxZoomFactor; i++) {
                  if (currObj.activePoint.width >= activeObj.activePoint.height || this.isSelectionBiggerThanCanvas(currObj) || this.isSelectionOutsideCanvas(currObj)) {
                    if (!isNullOrUndefined(zoomFactor)) {
                      parent.notify("transform", {
                        prop: "zoomAction",
                        onPropertyChange: false,
                        value: { zoomFactor: -0.1, zoomPoint: null },
                        isResize: null
                      });
                    }
                    break;
                  }
                  zoomFactor += 0.1;
                  parent.notify("transform", {
                    prop: "zoomAction",
                    onPropertyChange: false,
                    value: { zoomFactor, zoomPoint: null },
                    isResize: null
                  });
                }
              } else {
                for (var i = 2; i < parent.zoomSettings.maxZoomFactor; i++) {
                  if (currObj.activePoint.width >= activeObj.activePoint.height || this.isSelectionBiggerThanCanvas(currObj) || this.isSelectionOutsideCanvas(currObj)) {
                    if (!isNullOrUndefined(zoomFactor)) {
                      parent.notify("transform", {
                        prop: "zoomAction",
                        onPropertyChange: false,
                        value: { zoomFactor: 0.1, zoomPoint: null, isResize: null }
                      });
                    }
                    break;
                  }
                  zoomFactor -= 0.1;
                  parent.notify("transform", {
                    prop: "zoomAction",
                    onPropertyChange: false,
                    value: { zoomFactor, zoomPoint: null },
                    isResize: null
                  });
                }
              }
            } else {
              if (currObj.activePoint.height < activeObj.activePoint.width) {
                for (var i = 2; i < parent.zoomSettings.maxZoomFactor; i++) {
                  if (currObj.activePoint.height >= activeObj.activePoint.width || this.isSelectionBiggerThanCanvas(currObj) || this.isSelectionOutsideCanvas(currObj)) {
                    if (!isNullOrUndefined(zoomFactor)) {
                      parent.notify("transform", {
                        prop: "zoomAction",
                        onPropertyChange: false,
                        value: { zoomFactor: -0.1, zoomPoint: null },
                        isResize: null
                      });
                    }
                    break;
                  }
                  zoomFactor += 0.1;
                  parent.notify("transform", {
                    prop: "zoomAction",
                    onPropertyChange: false,
                    value: { zoomFactor, zoomPoint: null },
                    isResize: null
                  });
                }
              } else {
                for (var i = 2; i < parent.zoomSettings.maxZoomFactor; i++) {
                  if (currObj.activePoint.height >= activeObj.activePoint.width || this.isSelectionBiggerThanCanvas(currObj) || this.isSelectionOutsideCanvas(currObj)) {
                    if (!isNullOrUndefined(zoomFactor)) {
                      parent.notify("transform", {
                        prop: "zoomAction",
                        onPropertyChange: false,
                        value: { zoomFactor: 0.1, zoomPoint: null },
                        isResize: null
                      });
                    }
                    break;
                  }
                  zoomFactor -= 0.1;
                  parent.notify("transform", {
                    prop: "zoomAction",
                    onPropertyChange: false,
                    value: { zoomFactor, zoomPoint: null },
                    isResize: null
                  });
                }
              }
            }
          }
          var panX = parent.lowerCanvas.clientWidth / 2 - (currObj.activePoint.startX + currObj.activePoint.width / 2);
          var panY = (parent.lowerCanvas.clientHeight + 1) / 2 - (currObj.activePoint.startY + currObj.activePoint.height / 2);
          if (isNullOrUndefined(parent.activeObj.shape)) {
            parent.activeObj = extend({}, activeObj, {}, true);
          }
          if (parent.transform.degree === 0) {
            parent.img.destLeft += panX;
            parent.img.destTop += panY;
            parent.notify("transform", { prop: "drawPannImage", value: { point: { x: panX, y: panY } } });
          } else {
            parent.panPoint.currentPannedPoint = { x: panX, y: panY };
            parent.notify("transform", { prop: "drawPannedImage", value: { xDiff: panX, yDiff: panY } });
            parent.panPoint.currentPannedPoint = { x: 0, y: 0 };
          }
          parent.notify("transform", {
            prop: "setTempPanMove",
            onPropertyChange: false,
            value: { point: null }
          });
          parent.activeObj = extend({}, parent.objColl[parent.objColl.length - 1]);
          parent.objColl.pop();
          parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate", obj: parent.activeObj } });
        }
      }
    };
    Draw2.prototype.isSelectionBiggerThanCanvas = function(obj) {
      var isBigger = false;
      var parent = this.parent;
      var _a = obj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
      var _b = parent.img, destLeft = _b.destLeft, destTop = _b.destTop, destWidth = _b.destWidth, destHeight = _b.destHeight;
      if (startX <= destLeft || startY <= destTop || endX >= destLeft + destWidth || endY >= destTop + destHeight) {
        isBigger = true;
      }
      return isBigger;
    };
    Draw2.prototype.isSelectionOutsideCanvas = function(obj) {
      var isOutside = false;
      var parent = this.parent;
      if (obj.activePoint.height < parent.lowerCanvas.height - parent.toolbarHeight || obj.activePoint.width < parent.lowerCanvas.width) {
        isOutside = true;
      }
      return isOutside;
    };
    Draw2.prototype.downScaleImgCanvas = function(ctx, isImgAnnotation, isHFlip, isVFlip) {
      var parent = this.parent;
      var canvas = isImgAnnotation ? parent.activeObj.imageCanvas : parent.baseImgCanvas;
      var img = isImgAnnotation ? parent.activeObj.imageElement : parent.baseImg;
      var width = isImgAnnotation ? parent.activeObj.activePoint.width : parent.img.destWidth;
      var height = isImgAnnotation ? parent.activeObj.activePoint.height : parent.img.destHeight;
      var obj = { width: 0, height: 0 };
      if (parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0) {
        parent.notify("transform", {
          prop: "calcMaxDimension",
          onPropertyChange: false,
          value: { width: img.height, height: img.width, obj, isImgShape: isImgAnnotation }
        });
      } else {
        parent.notify("transform", {
          prop: "calcMaxDimension",
          onPropertyChange: false,
          value: { width: img.width, height: img.height, obj, isImgShape: isImgAnnotation }
        });
      }
      if (isImgAnnotation || parent.allowDownScale && !parent.isCropTab && !parent.isCropToolbar && img.width !== 0 && img.height !== 0 && obj["width"] * 0.75 > width && obj["height"] * 0.75 > height) {
        var tempCanvas = parent.createElement("canvas", {
          id: parent.element.id + "_downScaleCanvas",
          attrs: { name: "canvasImage" }
        });
        tempCanvas.width = isImgAnnotation ? img.width : parent.img.srcWidth;
        tempCanvas.height = isImgAnnotation ? img.height : parent.img.srcHeight;
        if (isImgAnnotation) {
          tempCanvas.getContext("2d").drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);
        } else {
          if (this.imageBackgroundColor !== "") {
            ctx.fillStyle = this.imageBackgroundColor;
            ctx.fillRect(parent.img.destLeft, parent.img.destTop, parent.img.destWidth, parent.img.destHeight);
          }
          tempCanvas.getContext("2d").drawImage(canvas, parent.img.srcLeft, parent.img.srcTop, parent.img.srcWidth, parent.img.srcHeight, 0, 0, tempCanvas.width, tempCanvas.height);
        }
        if (isImgAnnotation || this.isDownScale) {
          this.downScale(tempCanvas, width, height, isImgAnnotation);
        }
        if (isImgAnnotation) {
          ctx.canvas.width = tempCanvas.width;
          ctx.canvas.height = tempCanvas.height;
          if (isHFlip && isVFlip) {
            ctx.translate(parent.activeObj.imageCanvas.width, 0);
            ctx.scale(-1, 1);
            ctx.translate(0, parent.activeObj.imageCanvas.height);
            ctx.scale(1, -1);
          } else {
            if (isHFlip) {
              if (isNullOrUndefined(parent.activeObj.isHorImageFlip) || !parent.activeObj.isHorImageFlip) {
                parent.activeObj.isHorImageFlip = true;
                ctx.translate(parent.activeObj.imageCanvas.width, 0);
                ctx.scale(-1, 1);
              } else if (parent.activeObj.isHorImageFlip) {
                parent.activeObj.isHorImageFlip = false;
              }
              if (parent.activeObj.isVerImageFlip) {
                ctx.translate(0, parent.activeObj.imageCanvas.height);
                ctx.scale(1, -1);
              }
            } else if (isVFlip) {
              if (isNullOrUndefined(parent.activeObj.isVerImageFlip) || !parent.activeObj.isVerImageFlip) {
                parent.activeObj.isVerImageFlip = true;
                ctx.translate(0, parent.activeObj.imageCanvas.height);
                ctx.scale(1, -1);
              } else if (parent.activeObj.isVerImageFlip) {
                parent.activeObj.isVerImageFlip = false;
              }
              if (parent.activeObj.isHorImageFlip) {
                ctx.translate(parent.activeObj.imageCanvas.width, 0);
                ctx.scale(-1, 1);
              }
            }
          }
          ctx.drawImage(tempCanvas, 0, 0);
          ctx.setTransform(1, 0, 0, 1, 0, 0);
        } else if (parent.isFinetuning) {
          ctx.save();
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.drawImage(parent.inMemoryCanvas, 0, 0);
          ctx.restore();
        } else {
          ctx.drawImage(tempCanvas, 0, 0, tempCanvas.width, tempCanvas.height, parent.img.destLeft, parent.img.destTop, tempCanvas.width, tempCanvas.height);
        }
      } else {
        if ((isNullOrUndefined(isImgAnnotation) || !isImgAnnotation) && parent.baseImgCanvas.width !== 0 && parent.baseImgCanvas.height !== 0) {
          if (this.imageBackgroundColor !== "") {
            ctx.fillStyle = this.imageBackgroundColor;
            ctx.fillRect(parent.img.destLeft, parent.img.destTop, parent.img.destWidth, parent.img.destHeight);
          }
          ctx.drawImage(parent.baseImgCanvas, parent.img.srcLeft, parent.img.srcTop, parent.img.srcWidth, parent.img.srcHeight, parent.img.destLeft, parent.img.destTop, parent.img.destWidth, parent.img.destHeight);
        }
      }
      if (parent.isSafari) {
        parent.notify("filter", { prop: "apply-filter", onPropertyChange: false, value: { context: ctx } });
      }
    };
    Draw2.prototype.downScale = function(canvas, width, height, isImgAnnotation) {
      var parent = this.parent;
      if (isImgAnnotation && parent.isStraightening) {
        return;
      }
      var widthSource = canvas.width;
      var heightSource = canvas.height;
      width = Math.round(width);
      height = Math.round(height);
      var widthRatio = widthSource / width;
      var heightRatio = heightSource / height;
      var halfWidthRatio = Math.ceil(widthRatio / 2);
      var halfHeightRatio = Math.ceil(heightRatio / 2);
      var ctx = canvas.getContext("2d");
      var img = ctx.getImageData(0, 0, widthSource, heightSource);
      var img2 = ctx.createImageData(width, height);
      var data = img.data;
      var data2 = img2.data;
      for (var j = 0; j < height; j++) {
        for (var i = 0; i < width; i++) {
          var x2 = (i + j * width) * 4;
          var weight = 0;
          var weights = 0;
          var alphaWeights = 0;
          var r = 0;
          var g = 0;
          var b = 0;
          var a = 0;
          var centerY = (j + 0.5) * heightRatio;
          var startY = Math.floor(j * heightRatio);
          var stopY = Math.ceil((j + 1) * heightRatio);
          for (var y = startY; y < stopY; y++) {
            var dy = Math.abs(centerY - (y + 0.5)) / halfHeightRatio;
            var centerX = (i + 0.5) * widthRatio;
            var w0 = dy * dy;
            var startX = Math.floor(i * widthRatio);
            var stopX = Math.ceil((i + 1) * widthRatio);
            for (var x = startX; x < stopX; x++) {
              var dx = Math.abs(centerX - (x + 0.5)) / halfWidthRatio;
              var w = Math.sqrt(w0 + dx * dx);
              if (w >= 1) {
                continue;
              }
              weight = 2 * w * w * w - 3 * w * w + 1;
              var xPos = 4 * (x + y * widthSource);
              a += weight * data[xPos + 3];
              alphaWeights += weight;
              weight = weight * data[xPos + 3] / 250;
              r += weight * data[xPos];
              g += weight * data[xPos + 1];
              b += weight * data[xPos + 2];
              weights += weight;
            }
          }
          data2[x2] = r / weights;
          data2[x2 + 1] = g / weights;
          data2[x2 + 2] = b / weights;
          data2[x2 + 3] = a / alphaWeights;
        }
      }
      canvas.width = isImgAnnotation ? parent.activeObj.activePoint.width : parent.lowerCanvas.width;
      canvas.height = isImgAnnotation ? parent.activeObj.activePoint.height : parent.lowerCanvas.height;
      ctx.putImageData(img2, 0, 0);
    };
    Draw2.prototype.drawImgToCtx = function(ctx, preventImg) {
      var parent = this.parent;
      if (ctx.canvas.id !== parent.element.id + "_tempCanvas" && ctx !== this.upperContext && isNullOrUndefined(preventImg)) {
        this.downScaleImgCanvas(ctx, null, null, null);
      }
    };
    Draw2.prototype.getFrameColor = function(frameObj, ctx, points) {
      var parent = this.parent;
      var color = parent.frameObj.color;
      if (frameObj.gradientColor) {
        var gradient = ctx.createLinearGradient(points.startX, points.startY, points.startX + points.width, points.startY + points.height);
        gradient.addColorStop(0, frameObj.color);
        gradient.addColorStop(1, frameObj.gradientColor);
        color = gradient;
      } else {
        color = frameObj.color;
      }
      return color;
    };
    Draw2.prototype.applyFrame = function(ctx, frame, preventImg) {
      var parent = this.parent;
      parent.frameObj.type = frame;
      var tempLineWidth;
      var ratio = { width: 1, height: 1 };
      var points = {
        startX: parent.img.destLeft - ctx.lineWidth,
        startY: parent.img.destTop - ctx.lineWidth,
        width: parent.img.destWidth + 2 * ctx.lineWidth,
        height: parent.img.destHeight + 2 * ctx.lineWidth
      };
      var frameObj = {
        type: parent.frameObj.type,
        color: parent.frameObj.color,
        size: parent.frameObj.size,
        inset: parent.frameObj.inset,
        offset: parent.frameObj.offset / 2,
        radius: parent.frameObj.radius,
        amount: parent.frameObj.amount,
        border: parent.frameObj.border,
        gradientColor: parent.frameObj.gradientColor
      };
      var zoomFactor = parent.transform.zoomFactor;
      if (ctx.canvas.id === parent.element.id + "_tempCanvas") {
        var newWidth = ctx.canvas.width;
        var newHeight = ctx.canvas.height;
        var obj = { width: 0, height: 0 };
        parent.notify("crop", {
          prop: "calcRatio",
          onPropertyChange: false,
          value: { obj, dimension: { width: newWidth, height: newHeight } }
        });
        ratio = obj;
        frameObj.size *= (ratio.width + ratio.height) / 2;
        frameObj.inset *= (ratio.width + ratio.height) / 2;
        frameObj.offset *= (ratio.width + ratio.height) / 2;
        frameObj.radius *= (ratio.width + ratio.height) / 2;
        points = { startX: 0, startY: 0, width: ctx.canvas.width, height: ctx.canvas.height };
        parent.notify("export", { prop: "updateSaveContext", onPropertyChange: false, value: { context: ctx } });
      } else if (ctx === this.upperContext && parent.activeObj.shape) {
        points = { startX: parent.activeObj.activePoint.startX - ctx.lineWidth, startY: parent.activeObj.activePoint.startY - ctx.lineWidth, width: parent.activeObj.activePoint.width + 2 * ctx.lineWidth, height: parent.activeObj.activePoint.height + 2 * ctx.lineWidth };
      } else if (isNullOrUndefined(preventImg)) {
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      }
      var valueForty = 40 * ((ratio.width + ratio.height) / 2);
      var valueFifty = 50 * ((ratio.width + ratio.height) / 2);
      if (ctx !== this.upperContext) {
        frameObj.size += frameObj.size * zoomFactor;
        frameObj.inset += frameObj.inset * zoomFactor;
        frameObj.offset += frameObj.offset * zoomFactor;
        frameObj.radius += frameObj.radius * zoomFactor;
        valueForty += valueForty * zoomFactor;
        valueFifty += valueFifty * zoomFactor;
      }
      if (ctx === this.upperContext && parent.activeObj.shape) {
        if (frame === "mat" && (points.width - 2 * frameObj.size < 0 || points.height - 2 * frameObj.size < 0) || frame === "bevel" && (points.width - 2 * frameObj.size < 40 || points.height - 2 * frameObj.size < 40) || frame === "inset" && (points.startX + points.width - frameObj.offset - (points.startX + frameObj.offset) < 0 || points.startY + points.height - frameObj.offset - (points.startY + frameObj.offset) < 0) || frame === "hook" && (points.width - 2 * frameObj.size < 50 || points.height - 2 * frameObj.size < 50)) {
          return;
        }
      }
      var bevelObj = { bevelFilter: ctx.filter };
      var filter = ctx.filter;
      if (parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle" || parent.isCircleCrop || ctx === this.lowerContext && parent.isCropTab) {
        this.drawImgToCtx(ctx, preventImg);
      } else {
        switch (frame) {
          case "none":
            this.drawImgToCtx(ctx, preventImg);
            break;
          case "mat":
            this.drawImgToCtx(ctx, preventImg);
            while ((points.width - 2 * frameObj.size < 0 || points.height - 2 * frameObj.size < 0) && frameObj.size > 0) {
              frameObj.size -= 20;
            }
            ctx.filter = "none";
            ctx.fillStyle = this.getFrameColor(frameObj, ctx, points);
            ctx.beginPath();
            ctx.rect(points.startX, points.startY, points.width, points.height);
            ctx.rect(points.startX + frameObj.size, points.startY + frameObj.size, points.width - 2 * frameObj.size, points.height - 2 * frameObj.size);
            ctx.fill("evenodd");
            ctx.closePath();
            break;
          case "bevel":
            ctx.filter = "none";
            ctx.fillStyle = this.getFrameColor(frameObj, ctx, points);
            ctx.beginPath();
            ctx.fillRect(points.startX, points.startY, points.width, points.height);
            ctx.closePath();
            points.startX += frameObj.size;
            points.startY += frameObj.size;
            points.width -= 2 * frameObj.size;
            points.height -= 2 * frameObj.size;
            while ((points.width - 2 * frameObj.size < 40 || points.height - 2 * frameObj.size < 40) && frameObj.size > 0) {
              points.startX -= frameObj.size;
              points.startY -= frameObj.size;
              points.width += 2 * frameObj.size;
              points.height += 2 * frameObj.size;
              frameObj.size -= 20;
              points.startX += frameObj.size;
              points.startY += frameObj.size;
              points.width -= 2 * frameObj.size;
              points.height -= 2 * frameObj.size;
            }
            ctx.fillStyle = this.getFrameColor(frameObj, ctx, points);
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(points.startX + valueForty, points.startY);
            ctx.lineTo(points.startX + points.width - valueForty, points.startY);
            ctx.quadraticCurveTo(points.startX + points.width, points.startY, points.startX + points.width, points.startY + valueForty);
            ctx.lineTo(points.startX + points.width, points.startY + points.height - valueForty);
            ctx.quadraticCurveTo(points.startX + points.width, points.startY + points.height, points.startX + points.width - valueForty, points.startY + points.height);
            ctx.lineTo(points.startX + valueForty, points.startY + points.height);
            ctx.quadraticCurveTo(points.startX, points.startY + points.height, points.startX, points.startY + points.height - valueForty);
            ctx.lineTo(points.startX, points.startY + valueForty);
            ctx.quadraticCurveTo(points.startX, points.startY, points.startX + valueForty, points.startY);
            ctx.closePath();
            ctx.clip();
            ctx.filter = filter === "none" ? parent.canvasFilter : filter;
            if (ctx.canvas.id === parent.element.id + "_tempCanvas") {
              preventImg = null;
              ctx.filter = "none";
              ctx.drawImage(parent.inMemoryCanvas, 0, 0);
              ctx.filter = filter === "none" ? parent.canvasFilter : filter;
            } else {
              ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
              if (preventImg) {
                preventImg = null;
                if (parent.transform.zoomFactor !== 0) {
                  this.isRotateZoom = true;
                }
                parent.notify("filter", { prop: "getBevelFilter", onPropertyChange: false, value: { obj: bevelObj } });
                ctx.filter = bevelObj["bevelFilter"];
                this.updateCurrTransState("initial");
                this.drawImgToCtx(ctx, preventImg);
                this.updateCurrTransState("reverse");
                this.isRotateZoom = false;
                parent.frameObj.type = "none";
                ctx.filter = "none";
                parent.notify("shape", {
                  prop: "drawAnnotations",
                  onPropertyChange: false,
                  value: { ctx, shape: "iterate", pen: "iterate", isPreventApply: null }
                });
                parent.frameObj.type = "bevel";
                ctx.filter = filter === "none" ? parent.canvasFilter : filter;
              } else {
                parent.notify("filter", { prop: "getBevelFilter", onPropertyChange: false, value: { obj: bevelObj } });
                ctx.filter = bevelObj["bevelFilter"];
                this.drawImgToCtx(ctx, preventImg);
              }
            }
            ctx.restore();
            break;
          case "line":
            this.drawImgToCtx(ctx, preventImg);
            tempLineWidth = ctx.lineWidth;
            ctx.lineWidth = frameObj.size / 10;
            for (var i = 0; i < parent.frameObj.amount; i++) {
              if (i > 0) {
                points.startX += frameObj.offset;
                points.startY += frameObj.offset;
                points.width -= 2 * frameObj.offset;
                points.height -= 2 * frameObj.offset;
              }
              var arcY2 = points.startY + points.height - frameObj.inset - frameObj.radius;
              var lineY = points.startY + frameObj.inset + frameObj.radius;
              var arcX2 = points.startX + points.width - frameObj.inset - frameObj.radius;
              var lineX = points.startX + frameObj.inset + frameObj.radius;
              var arcX1 = points.startX + frameObj.inset + frameObj.radius;
              var lineX2 = points.startX + points.width - frameObj.inset - frameObj.radius;
              var arcY1 = points.startY + frameObj.inset + frameObj.radius;
              var lineY2 = points.startY + points.height - frameObj.inset - frameObj.radius;
              if (arcY2 >= lineY && arcX2 >= lineX && arcX1 <= lineX2 && arcY1 <= lineY2) {
                ctx.filter = "none";
                ctx.strokeStyle = this.getFrameColor(frameObj, ctx, points);
                if (frameObj.border === "dashed") {
                  ctx.setLineDash([ctx.lineWidth * 2.5, ctx.lineWidth * 1.5]);
                } else if (frameObj.border === "dotted") {
                  ctx.setLineDash([ctx.lineWidth, ctx.lineWidth]);
                }
                ctx.beginPath();
                ctx.moveTo(points.startX + frameObj.inset + frameObj.radius, points.startY + frameObj.inset);
                ctx.lineTo(points.startX + points.width - frameObj.inset - frameObj.radius, points.startY + frameObj.inset);
                ctx.arcTo(points.startX + points.width - frameObj.inset, points.startY + frameObj.inset, points.startX + points.width - frameObj.inset, points.startY + frameObj.inset + frameObj.radius, frameObj.radius);
                ctx.lineTo(points.startX + points.width - frameObj.inset, points.startY + points.height - frameObj.inset - frameObj.radius);
                ctx.arcTo(points.startX + points.width - frameObj.inset, points.startY + points.height - frameObj.inset, points.startX + points.width - frameObj.inset - frameObj.radius, points.startY + points.height - frameObj.inset, frameObj.radius);
                ctx.lineTo(points.startX + frameObj.inset + frameObj.radius, points.startY + points.height - frameObj.inset);
                ctx.arcTo(points.startX + frameObj.inset, points.startY + points.height - frameObj.inset, points.startX + frameObj.inset, points.startY + points.height - frameObj.inset - frameObj.radius, frameObj.radius);
                ctx.lineTo(points.startX + frameObj.inset, points.startY + frameObj.inset + frameObj.radius);
                ctx.arcTo(points.startX + frameObj.inset, points.startY + frameObj.inset, points.startX + frameObj.inset + frameObj.radius, points.startY + frameObj.inset, frameObj.radius);
                ctx.closePath();
                ctx.stroke();
                ctx.setLineDash([]);
              }
            }
            ctx.lineWidth = tempLineWidth;
            break;
          case "inset":
            this.drawImgToCtx(ctx, preventImg);
            ctx.filter = "none";
            ctx.strokeStyle = this.getFrameColor(frameObj, ctx, points);
            tempLineWidth = ctx.lineWidth;
            ctx.lineWidth = frameObj.size / 10;
            ctx.beginPath();
            ctx.moveTo(points.startX + frameObj.offset, points.startY + frameObj.inset);
            ctx.lineTo(points.startX + points.width - frameObj.offset, points.startY + frameObj.inset);
            ctx.moveTo(points.startX + points.width - frameObj.inset, points.startY + frameObj.offset);
            ctx.lineTo(points.startX + points.width - frameObj.inset, points.startY + points.height - frameObj.offset);
            ctx.moveTo(points.startX + points.width - frameObj.offset, points.startY + points.height - frameObj.inset);
            ctx.lineTo(points.startX + frameObj.offset, points.startY + points.height - frameObj.inset);
            ctx.moveTo(points.startX + frameObj.inset, points.startY + points.height - frameObj.offset);
            ctx.lineTo(points.startX + frameObj.inset, points.startY + frameObj.offset);
            ctx.stroke();
            ctx.closePath();
            ctx.lineWidth = tempLineWidth;
            break;
          case "hook":
            this.drawImgToCtx(ctx, preventImg);
            ctx.filter = "none";
            ctx.strokeStyle = this.getFrameColor(frameObj, ctx, points);
            tempLineWidth = ctx.lineWidth;
            ctx.lineWidth = frameObj.size / 10;
            ctx.beginPath();
            ctx.moveTo(points.startX + frameObj.inset + valueFifty, points.startY + frameObj.inset);
            ctx.lineTo(points.startX + frameObj.inset, points.startY + frameObj.inset);
            ctx.lineTo(points.startX + frameObj.inset, points.startY + frameObj.inset + valueFifty);
            ctx.moveTo(points.startX + points.width - frameObj.inset - valueFifty, points.startY + frameObj.inset);
            ctx.lineTo(points.startX + points.width - frameObj.inset, points.startY + frameObj.inset);
            ctx.lineTo(points.startX + points.width - frameObj.inset, points.startY + frameObj.inset + valueFifty);
            ctx.moveTo(points.startX + points.width - frameObj.inset - valueFifty, points.startY + points.height - frameObj.inset);
            ctx.lineTo(points.startX + points.width - frameObj.inset, points.startY + points.height - frameObj.inset);
            ctx.lineTo(points.startX + points.width - frameObj.inset, points.startY + points.height - frameObj.inset - valueFifty);
            ctx.moveTo(points.startX + frameObj.inset + valueFifty, points.startY + points.height - frameObj.inset);
            ctx.lineTo(points.startX + frameObj.inset, points.startY + points.height - frameObj.inset);
            ctx.lineTo(points.startX + frameObj.inset, points.startY + points.height - frameObj.inset - valueFifty);
            ctx.stroke();
            ctx.lineWidth = tempLineWidth;
            break;
        }
        if (parent.isCircleCrop || parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle") {
          parent.notify("crop", {
            prop: "cropCircle",
            onPropertyChange: false,
            value: { context: ctx, isSave: ctx.canvas.id === parent.element.id + "_tempCanvas" ? true : null, isFlip: null }
          });
        }
        ctx.filter = filter;
      }
    };
    Draw2.prototype.triggerFrameChange = function(prevFrameSettings) {
      var parent = this.parent;
      var currFrameSettings = {
        type: parent.toPascalCase(parent.frameObj.type),
        color: parent.frameObj.color,
        gradientColor: parent.frameObj.gradientColor,
        size: parent.frameObj.size,
        inset: parent.frameObj.inset,
        offset: parent.frameObj.offset,
        borderRadius: parent.frameObj.radius,
        frameLineStyle: parent.toPascalCase(parent.frameObj.border),
        lineCount: parent.frameObj.amount
      };
      var frameChange = {
        cancel: false,
        previousFrameSetting: prevFrameSettings,
        currentFrameSetting: currFrameSettings
      };
      parent.trigger("frameChange", frameChange);
      parent.editCompleteArgs = frameChange;
      if (!frameChange.cancel) {
        this.setFrameObj(frameChange.currentFrameSetting);
      }
      return frameChange;
    };
    Draw2.prototype.setFrameObj = function(currFrameSettings) {
      var parent = this.parent;
      parent.frameObj.type = currFrameSettings.type.toLowerCase();
      parent.frameObj.color = currFrameSettings.color;
      parent.frameObj.gradientColor = currFrameSettings.gradientColor;
      parent.frameObj.size = currFrameSettings.size;
      parent.frameObj.inset = currFrameSettings.inset;
      parent.frameObj.offset = currFrameSettings.offset;
      parent.frameObj.radius = currFrameSettings.borderRadius;
      parent.frameObj.border = currFrameSettings.frameLineStyle.toLowerCase();
      parent.frameObj.amount = currFrameSettings.lineCount;
    };
    Draw2.prototype.zoomToSel = function(activeObj, isToolbar) {
      var parent = this.parent;
      if (this.straightenActObj && JSON.stringify(this.straightenActObj.activePoint) === JSON.stringify(activeObj.activePoint)) {
        parent.activeObj = extend({}, this.straightenActObj, null, true);
        this.allowRedactStraighten = false;
        if (parent.transform.straighten === 0) {
          var destWidth = parent.img.destWidth;
          var destHeight = parent.img.destHeight;
          parent.transform.straighten = 360;
          while (true) {
            if (!isNullOrUndefined(this.straightenInitZoom) && Math.round(parent.transform.zoomFactor * Math.pow(10, 3)) / Math.pow(10, 3) > Math.round(this.straightenInitZoom * Math.pow(10, 3)) / Math.pow(10, 3)) {
              this.setZoomPan("out");
              if (destWidth === parent.img.destWidth && destHeight === parent.img.destHeight) {
                this.performDummyZoom();
                break;
              }
              if (parent.transform.degree === 0) {
                parent.transform.zoomFactor -= 0.025;
                parent.transform.cropZoomFactor -= 0.025;
              }
            } else {
              this.performDummyZoom();
              break;
            }
          }
          parent.transform.straighten = 0;
          parent.img = {
            destLeft: parent.img.destLeft,
            destTop: parent.img.destTop,
            destWidth: parent.img.destWidth,
            destHeight: parent.img.destHeight,
            srcLeft: parent.img.srcLeft,
            srcTop: parent.img.srcTop,
            srcWidth: parent.img.srcWidth,
            srcHeight: parent.img.srcHeight
          };
        } else {
          if (isNullOrUndefined(this.straightenInitZoom)) {
            this.straightenInitZoom = parent.transform.zoomFactor;
          }
          if (this.straightenInitZoom - parent.transform.zoomFactor > 0) {
            parent.notify("transform", {
              prop: "zoomAction",
              onPropertyChange: false,
              value: { zoomFactor: -(this.straightenInitZoom - parent.transform.zoomFactor), zoomPoint: null, isResize: true }
            });
          } else if (this.straightenInitZoom - parent.transform.zoomFactor < 0) {
            parent.notify("transform", {
              prop: "zoomAction",
              onPropertyChange: false,
              value: { zoomFactor: this.straightenInitZoom - parent.transform.zoomFactor, zoomPoint: null, isResize: true }
            });
          }
          parent.activeObj = extend({}, activeObj, null, true);
          parent.transform.zoomFactor += 1e-3;
          this.calcStraightenedPoints(isToolbar);
        }
      } else {
        this.straightenActObj = extend({}, activeObj, null, true);
        parent.activeObj = extend({}, this.straightenActObj, null, true);
        this.straightenInitZoom = parent.transform.zoomFactor;
        this.calcStraightenedPoints(isToolbar);
      }
    };
    Draw2.prototype.isDestPointSmall = function() {
      var parent = this.parent;
      var img = parent.img;
      var destPoints = {
        startX: img.destLeft,
        startY: img.destTop,
        width: img.destWidth,
        height: img.destHeight
      };
      parent.notify("shape", { prop: "straightenShapes", onPropertyChange: false });
      var isSmall = false;
      if (this.straightenDestPoints.destWidth && this.straightenDestPoints.destHeight && (img.destWidth < this.straightenDestPoints.destWidth || img.destHeight < this.straightenDestPoints.destHeight)) {
        isSmall = true;
      }
      img.destLeft = destPoints.startX;
      img.destTop = destPoints.startY;
      img.destWidth = destPoints.width;
      img.destHeight = destPoints.height;
      parent.img = img;
      return isSmall;
    };
    Draw2.prototype.calcStraightenedPoints = function(isToolbar) {
      var parent = this.parent;
      var destWidth = parent.img.destWidth;
      var destHeight = parent.img.destHeight;
      if (isNullOrUndefined(parent.transform.zoomFactor)) {
        parent.transform.zoomFactor += 0.025;
      }
      this.updateImgCanvasPoints();
      var _loop_1 = function() {
        if (this_1.isLinesIntersect() || this_1.isSelOutsideImg() || isToolbar && this_1.isDestPointSmall()) {
          parent.activeObj = extend({}, this_1.straightenActObj, null, true);
          this_1.setZoomPan("in");
          if (destWidth === parent.img.destWidth && destHeight === parent.img.destHeight) {
            this_1.performDummyZoom();
            return "break";
          }
          if (parent.transform.degree === 0) {
            parent.transform.zoomFactor += 0.025;
            parent.transform.cropZoomFactor += 0.025;
          }
          var points = this_1.imgCanvasPoints;
          var left_1 = parent.img.destLeft;
          var top_1 = parent.img.destTop;
          var width_1 = parent.img.destWidth;
          var height_1 = parent.img.destHeight;
          points.forEach(function(point) {
            point.x = point.ratioX * width_1 + left_1;
            point.y = point.ratioY * height_1 + top_1;
          });
          this_1.imgCanvasPoints = points;
        } else {
          this_1.performDummyZoom();
          return "break";
        }
      };
      var this_1 = this;
      while (true) {
        var state_1 = _loop_1();
        if (state_1 === "break")
          break;
      }
    };
    Draw2.prototype.performDummyZoom = function() {
      var parent = this.parent;
      parent.notify("transform", {
        prop: "zoomAction",
        onPropertyChange: false,
        value: { zoomFactor: 0.025, zoomPoint: null, isResize: true }
      });
      parent.notify("transform", {
        prop: "zoomAction",
        onPropertyChange: false,
        value: { zoomFactor: -0.025, zoomPoint: null, isResize: true }
      });
      var zoom = parent.transform.zoomFactor * 10;
      if (zoom < 1) {
        zoom = 1 + zoom / 10;
      }
      parent.setProperties({ zoomSettings: { zoomFactor: zoom } }, true);
      parent.notify("transform", {
        prop: "setPreviousZoomValue",
        onPropertyChange: false,
        value: { previousZoomValue: zoom }
      });
      this.panToSel();
    };
    Draw2.prototype.setZoomPan = function(type) {
      var parent = this.parent;
      var obj = { maxDimension: null };
      if (parent.transform.degree === 0) {
        parent.notify("transform", {
          prop: "cropZoom",
          onPropertyChange: false,
          value: { value: type === "in" ? 0.025 : -0.025, selectionObj: parent.activeObj, obj }
        });
        parent.img.destWidth = obj["maxDimension"]["width"];
        parent.img.destHeight = obj["maxDimension"]["height"];
      } else {
        parent.transform.zoomFactor += type === "in" ? 0.025 : -0.025;
        parent.transform.cropZoomFactor += type === "in" ? 0.025 : -0.025;
        this.updateCurrTransState("initial");
        this.isRotateZoom = true;
        this.setDestPoints();
        this.isRotateZoom = false;
        this.updateCurrTransState("reverse");
      }
    };
    Draw2.prototype.updateImgCanvasPoints = function() {
      var parent = this.parent;
      var points = this.getImagePoints();
      var obj = { width: 0, height: 0 };
      var width = parent.baseImgCanvas.width;
      var height = parent.baseImgCanvas.height;
      parent.notify("crop", {
        prop: "calcRatio",
        onPropertyChange: false,
        value: { obj, dimension: { width, height } }
      });
      var ratio = obj;
      width = parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0 ? ratio.height : ratio.width;
      height = parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0 ? ratio.width : ratio.height;
      var p1;
      var p2;
      var p3;
      var p4;
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      if (parent.transform.straighten > 0) {
        p1 = { x: destLeft + points[0].x / width, y: destTop };
        p2 = { x: destLeft + destWidth, y: destTop + points[1].y / height };
        p3 = { x: destLeft + destWidth - points[0].x / width, y: destTop + destHeight };
        p4 = { x: destLeft, y: destTop + destHeight - points[1].y / height };
      } else if (parent.transform.straighten < 0) {
        p1 = { x: destLeft, y: destTop + points[0].y / height };
        p2 = { x: destLeft + points[1].x / width, y: destTop };
        p3 = { x: destLeft + destWidth, y: destTop + destHeight - points[0].y / height };
        p4 = { x: destLeft + destWidth - points[1].x / width, y: destTop + destHeight };
      } else if (parent.transform.straighten === 0) {
        p1 = { x: destLeft, y: destTop };
        p2 = { x: destLeft + destWidth, y: destTop };
        p3 = { x: destLeft + destWidth, y: destTop + destHeight };
        p4 = { x: destLeft, y: destTop + destHeight };
      }
      p1.ratioX = (p1.x - destLeft) / destWidth;
      p1.ratioY = (p1.y - destTop) / destHeight;
      p2.ratioX = (p2.x - destLeft) / destWidth;
      p2.ratioY = (p2.y - destTop) / destHeight;
      p3.ratioX = (p3.x - destLeft) / destWidth;
      p3.ratioY = (p3.y - destTop) / destHeight;
      p4.ratioX = (p4.x - destLeft) / destWidth;
      p4.ratioY = (p4.y - destTop) / destHeight;
      this.imgCanvasPoints = [p1, p2, p3, p4];
    };
    Draw2.prototype.isLinesIntersect = function(obj) {
      var parent = this.parent;
      var point = parent.activeObj.activePoint;
      if (parent.activeObj.rotatedAngle !== 0) {
        var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY, width = _a.width, height = _a.height;
        var center = { x: startX + width / 2, y: startY + height / 2 };
        var cosAngle = Math.cos(parent.activeObj.rotatedAngle);
        var sinAngle = Math.sin(parent.activeObj.rotatedAngle);
        var p1 = {
          x: cosAngle * (startX - center.x) - sinAngle * (startY - center.y) + center.x,
          y: sinAngle * (startX - center.x) + cosAngle * (startY - center.y) + center.y
        };
        var p2 = {
          x: cosAngle * (endX - center.x) - sinAngle * (startY - center.y) + center.x,
          y: sinAngle * (endX - center.x) + cosAngle * (startY - center.y) + center.y
        };
        var p3 = {
          x: cosAngle * (startX - center.x) - sinAngle * (endY - center.y) + center.x,
          y: sinAngle * (startX - center.x) + cosAngle * (endY - center.y) + center.y
        };
        var p4 = {
          x: cosAngle * (endX - center.x) - sinAngle * (endY - center.y) + center.x,
          y: sinAngle * (endX - center.x) + cosAngle * (endY - center.y) + center.y
        };
        var imgPoints_1 = this.imgCanvasPoints;
        var isTopIntersect_1 = this.doIntersect(p1, p2, imgPoints_1[0], imgPoints_1[1]);
        var isRightIntersect_1 = this.doIntersect(p2, p4, imgPoints_1[1], imgPoints_1[2]);
        var isBottomIntersect_1 = this.doIntersect(p3, p4, imgPoints_1[2], imgPoints_1[3]);
        var isLeftIntersect_1 = this.doIntersect(p1, p3, imgPoints_1[3], imgPoints_1[0]);
        if (obj) {
          obj["arr"] = [isTopIntersect_1, isRightIntersect_1, isBottomIntersect_1, isLeftIntersect_1];
        }
        return isTopIntersect_1 || isRightIntersect_1 || isBottomIntersect_1 || isLeftIntersect_1;
      }
      var imgPoints = this.imgCanvasPoints;
      var isTopIntersect = this.doIntersect({ x: point.startX, y: point.startY }, { x: point.endX, y: point.startY }, imgPoints[0], imgPoints[1]);
      var isRightIntersect = this.doIntersect({ x: point.endX, y: point.startY }, { x: point.endX, y: point.endY }, imgPoints[1], imgPoints[2]);
      var isBottomIntersect = this.doIntersect({ x: point.startX, y: point.endY }, { x: point.endX, y: point.endY }, imgPoints[2], imgPoints[3]);
      var isLeftIntersect = this.doIntersect({ x: point.startX, y: point.startY }, { x: point.startX, y: point.endY }, imgPoints[3], imgPoints[0]);
      var isTopLeftInsideRect = this.isInsideRect(imgPoints[0]);
      var isTopRightInsideRect = this.isInsideRect(imgPoints[1]);
      var isBottomRightInsideRect = this.isInsideRect(imgPoints[2]);
      var isBottomLeftInsideRect = this.isInsideRect(imgPoints[3]);
      if (obj) {
        obj["arr"] = [isTopIntersect, isRightIntersect, isBottomIntersect, isLeftIntersect];
      }
      return isTopIntersect || isRightIntersect || isBottomIntersect || isLeftIntersect || isTopLeftInsideRect || isTopRightInsideRect || isBottomRightInsideRect || isBottomLeftInsideRect || imgPoints[0].x > point.startX && imgPoints[1].x < point.endX && imgPoints[2].x < point.endX && imgPoints[3].x > point.startX && imgPoints[0].y < point.startY && imgPoints[1].y < point.startY && imgPoints[2].y > point.endY && imgPoints[3].y > point.endY || imgPoints[0].x < point.startX && imgPoints[1].x > point.endX && imgPoints[2].x > point.endX && imgPoints[3].x < point.startX && imgPoints[0].y > point.startY && imgPoints[1].y > point.startY && imgPoints[2].y < point.endY && imgPoints[3].y < point.endY;
    };
    Draw2.prototype.isSelOutsideImg = function() {
      var parent = this.parent;
      var points = this.imgCanvasPoints;
      var actPoint = parent.activeObj.activePoint;
      return this.checkPointPosition(actPoint.startX, actPoint.startY, points[0].x, points[0].y, points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y) !== "inside" || this.checkPointPosition(actPoint.endX, actPoint.startY, points[0].x, points[0].y, points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y) !== "inside" || this.checkPointPosition(actPoint.startX, actPoint.endY, points[0].x, points[0].y, points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y) !== "inside" || this.checkPointPosition(actPoint.endX, actPoint.endY, points[0].x, points[0].y, points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y) !== "inside";
    };
    Draw2.prototype.calcTriangleArea = function(x1, y1, x2, y2, x3, y3) {
      return Math.abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2);
    };
    Draw2.prototype.checkPointPosition = function(x, y, x1, y1, x2, y2, x3, y3, x4, y4) {
      var area1 = this.calcTriangleArea(x, y, x1, y1, x4, y4);
      var area2 = this.calcTriangleArea(x, y, x4, y4, x3, y3);
      var area3 = this.calcTriangleArea(x, y, x3, y3, x2, y2);
      var area4 = this.calcTriangleArea(x, y, x2, y2, x1, y1);
      var areaRectangle = this.calcTriangleArea(x1, y1, x2, y2, x3, y3) + this.calcTriangleArea(x3, y3, x4, y4, x1, y1);
      if (area1 + area2 + area3 + area4 > areaRectangle) {
        return "outside";
      } else if (area1 + area2 + area3 + area4 === areaRectangle && (area1 === 0 || area2 === 0 || area3 === 0 || area4 === 0)) {
        return "on";
      } else {
        return "inside";
      }
    };
    Draw2.prototype.getImagePoints = function() {
      var point = [];
      var parent = this.parent;
      var degree = parent.transform.degree;
      var width = parent.baseImg.width;
      var height = parent.baseImg.height;
      var obj = { dim: null, width: height, height: width, angle: parent.transform.straighten };
      obj["dim"] = parent.getRotatedCanvasDim(obj["width"], obj["height"], obj["angle"]);
      var baseImgCanvasWidth = degree % 90 === 0 && degree % 180 !== 0 ? obj["dim"]["width"] : parent.baseImgCanvas.width;
      var baseImgCanvasHeight = degree % 90 === 0 && degree % 180 !== 0 ? obj["dim"]["height"] : parent.baseImgCanvas.height;
      var baseImgWidth = degree % 90 === 0 && degree % 180 !== 0 ? height : width;
      var baseImgHeight = degree % 90 === 0 && degree % 180 !== 0 ? width : height;
      var centerX = baseImgCanvasWidth / 2;
      var centerY = baseImgCanvasHeight / 2;
      var startX = centerX - baseImgWidth / 2;
      var startY = centerY - baseImgHeight / 2;
      var endX = centerX + baseImgWidth / 2;
      var endY = centerY + baseImgHeight / 2;
      var center = { x: centerX, y: centerY };
      var radians = parent.transform.straighten * (Math.PI / 180);
      var p1 = {
        x: Math.cos(radians) * (startX - center.x) - Math.sin(radians) * (startY - center.y) + center.x,
        y: Math.sin(radians) * (startX - center.x) + Math.cos(radians) * (startY - center.y) + center.y
      };
      var p2 = {
        x: Math.cos(radians) * (endX - center.x) - Math.sin(radians) * (startY - center.y) + center.x,
        y: Math.sin(radians) * (endX - center.x) + Math.cos(radians) * (startY - center.y) + center.y
      };
      var p3 = {
        x: Math.cos(radians) * (endX - center.x) - Math.sin(radians) * (endY - center.y) + center.x,
        y: Math.sin(radians) * (endX - center.x) + Math.cos(radians) * (endY - center.y) + center.y
      };
      var p4 = {
        x: Math.cos(radians) * (startX - center.x) - Math.sin(radians) * (endY - center.y) + center.x,
        y: Math.sin(radians) * (startX - center.x) + Math.cos(radians) * (endY - center.y) + center.y
      };
      point.push(p1);
      point.push(p2);
      point.push(p3);
      point.push(p4);
      return point;
    };
    Draw2.prototype.doIntersect = function(a, b, c, d) {
      var point1 = this.initiation(a, b, c);
      var point2 = this.initiation(a, b, d);
      var point3 = this.initiation(c, d, a);
      var point4 = this.initiation(c, d, b);
      if (point1 !== point2 && point3 !== point4) {
        return true;
      }
      if (point1 === 0 && this.onSegment(a, c, b)) {
        return true;
      }
      if (point2 === 0 && this.onSegment(a, d, b)) {
        return true;
      }
      if (point3 === 0 && this.onSegment(c, a, d)) {
        return true;
      }
      if (point4 === 0 && this.onSegment(c, b, d)) {
        return true;
      }
      return false;
    };
    Draw2.prototype.initiation = function(a, b, c) {
      var value = (b.y - a.y) * (c.x - b.x) - (b.x - a.x) * (c.y - b.y);
      if (value === 0) {
        return 0;
      }
      return value > 0 ? 1 : 2;
    };
    Draw2.prototype.onSegment = function(a, b, c) {
      if (b.x <= Math.max(a.x, c.x) && b.x >= Math.min(a.x, c.x) && b.y <= Math.max(a.y, c.y) && b.y >= Math.min(a.y, c.y)) {
        return true;
      }
      return false;
    };
    Draw2.prototype.isInsideRect = function(point) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var isInside = false;
      if (point.x >= actPoint.startX && point.x <= actPoint.endX && point.y >= actPoint.startY && point.y <= actPoint.endY) {
        isInside = true;
      }
      return isInside;
    };
    Draw2.prototype.setDestForStraighten = function() {
      var parent = this.parent;
      if (isNullOrUndefined(this.straightenDestPoints)) {
        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
        parent.notify("shape", { prop: "straightenShapes", onPropertyChange: false });
        this.straightenDestPoints = extend({}, parent.img, {}, true);
        parent.img.destLeft = destLeft;
        parent.img.destTop = destTop;
        parent.img.destWidth = destWidth;
        parent.img.destHeight = destHeight;
      }
    };
    Draw2.prototype.drawRedact = function(canvasDraw, obj) {
      var _a = obj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
      var _b = obj.activePoint, width = _b.width, height = _b.height;
      var isSaveCtx = false;
      var canvas = canvasDraw.canvas;
      if (canvas.id.indexOf("_tempCanvas") !== -1) {
        isSaveCtx = true;
      }
      var img = this.parent.img;
      if (width <= 0 || height <= 0) {
        return;
      } else if (this.parent.isCropTab) {
        canvasDraw.drawImage(obj.redactImage, 0, 0, obj.redactImage.width, obj.redactImage.height, startX, startY, width, height);
      } else {
        var offscreenCanvas = (undefined).createElement("canvas");
        var offscreenCtx = offscreenCanvas.getContext("2d");
        var imageWidth = canvas.width;
        var imageHeight = canvas.height;
        var tempRatio = Math.min(imageWidth, imageHeight) / 1e3;
        var straighten = Math.round(this.parent.activeObj.rotatedAngle * (180 / Math.PI));
        if (this.allowRedactStraighten && straighten !== 0) {
          var tempCanvas = (undefined).createElement("canvas");
          var tempCtx = tempCanvas.getContext("2d");
          if (isSaveCtx) {
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            tempCtx.drawImage(canvas, 0, 0);
          } else {
            tempCanvas.width = img.destWidth > canvas.width ? canvas.width : img.destWidth;
            tempCanvas.height = img.destHeight > canvas.height ? canvas.height : img.destHeight;
            tempCtx.drawImage(this.lowerContext.canvas, img.destLeft > 0 ? img.destLeft : 0, img.destTop > 0 ? img.destTop : 0, tempCanvas.width, tempCanvas.height, 0, 0, tempCanvas.width, tempCanvas.height);
          }
          var radians = -straighten * Math.PI / 180;
          var straightenCanvas = (undefined).createElement("canvas");
          var straightenCtx = straightenCanvas.getContext("2d");
          straightenCanvas.width = tempCanvas.width;
          straightenCanvas.height = tempCanvas.height;
          if (img.destWidth > canvas.width && !isSaveCtx) {
            straightenCanvas.width = canvas.width;
          }
          if (img.destHeight > canvas.height && !isSaveCtx) {
            straightenCanvas.height = canvas.height;
          }
          straightenCtx.save();
          straightenCtx.translate(tempCanvas.width / 2, tempCanvas.height / 2);
          straightenCtx.rotate(radians);
          straightenCtx.drawImage(tempCanvas, -tempCanvas.width / 2, -tempCanvas.height / 2);
          straightenCtx.restore();
          if (img.destLeft > 0 && !isSaveCtx) {
            startX -= img.destLeft;
            endX -= img.destLeft;
          }
          if (img.destTop > 0 && !isSaveCtx) {
            startY -= img.destTop;
            endY -= img.destTop;
          }
          var center = { x: startX + width / 2, y: startY + height / 2 };
          var cosAngle = Math.cos(straighten * Math.PI / 180);
          var sinAngle = Math.sin(straighten * Math.PI / 180);
          var p1 = {
            x: cosAngle * (startX - center.x) - sinAngle * (startY - center.y) + center.x,
            y: sinAngle * (startX - center.x) + cosAngle * (startY - center.y) + center.y
          };
          var p2 = {
            x: cosAngle * (endX - center.x) - sinAngle * (startY - center.y) + center.x,
            y: sinAngle * (endX - center.x) + cosAngle * (startY - center.y) + center.y
          };
          var p3 = {
            x: cosAngle * (startX - center.x) - sinAngle * (endY - center.y) + center.x,
            y: sinAngle * (startX - center.x) + cosAngle * (endY - center.y) + center.y
          };
          if (!isSaveCtx) {
            center = { x: img.destWidth / 2, y: img.destHeight / 2 };
            if (img.destWidth > canvas.width) {
              center.x = canvas.width / 2;
            }
            if (img.destHeight > canvas.height) {
              center.y = canvas.height / 2;
            }
          } else {
            center = { x: canvas.width / 2, y: canvas.height / 2 };
          }
          cosAngle = Math.cos(radians);
          sinAngle = Math.sin(radians);
          var newP1 = {
            x: cosAngle * (p1.x - center.x) - sinAngle * (p1.y - center.y) + center.x,
            y: sinAngle * (p1.x - center.x) + cosAngle * (p1.y - center.y) + center.y
          };
          var newP2 = {
            x: cosAngle * (p2.x - center.x) - sinAngle * (p2.y - center.y) + center.x,
            y: sinAngle * (p2.x - center.x) + cosAngle * (p2.y - center.y) + center.y
          };
          var newP3 = {
            x: cosAngle * (p3.x - center.x) - sinAngle * (p3.y - center.y) + center.x,
            y: sinAngle * (p3.x - center.x) + cosAngle * (p3.y - center.y) + center.y
          };
          var tempWidth = isSaveCtx ? canvasDraw.canvas.width : img.destWidth > canvas.width ? canvas.width : img.destWidth;
          var tempHeight = isSaveCtx ? canvasDraw.canvas.height : img.destHeight > canvas.height ? canvas.height : img.destHeight;
          var rotatedWidth = Math.abs(tempWidth * Math.cos(radians)) + Math.abs(tempHeight * Math.sin(radians));
          var rotatedHeight = Math.abs(tempWidth * Math.sin(radians)) + Math.abs(tempHeight * Math.cos(radians));
          var prevWidth = straightenCanvas.width;
          var prevHeight = straightenCanvas.height;
          straightenCanvas.width = rotatedWidth;
          straightenCanvas.height = rotatedHeight;
          straightenCtx.save();
          straightenCtx.translate(rotatedWidth / 2, rotatedHeight / 2);
          straightenCtx.rotate(radians);
          straightenCtx.drawImage(tempCanvas, -tempCanvas.width / 2, -tempCanvas.height / 2);
          straightenCtx.restore();
          if (this.parent.activeObj.redactType === "blur") {
            offscreenCanvas.width = width;
            offscreenCanvas.height = height;
            var x = newP1.x + (rotatedWidth - prevWidth) / 2;
            var y = newP1.y + (rotatedHeight - prevHeight) / 2;
            if (this.isRedactStraighten) {
              x = startX + (rotatedWidth - prevWidth) / 2;
              y = startY + (rotatedHeight - prevHeight) / 2;
            }
            offscreenCtx.drawImage(straightenCanvas, x, y, newP2.x - newP1.x, newP3.y - newP2.y, 0, 0, width, height);
          } else {
            var pixelSize = obj.redactPixelate / 100 * 20;
            if (isSaveCtx) {
              pixelSize = tempRatio * (obj.redactPixelate / 100) * 35;
            }
            offscreenCanvas.width = Math.ceil(width / pixelSize);
            offscreenCanvas.height = Math.ceil(height / pixelSize);
            var x = newP1.x + (rotatedWidth - prevWidth) / 2;
            var y = newP1.y + (rotatedHeight - prevHeight) / 2;
            if (this.isRedactStraighten) {
              x = startX + (rotatedWidth - prevWidth) / 2;
              y = startY + (rotatedHeight - prevHeight) / 2;
            }
            offscreenCtx.drawImage(straightenCanvas, x, y, newP2.x - newP1.x, newP3.y - newP2.y, 0, 0, offscreenCanvas.width, offscreenCanvas.height);
          }
        }
        if (this.parent.activeObj.redactType === "blur") {
          if (straighten === 0) {
            offscreenCanvas.width = width;
            offscreenCanvas.height = height;
            offscreenCtx.drawImage(isSaveCtx ? canvas : this.lowerContext.canvas, startX, startY, width, height, 0, 0, width, height);
          }
          if (isSaveCtx) {
            var blur_1 = tempRatio * (obj.redactBlur / 100 * 34);
            offscreenCtx.filter = "blur(" + blur_1 + "px)";
          } else {
            offscreenCtx.filter = "blur(" + obj.redactBlur / 100 * 17 + "px)";
          }
          offscreenCtx.drawImage(offscreenCanvas, 0, 0);
          if (straighten === 0) {
            offscreenCtx.drawImage(isSaveCtx ? canvas : this.lowerContext.canvas, startX, startY, width, height, 0, 0, width, height);
          } else {
            if (img.destLeft > 0 && !isSaveCtx) {
              startX += img.destLeft;
              endX += img.destLeft;
            }
            if (img.destTop > 0 && !isSaveCtx) {
              startY += img.destTop;
              endY += img.destTop;
            }
          }
          if (this.parent.isSafari) {
            this.parent.notify("filter", { prop: "apply-filter", onPropertyChange: false, value: { context: offscreenCtx } });
          }
          canvasDraw.drawImage(offscreenCanvas, 0, 0, width, height, startX, startY, width, height);
        } else {
          var pixelSize = obj.redactPixelate / 100 * 20;
          if (isSaveCtx) {
            pixelSize = tempRatio * (obj.redactPixelate / 100) * 35;
          }
          if (straighten === 0) {
            offscreenCanvas.width = Math.ceil(width / pixelSize);
            offscreenCanvas.height = Math.ceil(height / pixelSize);
            offscreenCtx.drawImage(isSaveCtx ? canvas : this.lowerContext.canvas, startX, startY, width, height, 0, 0, offscreenCanvas.width, offscreenCanvas.height);
          } else {
            if (img.destLeft > 0 && !isSaveCtx) {
              startX += img.destLeft;
              endX += img.destLeft;
            }
            if (img.destTop > 0 && !isSaveCtx) {
              startY += img.destTop;
              endY += img.destTop;
            }
          }
          canvasDraw.imageSmoothingEnabled = false;
          canvasDraw.drawImage(offscreenCanvas, 0, 0, offscreenCanvas.width, offscreenCanvas.height, startX, startY, width, height);
        }
        obj.redactImage = this.parent.createElement("canvas");
        obj.redactImage.width = offscreenCanvas.width;
        obj.redactImage.height = offscreenCanvas.height;
        obj.redactImage.getContext("2d").drawImage(offscreenCanvas, 0, 0);
        canvasDraw.beginPath();
        canvasDraw.rect(startX, startY, width, height);
        canvasDraw.rect(startX, startY, width, height);
        canvasDraw.fill("evenodd");
        canvasDraw.closePath();
      }
    };
    return Draw2;
  }()
);
var Export = (
  /** @class */
  function() {
    function Export2(parent) {
      this.parent = parent;
      this.addEventListener();
    }
    Export2.prototype.destroy = function() {
      if (this.parent.isDestroyed) {
        return;
      }
      this.removeEventListener();
    };
    Export2.prototype.addEventListener = function() {
      this.parent.on("export", this.export, this);
      this.parent.on("destroyed", this.destroy, this);
    };
    Export2.prototype.removeEventListener = function() {
      this.parent.off("export", this.export);
      this.parent.off("destroyed", this.destroy);
    };
    Export2.prototype.export = function(args) {
      this.parent.notify("toolbar", { prop: "refreshShapeDrawing", onPropertyChange: false });
      this.updatePvtVar();
      switch (args.prop) {
        case "export":
          this.exportImg(args.value["type"], args.value["fileName"], args.value["imgQuality"]);
          break;
        case "exportToCanvas":
          this.exportToCanvas(args.value["object"]);
          break;
        case "updateSaveContext":
          this.updateSaveContext(args.value["context"]);
          break;
        case "setImageQuality":
          this.imageQuality = args.value["value"];
          break;
        case "drawAnnotation":
          this.drawAnnotation(args.value["context"], args.value["ratio"]);
          break;
      }
    };
    Export2.prototype.getModuleName = function() {
      return "export";
    };
    Export2.prototype.updatePvtVar = function() {
      var parent = this.parent;
      if (parent.lowerCanvas) {
        this.lowerContext = parent.lowerCanvas.getContext("2d");
      }
    };
    Export2.prototype.exportImg = function(type, fileName, imgQuality) {
      var parent = this.parent;
      var obj = { fileName: "" };
      parent.notify("draw", { prop: "getFileName", onPropertyChange: false, value: { obj } });
      var imageName = obj["fileName"];
      if (!parent.disabled && parent.isImageLoaded) {
        parent.notify("shape", { prop: "applyActObj", onPropertyChange: false, value: { isMouseDown: null } });
        var obj_1 = { canvasFilter: this.parent.canvasFilter };
        this.lowerContext.filter = obj_1["canvasFilter"];
        type = type ? type : "Png";
        parent.notify("shape", {
          prop: "redrawActObj",
          onPropertyChange: false,
          value: { x: null, y: null, isMouseDown: null }
        });
        var beforeSave = {
          cancel: false,
          fileName: fileName ? fileName : imageName,
          fileType: type,
          imageQuality: imgQuality
        };
        parent.trigger("beforeSave", beforeSave);
        this.beforeSaveEvent(beforeSave, type, fileName, imageName, imgQuality);
      }
    };
    Export2.prototype.beforeSaveEvent = function(observableSaveArgs, type, fileName, imageName, imgQuality) {
      var parent = this.parent;
      if (!observableSaveArgs.cancel) {
        parent.currObjType.isSave = true;
        fileName = observableSaveArgs.fileName ? observableSaveArgs.fileName : fileName;
        var lowerCaseType = type.toLowerCase();
        fileName = fileName || imageName;
        if (lowerCaseType === "svg") {
          this.toSVGImg(fileName);
        } else {
          this.toBlobFn(fileName, lowerCaseType, imgQuality);
        }
        var saved = { fileName: fileName ? fileName : imageName, fileType: type };
        parent.trigger("saved", saved);
        var actionArgs = { action: "save", actionEventArgs: saved };
        parent.triggerEditCompleteEvent(actionArgs);
        parent.notify("toolbar", { prop: "refresh-main-toolbar", onPropertyChange: false });
        parent.lowerCanvas.style.left = parent.upperCanvas.style.left = "";
        parent.lowerCanvas.style.top = parent.upperCanvas.style.top = "";
        parent.lowerCanvas.style.maxWidth = parent.upperCanvas.style.maxWidth = "";
        parent.lowerCanvas.style.maxHeight = parent.upperCanvas.style.maxHeight = "";
      }
    };
    Export2.prototype.toSVGImg = function(fileName) {
      var parent = this.parent;
      showSpinner(parent.element);
      parent.element.style.opacity = "0.5";
      var tempCanvas = this.exportToCanvas();
      var dataUrl = tempCanvas.toDataURL();
      hideSpinner(parent.element);
      parent.element.style.opacity = "1";
      var svg = (undefined).createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttribute("width", tempCanvas.style.maxWidth);
      svg.setAttribute("height", tempCanvas.style.maxHeight);
      var XLinkNS = "http://www.w3.org/1999/xlink";
      var img = (undefined).createElementNS("http://www.w3.org/2000/svg", "image");
      img.setAttributeNS(null, "height", tempCanvas.height.toString());
      img.setAttributeNS(null, "width", tempCanvas.width.toString());
      img.setAttributeNS(XLinkNS, "xlink:href", dataUrl);
      svg.appendChild(img);
      var prefix = "data:image/svg+xml;base64,";
      var header = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"' + (' width="' + tempCanvas.width + '"') + (' height="' + tempCanvas.height + '"') + ">";
      var footer = "</svg>";
      var body = svg.innerHTML;
      var data = header + body + footer;
      var svgDataUrl = prefix + btoa(data);
      if (fileName === null) {
        return svgDataUrl;
      } else {
        this.downloadImg(svgDataUrl, fileName + ".svg");
        return null;
      }
    };
    Export2.prototype.toBlobFn = function(fileName, type, imgQuality) {
      var proxy = this;
      var parent = this.parent;
      showSpinner(parent.element);
      parent.element.style.opacity = "0.5";
      if (!isNullOrUndefined(imgQuality)) {
        imgQuality = imgQuality > 1 ? 1 : imgQuality <= 0 ? 0.01 : imgQuality;
        this.imageQuality = imgQuality ? imgQuality : null;
      }
      var tempCanvas = this.exportToCanvas();
      var imagetype = type === "jpeg" ? "image/jpeg" : type === "webp" ? "image/webp" : "image/png";
      tempCanvas.toBlob(function(blob) {
        var blobUrl = URL.createObjectURL(blob);
        proxy.downloadImg(blobUrl, fileName + "." + type);
        hideSpinner(parent.element);
        parent.element.style.opacity = "1";
      }, imagetype, this.imageQuality ? this.imageQuality : null);
    };
    Export2.prototype.exportToCanvas = function(object) {
      var parent = this.parent;
      var width;
      var height;
      var tempCropObj = extend({}, parent.cropObj, {}, true);
      var tempObj = { currObj: {} };
      parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object: tempObj } });
      var prevObj = tempObj["currObj"];
      prevObj.objColl = extend([], parent.objColl, [], true);
      prevObj.pointColl = extend([], parent.pointColl, [], true);
      prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      parent.notify("freehand-draw", {
        prop: "getSelPointColl",
        onPropertyChange: false,
        value: { obj: selPointCollObj }
      });
      if (this.parent.aspectWidth) {
        parent.notify("undo-redo", { prop: "setPreventUR", value: { bool: true } });
        parent.notify("toolbar", { prop: "resizeClick", value: { bool: false } });
        parent.okBtn();
        if (parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0) {
          width = this.parent.aspectHeight;
          height = this.parent.aspectWidth;
        } else {
          width = this.parent.aspectWidth;
          height = this.parent.aspectHeight;
        }
        parent.notify("undo-redo", { prop: "setPreventUR", value: { bool: false } });
      } else if (parent.currSelectionPoint) {
        width = parent.img.srcWidth;
        height = parent.img.srcHeight;
      } else {
        width = parent.baseImgCanvas.width;
        height = parent.baseImgCanvas.height;
      }
      var obj = { width: 0, height: 0 };
      parent.notify("crop", {
        prop: "calcRatio",
        onPropertyChange: false,
        value: { obj, dimension: { width, height } }
      });
      var ratio = obj;
      var tempContextFilter = this.lowerContext.filter;
      if (this.lowerContext.filter !== "none") {
        var splitWords = this.lowerContext.filter.split(" ");
        var value = parseFloat(splitWords[5].split("(")[1]);
        value *= (ratio.width + ratio.height) / 2;
        splitWords[5] = "blur(" + value + "px)";
        this.lowerContext.filter = splitWords.join(" ");
      }
      var tempCanvas = parent.createElement("canvas", {
        id: parent.element.id + "_tempCanvas",
        attrs: { name: "canvasImage" }
      });
      var tempContext = tempCanvas.getContext("2d");
      tempCanvas.width = width;
      tempCanvas.height = height;
      var dimObj = { width: 0, height: 0 };
      parent.notify("transform", {
        prop: "calcMaxDimension",
        onPropertyChange: false,
        value: { width, height, obj: dimObj }
      });
      var maxDimension = dimObj;
      tempCanvas.style.maxWidth = maxDimension.width + "px";
      tempCanvas.style.maxHeight = maxDimension.height + "px";
      var temp = this.lowerContext.filter;
      tempContext.filter = this.lowerContext.filter;
      this.downScaleImgCanvas(tempContext, width, height);
      this.lowerContext.filter = temp;
      if (parent.transform.degree !== 0 || parent.transform.currFlipState !== "" || parent.transform.straighten !== 0) {
        this.updateSaveContext(tempContext);
        this.exportTransformedImage(tempContext);
      }
      if (parent.isSafari) {
        parent.notify("filter", { prop: "apply-filter", onPropertyChange: false, value: { context: tempContext } });
      }
      this.drawAnnotation(tempContext, ratio);
      if (parent.isCircleCrop) {
        parent.notify("crop", {
          prop: "cropCircle",
          onPropertyChange: false,
          value: { context: tempContext, isSave: true, isFlip: null }
        });
      }
      this.updateFrame(tempContext, true);
      this.lowerContext.filter = tempContextFilter;
      parent.canvasFilter = tempContextFilter;
      if (object) {
        object["canvas"] = tempCanvas;
      }
      if (parent.aspectWidth) {
        parent.objColl = [];
        parent.pointColl = [];
        parent.freehandCounter = 0;
        parent.notify("freehand-draw", {
          prop: "setSelPointColl",
          onPropertyChange: false,
          value: { obj: { selPointColl: [] } }
        });
        parent.notify("draw", { prop: "setCurrentObj", onPropertyChange: false, value: { obj: prevObj } });
        prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
        parent.notify("freehand-draw", {
          prop: "setSelPointColl",
          onPropertyChange: false,
          value: { obj: { selPointColl: prevObj.selPointColl } }
        });
        parent.cropObj = tempCropObj;
        parent.objColl = extend([], prevObj.objColl, [], true);
        parent.pointColl = extend([], prevObj.pointColl, [], true);
        parent.freehandCounter = parent.pointColl.length;
        parent.transform.straighten = 0;
        this.lowerContext.filter = "none";
        parent.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
        });
        this.lowerContext.filter = prevObj.filter;
        parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
        if (parent.isCircleCrop || parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle") {
          parent.notify("crop", {
            prop: "cropCircle",
            onPropertyChange: false,
            value: { context: this.lowerContext, isSave: null, isFlip: null }
          });
        }
      }
      return tempCanvas;
    };
    Export2.prototype.drawAnnotation = function(tempContext, ratio) {
      var parent = this.parent;
      var tempObjColl = extend([], parent.objColl, [], true);
      var tempPointColl = extend([], parent.pointColl, [], true);
      var nonRedact = parent.shapeColl.filter(function(item) {
        return item.shape !== "redact";
      });
      var redact = parent.shapeColl.filter(function(item) {
        return item.shape === "redact";
      });
      parent.shapeColl = redact.concat(nonRedact);
      for (var i = 0; i < parent.shapeColl.length; i++) {
        if (parent.shapeColl[i].order) {
          if (parent.shapeColl[i].currIndex && parent.shapeColl[i].currIndex.indexOf("shape") > -1) {
            parent.objColl = [];
            parent.objColl.push(extend({}, parent.shapeColl[i], {}, true));
            this.drawShape(tempContext, ratio);
          } else if (parent.shapeColl[i].id && parent.shapeColl[i].id.indexOf("pen") > -1) {
            parent.pointColl = [];
            parent.freehandCounter = 0;
            parent.pointColl.push(extend({}, parent.shapeColl[i], {}, true));
            parent.freehandCounter = parent.pointColl.length;
            this.drawPen(tempContext, ratio);
          }
        }
      }
      parent.objColl = tempObjColl;
      parent.pointColl = tempPointColl;
      parent.freehandCounter = parent.pointColl.length;
    };
    Export2.prototype.drawShape = function(tempContext, ratio) {
      var parent = this.parent;
      if (parent.objColl.length > 0) {
        var temp = tempContext.filter;
        tempContext.filter = "none";
        var indexObj = { index: null };
        parent.notify("shape", { prop: "getSmallestIndex", onPropertyChange: false, value: { obj: indexObj } });
        var index = indexObj["index"];
        var objColl = extend([], parent.objColl, [], true);
        var tempObjColl = extend([], parent.objColl, [], true);
        while (objColl.length > 0) {
          var found = false;
          for (var i = 0; i < objColl.length; i++) {
            var currentObj = objColl[i];
            if (isNullOrUndefined(currentObj.order)) {
              objColl.splice(i, 1);
              i--;
              continue;
            }
            if (currentObj.order === index) {
              var temp_1 = tempContext.filter;
              tempContext.filter = "none";
              var currObj = objColl[i];
              var activePoint = currObj.activePoint;
              activePoint.startX -= parent.img.destLeft;
              activePoint.startY -= parent.img.destTop;
              activePoint.endX -= parent.img.destLeft;
              activePoint.endY -= parent.img.destTop;
              activePoint.width = activePoint.endX - activePoint.startX;
              activePoint.height = activePoint.endY - activePoint.startY;
              activePoint.startX *= ratio.width;
              activePoint.startY *= ratio.height;
              activePoint.endX *= ratio.width;
              activePoint.endY *= ratio.height;
              activePoint.width = activePoint.endX - activePoint.startX;
              activePoint.height = activePoint.endY - activePoint.startY;
              currObj.strokeSettings.strokeWidth *= (ratio.width + ratio.height) / 2;
              if (currObj.shape === "text") {
                currObj.textSettings.fontSize *= (ratio.width + ratio.height) / 2;
              } else if (currObj.shape === "path") {
                for (var l = 0; l < currObj.pointColl.length; l++) {
                  currObj.pointColl[l].x = (currObj.pointColl[l].x - parent.img.destLeft) * ratio.width;
                  currObj.pointColl[l].y = (currObj.pointColl[l].y - parent.img.destTop) * ratio.height;
                }
              } else if (currObj.shape === "image") {
                parent.activeObj = extend({}, objColl[i], {}, true);
                parent.notify("selection", { prop: "upgradeImageQuality", onPropertyChange: false });
                objColl[i] = extend({}, parent.activeObj, {}, true);
              }
              parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: {
                canvas: "saveContext",
                obj: objColl[i],
                isCropRatio: null,
                points: null,
                isPreventDrag: true,
                saveContext: tempContext,
                isPreventSelection: null
              } });
              tempContext.filter = temp_1;
              parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
              index++;
              var indexBool = { bool: false };
              parent.notify("shape", { prop: "isIndexInObjColl", onPropertyChange: false, value: { obj: indexBool, index } });
              if (!indexBool["bool"]) {
                index++;
              }
              objColl.splice(i, 1);
              found = true;
              break;
            }
          }
          if (!found) {
            break;
          }
        }
        tempContext.filter = temp;
        parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        parent.objColl = tempObjColl;
      }
    };
    Export2.prototype.drawPen = function(tempContext, ratio) {
      var parent = this.parent;
      if (parent.freehandCounter > 0) {
        var widthObj = { penStrokeWidth: null };
        parent.notify("freehand-draw", { prop: "getPenStrokeWidth", onPropertyChange: false, value: { obj: widthObj } });
        var tempPointColl = extend({}, parent.pointColl, {}, true);
        for (var n = 0; n < parent.freehandCounter; n++) {
          parent.points = extend([], parent.pointColl[n].points, []);
          parent.notify("freehand-draw", { prop: "setPointCounter", onPropertyChange: false, value: { value: 0 } });
          var len = parent.points.length;
          parent.pointColl[n].strokeWidth *= (ratio.width + ratio.height) / 2;
          for (var l = 0; l < len; l++) {
            parent.points[l].x = (parent.points[l].x - parent.img.destLeft) * ratio.width;
            parent.points[l].y = (parent.points[l].y - parent.img.destTop) * ratio.height;
          }
        }
        parent.notify("freehand-draw", {
          prop: "freehandRedraw",
          onPropertyChange: false,
          value: { context: tempContext, points: null }
        });
        parent.pointColl = tempPointColl;
        parent.notify("freehand-draw", { prop: "setPenStrokeWidth", onPropertyChange: false, value: { value: widthObj["penStrokeWidth"] } });
      }
    };
    Export2.prototype.downScaleImgCanvas = function(ctx, width, height) {
      var parent = this.parent;
      var canvas = parent.baseImgCanvas;
      var img = parent.baseImg;
      var obj = { width: 0, height: 0 };
      parent.notify("transform", {
        prop: "calcMaxDimension",
        onPropertyChange: false,
        value: { width: img.width, height: img.height, obj, isImgShape: null }
      });
      var bgObj = { color: null };
      parent.notify("draw", { prop: "getImageBackgroundColor", value: { obj: bgObj } });
      if (bgObj["color"] !== "") {
        ctx.fillStyle = bgObj["color"];
        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      }
      if (obj["width"] > width && obj["height"] > height) {
        var tempCanvas = parent.createElement("canvas", {
          id: parent.element.id + "_downScaleCanvas",
          attrs: { name: "canvasImage" }
        });
        tempCanvas.width = this.parent.img.srcWidth;
        tempCanvas.height = this.parent.img.srcHeight;
        tempCanvas.getContext("2d").drawImage(canvas, parent.img.srcLeft, parent.img.srcTop, parent.img.srcWidth, parent.img.srcHeight, 0, 0, tempCanvas.width, tempCanvas.height);
        parent.notify("draw", { prop: "downScale", value: { canvas: tempCanvas, width, height } });
        ctx.drawImage(tempCanvas, 0, 0);
      } else {
        ctx.drawImage(parent.baseImgCanvas, parent.img.srcLeft, parent.img.srcTop, parent.img.srcWidth, parent.img.srcHeight, 0, 0, width, height);
      }
    };
    Export2.prototype.updateFrame = function(tempContext, isAnnotation) {
      if (this.parent.frameObj.type !== "none") {
        var temp = tempContext.filter;
        tempContext.filter = "none";
        this.parent.notify("draw", { prop: "applyFrame", value: { ctx: tempContext, frame: this.parent.frameObj.type, preventImg: isAnnotation } });
        tempContext.filter = temp;
      }
    };
    Export2.prototype.downloadImg = function(blob, fileName) {
      var a = (undefined).createElement("a");
      a.href = blob;
      a.target = "_parent";
      a.download = fileName;
      ((undefined).body || (undefined).documentElement).appendChild(a);
      a.click();
      a.parentNode.removeChild(a);
    };
    Export2.prototype.exportTransformedImage = function(tempContext) {
      var parent = this.parent;
      var degree = parent.transform.degree;
      if (parent.rotateFlipColl.length > 0) {
        for (var i = 0, len = parent.rotateFlipColl.length; i < len; i++) {
          var flip2 = parent.rotateFlipColl[i];
          if (typeof flip2 === "number") {
            this.exportRotate(tempContext, flip2);
          } else if (flip2 === "horizontal") {
            this.exportFlip(tempContext, true, false);
          } else if (flip2 === "vertical") {
            this.exportFlip(tempContext, false, true);
          }
        }
      }
      parent.transform.degree = degree;
    };
    Export2.prototype.exportRotate = function(tempContext, degree) {
      var parent = this.parent;
      tempContext.clearRect(0, 0, tempContext.canvas.width, tempContext.canvas.height);
      this.setMaxDim(parent.transform.degree, tempContext.canvas);
      tempContext.translate(tempContext.canvas.width / 2, tempContext.canvas.height / 2);
      tempContext.rotate(Math.PI / 180 * degree);
      tempContext.drawImage(parent.inMemoryCanvas, -tempContext.canvas.height / 2, -tempContext.canvas.width / 2, tempContext.canvas.height, tempContext.canvas.width);
      this.updateSaveContext(tempContext);
    };
    Export2.prototype.exportFlip = function(tempContext, flipHorizontal, flipVertical) {
      tempContext.clearRect(0, 0, tempContext.canvas.width, tempContext.canvas.height);
      if (flipHorizontal) {
        tempContext.translate(tempContext.canvas.width, 0);
        tempContext.scale(-1, 1);
      }
      if (flipVertical) {
        tempContext.translate(0, tempContext.canvas.height);
        tempContext.scale(1, -1);
      }
      tempContext.drawImage(this.parent.inMemoryCanvas, 0, 0);
      this.updateSaveContext(tempContext);
    };
    Export2.prototype.updateSaveContext = function(tempContext) {
      var inMemoryContext = this.parent.inMemoryCanvas.getContext("2d");
      tempContext.setTransform(1, 0, 0, 1, 0, 0);
      var imageData = tempContext.getImageData(0, 0, tempContext.canvas.width, tempContext.canvas.height);
      this.parent.inMemoryCanvas.width = imageData.width;
      this.parent.inMemoryCanvas.height = imageData.height;
      inMemoryContext.putImageData(imageData, 0, 0);
    };
    Export2.prototype.setMaxDim = function(degree, tempCanvas) {
      var newWidth;
      var newHeight;
      if (degree % 90 === 0 && degree % 180 !== 0) {
        if (isNullOrUndefined(this.parent.currSelectionPoint)) {
          newWidth = this.parent.baseImgCanvas.height;
          newHeight = this.parent.baseImgCanvas.width;
        } else {
          newWidth = this.parent.img.srcHeight;
          newHeight = this.parent.img.srcWidth;
        }
      } else if (degree % 180 === 0 || degree === 0) {
        if (isNullOrUndefined(this.parent.currSelectionPoint)) {
          newWidth = this.parent.baseImgCanvas.width;
          newHeight = this.parent.baseImgCanvas.height;
        } else {
          newWidth = this.parent.img.srcWidth;
          newHeight = this.parent.img.srcHeight;
        }
      }
      if (!isNullOrUndefined(this.parent.aspectWidth)) {
        newWidth = this.parent.aspectWidth;
        newHeight = this.parent.aspectHeight;
      }
      tempCanvas.width = newWidth;
      tempCanvas.height = newHeight;
      var obj = { width: 0, height: 0 };
      this.parent.notify("transform", {
        prop: "calcMaxDimension",
        onPropertyChange: false,
        value: { width: newWidth, height: newHeight, obj, isImgShape: null }
      });
      var maxDimension = obj;
      tempCanvas.style.maxWidth = maxDimension.width + "px";
      tempCanvas.style.maxHeight = maxDimension.height + "px";
    };
    return Export2;
  }()
);
var Filter = (
  /** @class */
  function() {
    function Filter2(parent) {
      this.adjustmentLevel = {
        brightness: 0,
        contrast: 0,
        hue: 0,
        opacity: 100,
        saturation: 0,
        blur: 0,
        exposure: 0,
        transparency: 100,
        sharpen: false,
        bw: false
      };
      this.tempAdjustmentLevel = {
        brightness: 0,
        contrast: 0,
        hue: 0,
        opacity: 100,
        saturation: 0,
        blur: 0,
        exposure: 0,
        transparency: 100,
        sharpen: false,
        bw: false
      };
      this.adjustmentValue = "";
      this.isBrightnessAdjusted = false;
      this.bevelFilter = "none";
      this.tempAdjVal = {
        brightness: 0,
        contrast: 0,
        hue: 0,
        opacity: 100,
        saturation: 0,
        blur: 0,
        exposure: 0,
        transparency: 100,
        sharpen: false,
        bw: false
      };
      this.tempFilVal = "";
      this.parent = parent;
      this.addEventListener();
    }
    Filter2.prototype.destroy = function() {
      if (this.parent.isDestroyed) {
        return;
      }
      this.removeEventListener();
    };
    Filter2.prototype.addEventListener = function() {
      this.parent.on("filter", this.filter, this);
      this.parent.on("destroyed", this.destroy, this);
    };
    Filter2.prototype.removeEventListener = function() {
      this.parent.off("filter", this.filter);
      this.parent.off("destroyed", this.destroy);
    };
    Filter2.prototype.filter = function(args) {
      this.updatePrivateVariables();
      switch (args.prop) {
        case "finetuneImage":
          this.finetuneImage(args.value["option"], args.value["value"]);
          break;
        case "applyImageFilter":
          this.setFilter(args.value["option"]);
          break;
        case "update-finetunes":
          this.updateFinetunes();
          break;
        case "set-adjustment":
          this.setAdjustment(args.value["operation"]);
          break;
        case "initFilter":
          this.initFilter();
          break;
        case "setCurrAdjValue":
          this.setCurrAdjValue(args.value["type"], args.value["value"]);
          break;
        case "updateAdj":
          this.updateAdj(args.value["type"], args.value["value"], args.value["isPreview"], args.value["ctx"]);
          break;
        case "getCurrentObj":
          this.getCurrentObj(args.value["object"]);
          break;
        case "getAdjustmentLevel":
          if (isNullOrUndefined(this.parent.activeObj.opacity)) {
            this.adjustmentLevel.transparency = 100;
          } else {
            this.adjustmentLevel.transparency = this.parent.activeObj.opacity * 100;
          }
          args.value["obj"]["adjustmentLevel"] = this.adjustmentLevel;
          break;
        case "setAdjustmentLevel":
          this.adjustmentLevel = args.value["adjustmentLevel"];
          break;
        case "getTempAdjustmentLevel":
          args.value["obj"]["tempAdjustmentLevel"] = this.tempAdjustmentLevel;
          break;
        case "setTempAdjustmentLevel":
          this.tempAdjustmentLevel = args.value["tempAdjustmentLevel"];
          break;
        case "setAdjustmentValue":
          this.adjustmentValue = args.value["adjustmentValue"];
          break;
        case "setBrightnessAdjusted":
          this.isBrightnessAdjusted = args.value["isBrightnessAdjusted"];
          if (this.parent.currentFilter.split("_") && this.parent.currentFilter.split("_")[1] === "cold") {
            this.isBrightnessAdjusted = false;
          }
          break;
        case "getBevelFilter":
          args.value["obj"]["bevelFilter"] = this.bevelFilter;
          break;
        case "setBevelFilter":
          this.bevelFilter = args.value["bevelFilter"];
          break;
        case "setTempAdjVal":
          this.tempAdjVal = extend({}, this.adjustmentLevel, {}, true);
          break;
        case "setTempFilVal":
          this.tempFilVal = this.parent.currentFilter;
          break;
        case "reset":
          this.reset();
          break;
        case "apply-filter":
          this.applyFilter(args.value["context"]);
          break;
      }
    };
    Filter2.prototype.updatePrivateVariables = function() {
      var parent = this.parent;
      if (parent.lowerCanvas) {
        this.lowerContext = parent.lowerCanvas.getContext("2d");
      }
    };
    Filter2.prototype.getModuleName = function() {
      return "filter";
    };
    Filter2.prototype.reset = function() {
      this.adjustmentLevel = {
        brightness: 0,
        contrast: 0,
        hue: 0,
        opacity: 100,
        saturation: 0,
        blur: 0,
        exposure: 0,
        transparency: 100,
        sharpen: false,
        bw: false
      };
      this.tempAdjustmentLevel = {
        brightness: 0,
        contrast: 0,
        hue: 0,
        opacity: 100,
        saturation: 0,
        blur: 0,
        exposure: 0,
        transparency: 100,
        sharpen: false,
        bw: false
      };
      this.adjustmentValue = this.parent.getDefaultFilter();
      this.isBrightnessAdjusted = false;
      this.bevelFilter = "none";
      this.tempFilVal = "";
      this.tempAdjVal = {
        brightness: 0,
        contrast: 0,
        hue: 0,
        opacity: 100,
        saturation: 0,
        blur: 0,
        exposure: 0,
        transparency: 100,
        sharpen: false,
        bw: false
      };
    };
    Filter2.prototype.updateFinetunes = function() {
      var _this = this;
      var parent = this.parent;
      var fs = parent.finetuneSettings;
      if (fs) {
        var propertiesToSet = ["brightness", "contrast", "hue", "saturation", "exposure", "opacity", "blur"];
        propertiesToSet.forEach(function(property) {
          if (fs[property]) {
            _this.adjustmentLevel[property] = fs[property].defaultValue;
            _this.tempAdjustmentLevel[property] = fs[property].defaultValue;
          }
        });
        parent.notify("draw", { prop: "isInitialLoading", onPropertyChange: false, value: { isInitialLoading: true } });
      }
    };
    Filter2.prototype.initFilter = function() {
      this.setFilterAdj("brightness", this.adjustmentLevel.brightness);
      this.setFilterAdj("contrast", this.adjustmentLevel.contrast);
      this.setFilterAdj("hue", this.adjustmentLevel.hue);
      this.setFilterAdj("saturation", this.adjustmentLevel.saturation);
      this.setFilterAdj("exposure", this.adjustmentLevel.exposure);
      this.setFilterAdj("opacity", this.adjustmentLevel.opacity);
      this.setFilterAdj("blur", this.adjustmentLevel.blur);
    };
    Filter2.prototype.updateAdj = function(type, value, isPreview, ctx) {
      var parent = this.parent;
      this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      var splitWords = this.lowerContext.filter.split(" ");
      var values = [];
      var brightness = this.getFilterValue(this.adjustmentLevel.brightness);
      var saturate;
      var bright;
      var saturatePercent;
      var contrast;
      var saturatePercentage;
      switch (type) {
        case "brightness":
          value = this.getFilterValue(this.adjustmentLevel.exposure) + value * 5e-3;
          splitWords[0] = "brightness(" + value + ")";
          if (this.adjustmentLevel.brightness !== 0) {
            value = this.adjustmentLevel.opacity / 100 - this.adjustmentLevel.opacity * 0.3 / 100;
            splitWords[4] = "opacity(" + value + ")";
          } else {
            value = this.adjustmentLevel.opacity / 100;
            splitWords[4] = "opacity(" + value + ")";
          }
          this.adjustmentValue = splitWords.join(" ");
          break;
        case "contrast":
          splitWords[1] = "contrast(" + value + "%)";
          this.adjustmentValue = splitWords.join(" ");
          break;
        case "hue":
          splitWords[2] = "hue-rotate(" + value + "deg)";
          this.adjustmentValue = splitWords.join(" ");
          break;
        case "saturation":
          splitWords[3] = "saturate(" + value + "%)";
          this.adjustmentValue = splitWords.join(" ");
          break;
        case "opacity":
          if (parseFloat(splitWords[0].split("(")[1]) !== 1) {
            value -= 0.2;
          }
          if (value < 0) {
            value = 0;
          }
          splitWords[4] = "opacity(" + value + ")";
          this.adjustmentValue = splitWords.join(" ");
          break;
        case "blur":
          splitWords[5] = "blur(" + value + "px)";
          this.adjustmentValue = splitWords.join(" ");
          break;
        case "exposure":
          if (value > 1) {
            value -= 1;
            value += brightness;
          } else if (value < 1) {
            value = 1 - value;
            value = brightness - value;
          }
          splitWords[0] = "brightness(" + value + ")";
          this.adjustmentValue = splitWords.join(" ");
          break;
        case "chrome":
          saturate = this.getSaturationFilterValue(this.adjustmentLevel.saturation);
          saturate *= 100;
          value = saturate + saturate * 0.4;
          splitWords[3] = "saturate(" + value + "%)";
          values = this.adjustmentValue.split(" ");
          splitWords[0] = values[0];
          splitWords[1] = values[1];
          splitWords[2] = values[2];
          splitWords[4] = values[4];
          splitWords[5] = values[5];
          splitWords[6] = "sepia(0%)";
          splitWords[7] = "grayscale(0%)";
          splitWords[8] = "invert(0%)";
          break;
        case "cold":
          bright = this.getFilterValue(this.adjustmentLevel.brightness);
          bright *= 100;
          value = bright * 0.9;
          value *= 0.01;
          splitWords[0] = "brightness(" + value + ")";
          contrast = this.getFilterValue(this.adjustmentLevel.contrast);
          contrast *= 100;
          value = contrast + contrast * 0.5;
          splitWords[1] = "contrast(" + value + "%)";
          saturatePercentage = this.getSaturationFilterValue(this.adjustmentLevel.saturation);
          saturatePercentage *= 100;
          value = saturatePercentage;
          splitWords[3] = "saturate(" + value + "%)";
          values = this.adjustmentValue.split(" ");
          splitWords[2] = values[2];
          splitWords[4] = values[4];
          splitWords[5] = values[5];
          splitWords[6] = "sepia(0%)";
          splitWords[7] = "grayscale(0%)";
          splitWords[8] = "invert(0%)";
          break;
        case "warm":
          saturatePercent = this.getSaturationFilterValue(this.adjustmentLevel.saturation);
          saturatePercent *= 100;
          value = saturatePercent + saturatePercent * 0.4;
          splitWords[3] = "saturate(" + value + "%)";
          splitWords[6] = "sepia(25%)";
          values = this.adjustmentValue.split(" ");
          splitWords[0] = values[0];
          splitWords[1] = values[1];
          splitWords[2] = values[2];
          splitWords[4] = values[4];
          splitWords[5] = values[5];
          splitWords[7] = "grayscale(0%)";
          splitWords[8] = "invert(0%)";
          break;
        case "grayscale":
          splitWords[7] = "grayscale(100%)";
          values = this.adjustmentValue.split(" ");
          splitWords[0] = values[0];
          splitWords[1] = values[1];
          splitWords[2] = values[2];
          splitWords[3] = values[3];
          splitWords[4] = values[4];
          splitWords[5] = values[5];
          splitWords[6] = "sepia(0%)";
          splitWords[8] = "invert(0%)";
          break;
        case "sepia":
          splitWords[6] = "sepia(100%)";
          values = this.adjustmentValue.split(" ");
          splitWords[0] = values[0];
          splitWords[1] = values[1];
          splitWords[2] = values[2];
          splitWords[3] = values[3];
          splitWords[4] = values[4];
          splitWords[5] = values[5];
          splitWords[7] = "grayscale(0%)";
          splitWords[8] = "invert(0%)";
          break;
        case "invert":
          splitWords[8] = "invert(100%)";
          values = this.adjustmentValue.split(" ");
          splitWords[0] = values[0];
          splitWords[1] = values[1];
          splitWords[2] = values[2];
          splitWords[3] = values[3];
          splitWords[4] = values[4];
          splitWords[5] = values[5];
          splitWords[6] = "sepia(0%)";
          splitWords[7] = "grayscale(0%)";
          break;
      }
      if (type !== "sharpen" && type !== "blackandwhite") {
        if (isNullOrUndefined(isPreview)) {
          if (type === "default") {
            splitWords = this.getDefaultCurrentFilter(splitWords);
          }
          this.lowerContext.filter = splitWords.join(" ");
        }
        splitWords = this.setTempFilterValue(brightness, isPreview, splitWords, type);
        parent.notify("draw", { prop: "setRotateZoom", onPropertyChange: false, value: { isRotateZoom: true } });
        parent.notify("draw", {
          prop: "updateCurrTransState",
          onPropertyChange: false,
          value: { type: "initial", isPreventDestination: null, isRotatePan: null }
        });
        var tempFilter = undefined;
        if (parent.frameObj.type === "bevel") {
          tempFilter = this.lowerContext.filter;
          this.bevelFilter = tempFilter;
        }
        if (parent.transform.degree === 0 && parent.rotateFlipColl.length > 0) {
          parent.img.destLeft += parent.panPoint.totalPannedPoint.x;
          parent.img.destTop += parent.panPoint.totalPannedPoint.y;
        }
        parent.img.destLeft += parent.panPoint.totalPannedInternalPoint.x;
        parent.img.destTop += parent.panPoint.totalPannedInternalPoint.y;
        if (parent.transform.degree === 0) {
          parent.notify("transform", { prop: "setDestPointsForFlipState", onPropertyChange: false });
        }
        parent.notify("draw", { prop: "drawImage", onPropertyChange: false });
        parent.notify("draw", {
          prop: "updateCurrTransState",
          onPropertyChange: false,
          value: { type: "reverse", isPreventDestination: null, isRotatePan: null }
        });
        parent.notify("draw", { prop: "setRotateZoom", onPropertyChange: false, value: { isRotateZoom: false } });
        if (parent.transform.degree === 0 && parent.rotateFlipColl.length > 0) {
          parent.img.destLeft += parent.panPoint.totalPannedPoint.x;
          parent.img.destTop += parent.panPoint.totalPannedPoint.y;
        }
        splitWords = this.setTempFilterValue(brightness, isPreview, splitWords, type);
        if (isNullOrUndefined(isPreview)) {
          this.lowerContext.filter = splitWords.join(" ");
        }
        parent.initialAdjustmentValue = splitWords.join(" ");
        tempFilter = this.lowerContext.filter;
        this.lowerContext.filter = "brightness(1) contrast(100%) hue-rotate(0deg) saturate(100%) opacity(1) blur(0px) sepia(0%) grayscale(0%) invert(0%)";
        this.bevelFilter = tempFilter;
        parent.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "iterate", pen: "iterate", isPreventApply: null }
        });
        this.lowerContext.filter = tempFilter;
        parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
        if (parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle" || parent.isCircleCrop) {
          parent.notify("crop", {
            prop: "cropCircle",
            onPropertyChange: false,
            value: { context: this.lowerContext, isSave: null, isFlip: null }
          });
        }
        this.isBrightnessAdjusted = brightness !== 1;
      }
      var filter = splitWords.join(" ");
      if (ctx) {
        ctx.filter = filter;
      }
    };
    Filter2.prototype.setTempFilterValue = function(brightness, isPreview, splitWords, type) {
      if (isPreview) {
        if (type === "default") {
          splitWords = this.getDefaultCurrentFilter(splitWords);
        } else if (brightness !== 1) {
          var tempSplitWords = this.lowerContext.filter.split(" ");
          tempSplitWords[4] = splitWords[4];
          this.lowerContext.filter = tempSplitWords.join(" ");
        }
      }
      return splitWords;
    };
    Filter2.prototype.getDefaultCurrentFilter = function(splitWords) {
      var values = this.adjustmentValue.split(" ");
      splitWords = [values[0], values[1], values[2], values[3], values[4], values[5], "sepia(0%)", "grayscale(0%)", "invert(0%)"];
      return splitWords;
    };
    Filter2.prototype.getFilterValue = function(value) {
      return value === 0 ? 1 : 1 + value * 0.5 / 100;
    };
    Filter2.prototype.getSaturationFilterValue = function(value) {
      return value === 0 ? 1 : 1 + value / 100;
    };
    Filter2.prototype.setFilterAdj = function(type, value) {
      var parent = this.parent;
      parent.notify("freehand-draw", { prop: "apply-pen-draw", onPropertyChange: false });
      this.adjustmentLevel["" + type] = value;
      switch (type) {
        case "contrast":
        case "exposure":
          value = this.getFilterValue(value);
          if (type === "contrast") {
            value *= 100;
          }
          break;
        case "hue":
          value *= 3;
          break;
        case "saturation":
          value = this.getSaturationFilterValue(value) * 100;
          break;
        case "opacity":
          if (value < 10) {
            value += 1;
          }
          value /= 100;
          break;
        case "blur":
          if (value !== 0) {
            value /= 20;
            value += 0.5;
          }
          break;
      }
      var prevCropObj = extend({}, parent.cropObj, {}, true);
      var prevObj = this.getCurrentObj();
      prevObj.objColl = extend([], parent.objColl, [], true);
      prevObj.pointColl = extend([], parent.pointColl, [], true);
      prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      parent.notify("freehand-draw", { prop: "getSelPointColl", onPropertyChange: false, value: { obj: selPointCollObj } });
      prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
      this.updateAdj(type, value);
      parent.notify("undo-redo", { prop: "updateUndoRedoColl", onPropertyChange: false, value: {
        operation: type,
        previousObj: prevObj,
        previousObjColl: prevObj.objColl,
        previousPointColl: prevObj.pointColl,
        previousSelPointColl: prevObj.selPointColl,
        previousCropObj: prevCropObj,
        previousText: null,
        currentText: null,
        previousFilter: null,
        isCircleCrop: null
      } });
    };
    Filter2.prototype.setFilter = function(type) {
      var parent = this.parent;
      type = type.toLowerCase();
      parent.notify("freehand-draw", { prop: "apply-pen-draw", onPropertyChange: false });
      var obj = { currentFilter: this.parent.currentFilter };
      var prevFilter = obj["currentFilter"];
      var prevCropObj = extend({}, parent.cropObj, {}, true);
      var prevObj = this.getCurrentObj();
      prevObj.objColl = extend([], parent.objColl, [], true);
      prevObj.pointColl = extend([], parent.pointColl, [], true);
      prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      parent.notify("freehand-draw", { prop: "getSelPointColl", onPropertyChange: false, value: { obj: selPointCollObj } });
      prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
      this.updateAdj(type, null);
      parent.notify("draw", { prop: "setImageEdited", onPropertyChange: false });
      parent.notify("undo-redo", {
        prop: "updateUndoRedoColl",
        onPropertyChange: false,
        value: {
          operation: type,
          previousObj: prevObj,
          previousObjColl: prevObj.objColl,
          previousPointColl: prevObj.pointColl,
          previousSelPointColl: prevObj.selPointColl,
          previousCropObj: prevCropObj,
          previousText: null,
          currentText: null,
          previousFilter: prevFilter,
          isCircleCrop: null
        }
      });
    };
    Filter2.prototype.setAdjustment = function(type) {
      var splitWords = this.lowerContext.filter.split(" ");
      var value;
      var valueArr;
      switch (type) {
        case "brightness":
          valueArr = splitWords[0].split("(");
          value = parseFloat(valueArr[1].split(")")[0]);
          this.adjustmentLevel.brightness = this.setFilterValue(value);
          break;
        case "contrast":
          valueArr = splitWords[1].split("(");
          value = parseFloat(valueArr[1].split(")")[0]);
          value /= 100;
          this.adjustmentLevel.contrast = this.setFilterValue(value);
          break;
        case "hue":
          valueArr = splitWords[2].split("(");
          value = parseFloat(valueArr[1].split(")")[0]);
          value /= 3;
          this.adjustmentLevel.hue = value;
          break;
        case "saturation":
          valueArr = splitWords[3].split("(");
          value = parseFloat(valueArr[1].split(")")[0]);
          value /= 100;
          this.adjustmentLevel.saturation = this.setSaturationFilterValue(value);
          break;
        case "opacity":
          valueArr = splitWords[4].split("(");
          value = parseFloat(valueArr[1].split(")")[0]);
          if (value === 0.45) {
            value = 40;
          } else if (value === 0.4) {
            value = 30;
          } else if (value === 0.35) {
            value = 20;
          } else if (value === 0.3) {
            value = 10;
          } else if (value === 0.25) {
            value = 0;
          } else {
            value *= 100;
          }
          this.adjustmentLevel.opacity = value;
          break;
        case "blur":
          valueArr = splitWords[5].split("(");
          value = parseFloat(valueArr[1].split(")")[0]);
          value *= 20;
          this.adjustmentLevel.blur = value;
          break;
        case "exposure":
          valueArr = splitWords[0].split("(");
          value = parseFloat(valueArr[1].split(")")[0]);
          this.adjustmentLevel.exposure = this.setFilterValue(value);
          break;
      }
    };
    Filter2.prototype.setFilterValue = function(value) {
      return Math.round(value === 1 ? 0 : (value - 1) * 100 / 0.5);
    };
    Filter2.prototype.setSaturationFilterValue = function(value) {
      return Math.round(value === 1 ? 0 : (value - 1) * 100);
    };
    Filter2.prototype.finetuneImage = function(finetuneOption, value) {
      var parent = this.parent;
      if (!parent.disabled && parent.isImageLoaded) {
        switch (finetuneOption.toLowerCase()) {
          case "brightness":
            this.setFilterAdj("brightness", value);
            break;
          case "contrast":
            this.setFilterAdj("contrast", value);
            break;
          case "hue":
            this.setFilterAdj("hue", value);
            break;
          case "saturation":
            this.setFilterAdj("saturation", value);
            break;
          case "opacity":
            this.setFilterAdj("opacity", value);
            break;
          case "blur":
            this.setFilterAdj("blur", value);
            break;
          case "exposure":
            this.setFilterAdj("exposure", value);
            break;
        }
        this.parent.canvasFilter = this.lowerContext.filter;
        parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
      }
    };
    Filter2.prototype.setCurrAdjValue = function(type, value) {
      var parent = this.parent;
      this.parent.notify("draw", { prop: "setImageEdited", onPropertyChange: false });
      switch (type) {
        case "brightness":
          this.setFilterAdj("brightness", value);
          break;
        case "contrast":
          this.setFilterAdj("contrast", value);
          break;
        case "hue":
          this.setFilterAdj("hue", value);
          break;
        case "saturation":
          this.setFilterAdj("saturation", value);
          break;
        case "opacity":
          this.setFilterAdj("opacity", value);
          break;
        case "blur":
          this.setFilterAdj("blur", value);
          break;
        case "exposure":
          this.setFilterAdj("exposure", value);
          break;
      }
      parent.isFinetuneBtnClick = true;
      parent.curFinetuneObjEvent = { finetune: parent.toPascalCase(type), value };
    };
    Filter2.prototype.getCurrentObj = function(dummyObj) {
      var parent = this.parent;
      var tempFlipPanPointObj = { point: null };
      parent.notify("crop", { prop: "getTempFlipPanPoint", value: { obj: tempFlipPanPointObj } });
      var zoomObj = { previousZoomValue: null };
      parent.notify("transform", { prop: "getPreviousZoomValue", value: { obj: zoomObj } });
      var straightenObj = { zoomFactor: null };
      parent.notify("draw", { prop: "getStraightenInitZoom", value: { obj: straightenObj } });
      var bgObj = { color: null };
      parent.notify("draw", { prop: "getImageBackgroundColor", value: { obj: bgObj } });
      var obj = {
        cropZoom: 0,
        defaultZoom: 0,
        totalPannedPoint: { x: 0, y: 0 },
        totalPannedClientPoint: { x: 0, y: 0 },
        totalPannedInternalPoint: { x: 0, y: 0 },
        tempFlipPanPoint: { x: 0, y: 0 },
        activeObj: {},
        rotateFlipColl: [],
        degree: 0,
        currFlipState: "",
        zoomFactor: 0,
        previousZoomValue: 0,
        straighten: 0,
        destPoints: { startX: 0, startY: 0, width: 0, height: 0 },
        frame: "none",
        srcPoints: { startX: 0, startY: 0, width: 0, height: 0 },
        filter: "",
        isBrightAdjust: this.isBrightnessAdjusted,
        aspectWidth: null,
        aspectHeight: null,
        straightenZoom: 0,
        adjustmentLevel: extend({}, this.tempAdjVal, {}, true),
        currentFilter: this.tempFilVal,
        imageSource: "",
        bgColor: ""
      };
      obj.cropZoom = parent.transform.cropZoomFactor;
      obj.defaultZoom = parent.transform.defaultZoomFactor;
      obj.zoomFactor = parent.zoomSettings.zoomFactor;
      obj.previousZoomValue = zoomObj["previousZoomValue"];
      obj.straightenZoom = straightenObj["zoomFactor"];
      obj.totalPannedPoint = extend({}, parent.panPoint.totalPannedPoint, {}, true);
      obj.totalPannedClientPoint = extend({}, parent.panPoint.totalPannedClientPoint, {}, true);
      obj.totalPannedInternalPoint = extend({}, parent.panPoint.totalPannedInternalPoint, {}, true);
      obj.tempFlipPanPoint = extend({}, tempFlipPanPointObj["point"], {}, true);
      obj.activeObj = extend({}, parent.activeObj, {}, true);
      obj.rotateFlipColl = extend([], parent.rotateFlipColl, [], true);
      obj.degree = parent.transform.degree;
      obj.straighten = parent.cropObj.straighten;
      obj.currFlipState = parent.transform.currFlipState;
      obj.destPoints = {
        startX: parent.img.destLeft,
        startY: parent.img.destTop,
        endX: 0,
        endY: 0,
        width: parent.img.destWidth,
        height: parent.img.destHeight
      };
      obj.srcPoints = {
        startX: parent.img.srcLeft,
        startY: parent.img.srcTop,
        endX: 0,
        endY: 0,
        width: parent.img.srcWidth,
        height: parent.img.srcHeight
      };
      obj.filter = this.lowerContext.filter;
      obj.aspectWidth = parent.aspectWidth;
      obj.aspectHeight = parent.aspectHeight;
      obj.frame = parent.frameObj.type;
      obj.frameObj = extend({}, parent.frameObj);
      obj.imageSource = parent.baseImg.src;
      obj.bgColor = bgObj["color"];
      if (dummyObj) {
        dummyObj["currObj"] = obj;
      }
      return obj;
    };
    Filter2.prototype.getValFromPercentage = function(percentage) {
      var val = parseFloat(percentage);
      if (/%\s*?$/i.test(percentage)) {
        val /= 100;
      }
      return val;
    };
    Filter2.prototype.getValFromLength = function(length) {
      return parseFloat(length);
    };
    Filter2.prototype.parseFilterString = function(filterString) {
      var filterArray = [];
      if (filterString && filterString !== "none") {
        filterArray = filterString.split(" ").map(function(filter) {
          var _a = filter.match(/([a-z-]+)\(([^)]+)\)/).slice(1, 3), name = _a[0], value = _a[1];
          return { filter: name, value };
        });
      }
      return filterArray;
    };
    Filter2.prototype.applyFilter = function(context) {
      var _a = context.canvas, height = _a.height, width = _a.width;
      var imageData = context.getImageData(0, 0, width, height);
      var filterArray = this.parseFilterString(context.filter);
      for (var i = 0, len = filterArray.length; i < len; i++) {
        switch (filterArray[i].filter) {
          case "blur":
            imageData = this.blur(context, imageData, filterArray[i].value);
            break;
          case "brightness":
            imageData = this.brightness(imageData, filterArray[i].value);
            break;
          case "contrast":
            imageData = this.contrast(imageData, filterArray[i].value);
            break;
          case "grayscale":
            imageData = this.grayscale(imageData, filterArray[i].value);
            break;
          case "hue-rotate":
            imageData = this.hueRotate(imageData, filterArray[i].value);
            break;
          case "invert":
            imageData = this.invert(imageData, filterArray[i].value);
            break;
          case "opacity":
            imageData = this.opacity(imageData, filterArray[i].value);
            break;
          case "saturate":
            imageData = this.saturate(context, imageData, filterArray[i].value);
            break;
          case "sepia":
            imageData = this.sepia(imageData, filterArray[i].value);
            break;
        }
      }
      context.putImageData(imageData, 0, 0);
    };
    Filter2.prototype.blur = function(context, imageData, radius) {
      if (radius === undefined) {
        radius = "0";
      }
      var blurRadius = this.getValFromLength(radius);
      blurRadius = Math.floor(blurRadius);
      if (blurRadius <= 0) {
        return imageData;
      }
      var _a = context.canvas, height = _a.height, width = _a.width;
      var data = imageData.data;
      var blurredData = new Uint8ClampedArray(data.length);
      for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
          var r = 0;
          var g = 0;
          var b = 0;
          var a = 0;
          var count = 0;
          for (var dy = -blurRadius; dy <= blurRadius; dy++) {
            for (var dx = -blurRadius; dx <= blurRadius; dx++) {
              var nx = x + dx;
              var ny = y + dy;
              if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                var offset = (ny * width + nx) * 4;
                r += data[offset];
                g += data[offset + 1];
                b += data[offset + 2];
                a += data[offset + 3];
                count++;
              }
            }
          }
          var i = (y * width + x) * 4;
          blurredData[i] = r / count;
          blurredData[i + 1] = g / count;
          blurredData[i + 2] = b / count;
          blurredData[i + 3] = a / count;
        }
      }
      for (var i = 0; i < data.length; i++) {
        data[i] = blurredData[i];
      }
      return imageData;
    };
    Filter2.prototype.brightness = function(imageData, percentage) {
      if (percentage === undefined) {
        percentage = "1";
      }
      var factor = this.getValFromPercentage(percentage);
      if (factor !== 1) {
        var data = imageData.data;
        var length_1 = data.length;
        for (var i = 0; i < length_1; i += 4) {
          data[i + 0] *= factor;
          data[i + 1] *= factor;
          data[i + 2] *= factor;
        }
      }
      return imageData;
    };
    Filter2.prototype.contrast = function(imageData, percentage) {
      if (percentage === undefined) {
        percentage = "1";
      }
      var factor = this.getValFromPercentage(percentage);
      if (factor !== 1) {
        var data = imageData.data;
        var length_2 = data.length;
        for (var i = 0; i < length_2; i += 4) {
          data[i + 0] = ((data[i + 0] / 255 - 0.5) * factor + 0.5) * 255;
          data[i + 1] = ((data[i + 1] / 255 - 0.5) * factor + 0.5) * 255;
          data[i + 2] = ((data[i + 2] / 255 - 0.5) * factor + 0.5) * 255;
        }
      }
      return imageData;
    };
    Filter2.prototype.grayscale = function(imageData, percentage) {
      if (percentage === undefined) {
        percentage = "0";
      }
      var factor = this.getValFromPercentage(percentage);
      if (factor > 0) {
        var data = imageData.data;
        var length_3 = data.length;
        for (var i = 0; i < length_3; i += 4) {
          var r = data[i];
          var g = data[i + 1];
          var b = data[i + 2];
          var gray = 0.299 * r + 0.587 * g + 0.114 * b;
          data[i] = r * (1 - factor) + gray * factor;
          data[i + 1] = g * (1 - factor) + gray * factor;
          data[i + 2] = b * (1 - factor) + gray * factor;
        }
      }
      return imageData;
    };
    Filter2.prototype.hueRotate = function(imageData, rotation) {
      if (rotation === undefined) {
        rotation = "0deg";
      }
      var data = imageData.data;
      var angle = parseFloat(rotation) * (Math.PI / 180);
      if (angle > 0) {
        var cosA = Math.cos(angle);
        var sinA = Math.sin(angle);
        var matrix = [
          0.213 + cosA * 0.787 - sinA * 0.213,
          0.715 - cosA * 0.715 - sinA * 0.715,
          0.072 - cosA * 0.072 + sinA * 0.928,
          0.213 - cosA * 0.213 + sinA * 0.143,
          0.715 + cosA * 0.285 + sinA * 0.14,
          0.072 - cosA * 0.072 - sinA * 0.283,
          0.213 - cosA * 0.213 - sinA * 0.787,
          0.715 - cosA * 0.715 + sinA * 0.715,
          0.072 + cosA * 0.928 + sinA * 0.072
        ];
        for (var i = 0; i < data.length; i += 4) {
          var r = data[i];
          var g = data[i + 1];
          var b = data[i + 2];
          data[i] = matrix[0] * r + matrix[1] * g + matrix[2] * b;
          data[i + 1] = matrix[3] * r + matrix[4] * g + matrix[5] * b;
          data[i + 2] = matrix[6] * r + matrix[7] * g + matrix[8] * b;
        }
      }
      return imageData;
    };
    Filter2.prototype.invert = function(imageData, percentage) {
      if (percentage === undefined) {
        percentage = "0";
      }
      var factor = this.getValFromPercentage(percentage);
      if (factor > 0) {
        var data = imageData.data;
        var length_4 = data.length;
        for (var i = 0; i < length_4; i += 4) {
          data[i + 0] = Math.abs(data[i + 0] - 255 * factor);
          data[i + 1] = Math.abs(data[i + 1] - 255 * factor);
          data[i + 2] = Math.abs(data[i + 2] - 255 * factor);
        }
      }
      return imageData;
    };
    Filter2.prototype.opacity = function(imageData, percentage) {
      if (percentage === undefined) {
        percentage = "0";
      }
      var factor = this.getValFromPercentage(percentage);
      if (factor >= 0) {
        var data = imageData.data;
        var length_5 = data.length;
        for (var i = 3; i < length_5; i += 4) {
          data[i] *= factor;
        }
      }
      return imageData;
    };
    Filter2.prototype.saturate = function(context, imageData, percentage) {
      if (percentage === undefined) {
        percentage = "0";
      }
      var factor = this.getValFromPercentage(percentage);
      if (factor !== 1) {
        var _a = context.canvas, width = _a.width, height = _a.height;
        var data = imageData.data;
        var lumR = (1 - factor) * 0.3086;
        var lumG = (1 - factor) * 0.6094;
        var lumB = (1 - factor) * 0.082;
        var shiftW = width << 2;
        for (var j = 0; j < height; j++) {
          var offset = j * shiftW;
          for (var i = 0; i < width; i++) {
            var pos = offset + (i << 2);
            var r = data[pos + 0];
            var g = data[pos + 1];
            var b = data[pos + 2];
            data[pos + 0] = (lumR + factor) * r + lumG * g + lumB * b;
            data[pos + 1] = lumR * r + (lumG + factor) * g + lumB * b;
            data[pos + 2] = lumR * r + lumG * g + (lumB + factor) * b;
          }
        }
      }
      return imageData;
    };
    Filter2.prototype.sepia = function(imageData, percentage) {
      if (percentage === undefined) {
        percentage = "0";
      }
      var factor = this.getValFromPercentage(percentage);
      if (factor > 1) {
        factor = 1;
      }
      if (factor > 0) {
        var data = imageData.data;
        var length_6 = data.length;
        for (var i = 0; i < length_6; i += 4) {
          var r = data[i + 0];
          var g = data[i + 1];
          var b = data[i + 2];
          data[i + 0] = (0.393 * r + 0.769 * g + 0.189 * b) * factor + r * (1 - factor);
          data[i + 1] = (0.349 * r + 0.686 * g + 0.168 * b) * factor + g * (1 - factor);
          data[i + 2] = (0.272 * r + 0.534 * g + 0.131 * b) * factor + b * (1 - factor);
        }
      }
      return imageData;
    };
    return Filter2;
  }()
);
var FreehandDrawing = (
  /** @class */
  function() {
    function FreehandDrawing2(parent) {
      this.fhdObj = { lastWidth: 0, lastVelocity: 0, time: 0, pointX: 0, pointY: 0 };
      this.isFreehandDrawing = false;
      this.freehandDownPoint = { x: 0, y: 0 };
      this.isFreehandPointMoved = false;
      this.pointCounter = 0;
      this.selPointColl = {};
      this.currFHDIdx = 0;
      this.selPoints = [];
      this.dummyPoints = [];
      this.tempFHDStyles = { strokeColor: null, fillColor: null, strokeWidth: null };
      this.straightenPoint = { x: null, y: null, ratioX: null, ratioY: null };
      this.straightenPointAngle = 0;
      this.isMasking = false;
      this.parent = parent;
      this.addEventListener();
    }
    FreehandDrawing2.prototype.destroy = function() {
      if (this.parent.isDestroyed) {
        return;
      }
      this.removeEventListener();
    };
    FreehandDrawing2.prototype.addEventListener = function() {
      this.parent.on("freehand-draw", this.draw, this);
      this.parent.on("destroyed", this.destroy, this);
    };
    FreehandDrawing2.prototype.removeEventListener = function() {
      this.parent.off("freehand-draw", this.draw);
      this.parent.off("destroyed", this.destroy);
    };
    FreehandDrawing2.prototype.draw = function(args) {
      this.updateFhdPvtVar();
      switch (args.prop) {
        case "hoverFhd": {
          this.hoverFhd(args.value["strokeColor"], args.value["strokeWidth"]);
          break;
        }
        case "freehandDownHandler":
          this.freehandDownHandler(args.value["e"], args.value["canvas"]);
          break;
        case "freehandUpHandler":
          this.freehandUpHandler(args.value["e"], args.value["canvas"], args.value["context"]);
          break;
        case "handle-freehand-draw": {
          var id = parseInt(args.value["id"].split("_")[1], 10) - 1;
          if (this.isFHDIdx(id)) {
            this.deleteFhd(id, true);
          }
          break;
        }
        case "freehandRedraw":
          this.freehandRedraw(args.value["context"], args.value["points"]);
          break;
        case "deleteFhd": {
          var id = parseInt(args.value["id"].split("_")[1], 10) - 1;
          this.deleteFhd(id, true);
          break;
        }
        case "selectFhd": {
          var id = null;
          if (args.value["id"]) {
            id = parseInt(args.value["id"].split("_")[1], 10) - 1;
          }
          this.selectFhd(id);
          break;
        }
        case "applyFhd":
          this.applyFhd();
          break;
        case "cancelFhd":
          this.cancelFhd();
          break;
        case "updateFHDCurPts":
          this.updateFHDCurPts();
          break;
        case "rotateFhdColl":
          this.rotateFhdColl();
          break;
        case "flipFHDColl":
          this.flipFHDColl(args.value["value"]);
          break;
        case "panFHDColl":
          this.panFHDColl(args.value["xDiff"], args.value["yDiff"], args.value["panRegion"]);
          break;
        case "updateFHDColl":
          if (args.value && args.value["isPreventApply"]) {
            this.updateFHDColl(args.value["isPreventApply"]);
          } else {
            this.updateFHDColl();
          }
          break;
        case "zoomFHDColl":
          this.zoomFHDColl(args.value["isPreventApply"]);
          break;
        case "apply-pen-draw":
          this.applyPenDraw();
          break;
        case "freeHandDraw":
          this.freeHandDraw(args.value["value"]);
          break;
        case "isFHDIdx":
          this.isFHDIdx(args.value["index"], args.value["obj"]);
          break;
        case "getSqPtFD":
          this.getSqPtFD(args.value["idx"], args.value["obj"]);
          break;
        case "getSelPointColl":
          args.value["obj"]["selPointColl"] = extend([], this.selPointColl);
          break;
        case "setSelPointColl":
          this.selPointColl = extend([], args.value["obj"]["selPointColl"]);
          break;
        case "pushSelPointColl":
          this.selPointColl.push(extend([], args.value["obj"]["selPointColl"]));
          break;
        case "setFreehandDrawHoveredIndex":
          this.fhdHovIdx = args.value["index"];
          break;
        case "getFreehandDrawHoveredIndex":
          args.value["obj"]["index"] = this.fhdHovIdx;
          break;
        case "setPointCounter":
          this.pointCounter = args.value["value"];
          break;
        case "getPenStrokeWidth":
          args.value["obj"]["penStrokeWidth"] = this.penStrokeWidth;
          break;
        case "setPenStrokeWidth":
          this.penStrokeWidth = args.value["value"];
          break;
        case "getCurrentFreehandDrawIndex":
          args.value["obj"]["currentFreehandDrawIndex"] = this.currFHDIdx;
          break;
        case "setCurrentFreehandDrawIndex":
          this.currFHDIdx = args.value["value"];
          break;
        case "updateCropPtsForSel":
          this.updateCropPtsForSel();
          break;
        case "getFreehandDrawSelectedId":
          args.value["obj"]["freehandDrawSelectedId"] = this.fhdSelID;
          break;
        case "resetFreehandDrawSelectedId":
          this.fhdSelID = null;
          break;
        case "getTempFreeHandDrawEditingStyles":
          args.value["obj"]["tempFreeHandDrawEditingStyles"] = this.tempFHDStyles;
          break;
        case "setFreehandSelectedIndex":
          this.fhdSelIdx = args.value["index"];
          break;
        case "getFreehandSelectedIndex":
          args.value["obj"]["freehandSelectedIndex"] = this.fhdSelIdx;
          break;
        case "setCenterSelPoints":
          this.setCenterSelPoints();
          break;
        case "getStraightenPoint":
          args.value["obj"]["straightenPoint"] = extend({}, this.straightenPoint, {}, true);
          break;
        case "setStraightenPoint":
          this.straightenPoint.x = args.value["x"];
          this.straightenPoint.y = args.value["y"];
          if (args.value["ratioX"] && args.value["ratioY"]) {
            this.straightenPoint.ratioX = args.value["ratioX"];
            this.straightenPoint.ratioY = args.value["ratioY"];
          }
          break;
        case "resetStraightenPoint":
          this.straightenPoint = { x: null, y: null, ratioX: null, ratioY: null };
          this.prevStraightenObj = null;
          this.straightenPointAngle = 0;
          break;
        case "getStraightenPointAngle":
          args.value["obj"]["angle"] = this.straightenPointAngle;
          break;
        case "reset":
          this.reset();
          break;
        case "triggerShapeChanging":
          this.triggerShapeChanging(args.value["shapeChangingArgs"]);
          break;
        case "setMasking":
          this.isMasking = args.value["value"];
          break;
        case "resetSelPoints":
          this.selPoints = [];
          break;
      }
    };
    FreehandDrawing2.prototype.updateFhdPvtVar = function() {
      var parent = this.parent;
      if (parent.lowerCanvas) {
        this.lowerContext = parent.lowerCanvas.getContext("2d");
      }
      if (parent.upperCanvas) {
        this.upperContext = parent.upperCanvas.getContext("2d");
      }
    };
    FreehandDrawing2.prototype.reset = function() {
      this.fhdObj = { lastWidth: 0, lastVelocity: 0, time: 0, pointX: 0, pointY: 0 };
      this.isFreehandDrawing = this.isFreehandPointMoved = false;
      this.selPoints = [];
      this.dummyPoints = [];
      this.freehandDownPoint = { x: 0, y: 0 };
      this.selPointColl = {};
      this.straightenPointAngle = 0;
      this.fhdHovIdx = null;
      this.pointCounter = 0;
      this.fhdSelID = null;
      this.isMasking = false;
      this.penStrokeWidth = undefined;
      this.currFHDIdx = 0;
      this.fhdSelIdx = null;
      this.tempFHDStyles = { strokeColor: null, fillColor: null, strokeWidth: null };
      this.straightenPoint = { x: null, y: null, ratioX: null, ratioY: null };
      this.prevStraightenObj = null;
    };
    FreehandDrawing2.prototype.getModuleName = function() {
      return "freehand-draw";
    };
    FreehandDrawing2.prototype.hoverFhd = function(fillStyle, strokeWidth) {
      var parent = this.parent;
      var context = this.upperContext;
      var idx = -1;
      if (this.fhdHovIdx > -1) {
        idx = this.fhdHovIdx;
      } else {
        idx = this.fhdSelIdx;
      }
      parent.points = extend([], parent.pointColl[idx].points);
      this.pointCounter = 0;
      var len = parent.points.length;
      var controlPoint1;
      var controlPoint2;
      var startPoint;
      var endPoint;
      var minStrokeWidth = 0;
      var maxStrokeWidth = 0;
      context.fillStyle = fillStyle ? fillStyle : parent.pointColl[idx].strokeColor;
      context.strokeStyle = context.fillStyle;
      minStrokeWidth = maxStrokeWidth = this.penStrokeWidth = strokeWidth ? strokeWidth : parent.pointColl[idx].strokeWidth;
      if (len === 1) {
        controlPoint1 = controlPoint2 = startPoint = endPoint = parent.points[0];
        this.startDraw(context, controlPoint1, controlPoint2, startPoint, endPoint, minStrokeWidth, maxStrokeWidth);
      }
      for (var l = 0; l < len - 3; l++) {
        if (parent.points[l + 1] && parent.points[l + 2] && parent.points[l + 2]) {
          controlPoint1 = this.calcCurveCP(parent.points[l + 0], parent.points[l + 1], parent.points[l + 2]).controlPoint2;
          controlPoint2 = this.calcCurveCP(parent.points[l + 1], parent.points[l + 2], parent.points[l + 3]).controlPoint1;
          if (l === 0) {
            startPoint = parent.points[l];
          } else {
            startPoint = parent.points[l + 1];
          }
          endPoint = parent.points[l + 2];
          this.startDraw(context, controlPoint1, controlPoint2, startPoint, endPoint, minStrokeWidth, maxStrokeWidth);
        }
      }
      context.closePath();
      var point = this.getSqPtFD(idx);
      var tempLineWidth = context.lineWidth;
      context.lineWidth = 2;
      context.strokeStyle = parent.themeColl[parent.theme]["primaryColor"];
      context.beginPath();
      context.rect(point.startX, point.startY, point.width, point.height);
      context.stroke();
      context.closePath();
      context.lineWidth = tempLineWidth;
    };
    FreehandDrawing2.prototype.freehandDownHandler = function(e, canvas) {
      var parent = this.parent;
      parent.lowerCanvas = (undefined).querySelector("#" + parent.element.id + "_lowerCanvas");
      this.lowerContext = parent.lowerCanvas.getContext("2d");
      parent.upperCanvas = (undefined).querySelector("#" + parent.element.id + "_upperCanvas");
      this.upperContext = parent.upperCanvas.getContext("2d");
      this.fhdObj.time = (/* @__PURE__ */ new Date()).getTime();
      this.isFreehandDrawing = true;
      if (e.type === "mousedown") {
        this.freehandDownPoint = { x: e.clientX, y: e.clientY };
      } else {
        this.freehandDownPoint = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      }
      this.isFreehandPointMoved = false;
      EventHandler.add(canvas, "mousemove touchmove", this.freehandMoveHandler, this);
      var shapeSettings = {
        id: "pen_" + (this.currFHDIdx + 1),
        type: ShapeType.FreehandDraw,
        startX: this.freehandDownPoint.x,
        startY: this.freehandDownPoint.y,
        strokeColor: parent.activeObj.strokeSettings.strokeColor,
        strokeWidth: this.penStrokeWidth,
        points: null,
        index: parent.objColl.length + parent.freehandCounter + 1
      };
      var shapeChangingArgs = {
        cancel: false,
        action: "draw-start",
        previousShapeSettings: shapeSettings,
        currentShapeSettings: shapeSettings
      };
      this.triggerShapeChanging(shapeChangingArgs);
    };
    FreehandDrawing2.prototype.freehandUpHandler = function(e, canvas, context) {
      var rect = canvas.getBoundingClientRect();
      var parent = this.parent;
      EventHandler.remove(canvas, "mousemove touchmove", this.freehandMoveHandler);
      if (parent.points.length === 0) {
        if (e.type === "mouseup") {
          this.processPoint(e.clientX - rect.left, e.clientY - rect.top, true, context);
        } else if (e.type === "touchend" && e.changedTouches) {
          this.processPoint(e.changedTouches[0].clientX - rect.left, e.changedTouches[0].clientY - rect.top, true, context);
        } else {
          if (!this.isFreehandPointMoved) {
            this.processPoint(this.freehandDownPoint.x - rect.left, this.freehandDownPoint.y - rect.top, true, context);
          }
        }
      }
      context.closePath();
      var prevCropObj = extend({}, parent.cropObj, {}, true);
      var object = { currObj: {} };
      parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
      var prevObj = object["currObj"];
      prevObj.objColl = extend([], parent.objColl, [], true);
      prevObj.pointColl = extend([], parent.pointColl, [], true);
      prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      parent.notify("freehand-draw", { prop: "getSelPointColl", onPropertyChange: false, value: { obj: selPointCollObj } });
      prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
      var fhCnt = parent.freehandCounter;
      var order = parent.objColl.length + parent.freehandCounter + 1;
      parent.pointColl[fhCnt] = {
        points: extend([], parent.points),
        strokeColor: parent.activeObj.strokeSettings.strokeColor,
        strokeWidth: this.penStrokeWidth,
        flipState: parent.transform.currFlipState,
        id: "pen_" + (this.currFHDIdx + 1),
        order
      };
      parent.points = [];
      this.dummyPoints = [];
      this.selPointColl[fhCnt] = { points: extend([], this.selPoints) };
      this.selPoints = [];
      this.pointCounter = 0;
      parent.freehandCounter++;
      this.isFreehandDrawing = false;
      if (!parent.isMaskImage) {
        parent.notify("undo-redo", {
          prop: "updateUndoRedoColl",
          onPropertyChange: false,
          value: {
            operation: "freehand-draw",
            previousObj: prevObj,
            previousObjColl: prevObj.objColl,
            previousPointColl: prevObj.pointColl,
            previousSelPointColl: prevObj.selPointColl,
            previousCropObj: prevCropObj,
            previousText: null,
            currentText: null,
            previousFilter: null,
            isCircleCrop: null
          }
        });
      }
      var shapeSettings = {
        id: "pen_" + (this.currFHDIdx + 1),
        type: ShapeType.FreehandDraw,
        startX: this.freehandDownPoint.x,
        startY: this.freehandDownPoint.y,
        strokeColor: parent.activeObj.strokeSettings.strokeColor,
        strokeWidth: this.penStrokeWidth,
        points: parent.pointColl[this.currFHDIdx].points,
        index: order
      };
      var shapeChangingArgs = {
        cancel: false,
        action: "draw-end",
        previousShapeSettings: shapeSettings,
        currentShapeSettings: shapeSettings
      };
      this.triggerShapeChanging(shapeChangingArgs);
      this.currFHDIdx++;
    };
    FreehandDrawing2.prototype.freehandMoveHandler = function(e) {
      this.isFreehandPointMoved = true;
      var rect = this.parent.upperCanvas.getBoundingClientRect();
      var x;
      var y;
      if (e.type === "mousemove") {
        x = e.clientX - rect.left;
        y = e.clientY - rect.top;
      } else {
        x = e.touches[0].clientX - rect.left;
        y = e.touches[0].clientY - rect.top;
      }
      if (this.isFreehandDrawing) {
        this.upperContext.fillStyle = this.parent.activeObj.strokeSettings.strokeColor;
        if (this.parent.isMaskImage) {
          this.upperContext.globalCompositeOperation = "xor";
        }
        this.processPoint(x, y, false, this.upperContext);
      }
    };
    FreehandDrawing2.prototype.processPoint = function(x, y, mouseDown, context) {
      var parent = this.parent;
      var lastPoint = this.point(x, y, (/* @__PURE__ */ new Date()).getTime());
      lastPoint = parent.points.length > 0 && parent.points[parent.points.length - 1];
      var isLastPointTooClose = lastPoint ? this.distanceTo(lastPoint) <= 5 : false;
      var controlPoint1;
      var controlPoint2;
      var startPoint;
      var endPoint;
      this.selPoints.push({
        x,
        y,
        ratioX: (x - parent.img.destLeft) / parent.img.destWidth,
        ratioY: (y - parent.img.destTop) / parent.img.destHeight,
        time: this.fhdObj.time
      });
      if (!lastPoint || !(lastPoint && isLastPointTooClose) || mouseDown) {
        this.fhdObj.time = (/* @__PURE__ */ new Date()).getTime();
        parent.points.push({
          x,
          y,
          ratioX: (x - parent.img.destLeft) / parent.img.destWidth,
          ratioY: (y - parent.img.destTop) / parent.img.destHeight,
          time: this.fhdObj.time
        });
        this.dummyPoints.push({
          x,
          y,
          ratioX: (x - parent.img.destLeft) / parent.img.destWidth,
          ratioY: (y - parent.img.destTop) / parent.img.destHeight,
          time: this.fhdObj.time
        });
        if (this.dummyPoints.length > 2) {
          if (this.dummyPoints.length === 3) {
            this.dummyPoints.unshift(this.dummyPoints[0]);
          }
          var p0 = this.dummyPoints[0];
          var p1 = this.dummyPoints[1];
          var p2 = this.dummyPoints[2];
          var p3 = this.dummyPoints[3];
          controlPoint1 = this.calcCurveCP(p0, p1, p2).controlPoint2;
          controlPoint2 = this.calcCurveCP(p1, p2, p3).controlPoint1;
          startPoint = this.dummyPoints[1];
          endPoint = this.dummyPoints[2];
          var minStrokeWidth = 0.5;
          var maxStrokeWidth = 5;
          if (!isNullOrUndefined(this.penStrokeWidth)) {
            minStrokeWidth = maxStrokeWidth = this.penStrokeWidth;
          }
          this.startDraw(context, controlPoint1, controlPoint2, startPoint, endPoint, minStrokeWidth, maxStrokeWidth);
          this.pointCounter++;
          this.dummyPoints.shift();
        }
        if (mouseDown) {
          controlPoint1 = controlPoint2 = startPoint = endPoint = { x, y, time: (/* @__PURE__ */ new Date()).getTime() };
          var minStrokeWidth = 0.5;
          var maxStrokeWidth = 5;
          if (!isNullOrUndefined(this.penStrokeWidth)) {
            minStrokeWidth = maxStrokeWidth = this.penStrokeWidth;
          }
          this.startDraw(context, controlPoint1, controlPoint2, startPoint, endPoint, minStrokeWidth, maxStrokeWidth);
        }
      }
    };
    FreehandDrawing2.prototype.calcCurveCP = function(p1, p2, p3) {
      if (!p2) {
        p2 = p1;
      }
      if (!p3) {
        p3 = p2;
      }
      var dx1 = p1.x - p2.x;
      var dy1 = p1.y - p2.y;
      var dx2 = p2.x - p3.x;
      var dy2 = p2.y - p3.y;
      var m1 = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
      var m2 = { x: (p2.x + p3.x) / 2, y: (p2.y + p3.y) / 2 };
      var l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
      var l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
      var dxm = m1.x - m2.x;
      var dym = m1.y - m2.y;
      var k = l2 / (l1 + l2);
      var cm = { x: m2.x + dxm * k, y: m2.y + dym * k };
      var tx = p2.x - cm.x;
      var ty = p2.y - cm.y;
      return {
        controlPoint1: this.point(m1.x + tx, m1.y + ty, 0),
        controlPoint2: this.point(m2.x + tx, m2.y + ty, 0)
      };
    };
    FreehandDrawing2.prototype.point = function(x, y, time) {
      this.fhdObj.pointX = x;
      this.fhdObj.pointY = y;
      return { x: this.fhdObj.pointX, y: this.fhdObj.pointY, time };
    };
    FreehandDrawing2.prototype.startDraw = function(context, controlPoint1, controlPoint2, startPoint, endPoint, minStrokeWidth, maxStrokeWidth) {
      var tempVelocity;
      tempVelocity = this.pointVelocity(startPoint);
      tempVelocity = 0.7 * tempVelocity + (1 - 0.7) * this.fhdObj.lastVelocity;
      var newWidth = Math.max(maxStrokeWidth / (0.7 + 1), minStrokeWidth);
      this.drawCurve(this.fhdObj.time, newWidth, context, controlPoint1, controlPoint2, startPoint, endPoint, maxStrokeWidth);
      this.fhdObj.lastVelocity = tempVelocity;
      this.fhdObj.time = newWidth;
    };
    FreehandDrawing2.prototype.pointVelocity = function(startPoint) {
      return this.fhdObj.time !== startPoint.time ? this.distanceTo(startPoint) / (this.fhdObj.time - startPoint.time) : 0;
    };
    FreehandDrawing2.prototype.distanceTo = function(start) {
      return Math.sqrt(Math.pow(this.fhdObj.pointX - start.x, 2) + Math.pow(this.fhdObj.pointY - start.y, 2));
    };
    FreehandDrawing2.prototype.drawCurve = function(startWidth, endWidth, context, controlPoint1, controlPoint2, startPoint, endPoint, maxStrokeWidth) {
      var width;
      var i;
      var t1;
      var t2;
      var t3;
      var u1;
      var u2;
      var u3;
      var x;
      var y;
      var widthValue = endWidth - startWidth;
      var bezierLength = this.bezierLength(controlPoint1, controlPoint2, startPoint, endPoint);
      var drawSteps = Math.ceil(bezierLength) * 2;
      context.beginPath();
      for (i = 0; i < drawSteps; i++) {
        t1 = i / drawSteps;
        t2 = t1 * t1;
        t3 = t2 * t1;
        u1 = 1 - t1;
        u2 = u1 * u1;
        u3 = u2 * u1;
        x = u3 * startPoint.x;
        x += 3 * u2 * t1 * controlPoint1.x;
        x += 3 * u1 * t2 * controlPoint2.x;
        x += t3 * endPoint.x;
        y = u3 * startPoint.y;
        y += 3 * u2 * t1 * controlPoint1.y;
        y += 3 * u1 * t2 * controlPoint2.y;
        y += t3 * endPoint.y;
        width = Math.min(startWidth + t3 * widthValue, maxStrokeWidth);
        this.drawArc(x, y, width, context);
      }
      context.closePath();
      context.fill();
    };
    FreehandDrawing2.prototype.bezierLength = function(controlPoint1, controlPoint2, startPoint, endPoint) {
      var steps = 10;
      var length = 0;
      var i;
      var t;
      var pointX1;
      var pointY1;
      var pointX2;
      var pointY2;
      var pointX3;
      var pointY3;
      for (i = 0; i <= steps; i++) {
        t = i / steps;
        pointX1 = this.bezierPoint(t, startPoint.x, controlPoint1.x, controlPoint2.x, endPoint.x);
        pointY1 = this.bezierPoint(t, startPoint.y, controlPoint1.y, controlPoint2.y, endPoint.y);
        if (i > 0) {
          pointX3 = pointX1 - pointX2;
          pointY3 = pointY1 - pointY2;
          length += Math.sqrt(pointX3 * pointX3 + pointY3 * pointY3);
        }
        pointX2 = pointX1;
        pointY2 = pointY1;
      }
      return length;
    };
    FreehandDrawing2.prototype.bezierPoint = function(t, startPoint, cp1, cp2, endPoint) {
      return startPoint * (1 - t) * (1 - t) * (1 - t) + 3 * cp1 * (1 - t) * (1 - t) * t + 3 * cp2 * (1 - t) * t * t + endPoint * t * t * t;
    };
    FreehandDrawing2.prototype.drawArc = function(x, y, size, context) {
      var img = this.parent.img;
      if (x > img.destLeft && y > img.destTop && x < img.destLeft + img.destWidth && y < img.destTop + img.destHeight || context !== this.lowerContext && context !== this.upperContext) {
        context.moveTo(x, y);
        context.arc(x, y, size, 0, 2 * Math.PI, false);
      }
    };
    FreehandDrawing2.prototype.freehandRedraw = function(context, points) {
      var parent = this.parent;
      var temp = context.filter;
      context.filter = "none";
      if (points) {
        parent.pointColl[parent.freehandCounter] = {
          points,
          strokeColor: parent.activeObj.strokeSettings.strokeColor,
          strokeWidth: this.penStrokeWidth,
          flipState: parent.transform.currFlipState,
          id: "pen_" + (parent.freehandCounter + 1),
          order: parent.objColl.length + parent.freehandCounter + 1
        };
        this.selPointColl[parent.freehandCounter] = extend({}, parent.pointColl[parent.freehandCounter], {}, true);
        parent.freehandCounter++;
      }
      if (parent.freehandCounter > 0) {
        for (var n = 0; n < parent.freehandCounter; n++) {
          parent.points = extend([], parent.pointColl[n].points);
          this.pointCounter = 0;
          var len = parent.points.length;
          var controlPoint1 = undefined;
          var controlPoint2 = undefined;
          var startPoint = undefined;
          var endPoint = undefined;
          var minStrokeWidth = undefined;
          var maxStrokeWidth = undefined;
          if (len > 0) {
            context.fillStyle = parent.pointColl[n].strokeColor;
            minStrokeWidth = maxStrokeWidth = this.penStrokeWidth = parent.pointColl[n].strokeWidth;
          }
          if (len === 1) {
            controlPoint1 = controlPoint2 = startPoint = endPoint = parent.points[0];
            this.startDraw(context, controlPoint1, controlPoint2, startPoint, endPoint, minStrokeWidth, maxStrokeWidth);
          }
          for (var l = 0; l < len - 3; l++) {
            if (parent.points[l + 1] && parent.points[l + 2] && parent.points[l + 2]) {
              controlPoint1 = this.calcCurveCP(parent.points[l + 0], parent.points[l + 1], parent.points[l + 2]).controlPoint2;
              controlPoint2 = this.calcCurveCP(parent.points[l + 1], parent.points[l + 2], parent.points[l + 3]).controlPoint1;
              if (l === 0) {
                startPoint = parent.points[l];
              } else {
                startPoint = parent.points[l + 1];
              }
              endPoint = parent.points[l + 2];
              this.startDraw(context, controlPoint1, controlPoint2, startPoint, endPoint, minStrokeWidth, maxStrokeWidth);
            }
          }
          context.closePath();
        }
        if (context === this.lowerContext) {
          parent.notify("draw", { prop: "applyFrame", value: { ctx: this.lowerContext, frame: parent.frameObj.type, preventImg: true } });
          this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        }
      }
      context.filter = temp;
    };
    FreehandDrawing2.prototype.getSqPtFD = function(idx, obj) {
      var activePoint = { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 };
      var sPoints = extend([], this.selPointColl[idx].points, []);
      this.parent.points = extend([], this.parent.pointColl[idx].points);
      this.pointCounter = 0;
      var len = sPoints.length;
      for (var l = 0; l < len; l++) {
        if (activePoint.startX === 0 && activePoint.startY === 0 && activePoint.endX === 0 && activePoint.endY === 0) {
          activePoint.startX = sPoints[l].x;
          activePoint.startY = sPoints[l].y;
          activePoint.endX = sPoints[l].x;
          activePoint.endY = sPoints[l].y;
        } else {
          activePoint.startX = Math.min(activePoint.startX, sPoints[l].x);
          activePoint.startY = Math.min(activePoint.startY, sPoints[l].y);
          activePoint.endX = Math.max(activePoint.endX, sPoints[l].x);
          activePoint.endY = Math.max(activePoint.endY, sPoints[l].y);
        }
      }
      activePoint.startX -= this.penStrokeWidth;
      activePoint.startY -= this.penStrokeWidth;
      activePoint.endX += this.penStrokeWidth;
      activePoint.endY += this.penStrokeWidth;
      activePoint.width = activePoint.endX - activePoint.startX;
      activePoint.height = activePoint.endY - activePoint.startY;
      if (obj) {
        obj["activePoint"] = activePoint;
      }
      return activePoint;
    };
    FreehandDrawing2.prototype.applyPenDraw = function() {
      var parent = this.parent;
      if (parent.currObjType.shape === "freehanddraw") {
        parent.notify("shape", { prop: "apply", onPropertyChange: false, value: { shape: null, obj: null, canvas: null } });
        parent.upperCanvas.style.cursor = parent.cursor = "default";
        parent.currObjType.shape = "";
      }
      parent.notify("shape", { prop: "clearActObj" });
    };
    FreehandDrawing2.prototype.applyFhd = function() {
      var parent = this.parent;
      var selectedPoint = parent.pointColl[this.fhdSelIdx];
      if (selectedPoint.strokeColor === "#42a5f5") {
        selectedPoint.strokeColor = this.tempFHDStyles.strokeColor;
      }
      parent.notify("toolbar", { prop: "setSelectedFreehandColor", value: { color: "#42a5f5" } });
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null } });
      parent.notify("toolbar", { prop: "refresh-main-toolbar", onPropertyChange: false });
      if (selectedPoint) {
        selectedPoint.isSelected = false;
      }
      parent.notify("selection", { prop: "resetFreehandDrawVariables" });
      this.fhdHovIdx = this.fhdSelIdx = null;
    };
    FreehandDrawing2.prototype.cancelFhd = function() {
      var parent = this.parent;
      var selectedPoint = parent.pointColl[this.fhdSelIdx];
      parent.notify("toolbar", { prop: "setSelectedFreehandColor", value: { color: "#42a5f5" } });
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      this.lowerContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      this.pointCounter = 0;
      if (selectedPoint) {
        selectedPoint.strokeColor = this.tempFHDStyles.strokeColor;
        selectedPoint.strokeWidth = this.tempFHDStyles.strokeWidth;
        selectedPoint.isSelected = false;
      }
      this.fhdHovIdx = this.fhdSelIdx = this.fhdSelID = null;
      parent.notify("selection", { prop: "resetFreehandDrawVariables" });
      parent.activeObj.strokeSettings.strokeColor = this.tempFHDStyles.strokeColor;
      parent.activeObj.strokeSettings.strokeWidth = this.penStrokeWidth = this.tempFHDStyles.strokeWidth;
      this.tempFHDStyles = { strokeColor: null, strokeWidth: null, fillColor: null };
      parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null } });
      parent.notify("toolbar", { prop: "refresh-main-toolbar", onPropertyChange: false });
    };
    FreehandDrawing2.prototype.selectFhd = function(index) {
      var parent = this.parent;
      var tempFHDStyles = extend({}, this.tempFHDStyles, {}, true);
      parent.notify("selection", { prop: "setFreehandDrawEditing", onPropertyChange: false, value: { bool: true } });
      if (index || index === 0) {
        if (this.isFHDIdx(index)) {
          this.fhdSelIdx = this.fhdHovIdx = index;
          this.hoverFhd();
          parent.upperCanvas.style.cursor = parent.cursor = "pointer";
        } else {
          return;
        }
      }
      this.fhdSelIdx = this.fhdHovIdx;
      var point = parent.pointColl[this.fhdSelIdx];
      point.isSelected = true;
      this.fhdSelID = point.id;
      if (point.strokeColor !== "#42a5f5") {
        parent.activeObj.strokeSettings.strokeColor = this.tempFHDStyles.strokeColor = point.strokeColor;
      }
      parent.activeObj.strokeSettings.strokeWidth = this.tempFHDStyles.strokeWidth = parent.pointColl[this.fhdHovIdx].strokeWidth;
      var obj = { bool: false };
      parent.notify("selection", { prop: "getFreehandDrawEditing", onPropertyChange: false, value: { obj } });
      if (obj["bool"]) {
        var shapeSettings = {
          id: "pen_" + (this.fhdSelIdx + 1),
          type: ShapeType.FreehandDraw,
          startX: point.points[0].x,
          startY: point.points[0].y,
          strokeColor: point.strokeColor,
          strokeWidth: point.strokeWidth,
          points: point.points,
          opacity: point.opacity,
          index: point.order
        };
        var shapeChangingArgs = {
          cancel: false,
          action: "select",
          previousShapeSettings: shapeSettings,
          currentShapeSettings: shapeSettings
        };
        this.triggerShapeChanging(shapeChangingArgs);
      } else {
        parent.okBtn(null, true);
      }
      if (parent.isUndoRedoStack) {
        this.tempFHDStyles = tempFHDStyles;
      }
    };
    FreehandDrawing2.prototype.deleteFhd = function(index, isId) {
      var parent = this.parent;
      if (this.isFHDIdx(index)) {
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        var tempPointColl = extend({}, parent.pointColl, {}, true);
        var tempSelPointColl = extend({}, this.selPointColl, {}, true);
        parent.pointColl = {};
        this.selPointColl = {};
        var count = 0;
        for (var i = 0; i < parent.freehandCounter; i++) {
          if (parseInt(tempPointColl[i].id.split("_")[1], 10) - 1 !== index) {
            parent.pointColl[count] = tempPointColl[i];
            this.selPointColl[count] = tempSelPointColl[i];
            count++;
          }
        }
        parent.freehandCounter -= 1;
        this.fhdHovIdx = this.fhdSelIdx = null;
        parent.notify("selection", { prop: "resetFreehandDrawVariables" });
        parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null } });
        parent.notify("toolbar", { prop: "refresh-main-toolbar", onPropertyChange: false });
      }
    };
    FreehandDrawing2.prototype.zoomX = function(x) {
      return x * this.parent.img.destWidth + this.parent.img.destLeft;
    };
    FreehandDrawing2.prototype.zoomY = function(y) {
      return y * this.parent.img.destHeight + this.parent.img.destTop;
    };
    FreehandDrawing2.prototype.zoomFHDColl = function(isPreventApply) {
      var parent = this.parent;
      var destPoints = {
        startX: parent.img.destLeft,
        startY: parent.img.destTop,
        width: parent.img.destWidth,
        height: parent.img.destHeight
      };
      parent.notify("shape", { prop: "straightenShapes", onPropertyChange: false });
      for (var n = 0; n < parent.freehandCounter; n++) {
        parent.points = extend([], parent.pointColl[n].points, []);
        this.pointCounter = 0;
        var len = parent.points.length;
        for (var l = 0; l < len; l++) {
          var point = parent.points[l];
          point.x = this.zoomX(point.ratioX);
          point.y = this.zoomY(point.ratioY);
        }
      }
      this.updateFHDCurPts();
      if (this.straightenPoint.x && this.straightenPoint.y) {
        this.straightenPoint.x = this.zoomX(this.straightenPoint.ratioX);
        this.straightenPoint.y = this.zoomY(this.straightenPoint.ratioY);
      }
      if (parent.transform.straighten !== 0) {
        parent.notify("shape", { prop: "straightenFHD", onPropertyChange: false });
      }
      parent.img.destLeft = destPoints.startX;
      parent.img.destTop = destPoints.startY;
      parent.img.destWidth = destPoints.width;
      parent.img.destHeight = destPoints.height;
      if (isNullOrUndefined(isPreventApply)) {
        this.freehandRedraw(this.lowerContext, null);
      }
    };
    FreehandDrawing2.prototype.updateFHDCurPts = function() {
      var parent = this.parent;
      for (var n = 0; n < parent.freehandCounter; n++) {
        if (this.selPointColl[n]) {
          this.selPoints = extend([], this.selPointColl[n].points, []);
          this.pointCounter = 0;
          var len = this.selPoints.length;
          for (var l = 0; l < len; l++) {
            var point = this.selPoints[l];
            point.x = this.zoomX(point.ratioX);
            point.y = this.zoomY(point.ratioY);
          }
        }
      }
    };
    FreehandDrawing2.prototype.rotateFhdColl = function() {
      var parent = this.parent;
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      for (var n = 0; n < parent.freehandCounter; n++) {
        parent.points = extend([], parent.pointColl[n].points, []);
        this.pointCounter = 0;
        var len = parent.points.length;
        for (var l = 0; l < len; l++) {
          var point = parent.points[l];
          point.y = destTop + destHeight * point.ratioX;
          point.x = destLeft + destWidth - destWidth * point.ratioY;
          point.ratioX = (point.x - destLeft) / destWidth;
          point.ratioY = (point.y - destTop) / destHeight;
        }
      }
      for (var n = 0; n < parent.freehandCounter; n++) {
        if (this.selPointColl[n]) {
          this.selPoints = extend([], this.selPointColl[n].points, []);
          this.pointCounter = 0;
          var len = this.selPoints.length;
          for (var l = 0; l < len; l++) {
            var point = this.selPoints[l];
            point.y = destTop + destHeight * point.ratioX;
            point.x = destLeft + destWidth - destWidth * point.ratioY;
            point.ratioX = (point.x - destLeft) / destWidth;
            point.ratioY = (point.y - destTop) / destHeight;
          }
        }
      }
      this.updateFHDCurPts();
    };
    FreehandDrawing2.prototype.flipFHDColl = function(value) {
      var lowercaseValue = value.toLowerCase();
      if (lowercaseValue === "horizontal") {
        this.pointsHorizontalFlip();
      } else if (lowercaseValue === "vertical") {
        this.pointsVerticalFlip();
      } else {
        this.pointsHorizontalFlip();
        for (var i = 0; i < this.parent.freehandCounter; i++) {
          this.parent.pointColl[i].shapeFlip = "";
        }
        this.pointsVerticalFlip();
      }
    };
    FreehandDrawing2.prototype.pointsHorizontalFlip = function() {
      var parent = this.parent;
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      for (var n = 0; n < parent.freehandCounter; n++) {
        if (parent.pointColl[n].shapeFlip !== parent.transform.currFlipState) {
          parent.points = extend([], parent.pointColl[n].points, []);
          this.pointCounter = 0;
          var len = parent.points.length;
          for (var l = 0; l < len; l++) {
            var point = parent.points[l];
            if (point.x <= destLeft + destWidth / 2) {
              point.x = destLeft + destWidth - (point.x - destLeft);
            } else if (point.x >= destLeft + destWidth / 2) {
              point.x = destLeft + (destLeft + destWidth - point.x);
            }
            point.ratioX = (point.x - destLeft) / destWidth;
            point.ratioY = (point.y - destTop) / destHeight;
          }
          parent.pointColl[n].shapeFlip = parent.transform.currFlipState;
        }
      }
      for (var n = 0; n < parent.freehandCounter; n++) {
        if (this.selPointColl[n]) {
          if (this.selPointColl[n].shapeFlip !== parent.transform.currFlipState) {
            this.selPoints = extend([], this.selPointColl[n].points, []);
            this.pointCounter = 0;
            var len = this.selPoints.length;
            for (var l = 0; l < len; l++) {
              var point = this.selPoints[l];
              if (point.x <= destLeft + destWidth / 2) {
                point.x = destLeft + destWidth - (point.x - destLeft);
              } else if (point.x >= destLeft + destWidth / 2) {
                point.x = destLeft + (destLeft + destWidth - point.x);
              }
              point.ratioX = (point.x - destLeft) / destWidth;
              point.ratioY = (point.y - destTop) / destHeight;
            }
          }
        }
      }
      this.updateFHDCurPts();
    };
    FreehandDrawing2.prototype.pointsVerticalFlip = function() {
      var parent = this.parent;
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      for (var n = 0; n < parent.freehandCounter; n++) {
        if (parent.pointColl[n].shapeFlip !== parent.transform.currFlipState) {
          parent.points = extend([], parent.pointColl[n].points, []);
          this.pointCounter = 0;
          var len = parent.points.length;
          for (var l = 0; l < len; l++) {
            var point = parent.points[l];
            if (point.y <= destTop + destHeight / 2) {
              point.y = destTop + destHeight - (point.y - destTop);
            } else if (point.y >= destTop + destHeight / 2) {
              point.y = destTop + (destTop + destHeight - point.y);
            }
            point.ratioX = (point.x - destLeft) / destWidth;
            point.ratioY = (point.y - destTop) / destHeight;
          }
          parent.pointColl[n].shapeFlip = parent.transform.currFlipState;
        }
      }
      for (var n = 0; n < parent.freehandCounter; n++) {
        if (this.selPointColl[n]) {
          if (this.selPointColl[n].shapeFlip !== parent.transform.currFlipState) {
            this.selPoints = extend([], this.selPointColl[n].points, []);
            this.pointCounter = 0;
            var len = this.selPoints.length;
            for (var l = 0; l < len; l++) {
              var point = this.selPoints[l];
              if (point.y <= destTop + destHeight / 2) {
                point.y = destTop + destHeight - (point.y - destTop);
              } else if (point.y >= destTop + destHeight / 2) {
                point.y = destTop + (destTop + destHeight - point.y);
              }
              point.ratioX = (point.x - destLeft) / destWidth;
              point.ratioY = (point.y - destTop) / destHeight;
            }
          }
        }
      }
      this.updateFHDCurPts();
    };
    FreehandDrawing2.prototype.updateFHDColl = function(isPreventApply) {
      var parent = this.parent;
      var destPoints = {
        startX: parent.img.destLeft,
        startY: parent.img.destTop,
        width: parent.img.destWidth,
        height: parent.img.destHeight
      };
      parent.notify("shape", { prop: "straightenShapes", onPropertyChange: false });
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      for (var i = 0, iLen = parent.objColl.length; i < iLen; i++) {
        var currObj = parent.objColl[i];
        if (currObj.shape === "line" || currObj.shape === "arrow") {
          parent.notify("shape", { prop: "straightenShapePoints", value: { obj: currObj, isReverse: true } });
        } else if (currObj.shape === "path") {
          var temp = parent.transform.straighten;
          parent.transform.straighten = -parent.transform.straighten;
          parent.notify("shape", { prop: "straightenPath", onPropertyChange: false, value: { obj: currObj } });
          parent.transform.straighten = temp;
        }
        currObj.imageRatio = {
          startX: (currObj.activePoint.startX - destLeft) / destWidth,
          startY: (currObj.activePoint.startY - destTop) / destHeight,
          endX: (currObj.activePoint.endX - destLeft) / destWidth,
          endY: (currObj.activePoint.endY - destTop) / destHeight,
          width: destWidth / currObj.activePoint.width,
          height: destHeight / currObj.activePoint.height
        };
        if (currObj.shape === "path") {
          for (var j = 0, jLen = currObj.pointColl.length; j < jLen; j++) {
            currObj.pointColl[j].ratioX = (currObj.pointColl[j].x - destLeft) / destWidth;
            currObj.pointColl[j].ratioY = (currObj.pointColl[j].y - destTop) / destHeight;
          }
        }
        parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      }
      if (parent.freehandCounter > 0 && parent.transform.straighten !== 0) {
        var temp = parent.transform.straighten;
        parent.transform.straighten = -parent.transform.straighten;
        parent.notify("shape", { prop: "straightenFHD", onPropertyChange: false });
        parent.transform.straighten = temp;
      }
      for (var n = 0; n < parent.freehandCounter; n++) {
        parent.points = extend([], parent.pointColl[n].points, []);
        this.pointCounter = 0;
        var len = parent.points.length;
        for (var l = 0; l < len; l++) {
          var point = parent.points[l];
          point.ratioX = (point.x - destLeft) / destWidth;
          point.ratioY = (point.y - destTop) / destHeight;
        }
      }
      for (var n = 0; n < parent.freehandCounter; n++) {
        if (this.selPointColl[n]) {
          this.selPoints = extend([], this.selPointColl[n].points, []);
          this.pointCounter = 0;
          var len = this.selPoints.length;
          for (var l = 0; l < len; l++) {
            var point = this.selPoints[l];
            point.ratioX = (point.x - destLeft) / destWidth;
            point.ratioY = (point.y - destTop) / destHeight;
          }
        }
      }
      if (this.straightenPoint.x && this.straightenPoint.y) {
        this.straightenPoint.ratioX = (this.straightenPoint.x - destLeft) / destWidth;
        this.straightenPoint.ratioY = (this.straightenPoint.y - destTop) / destHeight;
      }
      parent.img.destLeft = destPoints.startX;
      parent.img.destTop = destPoints.startY;
      parent.img.destWidth = destPoints.width;
      parent.img.destHeight = destPoints.height;
      parent.notify("shape", {
        prop: "drawAnnotations",
        onPropertyChange: false,
        value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply }
      });
    };
    FreehandDrawing2.prototype.panFHDColl = function(xDiff, yDiff, panRegion) {
      var parent = this.parent;
      for (var n = 0; n < parent.freehandCounter; n++) {
        parent.points = extend([], parent.pointColl[n].points, []);
        this.pointCounter = 0;
        var len = parent.points.length;
        for (var l = 0; l < len; l++) {
          var point = parent.points[l];
          if (panRegion === "" || panRegion === "vertical") {
            point.x += xDiff;
          } else {
            point.x -= xDiff;
          }
          if (panRegion === "" || panRegion === "horizontal") {
            point.y += yDiff;
          } else {
            point.y -= yDiff;
          }
        }
      }
      for (var n = 0; n < parent.freehandCounter; n++) {
        if (this.selPointColl[n]) {
          this.selPoints = extend([], this.selPointColl[n].points, []);
          this.pointCounter = 0;
          var len = this.selPoints.length;
          for (var l = 0; l < len; l++) {
            var point = this.selPoints[l];
            if (panRegion === "" || panRegion === "vertical") {
              point.x += xDiff;
            } else {
              point.x -= xDiff;
            }
            if (panRegion === "" || panRegion === "horizontal") {
              point.y += yDiff;
            } else {
              point.y -= yDiff;
            }
          }
        }
      }
      if (this.straightenPoint.x && this.straightenPoint.y) {
        if (panRegion === "" || panRegion === "vertical") {
          this.straightenPoint.x += xDiff;
        } else {
          this.straightenPoint.x -= xDiff;
        }
        if (panRegion === "" || panRegion === "horizontal") {
          this.straightenPoint.y += yDiff;
        } else {
          this.straightenPoint.y -= yDiff;
        }
      }
      this.freehandRedraw(this.lowerContext, null);
    };
    FreehandDrawing2.prototype.freeHandDraw = function(value) {
      var parent = this.parent;
      if (value) {
        parent.points = [];
        this.dummyPoints = [];
        parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        parent.togglePen = true;
        parent.upperCanvas.style.cursor = parent.cursor = "crosshair";
        parent.upperCanvas.style.display = "block";
        if (isNullOrUndefined(parent.activeObj.strokeSettings)) {
          var obj = { strokeSettings: {} };
          parent.notify("shape", {
            prop: "getStrokeSettings",
            onPropertyChange: false,
            value: { obj }
          });
          parent.activeObj.strokeSettings = obj["strokeSettings"];
        }
        if (isNullOrUndefined(parent.activeObj.strokeSettings.strokeWidth)) {
          parent.activeObj.strokeSettings.strokeWidth = 2;
        }
        if (parent.isMaskImage) {
          parent.notify("toolbar", { prop: "refresh-main-toolbar", onPropertyChange: false });
        } else {
          parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
            type: "pen",
            isApplyBtn: null,
            isCropping: null,
            isZooming: null,
            cType: null
          } });
        }
      } else {
        parent.upperCanvas.style.cursor = parent.cursor = "default";
        var strokeWidth = this.penStrokeWidth;
        parent.notify("shape", { prop: "apply", onPropertyChange: false, value: { shape: null, obj: null, canvas: null } });
        parent.notify("toolbar", { prop: "refresh-main-toolbar", onPropertyChange: false });
        parent.notify("toolbar", { prop: "setCurrentToolbar", value: { type: "main" } });
        parent.notify("selection", { prop: "setFreehandDrawCustomized", value: { isFreehandDrawCustomized: false } });
        this.penStrokeWidth = strokeWidth;
      }
    };
    FreehandDrawing2.prototype.isFHDIdx = function(index, obj) {
      var isIndex = false;
      for (var i = 0; i < this.parent.freehandCounter; i++) {
        if (this.parent.pointColl[i].id && parseInt(this.parent.pointColl[i].id.split("_")[1], 10) - 1 === index) {
          isIndex = true;
          break;
        }
      }
      if (obj) {
        obj["isIndex"] = isIndex;
      }
      return isIndex;
    };
    FreehandDrawing2.prototype.updateCropPtsForSel = function() {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      for (var n = 0; n < parent.freehandCounter; n++) {
        var obj = { selPointColl: extend([], this.selPointColl) };
        if (obj["selPointColl"][n]) {
          this.selPoints = extend([], obj["selPointColl"][n].points, []);
          this.pointCounter = 0;
          var len = this.selPoints.length;
          for (var l = 0; l < len; l++) {
            var point = this.selPoints[l];
            point.ratioX = (point.x - actPoint.startX) / actPoint.width;
            point.ratioY = (point.y - actPoint.startY) / actPoint.height;
          }
        }
      }
    };
    FreehandDrawing2.prototype.triggerShapeChanging = function(shapeChangingArgs) {
      var parent = this.parent;
      var point = parent.pointColl[this.fhdSelIdx];
      parent.trigger("shapeChanging", shapeChangingArgs);
      if (parent.element.getAttribute("data-value") === "mask-drawing" && !this.isMasking) {
        this.isMasking = true;
        parent.upperCanvas.style.cursor = "crosshair";
        parent.notify("draw", { prop: "updateTempObjColl" });
        parent.notify("draw", { prop: "updateTempPointColl" });
        parent.discard();
        parent.selectMaskImage();
        return;
      }
      parent.editCompleteArgs = shapeChangingArgs;
      if (shapeChangingArgs.currentShapeSettings.id.indexOf("pen_") === -1 && (shapeChangingArgs.action === "draw-end" || shapeChangingArgs.action === "select")) {
        var id = "pen_" + shapeChangingArgs.currentShapeSettings.id;
        if (this.fhdSelIdx) {
          parent.pointColl[this.fhdSelIdx].id = id;
        } else {
          parent.pointColl[parent.freehandCounter - 1].id = id;
        }
      }
      this.penStrokeWidth = shapeChangingArgs.currentShapeSettings.strokeWidth;
      if (parent.activeObj.strokeSettings.strokeColor !== shapeChangingArgs.currentShapeSettings.strokeColor) {
        parent.activeObj.strokeSettings.strokeColor = shapeChangingArgs.currentShapeSettings.strokeColor;
        parent.notify("toolbar", { prop: "update-toolbar-items", onPropertyChange: false });
      }
      if (this.fhdSelID && point && shapeChangingArgs.currentShapeSettings) {
        point.strokeColor = shapeChangingArgs.currentShapeSettings.strokeColor;
        point.strokeWidth = shapeChangingArgs.currentShapeSettings.strokeWidth;
        point.points = shapeChangingArgs.currentShapeSettings.points;
        point.opacity = shapeChangingArgs.currentShapeSettings.opacity;
      }
      if (shapeChangingArgs.action === "select") {
        this.freehandRedraw(this.upperContext);
        parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
          type: "pen",
          isApplyBtn: null,
          isCropping: null,
          isZooming: null,
          cType: null
        } });
      }
    };
    FreehandDrawing2.prototype.setCenterSelPoints = function() {
      var parent = this.parent;
      var destPoints = {
        startX: parent.img.destLeft,
        startY: parent.img.destTop,
        width: parent.img.destWidth,
        height: parent.img.destHeight
      };
      parent.notify("shape", { prop: "straightenShapes", onPropertyChange: false });
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      var actPoint = parent.activeObj.activePoint;
      if (isNullOrUndefined(this.prevStraightenObj) || JSON.stringify(this.prevStraightenObj.activePoint) !== JSON.stringify(actPoint)) {
        this.straightenPoint = {
          x: actPoint.startX + actPoint.width / 2,
          y: actPoint.startY + actPoint.height / 2,
          ratioX: (actPoint.startX + actPoint.width / 2 - destLeft) / destWidth,
          ratioY: (actPoint.startY + actPoint.height / 2 - destTop) / destHeight
        };
        this.prevStraightenObj = extend({}, parent.activeObj, {}, true);
        this.straightenPointAngle = parent.transform.straighten;
      }
      parent.img.destLeft = destPoints.startX;
      parent.img.destTop = destPoints.startY;
      parent.img.destWidth = destPoints.width;
      parent.img.destHeight = destPoints.height;
    };
    return FreehandDrawing2;
  }()
);
var Selection = (
  /** @class */
  function() {
    function Selection2(parent) {
      this.diffPoint = { x: 0, y: 0 };
      this.oldPoint = {};
      this.isTouch = false;
      this.isObjSelected = false;
      this.isFhdPoint = false;
      this.dragPoint = { startX: 0, startY: 0, endX: 0, endY: 0 };
      this.isShapeInserted = false;
      this.tempActiveObj = {
        activePoint: { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 },
        flipObjColl: [],
        triangle: [],
        triangleRatio: [],
        order: null
      };
      this.isFirstMove = false;
      this.startTouches = [];
      this.tempTouches = [];
      this.currMousePoint = { x: 0, y: 0 };
      this.cursorTargetId = "";
      this.isPreventDragging = false;
      this.dragElement = "";
      this.textRow = 1;
      this.mouseDownPoint = { x: 0, y: 0 };
      this.previousPoint = { x: 0, y: 0 };
      this.zoomType = "Toolbar";
      this.isInitialTextEdited = false;
      this.dragCanvas = false;
      this.isFhdCustomized = false;
      this.touchEndPoint = {};
      this.isFhdEditing = false;
      this.currentDrawingShape = "";
      this.initialPrevObj = {};
      this.touchTime = 0;
      this.resizedElement = "";
      this.isImageClarity = true;
      this.isPinching = false;
      this.isSliding = false;
      this.mouseDown = "";
      this.isSliderActive = false;
      this.arrowShape = [ArrowheadType.None, ArrowheadType.SolidArrow];
      this.isTouchDblClick = false;
      this.isMouseDown = false;
      this.isMouseUp = false;
      this.mouseWheel = 0;
      this.isTransformedShape = false;
      this.parent = parent;
      this.addEventListener();
    }
    Selection2.prototype.destroy = function() {
      if (this.parent.isDestroyed) {
        return;
      }
      this.removeEventListener();
    };
    Selection2.prototype.addEventListener = function() {
      this.parent.on("selection", this.selection, this);
      this.parent.on("destroyed", this.destroy, this);
    };
    Selection2.prototype.removeEventListener = function() {
      this.parent.off("selection", this.selection);
      this.parent.off("destroyed", this.destroy);
    };
    Selection2.prototype.selection = function(args) {
      var parent = this.parent;
      this.updatePrivateVariables();
      switch (args.prop) {
        case "setCursor":
          this.setCursor(args.value["x"], args.value["y"]);
          break;
        case "updateActivePoint":
          this.updateActivePoint(args.value["x"], args.value["y"], args.value["isCropSelection"]);
          break;
        case "updateCursorStyles":
          this.updateCursorStyles(args.value["x"], args.value["y"], args.value["type"]);
          break;
        case "setTextSelection":
          this.setTextSelection(args.value["width"], args.value["height"]);
          break;
        case "setActivePoint":
          this.setActivePoint(args.value["startX"], args.value["startY"]);
          break;
        case "clearSelection":
          this.clearSelection(args.value["resetCrop"]);
          break;
        case "calcShapeRatio":
          this.calcShapeRatio(args.value["x"], args.value["y"], args.value["imgWidth"], args.value["imgHeight"]);
          break;
        case "tab":
          this.performTabAction();
          break;
        case "setDragDirection":
          this.setDragDirection(args.value["width"], args.value["height"]);
          break;
        case "clearUpperCanvas":
          if (this.isTouch) {
            setTimeout(function() {
              parent.upperCanvas.getContext("2d").clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            }, 550);
          }
          break;
        case "resetFreehandDrawVariables":
          this.isFhdEditing = this.isFhdPoint = false;
          break;
        case "isShapeInserted":
          this.isShapeInserted = args.value["bool"];
          break;
        case "redrawShape":
          this.redrawShape(args.value["obj"]);
          break;
        case "setTextBoxStylesToActObj":
          this.setTextBoxStylesToActObj();
          break;
        case "mouseDownEventHandler":
          this.mouseDownEventHandler(args.value["e"]);
          break;
        case "mouseMoveEventHandler":
          this.mouseMoveEventHandler(args.value["e"]);
          break;
        case "mouseUpEventHandler":
          this.mouseUpEventHandler(args.value["e"]);
          break;
        case "canvasMouseDownHandler":
          this.canvasMouseDownHandler(args.value["e"]);
          break;
        case "canvasMouseMoveHandler":
          this.canvasMouseMoveHandler(args.value["e"]);
          break;
        case "canvasMouseUpHandler":
          this.canvasMouseUpHandler(args.value["e"]);
          break;
        case "touchStartHandler":
          this.touchStartHandler(args.value["e"]);
          break;
        case "keyDownEventHandler":
          this.keyDownEventHandler(args.value["e"]);
          break;
        case "handleScroll":
          this.handleScroll(args.value["e"]);
          break;
        case "textKeyDown":
          setTimeout(this.textKeyDown.bind(this), 1, args.value["e"]);
          break;
        case "deleteItem":
          this.deleteItem();
          break;
        case "updatePrevShapeSettings":
          this.updatePrevShapeSettings(args.value["obj"]);
          break;
        case "getZoomType":
          args.value["obj"]["zoomType"] = this.zoomType;
          break;
        case "setZoomType":
          this.zoomType = args.value["zoomType"];
          break;
        case "setInitialTextEdit":
          this.isInitialTextEdited = args.value["bool"];
          break;
        case "setDragCanvas":
          this.dragCanvas = args.value["bool"];
          break;
        case "setFreehandDrawCustomized":
          this.isFhdCustomized = args.value["isFreehandDrawCustomized"];
          break;
        case "setTouchEndPoint":
          this.touchEndPoint.x = args.value["x"];
          this.touchEndPoint.y = args.value["y"];
          break;
        case "getPanDown":
          args.value["obj"]["panDown"] = this.panDown;
          break;
        case "setPanDown":
          this.panDown = args.value["panDown"];
          break;
        case "getFreehandDrawEditing":
          args.value["obj"]["bool"] = this.isFhdEditing;
          break;
        case "setFreehandDrawEditing":
          this.isFhdEditing = args.value["bool"];
          break;
        case "getTempActObj":
          args.value["obj"]["tempObj"] = this.tempActiveObj;
          break;
        case "setTempActObj":
          this.tempActiveObj = args.value["obj"];
          break;
        case "isInside":
          this.isInside(args.value["x"], args.value["y"], args.value["z1"], args.value["z2"], args.value["z3"], args.value["z4"]);
          break;
        case "setDragElement":
          this.dragElement = args.value["value"];
          break;
        case "setObjSelected":
          this.isObjSelected = args.value["bool"];
          break;
        case "adjustActObjForLineArrow":
          this.adjustActObjForLineArrow(args.value["obj"]);
          break;
        case "findTarget":
          this.findTarget(args.value["x"], args.value["y"], args.value["type"]);
          break;
        case "getCurrentFlipState":
          this.getCurrentFlipState();
          break;
        case "setDragWidth":
          this.setDragWidth(args.value["width"]);
          break;
        case "setDragHeight":
          this.setDragHeight(args.value["setDragHeight"]);
          break;
        case "annotate":
          this.currentDrawingShape = args.value["shape"];
          if (args.value["shape"] === "text") {
            parent.activeObj.textSettings.fontSize = 11;
            parent.activeObj.keyHistory = "Enter Text";
            parent.notify("shape", {
              prop: "initializeTextShape",
              onPropertyChange: false,
              value: { text: null, fontFamily: null, fontSize: null, bold: null, italic: null, strokeColor: null }
            });
          } else if (args.value["shape"] === "path") {
            parent.activeObj.pointColl = [];
          }
          break;
        case "getCurrentDrawingShape":
          args.value["obj"]["shape"] = this.currentDrawingShape;
          break;
        case "setCurrentDrawingShape":
          this.currentDrawingShape = args.value["value"];
          break;
        case "getTransRotationPoint":
          this.getTransRotationPoint(args.value["obj"], args.value["object"]);
          break;
        case "adjustNEPoints":
          this.adjustNEPoints(args.value["rectangle"], args.value["x"], args.value["y"], args.value["angle"]);
          break;
        case "adjustRotationPoints":
          this.adjustRotationPoints(args.value["rectangle"], args.value["x"], args.value["y"], args.value["angle"], args.value["type"], args.value["elem"]);
          break;
        case "getResizeDirection":
          this.getResizeDirection(args.value["rectangle"], args.value["x"], args.value["y"], args.value["angle"]);
          break;
        case "setResizedElement":
          this.resizedElement = args.value["value"];
          break;
        case "reset":
          this.reset();
          break;
        case "unWireEvent":
          this.unwireEvent();
          break;
        case "updPtCollForShpRot":
          this.updPtCollForShpRot(args.value["obj"]);
          break;
        case "findImageRatio":
          this.findImageRatio(args.value["width"], args.value["height"], args.value["obj"]);
          break;
        case "getNumTextValue":
          this.getNumTextValue(args.value["obj"]);
          break;
        case "setImageClarity":
          this.isImageClarity = args.value["bool"];
          break;
        case "upgradeImageQuality":
          this.upgradeImageQuality();
          break;
        case "triggerShapeChange":
          this.triggerShapeChange(args.value["shapeResizingArgs"], args.value["shapeMovingArgs"], args.value["type"]);
          break;
        case "applyTransformToImg":
          this.applyTransformToImg(args.value["ctx"]);
          break;
        case "findTargetObj":
          args.value["obj"]["bool"] = this.findTargetObj(args.value["x"], args.value["y"], args.value["isCrop"]);
          break;
        case "setSliding":
          this.isSliding = args.value["bool"];
          break;
        case "setSliderActive":
          this.isSliderActive = args.value["bool"];
          break;
        case "getArrowType":
          args.value["obj"]["type"] = this.getArrowType(args.value["type"]);
          break;
        case "setArrowShape":
          if (args.value["type"] === "initial") {
            this.arrowShape[0] = args.value["shape"];
          } else {
            this.arrowShape[1] = args.value["shape"];
          }
          break;
        case "updateNWPoints":
          this.updateNWPoints(args.value["x"], args.value["y"]);
          break;
        case "updateNPoints":
          this.updateNPoints(args.value["x"], args.value["y"]);
          break;
        case "updateNEPoints":
          this.updateNEPoints(args.value["x"], args.value["y"]);
          break;
        case "updateWPoints":
          this.updateWPoints(args.value["x"], args.value["y"]);
          break;
        case "updateEPoints":
          this.updateEPoints(args.value["x"], args.value["y"]);
          break;
        case "updateSWPoints":
          this.updateSWPoints(args.value["x"], args.value["y"]);
          break;
        case "updateSPoints":
          this.updateSPoints(args.value["x"], args.value["y"]);
          break;
        case "updateSEPoints":
          this.updateSEPoints(args.value["x"], args.value["y"]);
          break;
        case "drawMaskCircle":
          this.drawMaskCircle(args.value["x"], args.value["y"]);
          break;
        case "isValueUpdated":
          this.isValueUpdated();
          break;
        case "getDistance":
          this.getDistance(args.value["x"], args.value["y"]);
          break;
        case "redact":
          this.currentDrawingShape = args.value["shape"];
          break;
        case "updateTransColl":
          args.value["obj"]["coll"] = this.updateTransColl(args.value["object"]);
          break;
        case "getTransformedShape":
          args.value["obj"]["bool"] = this.isTransformedShape;
          break;
        case "setTransformedShape":
          this.isTransformedShape = args.value["bool"];
          break;
        case "rgbToHex":
          this.rgbToHex(args.value["r"], args.value["g"], args.value["b"], args.value["a"]);
          break;
        case "padLeft":
          this.padLeft(args.value["value"], args.value["length"], args.value["padChar"]);
          break;
        case "setTimer":
          this.setTimer(args.value["e"]);
          break;
        case "targetTouches":
          args.value["output"] = this.targetTouches(args.value["touches"]);
          break;
        case "calculateScale":
          args.value["output"] = this.calculateScale(args.value["startTouches"], args.value["endTouches"]);
          break;
        case "beforeSaveEvent":
          this.beforeSaveEvent(args.value["args"], args.value["e"]);
          break;
        case "isKeyBoardCrop":
          args.value["output"] = this.isKeyBoardCrop(args.value["e"]);
          break;
        case "focusRatioBtn":
          this.focusRatioBtn();
          break;
        case "performEnterAction":
          this.performEnterAction(args.value["e"]);
          break;
        case "getImagePoints":
          args.value["output"] = this.getImagePoints(args.value["x"], args.value["y"]);
          break;
        case "revertPoints":
          this.revertPoints(args.value["actPoint"], args.value["tempActiveObj"]);
          break;
        case "performNWResize":
          this.performNWResize(args.value["x"], args.value["y"], args.value["tempActiveObj"], args.value["actPoint"]);
          break;
        case "performSEResize":
          this.performSEResize(args.value["x"], args.value["y"], args.value["tempActiveObj"], args.value["actPoint"]);
          break;
        case "isMouseOutsideImg":
          args.value["output"] = this.isMouseOutsideImg(args.value["x"], args.value["y"]);
          break;
      }
    };
    Selection2.prototype.getModuleName = function() {
      return "selection";
    };
    Selection2.prototype.updatePrivateVariables = function() {
      var parent = this.parent;
      if (parent.lowerCanvas) {
        this.lowerContext = parent.lowerCanvas.getContext("2d");
      }
      if (parent.upperCanvas) {
        this.upperContext = parent.upperCanvas.getContext("2d");
      }
    };
    Selection2.prototype.reset = function() {
      this.diffPoint = { x: 0, y: 0 };
      this.oldPoint = {};
      this.isTouch = this.isObjSelected = this.isFhdPoint = this.isShapeInserted = false;
      this.dragPoint = { startX: 0, startY: 0, endX: 0, endY: 0 };
      this.tempActiveObj = {
        activePoint: { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 },
        flipObjColl: [],
        triangle: [],
        triangleRatio: [],
        order: null
      };
      this.isFirstMove = false;
      this.cursorTargetId = this.dragElement = "";
      this.isTouchDblClick = false;
      this.startTouches = [];
      this.tempTouches = [];
      this.currMousePoint = { x: 0, y: 0 };
      this.isPreventDragging = false;
      this.timer = undefined;
      this.tempObjColl = undefined;
      this.mouseWheel = 0;
      this.textRow = 1;
      this.mouseDownPoint = { x: 0, y: 0 };
      this.previousPoint = { x: 0, y: 0 };
      this.zoomType = "Toolbar";
      this.isInitialTextEdited = false;
      this.dragCanvas = this.isPinching = false;
      this.isFhdCustomized = false;
      this.touchEndPoint = {};
      this.panDown = null;
      this.isSliding = false;
      this.isFhdEditing = false;
      this.pathAdjustedIndex = null;
      this.touchTime = 0;
      this.isImageClarity = true;
      this.currentDrawingShape = "";
      this.initialPrevObj = {};
      this.resizedElement = "";
      this.mouseDown = "";
      this.isSliderActive = false;
      this.arrowShape = [ArrowheadType.None, ArrowheadType.SolidArrow];
      this.isMouseDown = this.isMouseUp = this.isTransformedShape = false;
    };
    Selection2.prototype.performTabAction = function() {
      var parent = this.parent;
      if (parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block") {
        var allowUndoRedoPush = this.applyCurrShape(false);
        parent.notify("shape", {
          prop: "redrawActObj",
          onPropertyChange: false,
          value: { x: null, y: null, isMouseDown: null }
        });
        if (allowUndoRedoPush) {
          parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
        }
      }
      parent.isKBDNavigation = true;
    };
    Selection2.prototype.selMouseUpEvent = function() {
      this.oldPoint.x = undefined;
      this.oldPoint.y = undefined;
    };
    Selection2.prototype.getMouseCursor = function(actObj, x, y, isCropSelection, isApply) {
      var rotationCirclePoint = this.getTransRotationPoint(actObj);
      var radius = actObj.bottomCenterCircle.radius;
      var cursor = "default";
      var ratio = isApply ? 0 : actObj.topLeftCircle.radius * 2;
      if (x >= actObj.topLeftCircle.startX - ratio && x <= actObj.topLeftCircle.startX + ratio && y >= actObj.topLeftCircle.startY - ratio && y <= actObj.topLeftCircle.startY + ratio) {
        cursor = "nw-resize";
      } else if (x >= actObj.topLeftCircle.startX - ratio && x <= actObj.topRightCircle.startX - ratio && y >= actObj.topCenterCircle.startY - ratio && y <= actObj.topCenterCircle.startY + ratio) {
        cursor = "n-resize";
      } else if (x >= actObj.topRightCircle.startX - ratio && x <= actObj.topRightCircle.startX + ratio && y >= actObj.topRightCircle.startY - ratio && y <= actObj.topRightCircle.startY + ratio) {
        cursor = "ne-resize";
      } else if (x >= actObj.centerLeftCircle.startX - ratio && x <= actObj.centerLeftCircle.startX + ratio && y >= actObj.topLeftCircle.startY - ratio && y <= actObj.bottomLeftCircle.startY - ratio) {
        cursor = "w-resize";
      } else if (x >= actObj.centerRightCircle.startX - ratio && x <= actObj.centerRightCircle.startX + ratio && y >= actObj.topRightCircle.startY - ratio && y <= actObj.bottomRightCircle.startY - ratio) {
        cursor = "e-resize";
      } else if (x >= actObj.bottomLeftCircle.startX - ratio && x <= actObj.bottomLeftCircle.startX + ratio && y >= actObj.bottomLeftCircle.startY - ratio && y <= actObj.bottomLeftCircle.startY + ratio) {
        cursor = "sw-resize";
      } else if (x >= actObj.bottomLeftCircle.startX - ratio && x <= actObj.bottomRightCircle.startX - ratio && y >= actObj.bottomCenterCircle.startY - ratio && y <= actObj.bottomCenterCircle.startY + ratio) {
        cursor = "s-resize";
      } else if (x >= actObj.bottomRightCircle.startX - ratio && x <= actObj.bottomRightCircle.startX + ratio && y >= actObj.bottomRightCircle.startY - ratio && y <= actObj.bottomRightCircle.startY + ratio) {
        cursor = "se-resize";
      } else if (x >= actObj.activePoint.startX && x <= actObj.activePoint.endX && (y >= actObj.activePoint.startY && y <= actObj.activePoint.endY)) {
        if (isCropSelection) {
          cursor = "grab";
        } else {
          cursor = "move";
        }
      } else if (rotationCirclePoint && !isApply && x >= rotationCirclePoint.x - (radius + 2) && x <= rotationCirclePoint.x + (radius + 2) && y >= rotationCirclePoint.y - (radius + 2) && y <= rotationCirclePoint.y + (radius + 2)) {
        cursor = "grabbing";
      } else {
        cursor = "default";
      }
      return cursor;
    };
    Selection2.prototype.setCursor = function(x, y) {
      var parent = this.parent;
      parent.upperCanvas.style.cursor = parent.cursor = "default";
      var frameObject = { bool: null };
      parent.notify("toolbar", { prop: "getFrameToolbar", onPropertyChange: false, value: { obj: frameObject } });
      if (parent.isResize || this.isSliding || frameObject["bool"]) {
        parent.upperCanvas.style.cursor = "default";
        return;
      }
      var isCropSelection = false;
      var splitWords;
      if (parent.activeObj.shape) {
        splitWords = parent.activeObj.shape.split("-");
      }
      if (!splitWords && parent.currObjType.isCustomCrop || splitWords && splitWords[0] === "crop") {
        isCropSelection = true;
      }
      if (parent.currObjType.isDragging) {
        if (this.dragElement === "") {
          parent.upperCanvas.style.cursor = parent.cursor = "move";
        } else {
          parent.upperCanvas.style.cursor = parent.cursor = this.dragElement;
        }
        return;
      }
      if (parent.togglePen) {
        parent.upperCanvas.style.cursor = parent.cursor = "crosshair";
        if (parent.isMaskImage) {
          this.drawMaskCircle(x, y);
          parent.upperCanvas.style.cursor = "none";
        }
        return;
      }
      if (parent.activeObj.shape) {
        this.setCursorForActObj(splitWords, isCropSelection, x, y);
      }
      if (parent.cursor === "default" || parent.cursor === "grab") {
        var highestOrder = this.getHighestOrder();
        var tempShapeColl = extend([], parent.shapeColl, [], true);
        var objColl = extend([], parent.objColl, [], true);
        var isShape = false;
        while (highestOrder > 0) {
          isShape = false;
          for (var i = tempShapeColl.length - 1; i >= 0; i--) {
            if (tempShapeColl[i].order === highestOrder) {
              isShape = true;
              if (tempShapeColl[i].id && tempShapeColl[i].id.indexOf("pen") > -1) {
                if (parent.pointColl[0] && (parent.cursor !== "grab" || !isCropSelection) && !parent.currObjType.isDragging && !parent.currObjType.isResize) {
                  var points = extend([], parent.points, [], true);
                  if (!isCropSelection) {
                    this.setCursorForFreehandDrawing(x, y, parent.upperCanvas, tempShapeColl[i].id);
                  }
                  parent.points = points;
                }
              } else {
                parent.objColl = [];
                parent.objColl.push(extend({}, tempShapeColl[i], null, true));
                var cursor = parent.upperCanvas.style.cursor;
                if (parent.objColl.length > 0 && (parent.cursor !== "grab" || !isCropSelection)) {
                  this.setCursorFromObj(x, y, parent.objColl, parent.upperCanvas, isCropSelection);
                }
                if (cursor === "grab" && parent.cursor === "default") {
                  parent.upperCanvas.style.cursor = parent.cursor = "grab";
                }
              }
            } else if (isNullOrUndefined(tempShapeColl[i].order)) {
              isShape = true;
            }
          }
          if (parent.cursor !== "default" && parent.cursor !== "grab") {
            break;
          } else if (isShape) {
            var isBreak = false;
            while (!isBreak && highestOrder > 0) {
              for (var a = 0; a < tempShapeColl.length; a++) {
                if (tempShapeColl[a].order === highestOrder - 1) {
                  isBreak = true;
                  break;
                }
              }
              highestOrder--;
              if (!isBreak) {
                highestOrder--;
              }
            }
          }
        }
        parent.objColl = objColl;
        if (parent.cursor === "default" || parent.cursor === "grab") {
          if (parent.togglePan) {
            parent.lowerCanvas.style.cursor = parent.upperCanvas.style.cursor = parent.cursor = "grab";
          }
        }
      }
      if (this.currentDrawingShape !== "" && (parent.cursor === "default" || parent.cursor === "grab")) {
        parent.upperCanvas.style.cursor = parent.cursor = "crosshair";
      }
    };
    Selection2.prototype.getHighestOrder = function() {
      var highestOrder = 0;
      for (var i = 0; i < this.parent.shapeColl.length; i++) {
        if (this.parent.shapeColl[i].order > highestOrder) {
          highestOrder = this.parent.shapeColl[i].order;
        }
      }
      return highestOrder;
    };
    Selection2.prototype.drawMaskCircle = function(x, y) {
      var parent = this.parent;
      if (parent.isMaskImage) {
        var radius = parent.activeObj.strokeSettings.strokeWidth * 2;
        var canvasDraw = parent.maskCanvas.getContext("2d");
        canvasDraw.clearRect(0, 0, parent.maskCanvas.width, parent.maskCanvas.height);
        canvasDraw.fillStyle = parent.activeObj.strokeSettings.strokeColor;
        canvasDraw.strokeStyle = "#fff";
        canvasDraw.beginPath();
        canvasDraw.ellipse(x, y, radius / 2, radius / 2, 0, 0, 2 * Math.PI, false);
        canvasDraw.fill();
        canvasDraw.stroke();
        canvasDraw.closePath();
        parent.maskCanvas.style.cursor = "none";
      }
    };
    Selection2.prototype.setCursorForActObj = function(splitWords, isCropSelection, x, y) {
      var parent = this.parent;
      if (parent.activeObj.horTopLine !== undefined) {
        if (parent.activeObj.shape !== undefined) {
          splitWords = parent.activeObj.shape.split("-");
        }
        if (splitWords === undefined && parent.currObjType.isCustomCrop) {
          isCropSelection = true;
        } else if (splitWords !== undefined && splitWords[0] === "crop") {
          isCropSelection = true;
        }
        if (!isCropSelection && parent.togglePan) {
          parent.lowerCanvas.style.cursor = parent.upperCanvas.style.cursor = parent.cursor = "grab";
        }
        var cursor = parent.upperCanvas.style.cursor;
        var actObj = extend({}, parent.activeObj, {}, true);
        this.cursorTargetId = actObj.currIndex;
        if (actObj.shapeDegree === 0) {
          parent.transform.degree;
        } else {
          parent.transform.degree - actObj.shapeDegree;
        }
        if (actObj.shape === "line" || actObj.shape === "arrow") {
          this.setCursorForLineArrow(actObj, x, y, parent.upperCanvas);
        } else if (actObj.shape === "path") {
          this.setCursorForPath(actObj, x, y, parent.upperCanvas);
        } else if (!isNullOrUndefined(actObj.rotatedAngle) && actObj.rotatedAngle !== 0) {
          this.setCursorForRotatedObject(actObj, x, y, parent.upperCanvas);
        } else {
          parent.upperCanvas.style.cursor = parent.cursor = this.getMouseCursor(actObj, x, y, isCropSelection, false);
          var cursorColl = ["n-resize", "s-resize", "e-resize", "w-resize"];
          if (actObj.shape === "text" && cursorColl.indexOf(parent.cursor) > -1) {
            parent.upperCanvas.style.cursor = parent.cursor = "move";
          }
        }
        if (cursor === "default" && parent.cursor === "default" && isCropSelection) {
          parent.upperCanvas.style.cursor = parent.cursor = "grab";
        }
        if (cursor === "grab" && parent.cursor === "default") {
          parent.upperCanvas.style.cursor = parent.cursor = "grab";
        }
      } else if (parent.togglePan && !parent.togglePen) {
        parent.lowerCanvas.style.cursor = parent.upperCanvas.style.cursor = parent.cursor = "grab";
      } else {
        if (parent.currObjType.isCustomCrop || parent.togglePen) {
          parent.upperCanvas.style.cursor = parent.cursor = "crosshair";
        } else {
          parent.upperCanvas.style.cursor = parent.cursor = "default";
        }
      }
    };
    Selection2.prototype.setCursorForPath = function(actObj, x, y, upperCanvas) {
      this.setCursorForLineArrow(actObj, x, y, upperCanvas);
      var parent = this.parent;
      if (parent.cursor === "default") {
        var obj = extend({}, actObj, null, true);
        var isMove = false;
        for (var i = 1, len = actObj.pointColl.length; i < len; i++) {
          if (isMove) {
            break;
          }
          obj.activePoint.startX = actObj.pointColl[i - 1].x;
          obj.activePoint.startY = actObj.pointColl[i - 1].y;
          obj.activePoint.endX = actObj.pointColl[i].x;
          obj.activePoint.endY = actObj.pointColl[i].y;
          parent.notify("shape", {
            prop: "setPointCollForLineArrow",
            onPropertyChange: false,
            value: { obj }
          });
          var radius = actObj.topLeftCircle.radius;
          for (var j = 0, jLen = obj.pointColl.length; j < jLen; j++) {
            var point = obj.pointColl[j];
            if (!isNullOrUndefined(point.x - radius * 2) && !isNullOrUndefined(point.x + radius * 2) && !isNullOrUndefined(point.y - radius * 2) && !isNullOrUndefined(point.y + radius * 2) && x >= point.x - radius * 2 && x <= point.x + radius * 2 && y >= point.y - radius * 2 && y <= point.y + radius * 2) {
              upperCanvas.style.cursor = parent.cursor = "move";
              isMove = true;
              break;
            } else {
              upperCanvas.style.cursor = parent.cursor = "default";
            }
          }
        }
      }
      return parent.cursor;
    };
    Selection2.prototype.setCursorForLineArrow = function(actObj, x, y, upperCanvas) {
      var index;
      var radius = actObj.topLeftCircle.radius;
      if (isNullOrUndefined(actObj.pointColl)) {
        return index;
      }
      for (var i = 0, len = actObj.pointColl.length; i < len; i++) {
        var point = actObj.pointColl[i];
        if (x >= point.x - radius * 2 && x <= point.x + radius * 2 && y >= point.y - radius * 2 && y <= point.y + radius * 2) {
          upperCanvas.style.cursor = this.parent.cursor = "move";
          index = i;
          break;
        } else {
          upperCanvas.style.cursor = this.parent.cursor = "default";
        }
      }
      return index;
    };
    Selection2.prototype.setCursorForRotatedObject = function(actObj, x, y, upperCanvas) {
      this.resizedElement = "";
      var parent = this.parent;
      var radius = actObj.bottomCenterCircle.radius;
      var horTP = actObj.horTopLinePointColl[Math.round(actObj.horTopLinePointColl.length / 2)];
      var horTP1 = actObj.horTopLinePointColl[Math.round(actObj.horTopLinePointColl.length - 1)];
      var verLP = actObj.verLeftLinePointColl[Math.round(actObj.verLeftLinePointColl.length / 2)];
      var verRP = actObj.verRightLinePointColl[Math.round(actObj.verRightLinePointColl.length / 2)];
      var horBP = actObj.horBottomLinePointColl[Math.round(actObj.horBottomLinePointColl.length / 2)];
      var horBP1 = actObj.horBottomLinePointColl[Math.round(actObj.horBottomLinePointColl.length - 1)];
      var rotCP = actObj.rotationCirclePointColl;
      var horTP0 = actObj.horTopLinePointColl[0];
      var horBP0 = actObj.horBottomLinePointColl[0];
      if (x >= horTP0.x - (radius + 2) && x <= horTP0.x + (radius + 2) && y >= horTP0.y - (radius + 2) && y <= horTP0.y + (radius + 2)) {
        upperCanvas.style.cursor = parent.cursor = "nw-resize";
      } else if (x >= horTP.x - 5 && x <= horTP.x + 5 && y >= horTP.y - 5 && y <= horTP.y + 5) {
        upperCanvas.style.cursor = parent.cursor = this.resizedElement = "n-resize";
      } else if (x >= horTP1.x - (radius + 2) && x <= horTP1.x + (radius + 2) && y >= horTP1.y - (radius + 2) && y <= horTP1.y + (radius + 2)) {
        upperCanvas.style.cursor = parent.cursor = "ne-resize";
      } else if (x >= verLP.x - 5 && x <= verLP.x + 5 && y >= verLP.y - 5 && y <= verLP.y + 5) {
        upperCanvas.style.cursor = parent.cursor = this.resizedElement = "w-resize";
      } else if (x >= verRP.x - 5 && x <= verRP.x + 5 && y >= verRP.y - 5 && y <= verRP.y + 5) {
        upperCanvas.style.cursor = parent.cursor = this.resizedElement = "e-resize";
      } else if (x >= horBP0.x - (radius + 2) && x <= horBP0.x + (radius + 2) && y >= horBP0.y - (radius + 2) && y <= horBP0.y + (radius + 2)) {
        upperCanvas.style.cursor = parent.cursor = "sw-resize";
      } else if (x >= horBP.x - 5 && x <= horBP.x + 5 && y >= horBP.y - 5 && y <= horBP.y + 5) {
        upperCanvas.style.cursor = parent.cursor = this.resizedElement = "s-resize";
      } else if (x >= horBP1.x - (radius + 2) && x <= horBP1.x + (radius + 2) && y >= horBP1.y - (radius + 2) && y <= horBP1.y + (radius + 2)) {
        upperCanvas.style.cursor = parent.cursor = "se-resize";
      } else if (rotCP && x >= rotCP.x - (radius + 2) && x <= rotCP.x + (radius + 2) && y >= rotCP.y - (radius + 2) && y <= rotCP.y + (radius + 2)) {
        upperCanvas.style.cursor = parent.cursor = "grabbing";
      } else {
        upperCanvas.style.cursor = parent.cursor = "default";
        var isPointsInsideRectangle = this.getRectanglePoints(actObj.activePoint.startX, actObj.activePoint.startY, actObj.activePoint.width, actObj.activePoint.height, actObj.rotatedAngle * (180 / Math.PI), x, y);
        if (isPointsInsideRectangle) {
          upperCanvas.style.cursor = parent.cursor = "move";
        }
      }
      if (parent.cursor === "default") {
        for (var i = 0, len = actObj.horTopLinePointColl.length; i < len; i++) {
          var horTP_1 = actObj.horTopLinePointColl[i];
          if (x >= horTP_1.x - 5 && x <= horTP_1.x + 5 && y >= horTP_1.y - 5 && y <= horTP_1.y + 5) {
            upperCanvas.style.cursor = parent.cursor = this.resizedElement = "n-resize";
            break;
          }
        }
      }
      if (parent.cursor === "default") {
        for (var i = 0, len = actObj.horBottomLinePointColl.length; i < len; i++) {
          var horBP_1 = actObj.horBottomLinePointColl[i];
          if (x >= horBP_1.x - 5 && x <= horBP_1.x + 5 && y >= horBP_1.y - 5 && y <= horBP_1.y + 5) {
            upperCanvas.style.cursor = parent.cursor = this.resizedElement = "s-resize";
            break;
          }
        }
      }
      if (parent.cursor === "default") {
        for (var i = 0, len = actObj.verLeftLinePointColl.length; i < len; i++) {
          var verLP_1 = actObj.verLeftLinePointColl[i];
          if (x >= verLP_1.x - 5 && x <= verLP_1.x + 5 && y >= verLP_1.y - 5 && y <= verLP_1.y + 5) {
            upperCanvas.style.cursor = parent.cursor = this.resizedElement = "w-resize";
            break;
          }
        }
      }
      if (parent.cursor === "default") {
        for (var i = 0, len = actObj.verRightLinePointColl.length; i < len; i++) {
          var verRP_1 = actObj.verRightLinePointColl[i];
          if (x >= verRP_1.x - 5 && x <= verRP_1.x + 5 && y >= verRP_1.y - 5 && y <= verRP_1.y + 5) {
            upperCanvas.style.cursor = parent.cursor = this.resizedElement = "e-resize";
            break;
          }
        }
      }
      this.adjustCursorStylesForRotatedState(actObj);
      return parent.cursor;
    };
    Selection2.prototype.adjustCursorStylesForRotatedState = function(actObj) {
      var parent = this.parent;
      var length = actObj.rotatedAngle * (180 / Math.PI);
      length = length > 0 ? Math.floor(length) : Math.ceil(length);
      if (length >= 92 && length <= 182 || length >= -178 && length <= -88) {
        var cursorMap = {
          "nw-resize": "ne-resize",
          "n-resize": "s-resize",
          "ne-resize": "nw-resize",
          "w-resize": "e-resize",
          "e-resize": "w-resize",
          "sw-resize": "se-resize",
          "s-resize": "n-resize",
          "se-resize": "sw-resize"
        };
        if (parent.cursor in cursorMap) {
          parent.cursor = cursorMap[parent.cursor];
        }
      }
      parent.upperCanvas.style.cursor = this.getResizeElement(actObj.rotatedAngle * (180 / Math.PI), parent.cursor);
      return parent.cursor;
    };
    Selection2.prototype.getResizeElement = function(degree, element2) {
      var resizeMappings = [];
      switch (element2) {
        case "nw-resize":
          resizeMappings = [
            [337.5, 22.5, "nw-resize"],
            [22.5, 67.5, "n-resize"],
            [67.5, 112.5, "ne-resize"],
            [112.5, 157.5, "e-resize"],
            [157.5, 202.5, "se-resize"],
            [202.5, 247.5, "s-resize"],
            [247.5, 292.5, "sw-resize"],
            [292.5, 337.5, "w-resize"]
          ];
          break;
        case "n-resize":
          resizeMappings = [
            [337.5, 22.5, "n-resize"],
            [22.5, 67.5, "ne-resize"],
            [67.5, 112.5, "e-resize"],
            [112.5, 157.5, "se-resize"],
            [157.5, 202.5, "s-resize"],
            [202.5, 247.5, "sw-resize"],
            [247.5, 292.5, "w-resize"],
            [292.5, 337.5, "nw-resize"]
          ];
          break;
        case "ne-resize":
          resizeMappings = [
            [337.5, 22.5, "ne-resize"],
            [22.5, 67.5, "e-resize"],
            [67.5, 112.5, "se-resize"],
            [112.5, 157.5, "s-resize"],
            [157.5, 202.5, "sw-resize"],
            [202.5, 247.5, "w-resize"],
            [247.5, 292.5, "nw-resize"],
            [292.5, 337.5, "n-resize"]
          ];
          break;
        case "e-resize":
          resizeMappings = [
            [337.5, 22.5, "e-resize"],
            [22.5, 67.5, "se-resize"],
            [67.5, 112.5, "s-resize"],
            [112.5, 157.5, "sw-resize"],
            [157.5, 202.5, "w-resize"],
            [202.5, 247.5, "nw-resize"],
            [247.5, 292.5, "n-resize"],
            [292.5, 337.5, "ne-resize"]
          ];
          break;
        case "se-resize":
          resizeMappings = [
            [337.5, 22.5, "se-resize"],
            [22.5, 67.5, "s-resize"],
            [67.5, 112.5, "sw-resize"],
            [112.5, 157.5, "w-resize"],
            [157.5, 202.5, "nw-resize"],
            [202.5, 247.5, "n-resize"],
            [247.5, 292.5, "ne-resize"],
            [292.5, 337.5, "e-resize"]
          ];
          break;
        case "s-resize":
          resizeMappings = [
            [337.5, 22.5, "s-resize"],
            [22.5, 67.5, "sw-resize"],
            [67.5, 112.5, "w-resize"],
            [112.5, 157.5, "nw-resize"],
            [157.5, 202.5, "n-resize"],
            [202.5, 247.5, "ne-resize"],
            [247.5, 292.5, "e-resize"],
            [292.5, 337.5, "se-resize"]
          ];
          break;
        case "sw-resize":
          resizeMappings = [
            [337.5, 22.5, "sw-resize"],
            [22.5, 67.5, "w-resize"],
            [67.5, 112.5, "nw-resize"],
            [112.5, 157.5, "n-resize"],
            [157.5, 202.5, "ne-resize"],
            [202.5, 247.5, "e-resize"],
            [247.5, 292.5, "se-resize"],
            [292.5, 337.5, "s-resize"]
          ];
          break;
        case "w-resize":
          resizeMappings = [
            [337.5, 22.5, "w-resize"],
            [22.5, 67.5, "nw-resize"],
            [67.5, 112.5, "n-resize"],
            [112.5, 157.5, "ne-resize"],
            [157.5, 202.5, "e-resize"],
            [202.5, 247.5, "se-resize"],
            [247.5, 292.5, "s-resize"],
            [292.5, 337.5, "sw-resize"]
          ];
          break;
      }
      var positiveDegree = degree < 0 ? 360 - Math.abs(degree) : degree;
      for (var _i = 0, resizeMappings_1 = resizeMappings; _i < resizeMappings_1.length; _i++) {
        var _a = resizeMappings_1[_i], startDegree = _a[0], endDegree = _a[1], resizeElement = _a[2];
        if (positiveDegree > startDegree && positiveDegree <= endDegree || positiveDegree + 360 > startDegree && positiveDegree + 360 <= endDegree) {
          return resizeElement;
        }
      }
      return element2;
    };
    Selection2.prototype.setCursorForFreehandDrawing = function(x, y, upperCanvas, id) {
      var upperContext = upperCanvas.getContext("2d");
      var parent = this.parent;
      var textArea = (undefined).querySelector("#" + parent.element.id + "_textArea");
      var isEntered = false;
      parent.notify("freehand-draw", {
        prop: "setFreehandDrawHoveredIndex",
        onPropertyChange: false,
        value: { index: -1 }
      });
      var sPoints;
      for (var n = 0; n < parent.freehandCounter; n++) {
        if (id && id !== parent.pointColl[n].id) {
          continue;
        }
        var obj = { selPointColl: {} };
        parent.notify("freehand-draw", { prop: "getSelPointColl", onPropertyChange: false, value: { obj } });
        sPoints = extend([], obj["selPointColl"][n].points, []);
        parent.points = extend([], parent.pointColl[n].points, []);
        var ptc = parent.pointColl[n];
        parent.notify("freehand-draw", { prop: "setPointCounter", onPropertyChange: false, value: { value: 0 } });
        var len = sPoints.length;
        for (var l = 0; l < len; l++) {
          if (l !== 0) {
            var isInside = false;
            if (sPoints[l - 1] && sPoints[l]) {
              isInside = this.isInside(x, y, sPoints[l - 1].x, sPoints[l - 1].y, sPoints[l].x, sPoints[l].y);
            }
            if (isInside) {
              this.isFhdPoint = true;
              parent.notify("freehand-draw", {
                prop: "setFreehandDrawHoveredIndex",
                onPropertyChange: false,
                value: { index: n }
              });
              parent.notify("freehand-draw", {
                prop: "hoverFhd",
                onPropertyChange: false,
                value: { strokeColor: null, strokeWidth: null }
              });
              upperCanvas.style.cursor = parent.cursor = "pointer";
              isEntered = true;
              break;
            } else if (!this.isFhdEditing || ptc.isSelected) {
              if (this.isFhdPoint || this.isFhdEditing) {
                upperContext.clearRect(0, 0, upperCanvas.width, upperCanvas.height);
                if (parent.activeObj.shape && textArea.style.display === "none") {
                  parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate", obj: parent.activeObj } });
                }
              }
              if (this.isFhdEditing) {
                var indexObj = { freehandSelectedIndex: -1 };
                parent.notify("freehand-draw", { prop: "getFreehandSelectedIndex", onPropertyChange: false, value: { obj: indexObj } });
                var strokeColor = parent.pointColl[indexObj["freehandSelectedIndex"]].strokeColor;
                var strokeWidth = parent.pointColl[indexObj["freehandSelectedIndex"]].strokeWidth;
                parent.notify("freehand-draw", {
                  prop: "hoverFhd",
                  onPropertyChange: false,
                  value: { strokeColor, strokeWidth }
                });
              } else {
                parent.notify("freehand-draw", {
                  prop: "setFreehandDrawHoveredIndex",
                  onPropertyChange: false,
                  value: { index: null }
                });
              }
              this.isFhdPoint = false;
            }
          } else {
            var pt = parent.points[l];
            if (x > pt.x - ptc.strokeWidth && x < pt.x + ptc.strokeWidth && y > pt.y - ptc.strokeWidth && y < pt.y + ptc.strokeWidth) {
              this.isFhdPoint = true;
              parent.notify("freehand-draw", { prop: "setFreehandDrawHoveredIndex", onPropertyChange: false, value: { index: n } });
              parent.notify("freehand-draw", { prop: "hoverFhd", onPropertyChange: false, value: { strokeColor: null, strokeWidth: null } });
              upperCanvas.style.cursor = parent.cursor = "pointer";
              isEntered = true;
              break;
            } else if (!this.isFhdEditing || ptc.isSelected) {
              if (this.isFhdPoint || this.isFhdEditing) {
                upperContext.clearRect(0, 0, upperCanvas.width, upperCanvas.height);
                if (parent.activeObj.shape && textArea.style.display === "none") {
                  parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate", obj: parent.activeObj } });
                }
              }
              if (this.isFhdEditing) {
                var indexObj = { freehandSelectedIndex: -1 };
                parent.notify("freehand-draw", { prop: "getFreehandSelectedIndex", onPropertyChange: false, value: { obj: indexObj } });
                var strokeColor = parent.pointColl[indexObj["freehandSelectedIndex"]].strokeColor;
                var strokeWidth = parent.pointColl[indexObj["freehandSelectedIndex"]].strokeWidth;
                parent.notify("freehand-draw", {
                  prop: "hoverFhd",
                  onPropertyChange: false,
                  value: { strokeColor, strokeWidth }
                });
              }
              this.isFhdPoint = false;
            }
          }
        }
        if (isEntered) {
          break;
        }
      }
    };
    Selection2.prototype.setCursorFromObj = function(x, y, obj, upperCanvas, isCropSelection) {
      var parent = this.parent;
      for (var i = 0, len = obj.length; i < len; i++) {
        if (parent.cursor === "move") {
          return;
        }
        var actObj = extend({}, obj[i], {}, true);
        if (actObj.activePoint.width === 0 && actObj.activePoint.height === 0) {
          obj.splice(i, 1);
          return;
        }
        this.cursorTargetId = actObj.currIndex;
        if (actObj.shape === "line" || actObj.shape === "arrow") {
          this.setCursorForLineArrow(actObj, x, y, upperCanvas);
        } else if (actObj.shape === "path") {
          this.setCursorForPath(actObj, x, y, upperCanvas);
        } else if (!isNullOrUndefined(actObj.rotatedAngle) && actObj.rotatedAngle !== 0) {
          this.setCursorForRotatedObject(actObj, x, y, upperCanvas);
        } else {
          upperCanvas.style.cursor = parent.cursor = this.getMouseCursor(actObj, x, y, isCropSelection, true);
        }
      }
    };
    Selection2.prototype.isInside = function(x, y, z1, z2, z3, z4) {
      var x1 = Math.min(z1, z3);
      var x2 = Math.max(z1, z3);
      var y1 = Math.min(z2, z4);
      var y2 = Math.max(z2, z4);
      if (x1 <= x && x <= x2 && (y1 <= y && y <= y2)) {
        return true;
      } else {
        return false;
      }
    };
    Selection2.prototype.preventResizing = function(tempActiveObj) {
      var parent = this.parent;
      if (parent.activeObj.preventShapeDragOut && this.isShapeDragOut()) {
        var actPoint = parent.activeObj.activePoint;
        actPoint.startX = tempActiveObj.activePoint.startX;
        actPoint.startY = tempActiveObj.activePoint.startY;
        actPoint.endX = tempActiveObj.activePoint.endX;
        actPoint.endY = tempActiveObj.activePoint.endY;
        actPoint.width = tempActiveObj.activePoint.width;
        actPoint.height = tempActiveObj.activePoint.height;
        parent.activeObj.rotatedAngle = tempActiveObj.rotatedAngle;
        parent.notify("draw", {
          prop: "updateActiveObject",
          onPropertyChange: false,
          value: { actPoint, obj: parent.activeObj, isMouseMove: null, x: null, y: null }
        });
      }
    };
    Selection2.prototype.updateActivePoint = function(x, y, isCropSelection) {
      var parent = this.parent;
      var obj = { width: 0, height: 0 };
      var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY;
      var _b = parent.activeObj.activePoint, width = _b.width, height = _b.height;
      parent.notify("transform", {
        prop: "calcMaxDimension",
        onPropertyChange: false,
        value: { width, height, obj, isImgShape: null }
      });
      var previousShapeSettings = this.updatePrevShapeSettings();
      var shapeResizingArgs = { cancel: false, action: "resize", previousShapeSettings, allowShapeOverflow: this.allowOutofBound() };
      var shapeMovingArgs = { cancel: false, action: "move", previousShapeSettings, allowShapeOverflow: this.allowOutofBound() };
      this.shapeResizingArgs = shapeResizingArgs;
      this.shapeMovingArgs = shapeMovingArgs;
      if (parent.activeObj.shape === "text" && this.dragElement !== "") {
        parent.notify("shape", {
          prop: "updateFontRatio",
          onPropertyChange: false,
          value: { obj: parent.activeObj, isTextArea: null }
        });
      }
      if (this.currentDrawingShape !== "" && (this.dragElement === "" || this.dragElement === "move") && parent.isShapeDrawing) {
        var shapeColl = ["line", "arrow", "path"];
        if (shapeColl.indexOf(parent.activeObj.shape) > -1) {
          this.dragElement = "e-resize";
        } else {
          if (x > startX && y > startY) {
            this.dragElement = "se-resize";
          } else if (x < startX && y > startY) {
            this.dragElement = "sw-resize";
          } else if (x > startX && y < startY) {
            this.dragElement = "ne-resize";
          } else if (x < startX && y < startY) {
            this.dragElement = "nw-resize";
          }
        }
      }
      if (parent.activeObj.shape === "arrow") {
        if (Math.atan2(x - parent.lowerCanvas.width / 2, y - parent.lowerCanvas.height / 2) > 0) {
          parent.activeObj.rotatedAngle = -Math.atan2(x - parent.lowerCanvas.width / 2, y - parent.lowerCanvas.height / 2);
        } else {
          parent.activeObj.rotatedAngle = Math.abs(Math.atan2(x - parent.lowerCanvas.width / 2, y - parent.lowerCanvas.height / 2));
        }
      }
      var degree;
      var isHorizontalflip = false;
      var isVerticalflip = false;
      if (isCropSelection && parent.transform.straighten !== 0 && this.isMouseOutsideImg(x, y)) {
        return;
      }
      var tempActiveObj = extend({}, parent.activeObj, {}, true);
      var splitWords;
      var cropResize;
      if (parent.activeObj.shape !== undefined) {
        splitWords = parent.activeObj.shape.split("-");
      }
      if (splitWords !== undefined && splitWords[0] === "crop") {
        cropResize = true;
      }
      switch (this.dragElement.toLowerCase()) {
        case "nw-resize":
          this.updateNWPoints(x, y);
          this.preventResizing(tempActiveObj);
          parent.notify("shape", {
            prop: "updateArrowDirection",
            onPropertyChange: false,
            value: { obj: parent.activeObj, flip: null, rotatedDegree: null }
          });
          this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, "resize");
          break;
        case "n-resize":
          this.updateNPoints(x, y);
          this.preventResizing(tempActiveObj);
          parent.notify("shape", {
            prop: "updateArrowDirection",
            onPropertyChange: false,
            value: { obj: parent.activeObj, flip: null, rotatedDegree: null }
          });
          this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, "resize");
          break;
        case "ne-resize":
          this.updateNEPoints(x, y);
          this.preventResizing(tempActiveObj);
          parent.notify("shape", {
            prop: "updateArrowDirection",
            onPropertyChange: false,
            value: { obj: parent.activeObj, flip: null, rotatedDegree: null }
          });
          this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, "resize");
          break;
        case "w-resize":
          this.updateWPoints(x, y);
          this.preventResizing(tempActiveObj);
          parent.notify("shape", {
            prop: "updateArrowDirection",
            onPropertyChange: false,
            value: { obj: parent.activeObj, flip: null, rotatedDegree: null }
          });
          this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, "resize");
          break;
        case "e-resize":
          this.updateEPoints(x, y);
          this.preventResizing(tempActiveObj);
          parent.notify("shape", {
            prop: "updateArrowDirection",
            onPropertyChange: false,
            value: { obj: parent.activeObj, flip: null, rotatedDegree: null }
          });
          this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, "resize");
          break;
        case "sw-resize":
          this.updateSWPoints(x, y);
          this.preventResizing(tempActiveObj);
          parent.notify("shape", {
            prop: "updateArrowDirection",
            onPropertyChange: false,
            value: { obj: parent.activeObj, flip: null, rotatedDegree: null }
          });
          this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, "resize");
          break;
        case "s-resize":
          this.updateSPoints(x, y);
          this.preventResizing(tempActiveObj);
          parent.notify("shape", {
            prop: "updateArrowDirection",
            onPropertyChange: false,
            value: { obj: parent.activeObj, flip: null, rotatedDegree: null }
          });
          this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, "resize");
          break;
        case "se-resize":
          this.updateSEPoints(x, y);
          this.preventResizing(tempActiveObj);
          parent.notify("shape", {
            prop: "updateArrowDirection",
            onPropertyChange: false,
            value: { obj: parent.activeObj, flip: null, rotatedDegree: null }
          });
          this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, "resize");
          break;
        case "grabbing":
          if (Math.atan2(x - (startX + width / 2), y - (startY + height / 2)) > 0) {
            parent.activeObj.rotatedAngle = -Math.atan2(x - (startX + width / 2), y - (startY + height / 2));
          } else {
            parent.activeObj.rotatedAngle = Math.abs(Math.atan2(x - (startX + width / 2), y - (startY + height / 2)));
          }
          if (parent.activeObj.shapeDegree === 0) {
            degree = parent.transform.degree;
          } else {
            degree = parent.transform.degree - parent.activeObj.shapeDegree;
          }
          if (degree < 0) {
            degree = 360 + degree;
          }
          for (var i = 0, len = parent.activeObj.flipObjColl.length; i < len; i++) {
            if (parent.activeObj.flipObjColl[i].toLowerCase() === "horizontal") {
              isHorizontalflip = true;
            } else if (parent.activeObj.flipObjColl[i].toLowerCase() === "vertical") {
              isVerticalflip = true;
            }
          }
          parent.activeObj.rotatedAngle -= degree * (Math.PI / 180);
          if (degree === 0 || degree === 360) {
            if (isVerticalflip) {
              parent.activeObj.rotatedAngle -= 180 * (Math.PI / 180);
            }
          } else if (degree === 90 || degree === -270) {
            if (isHorizontalflip) {
              parent.activeObj.rotatedAngle -= 180 * (Math.PI / 180);
            }
          } else if (degree === 180 || degree === -180) {
            if (isVerticalflip) {
              parent.activeObj.rotatedAngle -= 180 * (Math.PI / 180);
            }
          } else if (degree === 270 || degree === -90) {
            if (isHorizontalflip) {
              parent.activeObj.rotatedAngle -= 180 * (Math.PI / 180);
            }
          }
          this.preventResizing(tempActiveObj);
          break;
        case "pathdrag":
          if (!isNullOrUndefined(this.pathAdjustedIndex)) {
            parent.activeObj.pointColl[this.pathAdjustedIndex].x = x;
            parent.activeObj.pointColl[this.pathAdjustedIndex].y = y;
          }
          break;
        default:
          if (!isCropSelection && !parent.currObjType.isCustomCrop) {
            var activePoint = parent.activeObj.activePoint;
            if (this.dragPoint.startX) {
              var width_1 = this.dragPoint.endX - this.previousPoint.x;
              var height_1 = this.dragPoint.endY - this.previousPoint.y;
              activePoint.startX += width_1;
              activePoint.endX += width_1;
              activePoint.startY += height_1;
              activePoint.endY += height_1;
              startX = activePoint.startX;
              startY = activePoint.startY;
              if (parent.activeObj.shape !== "line" && parent.activeObj.shape !== "arrow" && parent.activeObj.rotationCirclePointColl) {
                parent.activeObj.rotationCirclePointColl.x += width_1;
                parent.activeObj.rotationCirclePointColl.y += height_1;
                parent.activeObj.rotationCirclePoint.x += width_1;
                parent.activeObj.rotationCirclePoint.y += height_1;
              }
              if (parent.activeObj.shape === "path") {
                for (var i = 0, len = parent.activeObj.pointColl.length; i < len; i++) {
                  parent.activeObj.pointColl[i].x += width_1;
                  parent.activeObj.pointColl[i].y += height_1;
                }
              }
              if (!this.isPreventDragging && this.isShapeDragOut() && (parent.activeObj.preventShapeDragOut || parent.activeObj.shape === "redact" || cropResize)) {
                activePoint.startX -= width_1;
                activePoint.endX -= width_1;
                activePoint.startY -= height_1;
                activePoint.endY -= height_1;
                if (parent.activeObj.shape !== "line" && parent.activeObj.shape !== "arrow" && parent.activeObj.rotationCirclePointColl) {
                  parent.activeObj.rotationCirclePointColl.x -= width_1;
                  parent.activeObj.rotationCirclePointColl.y -= height_1;
                  parent.activeObj.rotationCirclePoint.x -= width_1;
                  parent.activeObj.rotationCirclePoint.y -= height_1;
                } else if (parent.activeObj.shape === "path") {
                  for (var l = 0, len = parent.activeObj.pointColl.length; l < len; l++) {
                    parent.activeObj.pointColl[l].x -= width_1;
                    parent.activeObj.pointColl[l].y -= height_1;
                  }
                }
                if (parent.activeObj.rotatedAngle === 0) {
                  var tempEndX = parent.activeObj.activePoint.endX;
                  var tempEndY = parent.activeObj.activePoint.endY;
                  if (parent.activeObj.shape === "path") {
                    parent.activeObj.activePoint = parent.getSquarePointForPath(parent.activeObj);
                  }
                  this.setDragWidth(width_1);
                  this.setDragHeight(height_1);
                  var currObj = parent.activeObj;
                  var xDiff = currObj.activePoint.endX - tempEndX;
                  var yDiff = currObj.activePoint.endY - tempEndY;
                  if (currObj.shape === "path") {
                    for (var l = 0, len = currObj.pointColl.length; l < len; l++) {
                      currObj.pointColl[l].x += xDiff;
                      currObj.pointColl[l].y += yDiff;
                    }
                  }
                } else {
                  parent.notify("selection", { prop: "updPtCollForShpRot", onPropertyChange: false, value: { obj: parent.activeObj } });
                }
              }
            } else {
              activePoint.startX = x < this.mouseDownPoint.x ? x : this.mouseDownPoint.x;
              activePoint.startY = y < this.mouseDownPoint.y ? y : this.mouseDownPoint.y;
              x = x < this.mouseDownPoint.x ? this.mouseDownPoint.x : x;
              y = y < this.mouseDownPoint.y ? this.mouseDownPoint.y : y;
              activePoint.endX = x;
              activePoint.endY = y;
            }
            this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, "move");
          }
          break;
      }
    };
    Selection2.prototype.isShapeDragOut = function() {
      var parent = this.parent;
      var isShapeDragOut = false;
      var allowPreventing = false;
      var shape = parent.activeObj.shape;
      if (parent.activeObj.preventShapeDragOut) {
        allowPreventing = true;
      } else if (parent.activeObj.rotatedAngle === 0 && (shape !== "line" && shape !== "arrow" && shape !== "path")) {
        allowPreventing = true;
      }
      if (allowPreventing) {
        var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
        if (shape === "path") {
          var path = parent.getSquarePointForPath(parent.activeObj);
          startX = path.startX;
          startY = path.startY;
          endX = path.endX;
          endY = path.endY;
        }
        if (parent.activeObj.rotatedAngle === 0 || shape === "arrow") {
          isShapeDragOut = this.isObjOutsideImg(startX, startY, endX, endY, shape);
        } else {
          var obj = { isIntersect: null, arr: null };
          parent.notify("draw", { prop: "updateImgCanvasPoints", onPropertyChange: false });
          parent.notify("draw", { prop: "isLinesIntersect", onPropertyChange: false, value: { obj } });
          if (obj["arr"][0] || obj["arr"][1] || obj["arr"][2] || obj["arr"][3]) {
            isShapeDragOut = true;
          } else {
            isShapeDragOut = this.isObjOutsideImg(startX, startY, endX, endY, shape);
          }
        }
      }
      return isShapeDragOut;
    };
    Selection2.prototype.isObjOutsideImg = function(startX, startY, endX, endY, shape) {
      var parent = this.parent;
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      if (startX < destLeft || startY < destTop || endX > destLeft + destWidth || endY > destTop + destHeight || (shape === "line" || shape === "arrow") && (startX > destLeft + destWidth || startY > destTop + destHeight || endX < destLeft || endY < destTop)) {
        return true;
      }
      return false;
    };
    Selection2.prototype.triggerShapeChange = function(shapeResizingArgs, shapeMovingArgs, type) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      actPoint.width = actPoint.endX - actPoint.startX;
      actPoint.height = actPoint.endY - actPoint.startY;
      var currentShapeSettings = this.updatePrevShapeSettings();
      if (!isNullOrUndefined(this.shapeResizingArgs) && !isNullOrUndefined(this.shapeMovingArgs)) {
        shapeResizingArgs.currentShapeSettings = this.shapeResizingArgs.currentShapeSettings = currentShapeSettings;
        shapeMovingArgs.currentShapeSettings = this.shapeMovingArgs.currentShapeSettings = currentShapeSettings;
      } else {
        shapeResizingArgs.currentShapeSettings = currentShapeSettings;
        shapeMovingArgs.currentShapeSettings = currentShapeSettings;
      }
      if (type === "resize") {
        this.isCropSelection = false;
        var splitWords = undefined;
        if (parent.activeObj.shape !== undefined) {
          splitWords = parent.activeObj.shape.split("-");
        }
        if (splitWords !== undefined && splitWords[0] === "crop") {
          this.isCropSelection = true;
        }
        if (!this.isCropSelection) {
          if (this.currentDrawingShape !== "" && parent.upperCanvas.style.cursor === "crosshair") {
            shapeResizingArgs.action = "drawing";
          }
          if (!parent.currObjType.isRedact || parent.activeObj.shape !== "redact") {
            parent.trigger("shapeChanging", shapeResizingArgs);
          }
          parent.editCompleteArgs = shapeResizingArgs;
          this.isPreventShaping = shapeResizingArgs.cancel;
          parent.notify("shape", { prop: "updateShapeChangeEventArgs", onPropertyChange: false, value: { shapeSettings: shapeResizingArgs.currentShapeSettings, allowShapeOverflow: shapeResizingArgs.allowShapeOverflow } });
        } else {
          if (this.isMouseDown) {
            shapeResizingArgs.action = "resize-start";
          } else if (this.isMouseUp) {
            shapeResizingArgs.action = "resize-end";
          }
          var selectionResizingArgs = {
            action: shapeResizingArgs.action,
            previousSelectionSettings: {
              type: parent.getSelectionType(parent.activeObj.shape),
              startX: shapeResizingArgs.previousShapeSettings.startX,
              startY: shapeResizingArgs.previousShapeSettings.startY,
              width: shapeResizingArgs.previousShapeSettings.width,
              height: shapeResizingArgs.previousShapeSettings.height
            },
            currentSelectionSettings: {
              type: parent.getSelectionType(parent.activeObj.shape),
              startX: shapeResizingArgs.currentShapeSettings.startX,
              startY: shapeResizingArgs.currentShapeSettings.startY,
              width: shapeResizingArgs.currentShapeSettings.width,
              height: shapeResizingArgs.currentShapeSettings.height
            }
          };
          this.selectionResizingArgs = selectionResizingArgs;
          parent.trigger("selectionChanging", selectionResizingArgs);
          parent.editCompleteArgs = selectionResizingArgs;
          parent.notify("shape", {
            prop: "updSelChangeEventArgs",
            onPropertyChange: false,
            value: { selectionSettings: selectionResizingArgs.currentSelectionSettings }
          });
        }
      } else if (type === "mouse-down" || type === "mouse-up") {
        if (parent.activeObj.shape !== "redact") {
          parent.trigger("shapeChanging", shapeResizingArgs);
        }
        parent.editCompleteArgs = shapeResizingArgs;
        this.isPreventShaping = shapeResizingArgs.cancel;
        parent.notify("shape", {
          prop: "updateShapeChangeEventArgs",
          onPropertyChange: false,
          value: { shapeSettings: shapeResizingArgs.currentShapeSettings, allowShapeOverflow: shapeResizingArgs.allowShapeOverflow }
        });
      } else {
        if (parent.activeObj.shape !== "redact") {
          parent.trigger("shapeChanging", shapeMovingArgs);
        }
        parent.editCompleteArgs = shapeMovingArgs;
        this.isPreventShaping = shapeMovingArgs.cancel;
        parent.notify("shape", {
          prop: "updateShapeChangeEventArgs",
          onPropertyChange: false,
          value: { shapeSettings: shapeMovingArgs.currentShapeSettings, allowShapeOverflow: shapeMovingArgs.allowShapeOverflow }
        });
      }
      parent.eventType = type;
    };
    Selection2.prototype.setDragWidth = function(width) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var _a = parent.img, destLeft = _a.destLeft, destWidth = _a.destWidth;
      var tempWidth = width;
      var shape = parent.activeObj.shape;
      var preventDragOut = false;
      if (parent.activeObj.preventShapeDragOut && (shape === "line" || shape === "arrow")) {
        preventDragOut = true;
      }
      if (tempWidth >= 0) {
        for (var i = 0; i < tempWidth; i++) {
          width = tempWidth - i;
          actPoint.startX += width;
          actPoint.endX += width;
          if (actPoint.startX >= destLeft && actPoint.endX <= destLeft + destWidth && !preventDragOut || actPoint.startX >= destLeft && actPoint.endX <= destLeft + destWidth && actPoint.endX >= destLeft && actPoint.startX <= destLeft + destWidth && preventDragOut) {
            break;
          } else {
            actPoint.startX -= width;
            actPoint.endX -= width;
          }
        }
      } else {
        for (var i = 1; i < Math.abs(tempWidth); i++) {
          width = tempWidth + i;
          actPoint.startX += width;
          actPoint.endX += width;
          if (actPoint.startX >= destLeft && actPoint.endX <= destLeft + destWidth && !preventDragOut || actPoint.startX >= destLeft && actPoint.endX <= destLeft + destWidth && actPoint.endX >= destLeft && actPoint.startX <= destLeft + destWidth && preventDragOut) {
            break;
          } else {
            actPoint.startX -= width;
            actPoint.endX -= width;
          }
        }
      }
    };
    Selection2.prototype.setDragHeight = function(height) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var _a = parent.img, destTop = _a.destTop, destHeight = _a.destHeight;
      var tempHeight = height;
      var shape = parent.activeObj.shape;
      var preventDragOut = false;
      if (parent.activeObj.preventShapeDragOut && (shape === "line" || shape === "arrow")) {
        preventDragOut = true;
      }
      if (tempHeight >= 0) {
        for (var i = 1; i < tempHeight; i++) {
          height = tempHeight - i;
          actPoint.startY += height;
          actPoint.endY += height;
          if (actPoint.startY >= destTop && actPoint.endY <= destTop + destHeight && !preventDragOut || actPoint.startY >= destTop && actPoint.endY <= destTop + destHeight && actPoint.endY >= destTop && actPoint.startY <= destTop + destHeight && preventDragOut) {
            break;
          } else {
            actPoint.startY -= height;
            actPoint.endY -= height;
          }
        }
      } else {
        for (var i = 0; i < Math.abs(tempHeight); i++) {
          height = tempHeight + i;
          actPoint.startY += height;
          actPoint.endY += height;
          if (actPoint.startY >= destTop && actPoint.endY <= destTop + destHeight && !preventDragOut || actPoint.startY >= destTop && actPoint.endY <= destTop + destHeight && actPoint.endY >= destTop && actPoint.startY <= destTop + destHeight && preventDragOut) {
            break;
          } else {
            actPoint.startY -= height;
            actPoint.endY -= height;
          }
        }
      }
    };
    Selection2.prototype.limitDrag = function(isStart) {
      var isLimiting = false;
      var parent = this.parent;
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      var actPoint = parent.activeObj.activePoint;
      var startX = isStart ? actPoint.startX : actPoint.endX;
      var startY = isStart ? actPoint.startY : actPoint.endY;
      var endX = isStart ? actPoint.endX : actPoint.startX;
      var endY = isStart ? actPoint.endY : actPoint.startY;
      var wrapperWidth = parent.upperCanvas.width;
      var wrapperHeight = parent.upperCanvas.height;
      var minX = destLeft < 0 ? 0 : destLeft;
      var minY = destTop < 0 ? 0 : destTop;
      var maxX = destLeft + destWidth > wrapperWidth ? wrapperWidth : destLeft + destWidth;
      var maxY = destTop + destHeight > wrapperHeight ? wrapperHeight : destTop + destHeight;
      if (Browser.isDevice) {
        if (startX < minX) {
          startX = minX;
        }
        if (startY < minY) {
          startY = minY;
        }
        if (endX > maxX) {
          endX = maxX;
        }
        if (endY > maxY) {
          endY = maxY;
        }
      } else {
        if (startX < destLeft) {
          startX = destLeft;
        }
        if (startY < destTop) {
          startY = destTop;
        }
        if (endX > destLeft + destWidth) {
          endX = destLeft + destWidth;
        }
        if (endY > destTop + destHeight) {
          endY = destTop + destHeight;
        }
      }
      if (parent.transform.straighten !== 0) {
        var obj = { isIntersect: null, arr: null };
        parent.notify("draw", { prop: "updateImgCanvasPoints", onPropertyChange: false });
        parent.notify("draw", { prop: "isLinesIntersect", onPropertyChange: false, value: { obj } });
        if (obj["arr"][0] || obj["arr"][1] || obj["arr"][2] || obj["arr"][3]) {
          isLimiting = true;
        }
      }
      if (isStart) {
        actPoint.startX = startX;
        actPoint.startY = startY;
        actPoint.endX = endX;
        actPoint.endY = endY;
      } else {
        actPoint.startX = endX;
        actPoint.startY = endY;
        actPoint.endX = startX;
        actPoint.endY = startY;
      }
      return isLimiting;
    };
    Selection2.prototype.isMouseOutsideImg = function(x, y) {
      var obj = { bool: false };
      this.parent.notify("draw", { prop: "updateImgCanvasPoints", onPropertyChange: false });
      this.parent.notify("draw", { prop: "isPointsInsideImg", value: { obj, x, y } });
      return obj["bool"];
    };
    Selection2.prototype.preventDraggingInvertly = function() {
      var isLimiting = false;
      var parent = this.parent;
      if (parent.activeObj.shape === "image") {
        return isLimiting;
      }
      var splitWords;
      var cropResize;
      if (parent.activeObj.shape !== undefined) {
        splitWords = parent.activeObj.shape.split("-");
      }
      if (splitWords !== undefined && splitWords[0] === "crop") {
        cropResize = true;
      }
      if (!this.isPreventDragging && parent.activeObj.rotatedAngle === 0 && (parent.activeObj.preventShapeDragOut || parent.activeObj.shape === "redact" || cropResize)) {
        isLimiting = this.limitDrag(true);
        var shapeColl = ["line", "arrow", "path"];
        if (shapeColl.indexOf(parent.activeObj.shape) > -1) {
          isLimiting = this.limitDrag(false);
        }
      }
      return isLimiting;
    };
    Selection2.prototype.preventTextDraggingInvertly = function() {
      var parent = this.parent;
      var isLimiting = false;
      var actPoint = parent.activeObj.activePoint;
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      if (!this.isPreventDragging) {
        if (actPoint.startX < destLeft || actPoint.startY < destTop || actPoint.endX > destLeft + destWidth || actPoint.endY > destTop + destHeight) {
          isLimiting = true;
        }
      }
      return isLimiting;
    };
    Selection2.prototype.preventInverseResize = function(tempActiveObj) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      if (actPoint.width < 0) {
        actPoint.width = 0;
        actPoint.startX = tempActiveObj.activePoint.startX;
        actPoint.endX = tempActiveObj.activePoint.endX;
      }
      if (actPoint.height < 0) {
        actPoint.height = 0;
        actPoint.startY = tempActiveObj.activePoint.startY;
        actPoint.endY = tempActiveObj.activePoint.endY;
      }
    };
    Selection2.prototype.getScaleRatio = function(scale) {
      var parent = this.parent;
      var point = { x: scale, y: scale };
      if (parent.activeObj.shape && parent.activeObj.shape !== "crop-custom" && parent.activeObj.shape !== "crop-circle" && parent.activeObj.shape !== "crop-square") {
        var ratio = parent.activeObj.shape === "image" || parent.activeObj.shape === "text" ? this.findImageRatio(parent.activeObj.activePoint.width, parent.activeObj.activePoint.height).split("-") : parent.activeObj.shape.split("-");
        if (ratio.length > 1 || parent.activeObj.shape === "image" || parent.activeObj.shape === "text") {
          ratio = parent.activeObj.shape === "image" || parent.activeObj.shape === "text" ? ratio[0].split(":") : ratio[1].split(":");
          var newScale = scale / parseInt(ratio[1], 10);
          point.x = newScale * parseInt(ratio[0], 10);
          point.y = newScale * parseInt(ratio[1], 10);
        }
      }
      return point;
    };
    Selection2.prototype.findImageRatio = function(width, height, obj) {
      var gcd = function(a, b) {
        if (b === 0) {
          return a;
        }
        return gcd(b, a % b);
      };
      var divisor = gcd(width, height);
      var ratio = width / divisor + ":" + height / divisor;
      if (obj) {
        obj["ratio"] = ratio;
      }
      return ratio;
    };
    Selection2.prototype.revertResizing = function(tempActiveObj) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      if (this.preventDraggingInvertly()) {
        actPoint.startX = tempActiveObj.activePoint.startX;
        actPoint.startY = tempActiveObj.activePoint.startY;
        actPoint.endX = tempActiveObj.activePoint.endX;
        actPoint.endY = tempActiveObj.activePoint.endY;
      }
    };
    Selection2.prototype.performSEResize = function(x, y, tempActiveObj, actPoint) {
      var parent = this.parent;
      this.resizeImg(x, y, "se-resize", tempActiveObj);
      if (actPoint.endX < actPoint.startX) {
        var temp = actPoint.endX;
        actPoint.endX = actPoint.startX;
        actPoint.startX = temp;
        this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = "sw-resize";
      }
      if (actPoint.endY < actPoint.startY) {
        var temp = actPoint.endY;
        actPoint.endY = actPoint.startY;
        actPoint.startY = temp;
        this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = "ne-resize";
      }
      this.revertCustomSelection(actPoint, tempActiveObj, "se-resize");
      this.revertResizing(tempActiveObj);
    };
    Selection2.prototype.performNWResize = function(x, y, tempActiveObj, actPoint) {
      var parent = this.parent;
      this.resizeImg(x, y, "nw-resize", tempActiveObj);
      if (actPoint.startX > actPoint.endX) {
        var temp = actPoint.startX;
        actPoint.startX = actPoint.endX;
        actPoint.endX = temp;
        this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = "ne-resize";
      }
      if (actPoint.startY > actPoint.endY) {
        var temp = actPoint.startY;
        actPoint.startY = actPoint.endY;
        actPoint.endY = temp;
        this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = "sw-resize";
      }
      this.revertCustomSelection(actPoint, tempActiveObj, "nw-resize");
      this.revertResizing(tempActiveObj);
    };
    Selection2.prototype.isCustomSelection = function() {
      if (this.parent.activeObj.shape) {
        var shapeColl = ["custom", "circle", "square", "2:3", "3:2", "3:4", "4:3", "4:5", "5:4", "5:7", "7:5", "9:16", "16:9"];
        return this.parent.activeObj.shape.indexOf("crop-") > -1 && shapeColl.indexOf(this.parent.activeObj.shape.split("-")[1]) === -1;
      }
      return false;
    };
    Selection2.prototype.revertCustomSelection = function(actPoint, tempActiveObj, type) {
      var parent = this.parent;
      if (this.isCustomSelection()) {
        var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
        var endX = destLeft + destWidth < parent.lowerCanvas.width ? destLeft + destWidth : parent.lowerCanvas.width;
        var endY = destTop + destHeight < parent.lowerCanvas.height ? destTop + destHeight : parent.lowerCanvas.height;
        var left = destLeft > 0 ? destLeft : 0;
        var top_1 = destTop > 0 ? destTop : 0;
        var endY1 = destTop > 0 ? destTop : 0;
        var endX1 = destLeft > 0 ? destLeft : 0;
        if (type === "se-resize" && (actPoint.endX > endX || actPoint.endY > endY) || type === "nw-resize" && (actPoint.startX < left || actPoint.startY < top_1) || type === "ne-resize" && (actPoint.endX > endX || actPoint.startY < endY1) || type === "sw-resize" && (actPoint.startX < endX1 || actPoint.endY > endY)) {
          this.revertPoints(actPoint, tempActiveObj);
        }
      }
    };
    Selection2.prototype.revertPoints = function(actPoint, tempActiveObj) {
      actPoint.startX = tempActiveObj.activePoint.startX;
      actPoint.startY = tempActiveObj.activePoint.startY;
      actPoint.endX = tempActiveObj.activePoint.endX;
      actPoint.endY = tempActiveObj.activePoint.endY;
      actPoint.width = tempActiveObj.activePoint.width;
      actPoint.height = tempActiveObj.activePoint.height;
    };
    Selection2.prototype.updateNWPoints = function(x, y) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var width;
      var height;
      var scale;
      var tempActiveObj = extend({}, parent.activeObj, null, true);
      if (parent.activeObj.shape === "text") {
        this.resizeImg(x, y, "nw-resize", tempActiveObj);
        parent.notify("shape", {
          prop: "updateFontSize",
          onPropertyChange: false,
          value: { obj: parent.activeObj }
        });
      } else {
        var splitWords = undefined;
        if (parent.activeObj.shape !== undefined) {
          splitWords = parent.activeObj.shape.split("-");
        }
        if (parent.activeObj.shape === "crop-custom" || parent.activeObj.shape !== undefined && splitWords[0] !== "crop" || this.isCustomSelection()) {
          if (parent.activeObj.shape === "image" || this.isCustomSelection()) {
            this.resizeImg(x, y, "nw-resize", tempActiveObj);
          } else {
            this.adjustNWPoints(actPoint, x, y, parent.activeObj.rotatedAngle);
          }
          if (actPoint.startX > actPoint.endX) {
            var temp = actPoint.startX;
            actPoint.startX = actPoint.endX;
            actPoint.endX = temp;
            this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = "ne-resize";
          }
          if (actPoint.startY > actPoint.endY) {
            var temp = actPoint.startY;
            actPoint.startY = actPoint.endY;
            actPoint.endY = temp;
            this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = "sw-resize";
          }
          this.revertCustomSelection(actPoint, tempActiveObj, "nw-resize");
          this.revertResizing(tempActiveObj);
        } else {
          var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop;
          if (actPoint.startX < x && actPoint.startY < y) {
            width = x - actPoint.startX;
            height = y - actPoint.startY;
            scale = Math.min(width, height);
            var newScale = this.getScaleRatio(scale);
            actPoint.startX += newScale.x;
            actPoint.startY += newScale.y;
            var left = destLeft > 0 ? destLeft : 0;
            var top_2 = destTop > 0 ? destTop : 0;
            if (actPoint.startX < left || actPoint.startY < top_2) {
              actPoint.startX -= newScale.x;
              actPoint.startY -= newScale.y;
            }
          } else {
            width = actPoint.startX - x;
            height = y - actPoint.endY;
            scale = Math.max(width, height);
            var newScale = this.getScaleRatio(scale);
            actPoint.startX -= newScale.x;
            actPoint.startY -= newScale.y;
            var left = destLeft > 0 ? destLeft : 0;
            var top_3 = destTop > 0 ? destTop : 0;
            if (actPoint.startX < left || actPoint.startY < top_3) {
              actPoint.startX += newScale.x;
              actPoint.startY += newScale.y;
            }
          }
          actPoint.width = actPoint.endX - actPoint.startX;
          actPoint.height = actPoint.endY - actPoint.startY;
          this.revertResizing(tempActiveObj);
        }
        actPoint.width = actPoint.endX - actPoint.startX;
        actPoint.height = actPoint.endY - actPoint.startY;
        this.preventInverseResize(tempActiveObj);
      }
    };
    Selection2.prototype.updateNPoints = function(x, y) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var width;
      var height;
      var scale;
      var tempActiveObj = extend({}, parent.activeObj, null, true);
      if (parent.activeObj.shape !== "text") {
        var splitWords = undefined;
        if (parent.activeObj.shape) {
          splitWords = parent.activeObj.shape.split("-");
        }
        if (parent.activeObj.shape === "crop-custom" || parent.activeObj.shape && splitWords[0] !== "crop") {
          if (parent.activeObj.shape !== "line" && parent.activeObj.shape !== "arrow" && parent.activeObj.shape !== "path" && parent.activeObj.rotatedAngle !== 0 && this.dragPoint.startX) {
            if (this.dragPoint.startX && this.dragPoint.startY) {
              this.previousPoint.x = this.dragPoint.endX;
              this.previousPoint.y = this.dragPoint.endY;
              this.dragPoint.endX = x;
              this.dragPoint.endY = y;
            }
            width = this.dragPoint.endX - this.previousPoint.x;
            height = this.dragPoint.endY - this.previousPoint.y;
            this.adjustRotationPoints(actPoint, width, height, parent.activeObj.rotatedAngle);
          } else {
            actPoint.startY = y;
            actPoint.height = actPoint.endY - actPoint.startY;
          }
          if (actPoint.startY > actPoint.endY) {
            var temp = actPoint.startY;
            actPoint.startY = actPoint.endY;
            actPoint.endY = temp;
            this.dragElement = this.resizedElement = "s-resize";
          }
          this.revertResizing(tempActiveObj);
        } else {
          var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth;
          if (this.isCustomSelection()) {
            this.performNWResize(x, y, tempActiveObj, actPoint);
          } else if (actPoint.endX > x && actPoint.startY < y) {
            width = actPoint.endX - x;
            height = y - actPoint.startY;
            scale = Math.min(width, height);
            var newScale = this.getScaleRatio(scale);
            actPoint.endX -= newScale.x;
            actPoint.startY += newScale.y;
            if (actPoint.endX > destLeft + destWidth || actPoint.startY < destTop) {
              actPoint.endX += newScale.x;
              actPoint.startY -= newScale.y;
            }
          } else {
            width = x - actPoint.endX;
            height = actPoint.startY - y;
            scale = Math.max(width, height);
            var newScale = this.getScaleRatio(scale);
            actPoint.endX += newScale.x;
            actPoint.startY -= newScale.y;
            if (actPoint.endX > destLeft + destWidth || actPoint.startY < destTop) {
              actPoint.endX -= newScale.x;
              actPoint.startY += newScale.y;
            }
          }
          actPoint.width = actPoint.endX - actPoint.startX;
          actPoint.height = actPoint.endY - actPoint.startY;
          this.revertResizing(tempActiveObj);
        }
      }
    };
    Selection2.prototype.updateNEPoints = function(x, y) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var width;
      var height;
      var scale;
      var tempActiveObj = extend({}, parent.activeObj, null, true);
      if (parent.activeObj.shape === "text") {
        this.resizeImg(x, y, "ne-resize", tempActiveObj);
        parent.notify("shape", {
          prop: "updateFontSize",
          onPropertyChange: false,
          value: { obj: parent.activeObj }
        });
      } else {
        var splitWords = undefined;
        if (parent.activeObj.shape) {
          splitWords = parent.activeObj.shape.split("-");
        }
        if (parent.activeObj.shape === "crop-custom" || parent.activeObj.shape !== undefined && splitWords[0] !== "crop" || this.isCustomSelection()) {
          if (parent.activeObj.shape === "image" || this.isCustomSelection()) {
            this.resizeImg(x, y, "ne-resize", tempActiveObj);
          } else {
            this.adjustNEPoints(actPoint, x, y, parent.activeObj.rotatedAngle);
          }
          if (actPoint.endX < actPoint.startX) {
            var temp = actPoint.endX;
            actPoint.endX = actPoint.startX;
            actPoint.startX = temp;
            this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = "nw-resize";
          }
          if (actPoint.startY > actPoint.endY) {
            var temp = actPoint.startY;
            actPoint.startY = actPoint.endY;
            actPoint.endY = temp;
            this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = "se-resize";
          }
          this.revertCustomSelection(actPoint, tempActiveObj, "ne-resize");
          this.revertResizing(tempActiveObj);
        } else {
          var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth;
          if (actPoint.endX > x && actPoint.startY < y) {
            width = actPoint.endX - x;
            height = y - actPoint.startY;
            scale = Math.min(width, height);
            var newScale = this.getScaleRatio(scale);
            actPoint.endX -= newScale.x;
            actPoint.startY += newScale.y;
            var endX = destLeft + destWidth < parent.lowerCanvas.width ? destLeft + destWidth : parent.lowerCanvas.width;
            var endY = destTop > 0 ? destTop : 0;
            if (actPoint.endX > endX || actPoint.startY < endY) {
              actPoint.endX += newScale.x;
              actPoint.startY -= newScale.y;
            }
          } else {
            width = x - actPoint.endX;
            height = actPoint.startY - y;
            scale = Math.max(width, height);
            var newScale = this.getScaleRatio(scale);
            actPoint.endX += newScale.x;
            actPoint.startY -= newScale.y;
            var endX = destLeft + destWidth < parent.lowerCanvas.width ? destLeft + destWidth : parent.lowerCanvas.width;
            var endY = destTop > 0 ? destTop : 0;
            if (actPoint.endX > endX || actPoint.startY < endY) {
              actPoint.endX -= newScale.x;
              actPoint.startY += newScale.y;
            }
          }
          actPoint.width = actPoint.endX - actPoint.startX;
          actPoint.height = actPoint.endY - actPoint.startY;
          this.revertResizing(tempActiveObj);
        }
        actPoint.width = actPoint.endX - actPoint.startX;
        actPoint.height = actPoint.endY - actPoint.startY;
        this.preventInverseResize(tempActiveObj);
      }
    };
    Selection2.prototype.updateWPoints = function(x, y) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var width;
      var height;
      var scale;
      var tempActiveObj = extend({}, parent.activeObj, null, true);
      if (parent.activeObj.shape !== "text") {
        var splitWords = undefined;
        if (parent.activeObj.shape) {
          splitWords = parent.activeObj.shape.split("-");
        }
        if (parent.activeObj.shape === "crop-custom" || parent.activeObj.shape && splitWords[0] !== "crop") {
          if (parent.activeObj.shape !== "line" && parent.activeObj.shape !== "arrow" && parent.activeObj.shape !== "path" && parent.activeObj.rotatedAngle !== 0 && this.dragPoint.startX) {
            if (this.dragPoint.startX && this.dragPoint.startY) {
              this.previousPoint.x = this.dragPoint.endX;
              this.previousPoint.y = this.dragPoint.endY;
              this.dragPoint.endX = x;
              this.dragPoint.endY = y;
            }
            width = this.dragPoint.endX - this.previousPoint.x;
            height = this.dragPoint.endY - this.previousPoint.y;
            this.adjustRotationPoints(actPoint, width, height, parent.activeObj.rotatedAngle);
          } else {
            actPoint.startX = x;
            actPoint.width = actPoint.endX - actPoint.startX;
          }
          if (parent.activeObj.shape === "line" || parent.activeObj.shape === "arrow" || parent.activeObj.shape === "path") {
            actPoint.startY = y;
            actPoint.height = actPoint.endY - actPoint.startY;
            if (this.adjustActObjForLineArrow()) {
              this.dragElement = "e-resize";
              if (parent.activeObj.triangleDirection === "right") {
                parent.activeObj.triangleDirection = "left";
              } else if (parent.activeObj.triangleDirection === "left") {
                parent.activeObj.triangleDirection = "right";
              }
            }
          } else if (actPoint.startX > actPoint.endX) {
            var temp = actPoint.startX;
            actPoint.startX = actPoint.endX;
            actPoint.endX = temp;
            this.dragElement = this.resizedElement = "e-resize";
          }
          this.revertResizing(tempActiveObj);
        } else {
          var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destHeight = _a.destHeight;
          if (this.isCustomSelection()) {
            this.performNWResize(x, y, tempActiveObj, actPoint);
          } else if (actPoint.startX < x && actPoint.endY > y) {
            width = x - actPoint.startX;
            height = actPoint.endY - y;
            scale = Math.min(width, height);
            var newScale = this.getScaleRatio(scale);
            actPoint.startX += newScale.x;
            actPoint.endY -= newScale.y;
            if (actPoint.startX < destLeft || actPoint.endY > destTop + destHeight) {
              actPoint.startX -= newScale.x;
              actPoint.endY += newScale.y;
            }
          } else {
            width = actPoint.startX - x;
            height = y - actPoint.endY;
            scale = Math.max(width, height);
            var newScale = this.getScaleRatio(scale);
            actPoint.startX -= newScale.x;
            actPoint.endY += newScale.y;
            if (actPoint.startX < destLeft || actPoint.endY > destTop + destHeight) {
              actPoint.startX += newScale.x;
              actPoint.endY -= newScale.y;
            }
          }
          actPoint.width = actPoint.endX - actPoint.startX;
          actPoint.height = actPoint.endY - actPoint.startY;
          this.revertResizing(tempActiveObj);
        }
      }
    };
    Selection2.prototype.updateEPoints = function(x, y) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var width;
      var height;
      var scale;
      var tempActiveObj = extend({}, parent.activeObj, null, true);
      if (parent.activeObj.shape !== "text") {
        var splitWords = undefined;
        if (parent.activeObj.shape) {
          splitWords = parent.activeObj.shape.split("-");
        }
        if (parent.activeObj.shape === "crop-custom" || parent.activeObj.shape && splitWords[0] !== "crop") {
          if (parent.activeObj.shape !== "line" && parent.activeObj.shape !== "arrow" && parent.activeObj.shape !== "path" && parent.activeObj.rotatedAngle !== 0 && this.dragPoint.startX) {
            if (this.dragPoint.startX && this.dragPoint.startY) {
              this.previousPoint.x = this.dragPoint.endX;
              this.previousPoint.y = this.dragPoint.endY;
              this.dragPoint.endX = x;
              this.dragPoint.endY = y;
            }
            width = this.dragPoint.endX - this.previousPoint.x;
            height = this.dragPoint.endY - this.previousPoint.y;
            this.adjustRotationPoints(actPoint, width, height, parent.activeObj.rotatedAngle);
          } else {
            actPoint.endX = x;
            actPoint.width = actPoint.endX - actPoint.startX;
          }
          if (parent.activeObj.shape === "line" || parent.activeObj.shape === "arrow" || parent.activeObj.shape === "path") {
            actPoint.endY = y;
            actPoint.height = actPoint.endY - actPoint.startY;
            if (this.adjustActObjForLineArrow()) {
              this.dragElement = "w-resize";
              if (parent.activeObj.triangleDirection === "right") {
                parent.activeObj.triangleDirection = "left";
              } else if (parent.activeObj.triangleDirection === "left") {
                parent.activeObj.triangleDirection = "right";
              }
            }
          } else if (actPoint.endX < actPoint.startX) {
            var temp = actPoint.endX;
            actPoint.endX = actPoint.startX;
            actPoint.startX = temp;
            this.dragElement = this.resizedElement = "w-resize";
          }
          this.revertResizing(tempActiveObj);
        } else {
          var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
          if (this.isCustomSelection()) {
            this.performSEResize(x, y, tempActiveObj, actPoint);
          } else if (actPoint.endX > x && actPoint.endY > y) {
            width = actPoint.endX - x;
            height = actPoint.endY - y;
            scale = Math.min(width, height);
            var newScale = this.getScaleRatio(scale);
            actPoint.endX -= newScale.x;
            actPoint.endY -= newScale.y;
            if (actPoint.endX > destLeft + destWidth || actPoint.endY > destTop + destHeight) {
              actPoint.endX += newScale.x;
              actPoint.endY += newScale.y;
            }
          } else {
            width = x - actPoint.endX;
            height = y - actPoint.endY;
            scale = Math.max(width, height);
            var newScale = this.getScaleRatio(scale);
            actPoint.endX += newScale.x;
            actPoint.endY += newScale.y;
            if (actPoint.endX > destLeft + destWidth || actPoint.endY > destTop + destHeight) {
              actPoint.endX -= newScale.x;
              actPoint.endY -= newScale.y;
            }
          }
          actPoint.width = actPoint.endX - actPoint.startX;
          actPoint.height = actPoint.endY - actPoint.startY;
          this.revertResizing(tempActiveObj);
        }
      }
    };
    Selection2.prototype.updateSWPoints = function(x, y) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var width;
      var height;
      var scale;
      var tempActiveObj = extend({}, parent.activeObj, null, true);
      if (parent.activeObj.shape === "text") {
        this.resizeImg(x, y, "sw-resize", tempActiveObj);
        parent.notify("shape", {
          prop: "updateFontSize",
          onPropertyChange: false,
          value: { obj: parent.activeObj }
        });
      } else {
        var splitWords = undefined;
        if (parent.activeObj.shape !== undefined) {
          splitWords = parent.activeObj.shape.split("-");
        }
        if (parent.activeObj.shape === "crop-custom" || parent.activeObj.shape !== undefined && splitWords[0] !== "crop" || this.isCustomSelection()) {
          if (parent.activeObj.shape === "image" || this.isCustomSelection()) {
            this.resizeImg(x, y, "sw-resize", tempActiveObj);
          } else {
            this.adjustSWPoints(actPoint, x, y, parent.activeObj.rotatedAngle);
          }
          if (actPoint.startX > actPoint.endX) {
            var temp = actPoint.startX;
            actPoint.startX = actPoint.endX;
            actPoint.endX = temp;
            this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = "se-resize";
          }
          if (actPoint.endY < actPoint.startY) {
            var temp = actPoint.endY;
            actPoint.endY = actPoint.startY;
            actPoint.startY = temp;
            this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = "nw-resize";
          }
          this.revertCustomSelection(actPoint, tempActiveObj, "sw-resize");
          this.revertResizing(tempActiveObj);
        } else {
          var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destHeight = _a.destHeight;
          if (actPoint.startX < x && actPoint.endY > y) {
            width = x - actPoint.startX;
            height = actPoint.endY - y;
            scale = Math.min(width, height);
            var newScale = this.getScaleRatio(scale);
            actPoint.startX += newScale.x;
            actPoint.endY -= newScale.y;
            var endX = destLeft > 0 ? destLeft : 0;
            var endY = destTop + destHeight < parent.lowerCanvas.height ? destTop + destHeight : parent.lowerCanvas.height;
            if (actPoint.startX < endX || actPoint.endY > endY) {
              actPoint.startX -= newScale.x;
              actPoint.endY += newScale.y;
            }
          } else {
            width = actPoint.startX - x;
            height = y - actPoint.endY;
            scale = Math.max(width, height);
            var newScale = this.getScaleRatio(scale);
            actPoint.startX -= newScale.x;
            actPoint.endY += newScale.y;
            var endX = destLeft > 0 ? destLeft : 0;
            var endY = destTop + destHeight < parent.lowerCanvas.height ? destTop + destHeight : parent.lowerCanvas.height;
            if (actPoint.startX < endX || actPoint.endY > endY) {
              actPoint.startX += newScale.x;
              actPoint.endY -= newScale.y;
            }
          }
          actPoint.width = actPoint.endX - actPoint.startX;
          actPoint.height = actPoint.endY - actPoint.startY;
          this.revertResizing(tempActiveObj);
        }
        actPoint.width = actPoint.endX - actPoint.startX;
        actPoint.height = actPoint.endY - actPoint.startY;
        this.preventInverseResize(tempActiveObj);
      }
    };
    Selection2.prototype.updateSPoints = function(x, y) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var width;
      var height;
      var scale;
      var tempActiveObj = extend({}, parent.activeObj, null, true);
      if (parent.activeObj.shape !== "text") {
        var splitWords = undefined;
        if (parent.activeObj.shape) {
          splitWords = parent.activeObj.shape.split("-");
        }
        if (parent.activeObj.shape === "crop-custom" || parent.activeObj.shape && splitWords[0] !== "crop") {
          if (parent.activeObj.shape !== "line" && parent.activeObj.shape !== "arrow" && parent.activeObj.shape !== "path" && parent.activeObj.rotatedAngle !== 0 && this.dragPoint.startX) {
            if (this.dragPoint.startX && this.dragPoint.startY) {
              this.previousPoint.x = this.dragPoint.endX;
              this.previousPoint.y = this.dragPoint.endY;
              this.dragPoint.endX = x;
              this.dragPoint.endY = y;
            }
            width = this.dragPoint.endX - this.previousPoint.x;
            height = this.dragPoint.endY - this.previousPoint.y;
            this.adjustRotationPoints(actPoint, width, height, parent.activeObj.rotatedAngle);
          } else {
            actPoint.endY = y;
            actPoint.height = actPoint.endY - actPoint.startY;
          }
          if (actPoint.endY < actPoint.startY) {
            var temp = actPoint.endY;
            actPoint.endY = actPoint.startY;
            actPoint.startY = temp;
            this.dragElement = this.resizedElement = "n-resize";
          }
          this.revertResizing(tempActiveObj);
        } else {
          var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
          if (this.isCustomSelection()) {
            this.performSEResize(x, y, tempActiveObj, actPoint);
          } else if (actPoint.endX > x && actPoint.endY > y) {
            width = actPoint.endX - x;
            height = actPoint.endY - y;
            scale = Math.min(width, height);
            var newScale = this.getScaleRatio(scale);
            actPoint.endX -= newScale.x;
            actPoint.endY -= newScale.y;
            if (actPoint.endX > destLeft + destWidth || actPoint.endY > destTop + destHeight) {
              actPoint.endX += newScale.x;
              actPoint.endY += newScale.y;
            }
          } else {
            width = x - actPoint.endX;
            height = y - actPoint.endY;
            scale = Math.max(width, height);
            var newScale = this.getScaleRatio(scale);
            actPoint.endX += newScale.x;
            actPoint.endY += newScale.x;
            if (actPoint.endX > destLeft + destWidth || actPoint.endY > destTop + destHeight) {
              actPoint.endX -= newScale.x;
              actPoint.endY -= newScale.y;
            }
          }
          actPoint.width = actPoint.endX - actPoint.startX;
          actPoint.height = actPoint.endY - actPoint.startY;
          this.revertResizing(tempActiveObj);
        }
      }
    };
    Selection2.prototype.updateSEPoints = function(x, y) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var width;
      var height;
      var scale;
      var tempActiveObj = extend({}, parent.activeObj, null, true);
      if (parent.activeObj.shape === "text") {
        this.resizeImg(x, y, "se-resize", tempActiveObj);
        parent.notify("shape", {
          prop: "updateFontSize",
          onPropertyChange: false,
          value: { obj: parent.activeObj }
        });
      } else {
        var splitWords = undefined;
        var newScale = undefined;
        if (parent.activeObj.shape !== undefined) {
          splitWords = parent.activeObj.shape.split("-");
        }
        if (parent.activeObj.shape === "crop-custom" || parent.activeObj.shape !== undefined && splitWords[0] !== "crop" || this.isCustomSelection()) {
          if (parent.activeObj.shape === "image" || this.isCustomSelection()) {
            this.resizeImg(x, y, "se-resize", tempActiveObj);
          } else {
            this.adjustSEPoints(actPoint, x, y, parent.activeObj.rotatedAngle);
          }
          if (actPoint.endX < actPoint.startX) {
            var temp = actPoint.endX;
            actPoint.endX = actPoint.startX;
            actPoint.startX = temp;
            this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = "sw-resize";
          }
          if (actPoint.endY < actPoint.startY) {
            var temp = actPoint.endY;
            actPoint.endY = actPoint.startY;
            actPoint.startY = temp;
            this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = "ne-resize";
          }
          this.revertCustomSelection(actPoint, tempActiveObj, "se-resize");
          this.revertResizing(tempActiveObj);
        } else {
          var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
          if (actPoint.endX > x && actPoint.endY > y) {
            width = actPoint.endX - x;
            height = actPoint.endY - y;
            scale = Math.min(width, height);
            newScale = this.getScaleRatio(scale);
            actPoint.endX -= newScale.x;
            actPoint.endY -= newScale.y;
            var endX = destLeft + destWidth < parent.lowerCanvas.width ? destLeft + destWidth : parent.lowerCanvas.width;
            var endY = destTop + destHeight < parent.lowerCanvas.height ? destTop + destHeight : parent.lowerCanvas.height;
            if (actPoint.endX > endX || actPoint.endY > endY) {
              actPoint.endX += newScale.x;
              actPoint.endY += newScale.y;
            }
          } else {
            width = x - actPoint.endX;
            height = y - actPoint.endY;
            scale = Math.max(width, height);
            newScale = this.getScaleRatio(scale);
            actPoint.endX += newScale.x;
            actPoint.endY += newScale.y;
            var endX = destLeft + destWidth < parent.lowerCanvas.width ? destLeft + destWidth : parent.lowerCanvas.width;
            var endY = destTop + destHeight < parent.lowerCanvas.height ? destTop + destHeight : parent.lowerCanvas.height;
            if (actPoint.endX > endX || actPoint.endY > endY) {
              actPoint.endX -= newScale.x;
              actPoint.endY -= newScale.y;
            }
          }
          actPoint.width = actPoint.endX - actPoint.startX;
          actPoint.height = actPoint.endY - actPoint.startY;
          this.revertResizing(tempActiveObj);
        }
        this.preventInverseResize(tempActiveObj);
      }
    };
    Selection2.prototype.resizeImg = function(x, y, elem, tempActiveObj) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var width;
      var height;
      var scale;
      var newScale;
      if (this.previousPoint.x !== 0 && this.previousPoint.y !== 0) {
        if (this.currentDrawingShape === "text") {
          this.setCursor(x, y);
          if (parent.activeObj.textSettings.fontSize === 0) {
            parent.activeObj.textSettings.fontSize = 11;
            parent.notify("shape", {
              prop: "updateFontRatio",
              onPropertyChange: false,
              value: { obj: parent.activeObj, isTextArea: null }
            });
            parent.activeObj.textSettings.text = parent.activeObj.keyHistory = "Enter Text";
            parent.notify("shape", {
              prop: "updateFontStyles",
              onPropertyChange: false,
              value: { isTextBox: null }
            });
            var width_2 = this.upperContext.measureText(parent.activeObj.textSettings.text).width + parent.activeObj.textSettings.fontSize * 0.5;
            actPoint.endX = actPoint.startX + width_2;
            actPoint.endY = actPoint.startY + parent.activeObj.textSettings.fontSize;
            actPoint.width = actPoint.endX - actPoint.startX;
            actPoint.height = actPoint.endY - actPoint.startY;
            tempActiveObj = extend({}, parent.activeObj, null, true);
            parent.notify("draw", { prop: "updateActiveObject", onPropertyChange: false, value: {
              actPoint: parent.activeObj.activePoint,
              obj: parent.activeObj,
              isMouseMove: null,
              x: null,
              y: null
            } });
          }
        }
        switch (parent.upperCanvas.style.cursor) {
          case "se-resize":
          case "s-resize":
            if (this.previousPoint.x > x || this.previousPoint.y > y) {
              width = this.previousPoint.x - x;
              height = this.previousPoint.y - y;
              scale = (width + height) / 2;
              newScale = this.getScaleRatio(scale);
              this.adjustRotationPoints(actPoint, -Math.abs(newScale.x), -Math.abs(newScale.y), parent.activeObj.rotatedAngle, "img-resize", elem);
            } else if (this.previousPoint.x !== 0 && this.previousPoint.y !== 0) {
              width = x - this.previousPoint.x;
              height = y - this.previousPoint.y;
              scale = (width + height) / 2;
              newScale = this.getScaleRatio(scale);
              this.adjustRotationPoints(actPoint, Math.abs(newScale.x), Math.abs(newScale.y), parent.activeObj.rotatedAngle, "img-resize", elem);
            }
            break;
          case "sw-resize":
            if (this.previousPoint.x < x || this.previousPoint.y > y) {
              width = x - this.previousPoint.x;
              height = this.previousPoint.y - y;
              scale = (width + height) / 2;
              newScale = this.getScaleRatio(scale);
              this.adjustRotationPoints(actPoint, -Math.abs(newScale.x), -Math.abs(newScale.y), parent.activeObj.rotatedAngle, "img-resize", elem);
            } else if (this.previousPoint.x !== 0 && this.previousPoint.y !== 0) {
              width = this.previousPoint.x - x;
              height = y - this.previousPoint.y;
              scale = (width + height) / 2;
              newScale = this.getScaleRatio(scale);
              this.adjustRotationPoints(actPoint, Math.abs(newScale.x), Math.abs(newScale.y), parent.activeObj.rotatedAngle, "img-resize", elem);
            }
            break;
          case "w-resize":
          case "nw-resize":
            if (this.previousPoint.x < x || this.previousPoint.y < y) {
              width = x - this.previousPoint.x;
              height = y - this.previousPoint.y;
              scale = (width + height) / 2;
              newScale = this.getScaleRatio(scale);
              this.adjustRotationPoints(actPoint, -Math.abs(newScale.x), -Math.abs(newScale.y), parent.activeObj.rotatedAngle, "img-resize", elem);
            } else if (this.previousPoint.x !== 0 && this.previousPoint.y !== 0) {
              width = this.previousPoint.x - x;
              height = this.previousPoint.y - y;
              scale = (width + height) / 2;
              newScale = this.getScaleRatio(scale);
              this.adjustRotationPoints(actPoint, Math.abs(newScale.x), Math.abs(newScale.y), parent.activeObj.rotatedAngle, "img-resize", elem);
            }
            break;
          case "n-resize":
          case "ne-resize":
            if (this.previousPoint.x > x || this.previousPoint.y < y) {
              width = this.previousPoint.x - x;
              height = y - this.previousPoint.y;
              scale = (width + height) / 2;
              newScale = this.getScaleRatio(scale);
              this.adjustRotationPoints(actPoint, -Math.abs(newScale.x), -Math.abs(newScale.y), parent.activeObj.rotatedAngle, "img-resize", elem);
            } else if (this.previousPoint.x !== 0 && this.previousPoint.y !== 0) {
              width = x - this.previousPoint.x;
              height = this.previousPoint.y - y;
              scale = (width + height) / 2;
              newScale = this.getScaleRatio(scale);
              this.adjustRotationPoints(actPoint, Math.abs(newScale.x), Math.abs(newScale.y), parent.activeObj.rotatedAngle, "img-resize", elem);
            }
            break;
          case "e-resize":
            if (this.previousPoint.x > x || this.previousPoint.y > y) {
              width = this.previousPoint.x - x;
              height = this.previousPoint.y - y;
              scale = (width + height) / 2;
              newScale = this.getScaleRatio(scale);
              this.adjustRotationPoints(actPoint, -Math.abs(newScale.x), -Math.abs(newScale.y), parent.activeObj.rotatedAngle, "img-resize", elem);
            } else if (this.previousPoint.x !== 0 && this.previousPoint.y !== 0) {
              width = x - this.previousPoint.x;
              height = y - this.previousPoint.y;
              scale = (width + height) / 2;
              newScale = this.getScaleRatio(scale);
              this.adjustRotationPoints(actPoint, Math.abs(newScale.x), Math.abs(newScale.y), parent.activeObj.rotatedAngle, "img-resize", elem);
            }
            break;
        }
        actPoint.width = actPoint.endX - actPoint.startX;
        actPoint.height = actPoint.endY - actPoint.startY;
        if (actPoint.width < 10 || actPoint.height < 10 || parent.activeObj.shape === "text" && parent.activeObj.rotatedAngle === 0 && this.preventTextDraggingInvertly()) {
          parent.activeObj = extend({}, tempActiveObj, null, true);
        }
      }
      this.previousPoint = { x, y };
    };
    Selection2.prototype.adjustNWPoints = function(rectangle, x, y, angle) {
      var cx = rectangle.startX + rectangle.width / 2;
      var cy = rectangle.startY + rectangle.height / 2;
      var rotatedC = this.rotatePoints(rectangle.endX, rectangle.endY, cx, cy, angle);
      var newCenter = [(rotatedC[0] + x) / 2, (rotatedC[1] + y) / 2];
      var newBottomRight = this.rotatePoints(rotatedC[0], rotatedC[1], newCenter[0], newCenter[1], -angle);
      var newTopLeft = this.rotatePoints(x, y, newCenter[0], newCenter[1], -angle);
      rectangle.endX = newBottomRight[0];
      rectangle.endY = newBottomRight[1];
      rectangle.startY = newTopLeft[1];
      rectangle.startX = newTopLeft[0];
      rectangle.width = rectangle.endX - rectangle.startX;
      rectangle.height = rectangle.endY - rectangle.startY;
      return rectangle;
    };
    Selection2.prototype.adjustNEPoints = function(rectangle, x, y, angle) {
      var cx = rectangle.startX + rectangle.width / 2;
      var cy = rectangle.startY + rectangle.height / 2;
      var rotatedD = this.rotatePoints(rectangle.startX, rectangle.endY, cx, cy, angle);
      var newCenter = [(rotatedD[0] + x) / 2, (rotatedD[1] + y) / 2];
      var newBottomLeft = this.rotatePoints(rotatedD[0], rotatedD[1], newCenter[0], newCenter[1], -angle);
      var newTopRight = this.rotatePoints(x, y, newCenter[0], newCenter[1], -angle);
      rectangle.startX = newBottomLeft[0];
      rectangle.endY = newBottomLeft[1];
      rectangle.width = newTopRight[0] - newBottomLeft[0];
      rectangle.height = newBottomLeft[1] - newTopRight[1];
      rectangle.endX = rectangle.startX + rectangle.width;
      rectangle.startY = rectangle.endY - rectangle.height;
      return rectangle;
    };
    Selection2.prototype.adjustSWPoints = function(rectangle, x, y, angle) {
      var cx = rectangle.startX + rectangle.width / 2;
      var cy = rectangle.startY + rectangle.height / 2;
      var rotatedB = this.rotatePoints(rectangle.endX, rectangle.startY, cx, cy, angle);
      var newCenter = [(rotatedB[0] + x) / 2, (rotatedB[1] + y) / 2];
      var newTopRight = this.rotatePoints(rotatedB[0], rotatedB[1], newCenter[0], newCenter[1], -angle);
      var newBottomLeft = this.rotatePoints(x, y, newCenter[0], newCenter[1], -angle);
      rectangle.endX = newTopRight[0];
      rectangle.startY = newTopRight[1];
      rectangle.startX = newBottomLeft[0];
      rectangle.endY = newBottomLeft[1];
      rectangle.width = rectangle.endX - rectangle.startX;
      rectangle.height = rectangle.endY - rectangle.startY;
      return rectangle;
    };
    Selection2.prototype.adjustSEPoints = function(rectangle, x, y, angle) {
      var cx = rectangle.startX + rectangle.width / 2;
      var cy = rectangle.startY + rectangle.height / 2;
      var rotatedA = this.rotatePoints(rectangle.startX, rectangle.startY, cx, cy, angle);
      var newCenter = [(rotatedA[0] + x) / 2, (rotatedA[1] + y) / 2];
      var newTopLeft = this.rotatePoints(rotatedA[0], rotatedA[1], newCenter[0], newCenter[1], -angle);
      var newBottomRight = this.rotatePoints(x, y, newCenter[0], newCenter[1], -angle);
      rectangle.startX = newTopLeft[0];
      rectangle.startY = newTopLeft[1];
      rectangle.width = newBottomRight[0] - newTopLeft[0];
      rectangle.height = newBottomRight[1] - newTopLeft[1];
      rectangle.endX = rectangle.startX + rectangle.width;
      rectangle.endY = rectangle.startY + rectangle.height;
      return rectangle;
    };
    Selection2.prototype.adjustRotationPoints = function(rectangle, x, y, angle, type, elem) {
      var cx = rectangle.startX + rectangle.width / 2;
      var cy = rectangle.startY + rectangle.height / 2;
      this.getResizeDirection(rectangle, x, y, angle, type, elem);
      var rotatedA = this.rotatePoints(rectangle.startX, rectangle.startY, cx, cy, angle);
      var rotatedB = this.rotatePoints(rectangle.endX, rectangle.startY, cx, cy, angle);
      var rotatedC = this.rotatePoints(rectangle.endX, rectangle.endY, cx, cy, angle);
      var rotatedD = this.rotatePoints(rectangle.startX, rectangle.endY, cx, cy, angle);
      var newCenter = [(rotatedA[0] + rotatedC[0]) / 2, (rotatedA[1] + rotatedC[1]) / 2];
      var newTopLeft = this.rotatePoints(rotatedA[0], rotatedA[1], newCenter[0], newCenter[1], -angle);
      var newBottomLeft = this.rotatePoints(rotatedD[0], rotatedD[1], newCenter[0], newCenter[1], -angle);
      var newTopRight = this.rotatePoints(rotatedB[0], rotatedB[1], newCenter[0], newCenter[1], -angle);
      rectangle.startX = newTopLeft[0];
      rectangle.startY = newTopLeft[1];
      rectangle.endX = newTopRight[0];
      rectangle.endY = newBottomLeft[1];
      rectangle.width = rectangle.endX - rectangle.startX;
      rectangle.height = rectangle.endY - rectangle.startY;
      return rectangle;
    };
    Selection2.prototype.rotatePoints = function(x, y, cx, cy, angle) {
      return [
        (x - cx) * Math.cos(angle) - (y - cy) * Math.sin(angle) + cx,
        (x - cx) * Math.sin(angle) + (y - cy) * Math.cos(angle) + cy
      ];
    };
    Selection2.prototype.setResizedValue = function(element2, value, x, y) {
      switch (element2) {
        case "x":
          value += x;
          break;
        case "y":
          value += y;
          break;
        case "abs-x":
          value += x > 0 ? -x : Math.abs(x);
          break;
        case "abs-y":
          value += y > 0 ? -y : Math.abs(y);
          break;
        case "y-abs-x":
          value += y + (x > 0 ? -x : Math.abs(x)) / 2;
          break;
        case "abs-x-abs-y":
          value += (x > 0 ? -x : Math.abs(x)) + (y > 0 ? -y : Math.abs(y)) / 2;
          break;
        case "abs-y-x":
          value += (y > 0 ? -y : Math.abs(y)) + x / 2;
          break;
        case "x-y":
          value += x + y / 2;
          break;
        case "y-x":
          value += y + x / 2;
          break;
        case "img-resize-x":
          value += x;
          break;
        case "img-resize-y":
          value += y;
          break;
      }
      return value;
    };
    Selection2.prototype.getResizeDirection = function(rectangle, x, y, angle, type, elem) {
      var rotatedAngle = angle * (180 / Math.PI);
      var element2 = this.getResizedElement(rotatedAngle, this.resizedElement);
      if (this.resizedElement === "e-resize") {
        rectangle.width = this.setResizedValue(element2, rectangle.width, x, y);
        rectangle.endX = rectangle.width + rectangle.startX;
      } else if (this.resizedElement === "n-resize") {
        rectangle.startY = this.setResizedValue(element2, rectangle.startY, x, y);
        rectangle.height = rectangle.endY - rectangle.startY;
      } else if (this.resizedElement === "w-resize") {
        rectangle.startX = this.setResizedValue(element2, rectangle.startX, x, y);
        rectangle.width = rectangle.startX + rectangle.endX;
      } else if (this.resizedElement === "s-resize") {
        rectangle.height = this.setResizedValue(element2, rectangle.height, x, y);
        rectangle.endY = rectangle.height + rectangle.startY;
      } else if (type && type === "img-resize") {
        rectangle.width = this.setResizedValue("img-resize-x", rectangle.width, x, y);
        rectangle.height = this.setResizedValue("img-resize-y", rectangle.height, x, y);
        if (elem === "se-resize") {
          rectangle.endX = rectangle.width + rectangle.startX;
          rectangle.endY = rectangle.height + rectangle.startY;
        } else if (elem === "sw-resize") {
          rectangle.startX = rectangle.endX - rectangle.width;
          rectangle.endY = rectangle.height + rectangle.startY;
        } else if (elem === "ne-resize") {
          rectangle.endX = rectangle.width + rectangle.startX;
          rectangle.startY = rectangle.endY - rectangle.height;
        } else if (elem === "nw-resize") {
          rectangle.startX = rectangle.endX - rectangle.width;
          rectangle.startY = rectangle.endY - rectangle.height;
        }
      } else if (type && type === "text") {
        if (elem === "widthHeight") {
          rectangle.width = this.setResizedValue("x-y", rectangle.width, x, y);
          rectangle.endX = rectangle.width + rectangle.startX;
          rectangle.height = this.setResizedValue("y-x", rectangle.height, x, y);
          rectangle.endY = rectangle.height + rectangle.startY;
        } else if (elem === "width") {
          rectangle.width = this.setResizedValue("x-y", rectangle.width, x, y);
          rectangle.endX = rectangle.width + rectangle.startX;
        } else if (elem === "height") {
          rectangle.height = this.setResizedValue("y-abs-x", rectangle.height, x, y);
          rectangle.endY = rectangle.height + rectangle.startY;
        }
      }
    };
    Selection2.prototype.getResizedElement = function(degree, element2) {
      var resizeMappings = [];
      if (element2 === "n-resize") {
        resizeMappings = [
          [337.5, 360, "y"],
          [0, 22.5, "y"],
          [22.5, 67.5, "y-abs-x"],
          [67.5, 112.5, "abs-x"],
          [112.5, 157.5, "abs-x-abs-y"],
          [157.5, 202.5, "abs-y"],
          [202.5, 247.5, "abs-y-x"],
          [247.5, 292.5, "x"],
          [292.5, 337.5, "x-y"]
        ];
      } else if (element2 === "e-resize") {
        resizeMappings = [
          [337.5, 360, "x"],
          [0, 22.5, "x"],
          [22.5, 67.5, "x-y"],
          [67.5, 112.5, "y"],
          [112.5, 157.5, "y-abs-x"],
          [157.5, 202.5, "abs-x"],
          [202.5, 247.5, "abs-x-abs-y"],
          [247.5, 292.5, "abs-y"],
          [292.5, 337.5, "abs-y-x"]
        ];
      } else if (element2 === "s-resize") {
        resizeMappings = [
          [337.5, 360, "y"],
          [0, 22.5, "y"],
          [22.5, 67.5, "y-abs-x"],
          [67.5, 112.5, "abs-x"],
          [112.5, 157.5, "abs-x-abs-y"],
          [157.5, 202.5, "abs-y"],
          [202.5, 247.5, "abs-y-x"],
          [247.5, 292.5, "x"],
          [292.5, 337.5, "x-y"]
        ];
      } else if (element2 === "w-resize") {
        resizeMappings = [
          [337.5, 360, "x"],
          [0, 22.5, "x"],
          [22.5, 67.5, "x-y"],
          [67.5, 112.5, "y"],
          [112.5, 157.5, "y-abs-x"],
          [157.5, 202.5, "abs-x"],
          [202.5, 247.5, "abs-x-abs-y"],
          [247.5, 292.5, "abs-y"],
          [292.5, 337.5, "abs-y-x"]
        ];
      }
      var positiveDegree = degree < 0 ? 360 - Math.abs(degree) : degree;
      for (var _i = 0, resizeMappings_2 = resizeMappings; _i < resizeMappings_2.length; _i++) {
        var _a = resizeMappings_2[_i], startDegree = _a[0], endDegree = _a[1], resizeElement = _a[2];
        if (positiveDegree > startDegree && positiveDegree <= endDegree || positiveDegree + 360 > startDegree && positiveDegree + 360 <= endDegree) {
          return resizeElement;
        }
      }
      return element2;
    };
    Selection2.prototype.updateCursorStyles = function(x, y, type) {
      var parent = this.parent;
      var isResize = false;
      if (parent.activeObj.keyHistory !== "" && parent.activeObj.shape === undefined && !parent.currObjType.isCustomCrop && !parent.currObjType.isLine && parent.currObjType.isText) {
        parent.activeObj.shape = "text";
      }
      var actObj = extend({}, parent.activeObj, {}, true);
      if (isNullOrUndefined(actObj.topLeftCircle)) {
        return;
      }
      if (actObj.shapeDegree === 0) {
        parent.transform.degree;
      } else {
        parent.transform.degree - actObj.shapeDegree;
      }
      if (this.isObjSelected) {
        if (actObj.shape === "line" || actObj.shape === "arrow") {
          isResize = this.updateCursorStylesForLineArrow(x, y, actObj);
        } else if (actObj.shape === "path") {
          isResize = this.updateCursorStylesForPath(x, y, actObj);
        } else if (actObj.rotatedAngle) {
          this.setCursorForRotatedObject(actObj, x, y, parent.upperCanvas);
          if (parent.cursor === "grabbing") {
            parent.upperCanvas.style.cursor = parent.cursor = "grabbing";
            this.dragElement = parent.cursor;
          } else if (parent.cursor === "move") {
            this.dragPoint.startX = this.previousPoint.x = this.dragPoint.endX = x;
            this.dragPoint.startY = this.previousPoint.y = this.dragPoint.endY = y;
          } else if (parent.cursor !== "default") {
            isResize = true;
            this.dragElement = parent.cursor;
            parent.currObjType.isResize = true;
          }
        } else {
          var rotationCirclePoint = this.getTransRotationPoint(actObj);
          var radius = actObj.topLeftCircle.radius;
          if (rotationCirclePoint && x >= rotationCirclePoint.x - radius * 2 && x <= rotationCirclePoint.x + radius * 2 && y >= rotationCirclePoint.y - radius * 2 && y <= rotationCirclePoint.y + radius * 2 && this.dragElement !== "grabbing") {
            parent.upperCanvas.style.cursor = parent.cursor = "grabbing";
            this.dragElement = parent.upperCanvas.style.cursor;
          } else if (x >= actObj.topLeftCircle.startX - radius * 2 && x <= actObj.topLeftCircle.startX + radius * 2 && y >= actObj.topLeftCircle.startY - radius * 2 && y <= actObj.topLeftCircle.startY + radius * 2 && this.dragElement !== "nw-resize") {
            actObj.topLeftCircle.startX = actObj.topLeftCircle.startY = 0;
            parent.upperCanvas.style.cursor = parent.cursor = "nw-resize";
            isResize = true;
            this.dragElement = parent.upperCanvas.style.cursor;
          } else if (x >= actObj.topLeftCircle.startX - radius * 2 && x <= actObj.topRightCircle.startX - radius * 2 && y >= actObj.topCenterCircle.startY - radius * 2 && y <= actObj.topCenterCircle.startY + radius * 2 && this.dragElement !== "n-resize") {
            actObj.topCenterCircle.startX = actObj.topCenterCircle.startY = 0;
            parent.upperCanvas.style.cursor = parent.cursor = "n-resize";
            isResize = true;
            this.dragElement = parent.upperCanvas.style.cursor;
          } else if (x >= actObj.topRightCircle.startX - radius * 2 && x <= actObj.topRightCircle.startX + radius * 2 && y >= actObj.topRightCircle.startY - radius * 2 && y <= actObj.topRightCircle.startY + radius * 2 && this.dragElement !== "ne-resize") {
            actObj.topRightCircle.startX = actObj.topRightCircle.startY = 0;
            parent.upperCanvas.style.cursor = parent.cursor = "ne-resize";
            isResize = true;
            this.dragElement = parent.upperCanvas.style.cursor;
          } else if (x >= actObj.centerLeftCircle.startX - radius * 2 && x <= actObj.centerLeftCircle.startX + radius * 2 && y >= actObj.topLeftCircle.startY - radius * 2 && y <= actObj.bottomLeftCircle.startY - radius * 2 && this.dragElement !== "w-resize") {
            actObj.centerLeftCircle.startX = actObj.centerLeftCircle.startY = 0;
            parent.upperCanvas.style.cursor = parent.cursor = "w-resize";
            isResize = true;
            this.dragElement = parent.upperCanvas.style.cursor;
          } else if (x >= actObj.centerRightCircle.startX - radius * 2 && x <= actObj.centerRightCircle.startX + radius * 2 && y >= actObj.topRightCircle.startY - radius * 2 && y <= actObj.bottomRightCircle.startY - radius * 2 && this.dragElement !== "e-resize") {
            actObj.centerRightCircle.startX = actObj.centerRightCircle.startY = 0;
            parent.upperCanvas.style.cursor = parent.cursor = "e-resize";
            isResize = true;
            this.dragElement = parent.upperCanvas.style.cursor;
          } else if (x >= actObj.bottomLeftCircle.startX - radius * 2 && x <= actObj.bottomLeftCircle.startX + radius * 2 && y >= actObj.bottomLeftCircle.startY - radius * 2 && y <= actObj.bottomLeftCircle.startY + radius * 2 && this.dragElement !== "sw-resize") {
            actObj.bottomLeftCircle.startX = actObj.bottomLeftCircle.startY = 0;
            parent.upperCanvas.style.cursor = parent.cursor = "sw-resize";
            isResize = true;
            this.dragElement = parent.upperCanvas.style.cursor;
          } else if (x >= actObj.bottomLeftCircle.startX - radius * 2 && x <= actObj.bottomRightCircle.startX - radius * 2 && y >= actObj.bottomCenterCircle.startY - radius * 2 && y <= actObj.bottomCenterCircle.startY + radius * 2 && this.dragElement !== "s-resize") {
            actObj.bottomCenterCircle.startX = actObj.bottomCenterCircle.startY = 0;
            parent.upperCanvas.style.cursor = parent.cursor = "s-resize";
            isResize = true;
            this.dragElement = parent.upperCanvas.style.cursor;
          } else if (x >= actObj.bottomRightCircle.startX - radius * 2 && x <= actObj.bottomRightCircle.startX + radius * 2 && y >= actObj.bottomRightCircle.startY - radius * 2 && y <= actObj.bottomRightCircle.startY + radius * 2 && this.dragElement !== "se-resize") {
            actObj.bottomRightCircle.startX = actObj.bottomRightCircle.startY = 0;
            parent.upperCanvas.style.cursor = parent.cursor = "se-resize";
            isResize = true;
            this.dragElement = parent.upperCanvas.style.cursor;
          } else {
            this.dragPoint.startX = this.previousPoint.x = this.dragPoint.endX = x;
            this.dragPoint.startY = this.previousPoint.y = this.dragPoint.endY = y;
          }
          if (actObj.shape === "text" && (parent.cursor === "n-resize" || parent.cursor === "s-resize" || parent.cursor === "e-resize" || parent.cursor === "w-resize")) {
            parent.upperCanvas.style.cursor = parent.cursor = "move";
            this.dragElement = "";
            this.dragPoint.startX = this.previousPoint.x = this.dragPoint.endX = x;
            this.dragPoint.startY = this.previousPoint.y = this.dragPoint.endY = y;
          }
        }
      } else {
        this.dragPoint.startX = this.previousPoint.x = this.dragPoint.endX = x;
        this.dragPoint.startY = this.previousPoint.y = this.dragPoint.endY = y;
      }
      this.previousPoint.x = this.previousPoint.y = this.diffPoint.x = this.diffPoint.y = 0;
      if (type === "touchstart") {
        if (isResize || x >= actObj.activePoint.startX && x <= actObj.activePoint.endX && y >= actObj.activePoint.startY && y <= actObj.activePoint.endY || this.dragElement === "grabbing") {
          parent.currObjType.isDragging = true;
        } else if (actObj.shape === "line" || actObj.shape === "arrow") {
          this.setCursorForLineArrow(actObj, x, y, parent.upperCanvas);
          if (parent.cursor === "move") {
            parent.currObjType.isDragging = true;
          }
        } else if (actObj.shape === "path") {
          this.setCursorForPath(actObj, x, y, parent.upperCanvas);
          if (parent.cursor === "move") {
            parent.currObjType.isDragging = true;
          }
        }
      } else {
        parent.currObjType.isDragging = true;
      }
      if (actObj.rotatedAngle !== 0 && (this.dragElement === "e-resize" || this.dragElement === "w-resize" || this.dragElement === "n-resize" || this.dragElement === "s-resize")) {
        this.dragPoint.startX = this.previousPoint.x = this.dragPoint.endX = x;
        this.dragPoint.startY = this.previousPoint.y = this.dragPoint.endY = y;
      }
    };
    Selection2.prototype.updateCursorStylesForLineArrow = function(x, y, actObj) {
      var isResize = false;
      var parent = this.parent;
      var point;
      var radius = actObj.topLeftCircle.radius;
      for (var i = 0; i < 5; i++) {
        point = actObj.pointColl[i];
        if (x >= point.x - radius * 2 && x <= point.x + radius * 2 && y >= point.y - radius * 2 && y <= point.y + radius * 2) {
          actObj.centerLeftCircle.startX = actObj.centerLeftCircle.startY = 0;
          this.dragElement = "w-resize";
          isResize = true;
          break;
        }
      }
      if (!isResize) {
        for (var i = 1; i < 6; i++) {
          point = actObj.pointColl[actObj.pointColl.length - i];
          if (x >= point.x - radius * 2 && x <= point.x + radius * 2 && y >= point.y - radius * 2 && y <= point.y + radius * 2) {
            actObj.centerRightCircle.startX = actObj.centerRightCircle.startY = 0;
            this.dragElement = "e-resize";
            isResize = true;
            break;
          }
        }
      }
      if (!isResize) {
        for (var i = 0; i < actObj.pointColl.length; i++) {
          point = actObj.pointColl[i];
          if (x >= point.x - radius * 2 && x <= point.x + radius * 2 && y >= point.y - radius * 2 && y <= point.y + radius * 2) {
            parent.upperCanvas.style.cursor = parent.cursor = "move";
            this.dragPoint.startX = this.previousPoint.x = this.dragPoint.endX = x;
            this.dragPoint.startY = this.previousPoint.y = this.dragPoint.endY = y;
            break;
          } else {
            parent.upperCanvas.style.cursor = parent.cursor = "default";
          }
        }
      }
      return isResize;
    };
    Selection2.prototype.updateCursorStylesForPath = function(x, y, actObj) {
      var isResize = false;
      var parent = this.parent;
      this.pathAdjustedIndex = this.setCursorForLineArrow(actObj, x, y, parent.upperCanvas);
      if (parent.cursor === "move") {
        isResize = true;
        this.dragElement = "pathDrag";
      }
      if (!isResize) {
        parent.upperCanvas.style.cursor = parent.cursor = "move";
        this.dragPoint.startX = this.previousPoint.x = this.dragPoint.endX = x;
        this.dragPoint.startY = this.previousPoint.y = this.dragPoint.endY = y;
      }
      return isResize;
    };
    Selection2.prototype.setTextSelection = function(width, height) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var degree = parent.transform.degree;
      if (parent.activeObj.shapeDegree === 0) {
        degree = parent.transform.degree;
      } else {
        degree = parent.transform.degree - parent.activeObj.shapeDegree;
      }
      var coll = parent.activeObj.rotateFlipColl;
      if (this.isTransformedShape && coll) {
        degree = 0;
        for (var i = 0; i < coll.length; i++) {
          if (typeof coll[i] === "number") {
            degree += coll[i];
          }
        }
      }
      if (degree < 0) {
        degree = 360 + degree;
      }
      for (var i = 0, len = parent.activeObj.flipObjColl.length; i < len; i++) {
        var flip2 = parent.activeObj.flipObjColl[i].toLowerCase();
        switch (degree) {
          case 0:
            switch (flip2) {
              case "horizontal":
                actPoint = {
                  startX: actPoint.endX - width,
                  startY: actPoint.startY,
                  endX: actPoint.endX,
                  endY: actPoint.startY + (height ? height : 0)
                };
                break;
              case "vertical":
                actPoint.startY = actPoint.endY - height;
                actPoint = {
                  startX: actPoint.startX,
                  startY: actPoint.startY,
                  endX: actPoint.startX + (width ? width : 0),
                  endY: actPoint.endY
                };
                break;
              default:
                actPoint = {
                  startX: actPoint.startX,
                  startY: actPoint.startY,
                  endX: actPoint.startX + (width ? width : 0),
                  endY: actPoint.startY + (height ? height : 0)
                };
                break;
            }
            break;
          case 90:
            switch (flip2) {
              case "horizontal":
                actPoint.endX = actPoint.startX + height;
                actPoint = {
                  startX: actPoint.startX,
                  startY: actPoint.startY,
                  endX: actPoint.endX,
                  endY: actPoint.startY + (width ? width : 0)
                };
                break;
              case "vertical":
                actPoint.startX = actPoint.endX - height;
                actPoint = { startX: actPoint.startX, startY: actPoint.endY - width, endX: actPoint.endX, endY: actPoint.endY };
                break;
              default:
                actPoint.startX = actPoint.endX - height;
                actPoint = {
                  startX: actPoint.startX,
                  startY: actPoint.startY,
                  endX: actPoint.endX,
                  endY: actPoint.startY + (width ? width : 0)
                };
                break;
            }
            break;
          case 180:
            switch (flip2) {
              case "horizontal":
                actPoint.startY = actPoint.endY - height;
                actPoint = {
                  startX: actPoint.startX,
                  startY: actPoint.startY,
                  endX: actPoint.startX + width,
                  endY: actPoint.endY
                };
                break;
              case "vertical":
                actPoint.endY = actPoint.startY + height;
                actPoint = {
                  endX: actPoint.endX,
                  endY: actPoint.endY,
                  startX: actPoint.endX - (width ? width : 0),
                  startY: actPoint.startY
                };
                break;
              default:
                actPoint = {
                  endX: actPoint.endX,
                  endY: actPoint.endY,
                  startX: actPoint.endX - (width ? width : 0),
                  startY: actPoint.endY - (height ? height : 0)
                };
                break;
            }
            break;
          case 270:
            switch (flip2) {
              case "horizontal":
                actPoint.startX = actPoint.endX - height;
                actPoint = {
                  startX: actPoint.startX,
                  startY: actPoint.endY - (width ? width : 0),
                  endX: actPoint.endX,
                  endY: actPoint.endY
                };
                break;
              case "vertical":
                actPoint = {
                  startX: actPoint.startX,
                  startY: actPoint.startY,
                  endX: actPoint.startX + height,
                  endY: actPoint.startY + (width ? width : 0)
                };
                break;
              default:
                actPoint.endX = actPoint.startX + height;
                actPoint = {
                  startX: actPoint.startX,
                  startY: actPoint.endY - (width ? width : 0),
                  endX: actPoint.endX,
                  endY: actPoint.endY
                };
                break;
            }
            break;
        }
      }
      if (parent.activeObj.flipObjColl.length === 0) {
        switch (degree) {
          case 0:
            actPoint = {
              startX: actPoint.startX,
              startY: actPoint.startY,
              endX: actPoint.startX + (width ? width : 0),
              endY: actPoint.startY + (height ? height : 0)
            };
            break;
          case 90:
            actPoint.startX = actPoint.endX - height;
            actPoint = {
              startX: actPoint.startX,
              startY: actPoint.startY,
              endX: actPoint.endX,
              endY: actPoint.startY + (width ? width : 0)
            };
            break;
          case 180:
            actPoint = {
              endX: actPoint.endX,
              endY: actPoint.endY,
              startX: actPoint.endX - (width ? width : 0),
              startY: actPoint.endY - (height ? height : 0)
            };
            break;
          case 270:
            actPoint.endX = actPoint.startX + height;
            actPoint = {
              startX: actPoint.startX,
              startY: actPoint.endY - (width ? width : 0),
              endX: actPoint.endX,
              endY: actPoint.endY
            };
            break;
        }
      }
      actPoint.width = actPoint.endX - actPoint.startX;
      actPoint.height = actPoint.endY - actPoint.startY;
      parent.activeObj.activePoint = actPoint;
      if (parent.transform.degree === 360 || parent.transform.degree === -360) {
        parent.transform.degree = 0;
      }
    };
    Selection2.prototype.setActivePoint = function(startX, startY) {
      var parent = this.parent;
      var activePoint = parent.activeObj.activePoint;
      if (isNullOrUndefined(activePoint)) {
        return;
      }
      if (parent.currObjType.isText) {
        var textWidth = startX ? startX : 0;
        var textHeight = startY ? startY : parent.activeObj.textSettings.fontSize;
        if (parent.activeObj.textSettings.fontSize === undefined) {
          parent.activeObj.textSettings.fontSize = Math.abs(parent.baseImgCanvas.width - parent.baseImgCanvas.height) * 0.1;
        }
        this.setTextSelection(textWidth, textHeight);
        this.mouseDownPoint.x = activePoint.endX;
        this.mouseDownPoint.y = activePoint.endY;
        if (parent.activeObj.horTopLine !== undefined) {
          parent.activeObj.activePoint = extend({}, activePoint, {}, true);
        }
        parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate" } });
      } else if (startX && startY) {
        activePoint.startX = this.mouseDownPoint.x = startX;
        activePoint.startY = this.mouseDownPoint.y = startY;
        parent.currObjType.isDragging = true;
      } else {
        var selectInfo = parent.activeObj;
        activePoint = {
          startX: selectInfo.horTopLine.startX,
          startY: selectInfo.horTopLine.startY,
          endX: selectInfo.horTopLine.endX,
          endY: selectInfo.horTopLine.endY
        };
        activePoint.width = activePoint.endX - activePoint.startX;
        activePoint.height = activePoint.endY - activePoint.startY;
      }
    };
    Selection2.prototype.mouseDownEventHandler = function(e) {
      var parent = this.parent;
      parent.isKBDNavigation = false;
      this.mouseDown = e.currentTarget === parent.lowerCanvas || e.currentTarget === parent.upperCanvas ? "canvas" : "";
      if (e.type === "touchstart") {
        this.isTouch = true;
      } else {
        this.isTouch = false;
      }
      if (e.type === "touchstart" && e.currentTarget === parent.lowerCanvas && !parent.isImageLoaded) {
        return;
      }
      this.isCropSelection = false;
      this.isPan = true;
      var splitWords;
      if (parent.activeObj.shape !== undefined) {
        splitWords = parent.activeObj.shape.split("-");
      }
      if (splitWords !== undefined && splitWords[0] === "crop") {
        this.isCropSelection = true;
      }
      if (this.isCropSelection) {
        this.dragCanvas = parent.togglePan = true;
      }
      if (parent.cursor === "grabbing") {
        var obj = { shapeSettingsObj: {} };
        this.isGrabbing = true;
        parent.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj } });
        var shapeSettings = obj["shapeSettingsObj"];
        var shapeResizingArgs = { cancel: false, action: "rotate-start", previousShapeSettings: shapeSettings, allowShapeOverflow: this.allowOutofBound() };
        var shapeMovingArgs = { cancel: false, action: "rotate-start", previousShapeSettings: shapeSettings, allowShapeOverflow: this.allowOutofBound() };
        this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, "mouse-down");
      }
      var imageEditorClickEventArgs = { point: this.setXYPoints(e) };
      parent.trigger("click", imageEditorClickEventArgs);
      this.isMouseDown = true;
      this.isMouseUp = false;
      this.clickEvent(imageEditorClickEventArgs, e);
    };
    Selection2.prototype.getImagePoints = function(x, y) {
      var parent = this.parent;
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      if (x < destLeft) {
        x = destLeft;
      } else if (x > destLeft + destWidth) {
        x = destLeft + destWidth;
      }
      if (y < destTop) {
        y = destTop;
      } else if (y > destTop + destHeight) {
        y = destTop + destHeight;
      }
      return { x, y };
    };
    Selection2.prototype.clickEvent = function(imageEditorClickEventArgs, e) {
      var parent = this.parent;
      var activePoint = parent.activeObj.activePoint;
      var x = imageEditorClickEventArgs.point.x;
      var y = imageEditorClickEventArgs.point.y;
      var cursor = parent.activeObj.shape && parent.activeObj.shape === "text" ? parent.cursor : "default";
      var tempCursor = parent.upperCanvas.style.cursor;
      if (parent.isResize) {
        this.performEnterAction(e);
        parent.upperCanvas.style.cursor = "default";
        return;
      } else if (JSON.stringify(parent.frameObj) !== JSON.stringify(parent.tempFrameObj)) {
        parent.okBtn();
      } else if (this.currentDrawingShape !== "" && (!this.isShapeTouch(e, this.isCropSelection) && (this.isTouch || tempCursor === "crosshair" || parent.isShapeDrawing))) {
        if (parent.drawingShape && !parent.isShapeDrawing) {
          parent.okBtn();
          parent.enableShapeDrawing(parent.toPascalCase(parent.drawingShape), true);
        }
        activePoint = parent.activeObj.activePoint;
        var object_1 = { currObj: {} };
        parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object: object_1 } });
        this.initialPrevObj = object_1["currObj"];
        this.initialPrevObj.objColl = extend([], parent.objColl, [], true);
        this.initialPrevObj.pointColl = extend([], parent.pointColl, [], true);
        this.initialPrevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        parent.notify("freehand-draw", {
          prop: "getSelPointColl",
          onPropertyChange: false,
          value: { obj: selPointCollObj }
        });
        this.initialPrevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
        this.setActivePoint(x, y);
        activePoint = parent.activeObj.activePoint;
        if (this.currentDrawingShape === "path") {
          var point = this.getImagePoints(x, y);
          parent.activeObj.pointColl.push({ x: point.x, y: point.y });
          if (activePoint.width !== 0 && activePoint.height !== 0) {
            activePoint.width = 0;
            activePoint.height = 0;
            activePoint.startX = parent.activeObj.pointColl[parent.activeObj.pointColl.length - 1].x;
            activePoint.startY = parent.activeObj.pointColl[parent.activeObj.pointColl.length - 1].y;
          }
        }
        activePoint.endX = activePoint.startX;
        activePoint.endY = activePoint.startY;
        if (this.currentDrawingShape === "text") {
          parent.activeObj.textSettings.fontSize = 11;
          this.previousPoint.x = activePoint.startX;
          this.previousPoint.y = activePoint.startY;
          parent.notify("shape", {
            prop: "updateFontStyles",
            onPropertyChange: false,
            value: { isTextBox: null }
          });
          var width = this.upperContext.measureText(parent.activeObj.textSettings.text).width + parent.activeObj.textSettings.fontSize * 0.5;
          activePoint.endX = activePoint.startX + width;
          activePoint.endY = activePoint.startY + parent.activeObj.textSettings.fontSize;
          activePoint.width = activePoint.endX - activePoint.startX;
          activePoint.height = activePoint.endY - activePoint.startY;
        } else if (this.currentDrawingShape === "arrow") {
          parent.activeObj.start = this.arrowShape[0];
          parent.activeObj.end = this.arrowShape[1];
        }
        parent.currObjType.isDragging = true;
        var previousShapeSettings = this.updatePrevShapeSettings();
        var shapeResizingArgs = { cancel: false, action: "draw-start", previousShapeSettings, allowShapeOverflow: this.allowOutofBound() };
        var shapeMovingArgs = { cancel: false, action: "move", previousShapeSettings, allowShapeOverflow: this.allowOutofBound() };
        this.shapeResizingArgs = shapeResizingArgs;
        this.shapeMovingArgs = shapeMovingArgs;
        this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, "mouse-down");
        parent.activeObj.activePoint = activePoint;
        parent.isShapeDrawing = true;
        this.tempActiveObj = extend({}, parent.activeObj, {}, true);
        return;
      }
      parent.notify("draw", { prop: "resetFrameZoom", onPropertyChange: false, value: { isOk: true } });
      if (this.isCropSelection && this.dragCanvas) {
        this.setCursor(x, y);
        if (parent.cursor !== "move" && parent.cursor !== "crosshair" && parent.cursor !== "default" && parent.cursor !== "grab") {
          this.isPan = false;
        }
      }
      if (parent.activeObj.shape) {
        this.isObjSelected = true;
      } else {
        this.isObjSelected = false;
      }
      var object = { currObj: {} };
      parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
      var prevObj = object["currObj"];
      var activeObj = extend({}, parent.activeObj, null, true);
      var isShape = this.isShapeTouch(e, this.isCropSelection);
      var isFreehandDraw = this.isFreehandDrawTouch(e, this.isCropSelection);
      var isShapeClick = isShape ? isShape : this.isShapeClick(e, this.isCropSelection);
      var allowUndoRedoPush = this.applyCurrShape(isShapeClick);
      var isTextArea = parent.textArea.style.display !== "none" ? true : false;
      if (this.isTouch && !isShape && activeObj.shape && !this.isCropSelection) {
        if (this.applyObj(x, y)) {
          parent.okBtn(true);
          parent.notify("draw", { prop: "setPrevActObj", onPropertyChange: false, value: { prevActObj: null } });
        }
        var prevCropObj = extend({}, parent.cropObj, {}, true);
        parent.notify("undo-redo", {
          prop: "updateUndoRedoColl",
          onPropertyChange: false,
          value: {
            operation: "shapeTransform",
            previousObj: prevObj,
            previousObjColl: prevObj.objColl,
            previousPointColl: prevObj.pointColl,
            previousSelPointColl: prevObj.selPointColl,
            previousCropObj: prevCropObj,
            previousText: null,
            currentText: null,
            previousFilter: null,
            isCircleCrop: parent.isCircleCrop
          }
        });
        if (allowUndoRedoPush) {
          parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
        }
      }
      if (!isShape && !parent.togglePen && !this.isCropSelection && parent.activeObj.redactType !== "blur" && parent.activeObj.redactType !== "pixelate") {
        parent.notify("toolbar", { prop: "refresh-main-toolbar", onPropertyChange: false });
        parent.notify("toolbar", { prop: "close-contextual-toolbar", onPropertyChange: false });
      }
      if (this.dragCanvas && this.isPan && (parent.cursor === "grab" || this.isTouch) && !isShape && !isFreehandDraw && !parent.togglePen) {
        if (this.applyObj(x, y)) {
          parent.okBtn(true);
          if (allowUndoRedoPush) {
            var cursor_1 = parent.cursor;
            parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
            parent.cursor = cursor_1;
          }
          parent.notify("draw", { prop: "setPrevActObj", onPropertyChange: false, value: { prevActObj: null } });
        }
        if (this.isFhdEditing) {
          parent.notify("freehand-draw", { prop: "applyFhd", onPropertyChange: false });
          this.isFhdCustomized = false;
          parent.notify("toolbar", { prop: "destroy-qa-toolbar", onPropertyChange: false });
        }
        var shape = parent.activeObj.shape;
        var shapeColl = ["rectangle", "ellipse", "line", "arrow", "path", "text", "image", "redact"];
        if (shape && shapeColl.indexOf(shape) > -1) {
          parent.notify("shape", {
            prop: "redrawActObj",
            onPropertyChange: false,
            value: { x: null, y: null, isMouseDown: null }
          });
          parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
          parent.notify("toolbar", { prop: "setCurrentToolbar", value: { type: "main" } });
          parent.notify("toolbar", { prop: "refresh-main-toolbar", onPropertyChange: false });
        }
        var isCropSelection = false;
        if (parent.activeObj.shape && parent.activeObj.shape.indexOf("crop-") > -1) {
          isCropSelection = true;
        }
        if (parent.element.querySelector(".e-contextual-toolbar-wrapper") && !isCropSelection) {
          if (!parent.element.querySelector(".e-contextual-toolbar-wrapper").classList.contains("e-hide")) {
            parent.okBtn();
            parent.element.querySelector(".e-contextual-toolbar-wrapper").classList.add("e-hide");
          }
        }
        this.canvasMouseDownHandler(e);
      } else {
        var isLineArrow = false;
        if (parent.activeObj.shape && (parent.activeObj.shape === "line" || parent.activeObj.shape === "arrow")) {
          isLineArrow = true;
        }
        var points = this.setXYPoints(e);
        var x_1 = points.x;
        var y_1 = points.y;
        if (this.applyObj(x_1, y_1)) {
          parent.okBtn(true);
          if (allowUndoRedoPush) {
            var cursor_2 = parent.cursor;
            parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
            parent.cursor = cursor_2;
          }
          parent.notify("draw", { prop: "setPrevActObj", onPropertyChange: false, value: { prevActObj: null } });
        }
        parent.notify("shape", {
          prop: "redrawActObj",
          onPropertyChange: false,
          value: { x: x_1, y: y_1, isMouseDown: true }
        });
        var obj = { index: null };
        parent.notify("freehand-draw", { prop: "getFreehandDrawHoveredIndex", onPropertyChange: false, value: { obj } });
        var indexObj = { freehandSelectedIndex: null };
        parent.notify("freehand-draw", { prop: "getFreehandSelectedIndex", onPropertyChange: false, value: { obj: indexObj } });
        if (this.isFhdPoint || this.isFhdCustomized && !parent.togglePen) {
          if (!isNullOrUndefined(indexObj["freehandSelectedIndex"]) && indexObj["freehandSelectedIndex"] !== obj["index"]) {
            var tempHoveredIndex = obj["index"];
            parent.okBtn();
            this.isFhdCustomized = false;
            parent.notify("freehand-draw", {
              prop: "setFreehandDrawHoveredIndex",
              onPropertyChange: false,
              value: { index: tempHoveredIndex }
            });
            if (obj["index"] > -1) {
              var strokeColor = parent.pointColl[obj["index"]].strokeColor;
              parent.notify("freehand-draw", {
                prop: "hoverFhd",
                onPropertyChange: false,
                value: { strokeColor, strokeWidth: parent.pointColl[obj["index"]].strokeWidth }
              });
            }
          }
          indexObj["freehandSelectedIndex"] = null;
          parent.notify("freehand-draw", { prop: "getFreehandSelectedIndex", onPropertyChange: false, value: { obj: indexObj } });
          var objColl = extend([], parent.objColl, [], true);
          if (!isNullOrUndefined(obj["index"]) && obj["index"] > -1) {
            parent.notify("freehand-draw", { prop: "selectFhd", value: { type: "ok" } });
            parent.notify("freehand-draw", {
              prop: "hoverFhd",
              onPropertyChange: false,
              value: { strokeColor: null, strokeWidth: null }
            });
            parent.notify("toolbar", { prop: "renderQAT", onPropertyChange: false, value: { isPenEdit: true } });
          } else if (indexObj["freehandSelectedIndex"]) {
            parent.okBtn();
            var strokeColor = parent.pointColl[indexObj["freehandSelectedIndex"]].strokeColor;
            parent.notify("freehand-draw", {
              prop: "hoverFhd",
              onPropertyChange: false,
              value: { strokeColor, strokeWidth: parent.pointColl[indexObj["freehandSelectedIndex"]].strokeWidth }
            });
          } else if (this.findTargetObj(x_1, y_1, false)) {
            parent.objColl = objColl;
            this.findTarget(x_1, y_1, e.type);
            parent.notify("draw", { prop: "redrawDownScale" });
          }
        } else {
          if (this.isFhdEditing) {
            parent.apply();
            var qbArea = (undefined).getElementById(parent.element.id + "_quickAccessToolbarArea");
            if (qbArea) {
              qbArea.style.display = "none";
            }
            var point = parent.pointColl[indexObj["freehandSelectedIndex"]];
            var shapeSettings = {
              id: "pen_" + (indexObj["freehandSelectedIndex"] + 1),
              type: ShapeType.FreehandDraw,
              startX: point.points[0].x,
              startY: point.points[0].y,
              strokeColor: point.strokeColor,
              strokeWidth: point.strokeWidth,
              points: point.points,
              opacity: point.opacity,
              index: point.order
            };
            var shapeChangedArgs = { action: "apply", currentShapeSettings: extend({}, shapeSettings, {}, true) };
            parent.trigger("shapeChange", shapeChangedArgs);
            parent.editCompleteArgs = shapeChangedArgs;
          }
          var isPenDraw = parent.togglePen;
          var tempCursor_1 = parent.cursor;
          parent.notify("toolbar", { prop: "close-contextual-toolbar", onPropertyChange: false });
          if (activeObj.shape === "redact" && tempCursor_1 !== "default") {
            parent.cursor = tempCursor_1;
          }
          if (isPenDraw) {
            parent.freeHandDraw(true);
          }
          this.isFhdEditing = false;
          if (isLineArrow) {
            this.setCursor(x_1, y_1);
          } else if (cursor !== "default") {
            parent.upperCanvas.style.cursor = parent.cursor = cursor;
          }
          if (parent.cursor === "crosshair" || Browser.isDevice && parent.togglePen) {
            if (parent.togglePen) {
              if (isNullOrUndefined(parent.activeObj.strokeSettings)) {
                var obj_1 = { strokeSettings: {} };
                parent.notify("shape", { prop: "getStrokeSettings", onPropertyChange: false, value: { obj: obj_1 } });
                parent.activeObj.strokeSettings = obj_1["strokeSettings"];
              }
              var obj_2 = { penStrokeWidth: null };
              parent.notify("freehand-draw", { prop: "getPenStrokeWidth", onPropertyChange: false, value: { obj: obj_2 } });
              if (isNullOrUndefined(obj_2["penStrokeWidth"])) {
                parent.notify("freehand-draw", { prop: "setPenStrokeWidth", onPropertyChange: false, value: { value: 2 } });
              }
              this.upperContext.strokeStyle = parent.activeObj.strokeSettings.strokeColor;
              this.upperContext.fillStyle = parent.activeObj.strokeSettings.strokeColor;
              parent.notify("freehand-draw", { prop: "resetSelPoints", onPropertyChange: false });
              parent.notify("freehand-draw", {
                prop: "freehandDownHandler",
                onPropertyChange: false,
                value: { e, canvas: parent.upperCanvas }
              });
            } else {
              parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
              this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            }
            parent.currObjType.isActiveObj = false;
            this.dragElement = "";
            this.dragPoint.startX = this.dragPoint.startY = this.dragPoint.endX = this.dragPoint.endY = 0;
          }
          if ((this.isTouch && tempCursor_1 !== "crosshair" || parent.cursor !== "crosshair") && e.type.toLowerCase() === "touchstart" || parent.currObjType.isActiveObj && parent.cursor !== "default" && !parent.togglePen) {
            parent.notify("draw", { prop: "updateTempObjColl" });
            parent.notify("draw", { prop: "updateTempPointColl" });
            this.findTarget(x_1, y_1, e.type);
            parent.notify("draw", { prop: "redrawDownScale" });
          } else if ((parent.currObjType.shape === "" || parent.currObjType.isCustomCrop) && !parent.togglePen && parent.cursor !== "default") {
            this.setActivePoint(x_1, y_1);
          }
          if (isTextArea) {
            parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
          }
        }
      }
      this.isShapeInserted = false;
      this.tempActiveObj = extend({}, parent.activeObj, {}, true);
    };
    Selection2.prototype.mouseMoveEventHandler = function(e) {
      var parent = this.parent;
      var cursor = parent.cursor;
      var canvasCursor = parent.upperCanvas.style.cursor;
      e.preventDefault();
      if (this.isPreventShaping || parent.isShapeDrawing && parent.currObjType.isDragging && this.isTouch && parent.activeObj.shape && parent.activeObj.shape === "path") {
        return;
      }
      if (parent.cursor === "grabbing" && this.isGrabbing) {
        var obj = { shapeSettingsObj: {} };
        parent.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj } });
        var shapeSettings = obj["shapeSettingsObj"];
        var shapeResizingArgs = { cancel: false, action: "rotating", previousShapeSettings: shapeSettings, allowShapeOverflow: this.allowOutofBound() };
        var shapeMovingArgs = { cancel: false, action: "rotating", previousShapeSettings: shapeSettings, allowShapeOverflow: this.allowOutofBound() };
        this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, "mouse-down");
      }
      if (this.timer && this.timer > 0 && this.dragPoint.startX && this.dragPoint.startY) {
        var width = Math.abs(this.dragPoint.startX - e.touches[0].clientX);
        var height = Math.abs(this.dragPoint.startY - e.touches[0].clientY);
        if (width > 10 || height > 10) {
          this.timer = 0;
        }
      }
      var bbox = parent.lowerCanvas.getBoundingClientRect();
      if (e.type === "touchmove" && e.touches.length === 2) {
        if (this.isFirstMove) {
          this.startTouches = this.targetTouches(e.touches);
          this.tempTouches = [];
          this.tempTouches.push({
            x: e.touches[0].clientX || e.touches[0].pageX - parent.lowerCanvas.offsetLeft - bbox.left,
            y: (e.touches[0].clientY || e.touches[0].pageY - parent.lowerCanvas.offsetTop) - bbox.top
          });
          this.tempTouches.push({
            x: (e.touches[1].clientX || e.touches[1].pageX - parent.lowerCanvas.offsetLeft) - bbox.left,
            y: (e.touches[1].clientY || e.touches[1].pageY - parent.lowerCanvas.offsetTop) - bbox.top
          });
        } else {
          var firstFingerX = (e.touches[0].clientX || e.touches[0].pageX - parent.lowerCanvas.offsetLeft) - bbox.left;
          var firstFingerY = (e.touches[0].clientY || e.touches[0].pageY - parent.lowerCanvas.offsetTop) - bbox.top;
          var secondFingerX = (e.touches[1].clientX || e.touches[1].pageX - parent.lowerCanvas.offsetLeft) - bbox.left;
          var secondFingerY = (e.touches[1].clientY || e.touches[1].pageY - parent.lowerCanvas.offsetTop) - bbox.top;
          var center = { x: firstFingerX < secondFingerX ? secondFingerX - (secondFingerX - firstFingerX) / 2 : firstFingerX - (firstFingerX - secondFingerX) / 2, y: firstFingerY < secondFingerY ? secondFingerY - (secondFingerY - firstFingerY) / 2 : firstFingerY - (firstFingerY - secondFingerY) / 2 };
          if (this.currMousePoint.x !== center.x && this.currMousePoint.y !== center.y) {
            var type = "";
            if (e.type === "touchmove" && (parent.zoomSettings.zoomTrigger & ZoomTrigger.Pinch) === ZoomTrigger.Pinch) {
              this.zoomType = "Pinch";
              var scale = this.calculateScale(this.startTouches, this.targetTouches(e.touches));
              this.startTouches = this.targetTouches(e.touches);
              if (scale > 1) {
                type = "zoomIn";
              } else if (scale < 1) {
                type = "zoomOut";
              }
            }
            if (type !== "") {
              parent.isZoomBtnClick = true;
              parent.notify("draw", {
                prop: "performPointZoom",
                onPropertyChange: false,
                value: { x: center.x, y: center.y, type, isResize: null }
              });
            }
            this.tempTouches = [];
            this.tempTouches.push({
              x: e.touches[0].clientX || e.touches[0].pageX - parent.lowerCanvas.offsetLeft,
              y: e.touches[0].clientY || e.touches[0].pageY - parent.lowerCanvas.offsetTop
            });
            this.tempTouches.push({
              x: e.touches[1].clientX || e.touches[1].pageX - parent.lowerCanvas.offsetLeft,
              y: e.touches[1].clientY || e.touches[1].pageY - parent.lowerCanvas.offsetTop
            });
            this.currMousePoint.x = center.x;
            this.currMousePoint.y = center.y;
            this.isPinching = true;
          }
        }
        this.isFirstMove = false;
        return;
      }
      var x;
      var y;
      if (e.type === "mousemove") {
        x = e.clientX;
        y = e.clientY;
      } else {
        this.touchEndPoint.x = x = e.touches[0].clientX;
        this.touchEndPoint.y = y = e.touches[0].clientY;
      }
      x -= bbox.left;
      y -= bbox.top;
      this.canvasMouseMoveHandler(e);
      var isCropSelection = false;
      var splitWords;
      if (parent.activeObj.shape !== undefined) {
        splitWords = parent.activeObj.shape.split("-");
      }
      if (splitWords !== undefined && splitWords[0] === "crop") {
        isCropSelection = true;
      }
      if (isCropSelection) {
        parent.notify("transform", { prop: "disableZoomOutBtn", value: { isZoomOut: true } });
      }
      parent.upperCanvas.style.cursor = canvasCursor;
      parent.cursor = cursor;
      if (parent.currObjType.isActiveObj && (parent.activeObj.activePoint !== undefined || parent.objColl.length > 0) && !this.dragCanvas || parent.activeObj.activePoint !== undefined) {
        if (this.dragElement === "") {
          this.setCursor(x, y);
          if (parent.activeObj.activePoint && (parent.activeObj.activePoint.width === 0 || !isNullOrUndefined(parent.activeObj.currIndex) && this.cursorTargetId !== parent.activeObj.currIndex) && parent.cursor !== "default" && parent.cursor !== "move" && parent.cursor !== "crosshair" && parent.cursor !== "grab" && parent.cursor !== "pointer") {
            parent.upperCanvas.style.cursor = parent.cursor = "move";
          }
          this.findTarget(x, y, e.type);
        }
      }
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      if (parent.currObjType.isDragging) {
        if (parent.activeObj.shape && parent.activeObj.preventShapeDragOut) {
          if (x < destLeft || x > destLeft + destWidth || y < destTop || y > destTop + destHeight) {
            return;
          }
        }
        this.upperContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        this.updateActivePoint(x, y, isCropSelection);
        parent.notify("shape", { prop: "updateTrianglePoints", onPropertyChange: false, value: { obj: parent.activeObj } });
        if (this.isPreventDragging) {
          if (!this.isShapeDragOut()) {
            this.isPreventDragging = false;
          }
          parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: {
            canvas: "duplicate",
            obj: null,
            isCropRatio: null,
            points: null,
            isPreventDrag: true,
            saveContext: null,
            isPreventSelection: null
          } });
        } else {
          parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: {
            canvas: "duplicate",
            obj: null,
            isCropRatio: null,
            points: null,
            isPreventDrag: null,
            saveContext: null,
            isPreventSelection: null
          } });
        }
        if (isCropSelection) {
          this.dragCanvas = parent.togglePan = true;
        }
      }
      this.isMouseDown = false;
      this.isMouseUp = false;
    };
    Selection2.prototype.mouseUpEventHandler = function(e) {
      var parent = this.parent;
      var id = parent.element.id;
      parent.isKBDNavigation = this.isMouseDown = false;
      this.isMouseUp = true;
      if (!Browser.isDevice && (parent.element.querySelector("#" + id + "_contextualToolbar") && !parent.element.querySelector("#" + id + "_contextualToolbar").parentElement.classList.contains("e-hide") || parent.element.querySelector("#" + id + "_headWrapper") && !parent.element.querySelector("#" + id + "_headWrapper").parentElement.classList.contains("e-hide"))) {
        if (!(parent.activeObj.shape && parent.activeObj.shape === "redact" && parent.isShapeDrawing)) {
          return;
        }
      }
      if (parent.cursor === "grabbing" && this.isGrabbing) {
        var obj = { shapeSettingsObj: {} };
        parent.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj } });
        var shapeSettings = obj["shapeSettingsObj"];
        var shapeResizingArgs = { cancel: false, action: "rotate-end", previousShapeSettings: shapeSettings, allowShapeOverflow: this.allowOutofBound() };
        var shapeMovingArgs = { cancel: false, action: "rotate-end", previousShapeSettings: shapeSettings, allowShapeOverflow: this.allowOutofBound() };
        this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, "mouse-up");
      }
      this.isGrabbing = false;
      if (this.isPreventShaping) {
        this.isPreventShaping = false;
      }
      if (this.mouseDown === "canvas" || this.isSliderActive || /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
      e.target.closest(".e-image-editor") || e.target.closest(".e-ie-ddb-popup")) {
        if (e.type === "touchstart") {
          this.isTouch = false;
        } else if (e.type === "touchend") {
          e.stopImmediatePropagation();
        }
        e.preventDefault();
        if (parent.togglePan) {
          this.canvasMouseUpHandler(e);
        }
        var x = undefined;
        var y = undefined;
        if (e.type === "mouseup") {
          x = e.clientX;
          y = e.clientY;
        } else if (!this.isTouchDblClick) {
          x = this.touchEndPoint.x;
          y = this.touchEndPoint.y;
        }
        var bbox = parent.lowerCanvas.getBoundingClientRect();
        x -= bbox.left;
        y -= bbox.top;
        var activeObjShape = undefined;
        var currentDrawingShape = this.currentDrawingShape;
        var dummyClick = false;
        if (e.type === "touchend") {
          this.startTouches = this.tempTouches = [];
          this.isFirstMove = false;
          if (parent.textArea.style.display === "none") {
            this.timer = 0;
          }
          if (this.isPinching) {
            this.isPinching = false;
            parent.notify("draw", { prop: "redrawDownScale" });
            if (parent.isCropTab || parent.activeObj.shape) {
              parent.notify("draw", { prop: "setStraightenActObj", value: { activeObj: null } });
              parent.notify("freehand-draw", { prop: "resetStraightenPoint" });
            }
            if (parent.isStraightening) {
              parent.notify("draw", { prop: "resetStraightenDestPoints" });
              parent.notify("draw", { prop: "setDestForStraighten" });
            }
            return;
          }
        }
        var isCropSelection = false;
        var splitWords = undefined;
        if (parent.activeObj.shape !== undefined) {
          splitWords = parent.activeObj.shape.split("-");
        }
        if (splitWords !== undefined && splitWords[0] === "crop") {
          isCropSelection = true;
        }
        if (this.currentDrawingShape === "path" && parent.isShapeDrawing) {
          var elem = e.srcElement;
          var elemId = elem.parentElement.id;
          var id_1 = parent.element.id;
          if (e.currentTarget !== parent.upperCanvas && e.currentTarget !== parent.lowerCanvas && parent.activeObj.pointColl.length > 0 && (elem.classList.contains("e-upload-icon") || elemId === id_1 + "_zoomIn" || elemId === id_1 + "_zoomOut" || elemId === id_1 + "_annotationBtn" || elemId === id_1 + "_borderColorBtn" || elemId === id_1 + "_borderWidthBtn")) {
            parent.notify("shape", { prop: "stopPathDrawing", onPropertyChange: false, value: { e, isApply: true } });
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: {
              canvas: "duplicate",
              obj: parent.activeObj,
              isCropRatio: null,
              points: null,
              isPreventDrag: true,
              saveContext: null,
              isPreventSelection: true
            } });
          }
          if (parent.currObjType.isDragging && this.isTouch && parent.activeObj.shape && parent.activeObj.shape === "path") {
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: {
              canvas: "duplicate",
              obj: parent.activeObj,
              isCropRatio: null,
              points: null,
              isPreventDrag: true,
              saveContext: null,
              isPreventSelection: true
            } });
          }
          return;
        }
        if (e.currentTarget === parent.upperCanvas && !parent.isResize) {
          this.pathAdjustedIndex = null;
          if (this.currentDrawingShape !== "") {
            if (this.currentDrawingShape === "text") {
              var prevCropObj_1 = extend({}, parent.cropObj, {}, true);
              parent.notify("undo-redo", {
                prop: "updateUndoRedoColl",
                onPropertyChange: false,
                value: {
                  operation: "shapeInsert",
                  previousObj: this.initialPrevObj,
                  previousObjColl: this.initialPrevObj.objColl,
                  previousPointColl: this.initialPrevObj.pointColl,
                  previousSelPointColl: this.initialPrevObj.selPointColl,
                  previousCropObj: prevCropObj_1,
                  previousText: null,
                  currentText: null,
                  previousFilter: null,
                  isCircleCrop: null
                }
              });
            } else {
              parent.notify("undo-redo", { prop: "updateUrObj", onPropertyChange: false, value: { objColl: this.initialPrevObj.objColl, operation: "shapeInsert" } });
            }
            this.isShapeInserted = true;
            this.currentDrawingShape = "";
            if (parent.activeObj.shape && parent.activeObj.shape === "path" && parent.activeObj.pointColl.length === 0 || (!parent.activeObj.shape || parent.activeObj.shape !== "path") && parent.activeObj.activePoint.width === 0 && parent.activeObj.activePoint.height === 0) {
              dummyClick = true;
              parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
              this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            }
            var previousShapeSettings = this.updatePrevShapeSettings();
            var shapeResizingArgs = { cancel: false, action: "draw-end", previousShapeSettings };
            var shapeMovingArgs = { cancel: false, action: "move", previousShapeSettings };
            this.shapeResizingArgs = shapeResizingArgs;
            this.shapeMovingArgs = shapeMovingArgs;
            this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, "mouse-up");
          }
          if (parent.activeObj.shape && parent.activeObj.shape === "path" && parent.activeObj.pointColl.length > 0) {
            parent.activeObj.activePoint = parent.getSquarePointForPath(parent.activeObj);
          }
          this.adjustActObjForLineArrow();
          this.updPtCollForShpRot();
          parent.currObjType.shape = parent.currObjType.shape.toLowerCase();
          var prevCropObj = extend({}, parent.cropObj, {}, true);
          var object = { currObj: {} };
          parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
          var prevObj = object["currObj"];
          prevObj.objColl = extend([], parent.objColl, [], true);
          prevObj.pointColl = extend([], parent.pointColl, [], true);
          prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
          var selPointCollObj = { selPointColl: null };
          parent.notify("freehand-draw", {
            prop: "getSelPointColl",
            onPropertyChange: false,
            value: { obj: selPointCollObj }
          });
          prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
          if (!parent.togglePen && !isCropSelection) {
            if (this.tempObjColl && parent.activeObj.activePoint.width !== 0) {
              parent.notify("shape", { prop: "updImgRatioForActObj", onPropertyChange: false });
              parent.objColl.push(parent.activeObj);
              if (JSON.stringify(parent.activeObj.activePoint) !== JSON.stringify(this.tempActiveObj.activePoint)) {
                parent.notify("undo-redo", {
                  prop: "updateUndoRedoColl",
                  onPropertyChange: false,
                  value: {
                    operation: "shapeTransform",
                    previousObj: prevObj,
                    previousObjColl: this.tempObjColl,
                    previousPointColl: prevObj.pointColl,
                    previousSelPointColl: prevObj.selPointColl,
                    previousCropObj: prevCropObj,
                    previousText: null,
                    currentText: null,
                    previousFilter: null,
                    isCircleCrop: null
                  }
                });
              }
              var tempObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
              parent.objColl.pop();
              this.redrawShape(tempObj);
              this.tempObjColl = undefined;
            }
            if (!this.isFhdEditing) {
              this.applyCurrActObj(x, y);
              parent.currObjType.isResize = false;
              parent.notify("toolbar", { prop: "destroy-qa-toolbar", onPropertyChange: false });
            }
          } else if (isCropSelection && this.isMouseUp && parent.cursor.indexOf("resize") > -1) {
            var previousShapeSettings = this.updatePrevShapeSettings();
            var shapeResizingArgs = { cancel: false, action: "resize-end", previousShapeSettings };
            this.triggerShapeChange(shapeResizingArgs, shapeResizingArgs, "resize");
          }
          if (parent.activeObj) {
            var isCropSelection_1 = false;
            var splitWords_1;
            if (parent.activeObj.shape !== undefined) {
              splitWords_1 = parent.activeObj.shape.split("-");
            }
            if (splitWords_1 === undefined && (parent.currObjType.isCustomCrop || parent.togglePen)) {
              isCropSelection_1 = true;
            } else if (splitWords_1 !== undefined && splitWords_1[0] === "crop") {
              isCropSelection_1 = true;
            }
            var shape = parent.activeObj.shape;
            activeObjShape = shape;
            var shapeColl = ["rectangle", "ellipse", "line", "arrow", "path"];
            if (shapeColl.indexOf(shape) > -1) {
              parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
                type: "shapes",
                isApplyBtn: null,
                isCropping: null,
                isZooming: null,
                cType: null
              } });
            } else if (shape === "text") {
              if (parent.textArea.style.display === "none") {
                parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
                  type: "text",
                  isApplyBtn: null,
                  isCropping: null,
                  isZooming: null,
                  cType: null
                } });
              }
            } else if (shape === "redact") {
              parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
                type: "redact",
                isApplyBtn: null,
                isCropping: null,
                isZooming: null,
                cType: null
              } });
            } else if (this.isFhdEditing) {
              parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
                type: "pen",
                isApplyBtn: null,
                isCropping: null,
                isZooming: null,
                cType: null
              } });
            } else if (!isCropSelection_1) {
              var eventargs = { type: "main", isApplyBtn: null, isCropping: false, isZooming: null };
              parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: eventargs });
            }
            parent.notify("toolbar", { prop: "update-toolbar-items", onPropertyChange: false });
            if (!this.isFhdEditing) {
              var width = Math.floor(parent.activeObj.activePoint.width);
              if (parent.activeObj.shape && parent.activeObj.shape === "text" && parent.activeObj.textSettings.fontSize === 11 && Math.floor(parent.activeObj.activePoint.height) === 11 && (width === 55 || parent.activeObj.textSettings.bold && width === 58)) {
                parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
                if (parent.drawingShape === "text" && !parent.activeObj.keyHistory) {
                  parent.activeObj.keyHistory = "Enter Text";
                }
              }
              if (!isCropSelection_1) {
                this.adjustActObjForLineArrow();
                if (parent.isShapeDrawing) {
                  var temp = this.currentDrawingShape;
                  parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
                  this.currentDrawingShape = temp;
                } else {
                  parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
                }
              }
            }
          }
        }
        if (parent.activeObj.shape !== undefined) {
          splitWords = parent.activeObj.shape.split("-");
        }
        if (splitWords !== undefined && splitWords[0] === "crop") {
          isCropSelection = true;
        }
        if (parent.activeObj.shape && !isCropSelection && e.currentTarget === parent.upperCanvas && parent.textArea.style.display === "none") {
          if (parent.activeObj.shape === "text") {
            parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
              type: "text",
              isApplyBtn: null,
              isCropping: null,
              isZooming: null,
              cType: null
            } });
          } else if (parent.activeObj.shape === "redact") {
            parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
              type: "redact",
              isApplyBtn: null,
              isCropping: null,
              isZooming: null,
              cType: null
            } });
          } else {
            var temp = this.currentDrawingShape;
            this.currentDrawingShape = "";
            parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
              type: "shapes",
              isApplyBtn: null,
              isCropping: null,
              isZooming: null,
              cType: null
            } });
            this.currentDrawingShape = temp;
          }
          parent.notify("toolbar", { prop: "update-toolbar-items", onPropertyChange: false });
          parent.notify("toolbar", { prop: "renderQAT", onPropertyChange: false, value: { isPenEdit: null } });
        }
        var obj = { freehandDrawSelectedId: null };
        parent.notify("freehand-draw", { prop: "getFreehandDrawSelectedId", onPropertyChange: false, value: { obj } });
        if (parent.togglePen && e.currentTarget === parent.upperCanvas && !obj["freehandDrawSelectedId"]) {
          parent.notify("freehand-draw", {
            prop: "freehandUpHandler",
            onPropertyChange: false,
            value: { e, canvas: parent.upperCanvas, context: this.upperContext }
          });
          if (parent.togglePen && !parent.isMaskImage && (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.length > 0 || !isNullOrUndefined(parent.toolbarTemplate))) {
            parent.okBtn();
            parent.freeHandDraw(true);
          }
        } else {
          parent.currObjType.shape = "";
        }
        this.dragElement = "";
        this.mouseDown = "";
        this.isSliderActive = false;
        parent.currObjType.isInitialLine = parent.currObjType.isDragging = false;
        this.selMouseUpEvent();
        if (isNullOrUndefined(parent.drawingShape) && activeObjShape && currentDrawingShape !== "") {
          parent.drawingShape = activeObjShape;
        }
        if (parent.drawingShape) {
          this.currentDrawingShape = parent.drawingShape.toLowerCase();
          if (dummyClick) {
            parent.enableShapeDrawing(parent.toPascalCase(parent.drawingShape), true);
            parent.upperCanvas.style.cursor = "crosshair";
          }
        }
        parent.isShapeDrawing = false;
        parent.notify("freehand-draw", { prop: "resetSelPoints", onPropertyChange: false });
      }
      this.isMouseUp = false;
    };
    Selection2.prototype.adjustActObjForLineArrow = function(obj) {
      var isAdjusted = false;
      var parent = this.parent;
      obj = obj ? obj : parent.activeObj;
      if (obj.shape && (obj.shape === "line" || parent.activeObj.shape === "arrow")) {
        var temp = undefined;
        if (this.dragElement === "e-resize" && obj.activePoint.endX < obj.activePoint.startX || this.dragElement === "w-resize" && obj.activePoint.startX > obj.activePoint.endX) {
          isAdjusted = true;
          temp = obj.activePoint.startX;
          obj.activePoint.startX = obj.activePoint.endX;
          obj.activePoint.endX = temp;
          temp = obj.activePoint.startY;
          obj.activePoint.startY = obj.activePoint.endY;
          obj.activePoint.endY = temp;
        }
        obj.activePoint.width = Math.abs(obj.activePoint.endX - obj.activePoint.startX);
        obj.activePoint.height = Math.abs(obj.activePoint.endY - obj.activePoint.startY);
        if (parent.activeObj.shape !== "path") {
          parent.notify("shape", {
            prop: "setPointCollForLineArrow",
            onPropertyChange: false,
            value: { obj }
          });
          for (var i = 0; i < obj.pointColl.length; i++) {
            obj.pointColl[i].ratioX = (obj.pointColl[i].x - parent.img.destLeft) / parent.img.destWidth;
            obj.pointColl[i].ratioY = (obj.pointColl[i].y - parent.img.destTop) / parent.img.destHeight;
          }
        }
      }
      return isAdjusted;
    };
    Selection2.prototype.updPtCollForShpRot = function(obj) {
      var parent = this.parent;
      obj = obj ? obj : parent.activeObj;
      if (obj.shape && obj.rotatedAngle !== 0) {
        parent.notify("shape", { prop: "setPointCollForShapeRotation", onPropertyChange: false, value: { obj } });
        var _a = parent.img, destLeft_1 = _a.destLeft, destTop_1 = _a.destTop, destWidth_1 = _a.destWidth, destHeight_1 = _a.destHeight;
        var horTopLinePointColl = obj.horTopLinePointColl, horBottomLinePointColl = obj.horBottomLinePointColl, verLeftLinePointColl = obj.verLeftLinePointColl, verRightLinePointColl = obj.verRightLinePointColl;
        var setRatio = function(point) {
          point.ratioX = (point.x - destLeft_1) / destWidth_1;
          point.ratioY = (point.y - destTop_1) / destHeight_1;
        };
        horTopLinePointColl.forEach(setRatio);
        horBottomLinePointColl.forEach(setRatio);
        verLeftLinePointColl.forEach(setRatio);
        verRightLinePointColl.forEach(setRatio);
      }
    };
    Selection2.prototype.setXYPoints = function(e) {
      e.preventDefault();
      var x;
      var y;
      if (e.type === "mousedown") {
        x = e.clientX;
        y = e.clientY;
      } else {
        this.touchEndPoint.x = x = e.touches[0].clientX;
        this.touchEndPoint.y = y = e.touches[0].clientY;
      }
      var bbox = this.parent.lowerCanvas.getBoundingClientRect();
      x -= bbox.left;
      y -= bbox.top;
      return { x, y };
    };
    Selection2.prototype.getCurrentIndex = function() {
      var index;
      var parent = this.parent;
      for (var i = 0, len = parent.objColl.length; i < len; i++) {
        if (parent.activeObj.currIndex === parent.objColl[i].currIndex) {
          index = i;
          break;
        }
      }
      return index;
    };
    Selection2.prototype.isShapeClick = function(e, isCropSelection) {
      var parent = this.parent;
      var isShape = false;
      if (parent.togglePen) {
        return isShape;
      }
      if (parent.activeObj.shape && parent.activeObj.shape === "text" && this.isShapeInserted) {
        var isTextArea = parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block" ? true : false;
        var activeObj = extend({}, parent.activeObj, null, true);
        parent.notify("shape", {
          prop: "redrawActObj",
          onPropertyChange: false,
          value: { x: null, y: null, isMouseDown: true }
        });
        var points = this.setXYPoints(e);
        var x = points.x;
        var y = points.y;
        isShape = this.findTargetObj(x, y, isCropSelection);
        if (!isCropSelection) {
          this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
          if (isShape) {
            parent.notify("shape", {
              prop: "redrawActObj",
              onPropertyChange: false,
              value: { x: null, y: null, isMouseDown: true }
            });
          }
        }
        if (isTextArea) {
          parent.textArea.value = parent.objColl[parent.objColl.length - 1].keyHistory;
          parent.textArea.style.display = "block";
          parent.activeObj = activeObj;
          var index = this.getCurrentIndex();
          if (isNullOrUndefined(index)) {
            parent.objColl.pop();
          } else {
            parent.objColl.splice(index, 1);
          }
        } else if (!isShape && activeObj.shape) {
          parent.activeObj = activeObj;
          var index = this.getCurrentIndex();
          if (!isNullOrUndefined(index) && JSON.stringify(parent.activeObj.activePoint) === JSON.stringify(parent.objColl[index].activePoint)) {
            parent.objColl.splice(index, 1);
          } else if (isNullOrUndefined(parent.activeObj.currIndex)) {
            parent.objColl.pop();
          }
        }
      }
      return isShape;
    };
    Selection2.prototype.isShapeTouch = function(e, isCropSelection) {
      var parent = this.parent;
      var isShape = false;
      if (e.type === "touchstart" && !parent.togglePen) {
        if (parent.activeObj && parent.activeObj.shape === "text") {
          this.timer = setTimeout(this.setTimer.bind(this), 1e3, e);
        }
        var isTextArea = parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block" ? true : false;
        var activeObj = extend({}, parent.activeObj, null, true);
        parent.notify("shape", {
          prop: "redrawActObj",
          onPropertyChange: false,
          value: { x: null, y: null, isMouseDown: true }
        });
        var points = this.setXYPoints(e);
        var x = points.x;
        var y = points.y;
        isShape = this.findTargetObj(x, y, isCropSelection);
        if (!isCropSelection) {
          this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        }
        if (isTextArea) {
          parent.textArea.value = parent.objColl[parent.objColl.length - 1].keyHistory;
          parent.textArea.style.display = "block";
          parent.activeObj = activeObj;
          var index = this.getCurrentIndex();
          if (isNullOrUndefined(index)) {
            parent.objColl.pop();
          } else {
            parent.objColl.splice(index, 1);
          }
        } else if (!isShape && activeObj.shape && (activeObj.activePoint.width !== 0 || activeObj.activePoint.height !== 0 || activeObj.shape === "path" && activeObj.pointColl.length > 0)) {
          parent.activeObj = activeObj;
          var index = this.getCurrentIndex();
          if (!isCropSelection) {
            if (!isNullOrUndefined(index) && JSON.stringify(parent.activeObj.activePoint) === JSON.stringify(parent.objColl[index].activePoint)) {
              parent.objColl.splice(index, 1);
            } else if (isNullOrUndefined(parent.activeObj.currIndex)) {
              parent.objColl.pop();
            }
          }
        }
      }
      return isShape;
    };
    Selection2.prototype.isFreehandDrawTouch = function(e, isCropSelection) {
      var parent = this.parent;
      var isFreehandDraw = false;
      if (e.type === "touchstart" && !isCropSelection && !parent.togglePen) {
        var isTextArea = parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block" ? true : false;
        var activeObj = extend({}, parent.activeObj, null, true);
        parent.notify("shape", {
          prop: "redrawActObj",
          onPropertyChange: false,
          value: { x: null, y: null, isMouseDown: true }
        });
        var points = this.setXYPoints(e);
        var x = points.x;
        var y = points.y;
        this.setCursor(x, y);
        if (this.isFhdPoint) {
          isFreehandDraw = true;
        }
        if (isTextArea) {
          parent.textArea.value = parent.objColl[parent.objColl.length - 1].keyHistory;
          parent.textArea.style.display = "block";
          parent.activeObj = activeObj;
          var index = this.getCurrentIndex();
          if (isNullOrUndefined(index)) {
            parent.objColl.pop();
          } else {
            parent.objColl.splice(index, 1);
          }
        } else if (activeObj.shape) {
          parent.activeObj = activeObj;
          var index = this.getCurrentIndex();
          if (!isCropSelection) {
            if (!isNullOrUndefined(index) && JSON.stringify(parent.activeObj.activePoint) === JSON.stringify(parent.objColl[index].activePoint)) {
              parent.objColl.splice(index, 1);
            } else if (isNullOrUndefined(parent.activeObj.currIndex)) {
              parent.objColl.pop();
            }
          }
        }
      }
      return isFreehandDraw;
    };
    Selection2.prototype.applyObj = function(x, y) {
      var parent = this.parent;
      var isApply = false;
      if (parent.activeObj.activePoint.width === 0 && parent.activeObj.activePoint.height === 0) {
        return false;
      }
      var shapeColl = ["rectangle", "ellipse", "line", "arrow", "path", "image", "text"];
      var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
      if (parent.activeObj.shape && shapeColl.indexOf(parent.activeObj.shape) > -1) {
        var radius = parent.activeObj.topLeftCircle.radius;
        if (x >= startX - radius * 2 && x <= endX + radius * 2 && y >= startY - radius * 2 && y <= endY + radius * 2) {
          isApply = false;
        } else if (parent.upperCanvas.style.cursor !== "default" && parent.upperCanvas.style.cursor !== "grab" && parent.upperCanvas.style.cursor !== "crosshair" && parent.upperCanvas.style.cursor !== "pointer" && parent.upperCanvas.style.cursor !== "move") {
          isApply = false;
        } else {
          isApply = true;
        }
      }
      return isApply;
    };
    Selection2.prototype.applyCurrShape = function(isShapeClick) {
      var parent = this.parent;
      var isApply = false;
      if (parent.togglePen) {
        return isApply;
      }
      var obj = extend({}, parent.activeObj, null, true);
      if (this.isShapeInserted && parent.activeObj.shape === "text" && isShapeClick) {
        this.isInitialTextEdited = true;
        parent.notify("draw", { prop: "setShapeTextInsert", onPropertyChange: false, value: { bool: true } });
      }
      if (parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block") {
        var activeObj = extend({}, parent.activeObj, null, true);
        parent.notify("shape", {
          prop: "redrawActObj",
          onPropertyChange: false,
          value: { x: null, y: null, isMouseDown: null }
        });
        obj = extend({}, parent.objColl[parent.objColl.length - 1], null, true);
        parent.objColl.pop();
        parent.activeObj = extend({}, activeObj, null, true);
        parent.textArea.value = obj.keyHistory;
        parent.textArea.style.display = "block";
        var strokeColor = obj.strokeSettings && obj.strokeSettings.strokeColor ? obj.strokeSettings.strokeColor.split("(")[0] === "rgb" ? this.rgbToHex(parseFloat(obj.strokeSettings.strokeColor.split("(")[1].split(",")[0]), parseFloat(obj.strokeSettings.strokeColor.split("(")[1].split(",")[1]), parseFloat(obj.strokeSettings.strokeColor.split("(")[1].split(",")[2]), parseFloat(obj.strokeSettings.strokeColor.split("(")[1].split(",")[3])) : obj.strokeSettings.strokeColor : null;
        if (strokeColor && strokeColor === "#ffffff") {
          strokeColor = "#fff";
        }
        if (this.tempActiveObj.strokeSettings && this.tempActiveObj.strokeSettings.strokeColor && this.tempActiveObj.strokeSettings.strokeColor === "#ffffff") {
          this.tempActiveObj.strokeSettings.strokeColor = "#fff";
        }
        if (obj.keyHistory !== this.tempActiveObj.keyHistory || strokeColor && strokeColor !== this.tempActiveObj.strokeSettings.strokeColor || obj.textSettings && obj.textSettings.fontFamily !== this.tempActiveObj.textSettings.fontFamily || obj.textSettings && Math.round(obj.textSettings.fontSize) !== Math.round(this.tempActiveObj.textSettings.fontSize) || obj.textSettings && Math.round(obj.textSettings.fontRatio) !== Math.round(this.tempActiveObj.textSettings.fontRatio) || obj.textSettings && obj.textSettings.bold !== this.tempActiveObj.textSettings.bold || obj.textSettings && obj.textSettings.italic !== this.tempActiveObj.textSettings.italic || obj.textSettings && obj.textSettings.underline !== this.tempActiveObj.textSettings.underline) {
          isApply = true;
        }
        if (this.isInitialTextEdited && !isApply) {
          isApply = true;
          this.isInitialTextEdited = false;
        }
      } else {
        this.tempActiveObj.activePoint.height = Math.abs(this.tempActiveObj.activePoint.height);
        isApply = JSON.stringify(obj) !== JSON.stringify(this.tempActiveObj);
      }
      return isApply;
    };
    Selection2.prototype.canvasMouseDownHandler = function(e) {
      var parent = this.parent;
      e.preventDefault();
      var x;
      var y;
      if (e.type === "mousedown") {
        x = e.offsetX || e.pageX - parent.lowerCanvas.offsetLeft;
        y = e.offsetY || e.pageY - parent.lowerCanvas.offsetTop;
      } else {
        x = e.touches[0].clientX || e.touches[0].pageX - parent.lowerCanvas.offsetLeft;
        y = e.touches[0].clientY || e.touches[0].pageY - parent.lowerCanvas.offsetTop;
      }
      var bbox = parent.lowerCanvas.getBoundingClientRect();
      x -= bbox.left;
      y -= bbox.top;
      this.panDown = { x, y };
      var tempPanMoveObj = { tempPanMove: null };
      parent.notify("transform", {
        prop: "getTempPanMove",
        onPropertyChange: false,
        value: { obj: tempPanMoveObj }
      });
      if (isNullOrUndefined(tempPanMoveObj["tempPanMove"])) {
        parent.notify("transform", {
          prop: "setTempPanMove",
          onPropertyChange: false,
          value: { point: { x, y } }
        });
      }
    };
    Selection2.prototype.canvasMouseMoveHandler = function(e) {
      var parent = this.parent;
      var frameObject = { bool: null };
      parent.notify("toolbar", { prop: "getFrameToolbar", onPropertyChange: false, value: { obj: frameObject } });
      if (parent.isResize || frameObject["bool"]) {
        parent.upperCanvas.style.cursor = "default";
        return;
      }
      if (this.dragCanvas) {
        parent.lowerCanvas.style.cursor = "grab";
      } else {
        this.dragCanvas = parent.togglePan = false;
        parent.lowerCanvas.style.cursor = parent.upperCanvas.style.cursor = parent.cursor = "default";
      }
      var x;
      var y;
      if (e.type === "mousemove") {
        x = e.offsetX;
        y = e.offsetY;
      } else {
        x = e.touches[0].clientX || e.touches[0].pageX - parent.lowerCanvas.offsetLeft;
        y = e.touches[0].clientY || e.touches[0].pageY - parent.lowerCanvas.offsetTop;
      }
      var bbox = parent.lowerCanvas.getBoundingClientRect();
      x -= bbox.left;
      y -= bbox.top;
      var panMove = { x, y };
      parent.notify("transform", {
        prop: "setPanMove",
        onPropertyChange: false,
        value: { point: { x, y } }
      });
      if (this.panDown && panMove && parent.togglePan && this.dragCanvas) {
        if (parent.isCropTab || parent.activeObj.shape) {
          parent.notify("draw", { prop: "setStraightenActObj", value: { activeObj: null } });
          parent.notify("freehand-draw", { prop: "resetStraightenPoint" });
        }
        parent.notify("transform", {
          prop: "drawPannedImage",
          onPropertyChange: false,
          value: { xDiff: null, yDiff: null }
        });
      }
    };
    Selection2.prototype.canvasMouseUpHandler = function(e) {
      var parent = this.parent;
      e.preventDefault();
      var panMoveObj = { panMove: null };
      parent.notify("transform", {
        prop: "getPanMove",
        onPropertyChange: false,
        value: { obj: panMoveObj }
      });
      if (parent.togglePan) {
        if (this.panDown && panMoveObj["panMove"] && parent.togglePan && this.dragCanvas) {
          this.panDown = null;
          parent.notify("transform", {
            prop: "setPanMove",
            onPropertyChange: false,
            value: { point: null }
          });
        }
      }
      parent.notify("transform", {
        prop: "setTempPanMove",
        onPropertyChange: false,
        value: { point: null }
      });
      if (this.currentDrawingShape !== "path") {
        parent.currObjType.isDragging = false;
      }
    };
    Selection2.prototype.touchStartHandler = function(e) {
      e.preventDefault();
      var parent = this.parent;
      if (this.touchTime === 0) {
        this.touchTime = (/* @__PURE__ */ new Date()).getTime();
      } else {
        if ((/* @__PURE__ */ new Date()).getTime() - this.touchTime < 400) {
          this.isTouchDblClick = true;
          var temp = parent.isShapeDrawing;
          parent.notify("shape", { prop: "stopPathDrawing", onPropertyChange: false, value: { e, isApply: null } });
          this.isTouchDblClick = false;
          this.touchTime = 0;
          if (temp !== parent.isShapeDrawing && parent.activeObj.shape && parent.activeObj.shape === "path") {
            return;
          }
        } else {
          this.touchTime = (/* @__PURE__ */ new Date()).getTime();
        }
      }
      if (e.touches.length === 2) {
        this.isFirstMove = true;
      } else {
        this.mouseDownEventHandler(e);
      }
      EventHandler.add(parent.lowerCanvas, "touchend", this.mouseUpEventHandler, this);
      EventHandler.add(parent.lowerCanvas, "touchmove", this.mouseMoveEventHandler, this);
      EventHandler.add(parent.upperCanvas, "touchend", this.mouseUpEventHandler, this);
      EventHandler.add(parent.upperCanvas, "touchmove", this.mouseMoveEventHandler, this);
    };
    Selection2.prototype.unwireEvent = function() {
      var parent = this.parent;
      EventHandler.remove(parent.lowerCanvas, "touchend", this.mouseUpEventHandler);
      EventHandler.remove(parent.lowerCanvas, "touchmove", this.mouseMoveEventHandler);
      EventHandler.remove(parent.upperCanvas, "touchend", this.mouseUpEventHandler);
      EventHandler.remove(parent.upperCanvas, "touchmove", this.mouseMoveEventHandler);
    };
    Selection2.prototype.keyDownEventHandler = function(e) {
      var parent = this.parent;
      if (e.ctrlKey && (e.key === "+" || e.key === "-")) {
        e.preventDefault();
      }
      var obj = { fileName: "", fileType: null };
      parent.notify("draw", { prop: "getFileName", onPropertyChange: false, value: { obj } });
      var beforeSave = { fileName: obj["fileName"], fileType: obj["fileType"], cancel: false };
      switch (e.key) {
        case (e.ctrlKey && "s"):
          parent.trigger("beforeSave", beforeSave);
          this.beforeSaveEvent(beforeSave, e);
          break;
        case (e.ctrlKey && "z"):
          if (parent.allowUndoRedo) {
            parent.noPushUndo = false;
            if (parent.togglePen || parent.drawingShape) {
              parent.okBtn();
              parent.drawingShape = null;
            }
            parent.notify("undo-redo", { prop: "call-undo" });
          }
          break;
        case (e.ctrlKey && "y"):
          if (parent.allowUndoRedo) {
            parent.noPushUndo = false;
            if (parent.togglePen || parent.drawingShape) {
              parent.okBtn();
              parent.drawingShape = null;
            }
            parent.notify("undo-redo", { prop: "call-redo" });
          }
          break;
        case (e.ctrlKey && "+"):
          if ((parent.zoomSettings.zoomTrigger & ZoomTrigger.Commands) === ZoomTrigger.Commands) {
            this.zoomType = "Commands";
            parent.isZoomBtnClick = true;
            parent.notify("transform", {
              prop: "zoomAction",
              onPropertyChange: false,
              value: { zoomFactor: 0.1, zoomPoint: null },
              isResize: null
            });
            parent.notify("draw", { prop: "redrawDownScale" });
            if (parent.isCropTab || parent.activeObj.shape) {
              parent.notify("draw", { prop: "setStraightenActObj", value: { activeObj: null } });
              parent.notify("freehand-draw", { prop: "resetStraightenPoint" });
            }
            if (parent.isStraightening) {
              parent.notify("draw", { prop: "resetStraightenDestPoints" });
              parent.notify("draw", { prop: "setDestForStraighten" });
            }
          }
          break;
        case (e.ctrlKey && "-"):
          if ((parent.zoomSettings.zoomTrigger & ZoomTrigger.Commands) === ZoomTrigger.Commands) {
            this.zoomType = "Commands";
            parent.isZoomBtnClick = true;
            parent.notify("transform", {
              prop: "zoomAction",
              onPropertyChange: false,
              value: { zoomFactor: -0.1, zoomPoint: null },
              isResize: null
            });
            parent.notify("draw", { prop: "redrawDownScale" });
            if (parent.isCropTab || parent.activeObj.shape) {
              parent.notify("draw", { prop: "setStraightenActObj", value: { activeObj: null } });
              parent.notify("freehand-draw", { prop: "resetStraightenPoint" });
            }
            if (parent.isStraightening) {
              parent.notify("draw", { prop: "resetStraightenDestPoints" });
              parent.notify("draw", { prop: "setDestForStraighten" });
            }
          }
          break;
        case "Delete":
          this.deleteItem();
          break;
        case "Escape":
          parent.notify("draw", { prop: "performCancel", value: { isContextualToolbar: null, isFinalCancel: true } });
          break;
        case "Enter":
          this.performEnterAction(e);
          break;
        case "Tab":
          this.performTabAction();
          break;
        default:
          if (Browser.isDevice && (parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block")) {
            setTimeout(this.textKeyDown.bind(this), 1, e);
          }
          break;
      }
    };
    Selection2.prototype.performEnterAction = function(e) {
      var parent = this.parent;
      if (parent.isResize) {
        var target = e.target;
        var isIcon = target.id.indexOf("aspectratio") || target.id.indexOf("non-aspectratio") > -1 ? true : false;
        var isValue = this.isValueUpdated();
        if (!isValue) {
          if (isIcon) {
            this.focusRatioBtn();
          }
          return;
        }
        var point = this.getNumTextValue();
        var aspectRatioElement = parent.element.querySelector("#" + parent.element.id + "_aspectratio");
        var blrAspRatElem = parent.element.querySelector(".e-ie-toolbar-aspect-ratio-btn");
        if (point && point.x && point.y) {
          if (aspectRatioElement || blrAspRatElem && !blrAspRatElem.classList.contains("e-hidden")) {
            parent.notify("transform", { prop: "resize", value: { width: point.x, height: null, isAspectRatio: true } });
          } else {
            parent.notify("transform", { prop: "resize", value: { width: point.x, height: point.y, isAspectRatio: false } });
          }
        }
        var aspectRatioHeight = parent.element.querySelector("#" + parent.element.id + "_resizeHeight");
        var aspectRatioWidth = parent.element.querySelector("#" + parent.element.id + "_resizeWidth");
        if (isNullOrUndefined(aspectRatioElement)) {
          if (aspectRatioHeight) {
            var elem = getComponent(aspectRatioHeight, "numerictextbox");
            if (aspectRatioHeight && aspectRatioHeight.value === "") {
              elem.value = parseFloat(elem.placeholder);
              aspectRatioHeight.value = elem.placeholder + "px";
            }
          }
          if (aspectRatioWidth) {
            var elem = getComponent(aspectRatioWidth, "numerictextbox");
            if (aspectRatioWidth && aspectRatioWidth.value === "") {
              elem.value = parseFloat(elem.placeholder);
              aspectRatioWidth.value = elem.placeholder + "px";
            }
          }
        }
        parent.notify("draw", { prop: "redrawDownScale" });
        if (isIcon) {
          this.focusRatioBtn();
        }
      } else if (e.target.classList.contains("e-upload")) {
        var upload = parent.element.querySelector(".e-image-upload");
        if (upload && upload.querySelector(".e-tbar-btn")) {
          upload.querySelector(".e-tbar-btn").click();
        }
      } else if (e.target.classList.contains("filter-wrapper")) {
        e.target.parentElement.click();
      } else {
        var splitWords = undefined;
        if (parent.activeObj.shape) {
          splitWords = parent.activeObj.shape.split("-");
        }
        if (e && this.isKeyBoardCrop(e) && parent.activeObj.horTopLine && (parent.activeObj.shape && splitWords[0] === "crop")) {
          parent.crop();
        }
      }
    };
    Selection2.prototype.focusRatioBtn = function() {
      var id = this.parent.element.id;
      if (this.parent.isKBDNavigation) {
        setTimeout(function() {
          if ((undefined).getElementById(id + "_aspectratio")) {
            (undefined).getElementById(id + "_aspectratio").focus();
          } else if ((undefined).getElementById(id + "_nonaspectratio")) {
            (undefined).getElementById(id + "_nonaspectratio").focus();
          }
        }, 50);
      }
    };
    Selection2.prototype.isKeyBoardCrop = function(e) {
      var bool = false;
      var target = e.target;
      if (target.id === this.parent.element.id + "_ok" || target.id === "") {
        bool = true;
      }
      return bool;
    };
    Selection2.prototype.beforeSaveEvent = function(observableSaveArgs, e) {
      var parent = this.parent;
      if (!observableSaveArgs.cancel) {
        parent.notify("export", {
          prop: "export",
          onPropertyChange: false,
          value: { type: observableSaveArgs.fileType, fileName: observableSaveArgs.fileName }
        });
      }
      e.preventDefault();
      e.stopImmediatePropagation();
    };
    Selection2.prototype.handleScroll = function(e) {
      this.mouseWheel++;
      var parent = this.parent;
      var x;
      var y;
      var isInsideCanvas = false;
      if (e.type === "mousewheel") {
        x = e.clientX;
        y = e.clientY;
      }
      var bbox = parent.lowerCanvas.getBoundingClientRect();
      x -= bbox.left;
      y -= bbox.top;
      if (x > parent.img.destLeft && x < parent.img.destLeft + parent.img.destWidth && y > parent.img.destTop && y < parent.img.destTop + parent.img.destHeight) {
        isInsideCanvas = true;
      }
      if (this.mouseWheel === 2) {
        this.mouseWheel = 0;
        if (e.ctrlKey === true && isInsideCanvas) {
          e.preventDefault();
        }
        return;
      }
      e.stopPropagation();
      if (e.ctrlKey === true && isInsideCanvas) {
        e.preventDefault();
        if (!parent.isCropTab && (parent.activeObj.shape && parent.activeObj.shape.split("-")[0] !== "crop")) {
          parent.okBtn(null, true);
          parent.notify("toolbar", { prop: "close-contextual-toolbar", onPropertyChange: false });
        }
        var type = "";
        if (e.type === "mousewheel" && (parent.zoomSettings.zoomTrigger & ZoomTrigger.MouseWheel) === ZoomTrigger.MouseWheel) {
          this.zoomType = "MouseWheel";
          if (e.wheelDelta > 0) {
            type = "zoomIn";
          } else {
            type = "zoomOut";
          }
        }
        if (type !== "") {
          parent.isZoomBtnClick = true;
          parent.notify("draw", {
            prop: "performPointZoom",
            onPropertyChange: false,
            value: { x, y, type, isResize: null }
          });
          parent.notify("draw", { prop: "redrawDownScale" });
          if (parent.isCropTab || parent.activeObj.shape) {
            parent.notify("draw", { prop: "setStraightenActObj", value: { activeObj: null } });
            parent.notify("freehand-draw", { prop: "resetStraightenPoint" });
          }
          if (parent.isStraightening) {
            parent.notify("draw", { prop: "resetStraightenDestPoints" });
            parent.notify("draw", { prop: "setDestForStraighten" });
          }
        }
      }
    };
    Selection2.prototype.textKeyDown = function(e) {
      var parent = this.parent;
      if (parent.activeObj.rotatedAngle !== 0) {
        return;
      }
      if (String.fromCharCode(e.which) === "\r") {
        this.textRow += 1;
      }
      parent.textArea.setAttribute("rows", this.textRow.toString());
      parent.textArea.style.height = "auto";
      parent.textArea.style.height = parent.textArea.scrollHeight + "px";
      parent.notify("shape", { prop: "setTextBoxWidth", onPropertyChange: false, value: { e } });
      if (Browser.isDevice) {
        parent.textArea.style.width = parseFloat(parent.textArea.style.width) + parent.textArea.style.fontSize + "px";
      }
      var rows = parent.textArea.value.split("\n");
      this.textRow = rows.length;
      parent.textArea.setAttribute("rows", this.textRow.toString());
      this.isInitialTextEdited = false;
    };
    Selection2.prototype.clearSelection = function(resetCrop) {
      var parent = this.parent;
      if (!parent.disabled && parent.isImageLoaded) {
        if (resetCrop) {
          parent.notify("draw", { prop: "performCancel", value: { isContextualToolbar: null } });
        } else {
          parent.togglePen = false;
          parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
          this.dragElement = "";
          this.dragPoint.startX = this.dragPoint.startY = this.dragPoint.endX = this.dragPoint.endY = 0;
          parent.currObjType.shape = "";
          this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
          parent.currObjType.isActiveObj = true;
          parent.currObjType.isCustomCrop = false;
          parent.upperCanvas.style.cursor = parent.cursor = "default";
        }
      }
    };
    Selection2.prototype.setDragDirection = function(width, height) {
      var arcRadius = 7.5;
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      if (parent.img.destWidth > parent.img.destHeight) {
        actPoint.startX = this.dragPoint.startX = width / 2 - height / 2 + arcRadius;
        actPoint.startY = this.dragPoint.startY = height / 2 - height / 2 + arcRadius;
        actPoint.endX = width / 2 + height / 2 - arcRadius;
        actPoint.endY = height / 2 + height / 2 - arcRadius;
      } else {
        actPoint.startY = this.dragPoint.startX = height / 2 - width / 2 + arcRadius;
        actPoint.endY = height / 2 + width / 2 - arcRadius;
        actPoint.startX = this.dragPoint.startX = arcRadius;
        actPoint.endX = width - arcRadius;
      }
    };
    Selection2.prototype.calcShapeRatio = function(x, y, imgWidth, imgHeight) {
      var parent = this.parent;
      var actPoint = parent.activeObj.activePoint;
      var arcRadius = 7.5;
      var presetRatio = x / y;
      var originalWidth2 = imgWidth;
      var originalHeight2 = imgHeight;
      var standardSize = originalWidth2 >= originalHeight2 ? originalWidth2 : originalHeight2;
      var width = standardSize * presetRatio;
      var height = standardSize;
      var scaleWidth = this.getScale(width, originalWidth2);
      var snippetArray = [];
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      for (var i = 0; i < 2; i++) {
        if (i === 0) {
          snippetArray.push(width * scaleWidth);
        } else {
          snippetArray.push(height * scaleWidth);
        }
      }
      width = snippetArray[0];
      height = snippetArray[1];
      var scaleHeight = this.getScale(height, originalHeight2);
      var snippetArray1 = [];
      for (var i = 0; i < 2; i++) {
        if (i === 0) {
          snippetArray1.push(width * scaleHeight);
        } else {
          snippetArray1.push(height * scaleHeight);
        }
      }
      width = snippetArray1[0];
      height = snippetArray1[1];
      actPoint.width = width;
      actPoint.height = height;
      actPoint.startX = (this.dragPoint.startX = (originalWidth2 - width) / 2) + arcRadius;
      actPoint.startY = (this.dragPoint.startY = (originalHeight2 - height) / 2) + arcRadius;
      actPoint.endX = actPoint.startX + actPoint.width;
      actPoint.endY = actPoint.startY + actPoint.height;
      if (actPoint.startX < destLeft && destLeft + destWidth > parent.lowerCanvas.clientWidth) {
        actPoint.startX = destLeft;
        actPoint.endX = actPoint.startX + width - arcRadius;
      }
      if (actPoint.startY < destTop && destTop + destHeight > parent.lowerCanvas.clientHeight) {
        actPoint.startY = destTop;
        actPoint.endY = actPoint.startY + height - arcRadius;
      }
      actPoint.width = actPoint.endX - actPoint.startX;
      actPoint.height = actPoint.endY - actPoint.startY;
    };
    Selection2.prototype.getScale = function(value, originalValue) {
      return value > originalValue ? originalValue / value : 1;
    };
    Selection2.prototype.findTarget = function(x, y, type) {
      var parent = this.parent;
      if (type.toLowerCase() === "mousedown" || type.toLowerCase() === "touchstart") {
        var splitWords = undefined;
        var isCrop = false;
        if (parent.activeObj.shape) {
          splitWords = parent.activeObj.shape.split("-");
          if (splitWords[0] === "crop") {
            isCrop = true;
          }
        }
        this.findTargetObj(x, y, isCrop);
        this.updateCursorStyles(x, y, type);
      } else {
        var _a = parent.activeObj, topLeftCircle = _a.topLeftCircle, topCenterCircle = _a.topCenterCircle, topRightCircle = _a.topRightCircle, centerLeftCircle = _a.centerLeftCircle, centerRightCircle = _a.centerRightCircle, bottomLeftCircle = _a.bottomLeftCircle, bottomCenterCircle = _a.bottomCenterCircle, bottomRightCircle = _a.bottomRightCircle;
        switch (this.dragElement.toLowerCase()) {
          case "nw-resize":
            topLeftCircle.startX = x;
            topLeftCircle.startY = y;
            break;
          case "n-resize":
            topCenterCircle.startX = x;
            topCenterCircle.startY = y;
            break;
          case "ne-resize":
            topRightCircle.startX = x;
            topRightCircle.startY = y;
            break;
          case "w-resize":
            centerLeftCircle.startX = x;
            centerLeftCircle.startY = y;
            break;
          case "e-resize":
            centerRightCircle.startX = x;
            centerRightCircle.startY = y;
            break;
          case "sw-resize":
            bottomLeftCircle.startX = x;
            bottomLeftCircle.startY = y;
            break;
          case "s-resize":
            bottomCenterCircle.startX = x;
            bottomCenterCircle.startY = y;
            break;
          case "se-resize":
            bottomRightCircle.startX = x;
            bottomRightCircle.startY = y;
            break;
          default:
            if (this.dragPoint.startX && this.dragPoint.startY) {
              this.previousPoint.x = this.dragPoint.endX;
              this.previousPoint.y = this.dragPoint.endY;
              this.dragPoint.endX = x;
              this.dragPoint.endY = y;
            }
            break;
        }
      }
    };
    Selection2.prototype.findTargetObj = function(x, y, isCrop) {
      var parent = this.parent;
      var isShape = false;
      if (parent.objColl.length !== 0 && !parent.currObjType.isCustomCrop && !isCrop) {
        var prevIndex = 0;
        var i = undefined;
        for (var index = 0; index < parent.objColl.length; index++) {
          var cursor = parent.upperCanvas.style.cursor;
          this.setCursor(x, y);
          var actObj = extend({}, parent.objColl[index], {}, true);
          var radius = actObj.topLeftCircle.radius;
          if (actObj.shape === "line" || actObj.shape === "arrow") {
            for (var j = 0; j < actObj.pointColl.length; j++) {
              if (x >= actObj.pointColl[j].x - radius * 2 && x <= actObj.pointColl[j].x + radius * 2 && y >= actObj.pointColl[j].y - radius * 2 && y <= actObj.pointColl[j].y + radius * 2) {
                if (this.tempActiveObj && this.tempActiveObj.activePoint && JSON.stringify(this.tempActiveObj.activePoint) === JSON.stringify(actObj.activePoint)) {
                  i = index;
                  break;
                } else {
                  if (this.isTouch || parent.cursor === "move" || parent.cursor === "grab" || this.isShapeInserted) {
                    if (prevIndex === 0 || prevIndex < actObj.order) {
                      prevIndex = actObj.order;
                      i = index;
                    }
                  } else if (parent.objColl[index].currIndex === this.tempActiveObj.currIndex) {
                    i = index;
                  }
                }
                break;
              }
            }
          } else if (actObj.shape === "path") {
            var cursor_3 = this.setCursorForPath(actObj, x, y, parent.upperCanvas);
            if (cursor_3 !== "default" && cursor_3 !== "grab") {
              if (this.tempActiveObj && this.tempActiveObj.activePoint && JSON.stringify(this.tempActiveObj.activePoint) === JSON.stringify(actObj.activePoint)) {
                i = index;
                break;
              } else {
                if (this.isTouch || parent.cursor === "move" || parent.cursor === "grab" || this.isShapeInserted) {
                  if (prevIndex === 0 || prevIndex < actObj.order) {
                    prevIndex = actObj.order;
                    i = index;
                  }
                } else if (parent.objColl[index].currIndex === this.tempActiveObj.currIndex) {
                  i = index;
                }
              }
            }
          } else if (actObj.rotatedAngle !== 0) {
            var cursor_4 = this.setCursorForRotatedObject(actObj, x, y, parent.upperCanvas);
            if (cursor_4 !== "default" && cursor_4 !== "grab") {
              if (this.tempActiveObj && this.tempActiveObj.activePoint && JSON.stringify(this.tempActiveObj.activePoint) === JSON.stringify(actObj.activePoint)) {
                i = index;
                break;
              } else {
                if (this.isTouch || parent.cursor === "move" || parent.cursor === "grab" || this.isShapeInserted) {
                  if (prevIndex === 0 || prevIndex < actObj.order && (actObj.shape !== "redact" || parent.drawingShape === "redact")) {
                    prevIndex = actObj.order;
                    i = index;
                  }
                } else if (parent.objColl[index].currIndex === this.tempActiveObj.currIndex) {
                  i = index;
                }
              }
            }
          } else {
            var rotationCirclePoint = this.getTransRotationPoint(actObj);
            if (x >= actObj.activePoint.startX - radius * 2 && x <= actObj.activePoint.endX + radius * 2 && y >= actObj.activePoint.startY - radius * 2 && y <= actObj.activePoint.endY + radius * 2 || rotationCirclePoint && x >= rotationCirclePoint.x - radius * 2 && x <= rotationCirclePoint.x + radius * 2 && y >= rotationCirclePoint.y - radius * 2 && y <= rotationCirclePoint.y + radius * 2) {
              if (this.tempActiveObj && this.tempActiveObj.activePoint && JSON.stringify(this.tempActiveObj.activePoint) === JSON.stringify(actObj.activePoint)) {
                i = index;
                break;
              } else {
                if (this.isTouch || cursor === "move" || cursor === "grabbing" || this.isShapeInserted || parent.cursor === "move" || parent.cursor === "grabbing") {
                  if (prevIndex === 0 || prevIndex < actObj.order && (actObj.shape !== "redact" || parent.drawingShape === "redact")) {
                    prevIndex = actObj.order;
                    i = index;
                  }
                } else if (parent.objColl[index].currIndex === this.tempActiveObj.currIndex) {
                  i = index;
                }
              }
            }
          }
        }
        if (isNullOrUndefined(i)) {
          parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
          isShape = false;
        } else {
          this.tempObjColl = extend([], parent.objColl, [], true);
          parent.currObjType.isCustomCrop = false;
          parent.activeObj = extend({}, parent.objColl[i], {}, true);
          var temp = extend({}, parent.objColl[i], {}, true);
          parent.objColl.splice(i, 1);
          if (parent.transform.degree === 0) {
            var temp_1 = this.lowerContext.filter;
            this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
            parent.notify("draw", { prop: "drawImage", onPropertyChange: false });
            this.lowerContext.filter = "none";
            parent.notify("shape", {
              prop: "drawAnnotations",
              onPropertyChange: false,
              value: { ctx: this.lowerContext, shape: "iterate", pen: "iterate", isPreventApply: null }
            });
            parent.activeObj = extend({}, temp_1, {}, true);
            this.lowerContext.filter = temp_1;
            this.getCurrentFlipState();
          } else {
            var totalPannedInternalPoint = extend({}, parent.panPoint.totalPannedInternalPoint, {}, true);
            var destPoints = {
              startX: parent.img.destLeft,
              startY: parent.img.destTop,
              width: parent.img.destWidth,
              height: parent.img.destHeight
            };
            parent.notify("draw", { prop: "callUpdateCurrTransState", onPropertyChange: false });
            parent.panPoint.totalPannedInternalPoint = totalPannedInternalPoint;
            parent.img.destLeft = destPoints.startX;
            parent.img.destTop = destPoints.startY;
            parent.img.destWidth = destPoints.width;
            parent.img.destHeight = destPoints.height;
            parent.notify("shape", {
              prop: "drawAnnotations",
              onPropertyChange: false,
              value: { ctx: this.lowerContext, shape: "iterate", pen: "iterate", isPreventApply: null }
            });
          }
          parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
          if (parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle" || parent.isCircleCrop) {
            parent.notify("crop", {
              prop: "cropCircle",
              onPropertyChange: false,
              value: { context: this.lowerContext, isSave: null, isFlip: null }
            });
          }
          parent.activeObj = extend({}, temp, {}, true);
          this.setActivePoint();
          parent.activeObj = extend({}, temp, {}, true);
          var tempStrokeSettings = extend({}, parent.activeObj.strokeSettings, {}, true);
          parent.notify("draw", {
            prop: "setTempStrokeSettings",
            onPropertyChange: false,
            value: { tempStrokeSettings }
          });
          var tempTextSettings = extend({}, parent.activeObj.textSettings, {}, true);
          parent.notify("draw", { prop: "setTempTextSettings", onPropertyChange: false, value: { tempTextSettings } });
          var shapeSettings = this.updatePrevShapeSettings();
          var shapeChangingArgs = {
            cancel: false,
            action: "select",
            previousShapeSettings: shapeSettings,
            currentShapeSettings: shapeSettings,
            allowShapeOverflow: this.allowOutofBound()
          };
          if (parent.activeObj.shape === "line" || parent.activeObj.shape === "arrow") {
            shapeChangingArgs.currentShapeSettings.width = parent.activeObj.activePoint.endX - parent.activeObj.activePoint.startX;
            shapeChangingArgs.currentShapeSettings.height = parent.activeObj.activePoint.endY - parent.activeObj.activePoint.startY;
          }
          this.isCropSelection = false;
          var splitWords = undefined;
          if (parent.activeObj.shape !== undefined) {
            splitWords = parent.activeObj.shape.split("-");
          }
          if (splitWords !== undefined && splitWords[0] === "crop") {
            this.isCropSelection = true;
          }
          if (!this.isCropSelection && parent.activeObj.shape !== "redact") {
            parent.trigger("shapeChanging", shapeChangingArgs);
            this.shapeEvent(shapeChangingArgs);
            parent.editCompleteArgs = shapeChangingArgs;
          } else {
            if (this.isMouseDown) {
              shapeChangingArgs.action = "resize-start";
            } else if (this.isMouseUp) {
              shapeChangingArgs.action = "resize-end";
            }
            var selectionChangingArgs = {
              action: shapeChangingArgs.action,
              previousSelectionSettings: {
                type: parent.getSelectionType(parent.activeObj.shape),
                startX: shapeChangingArgs.previousShapeSettings.startX,
                startY: shapeChangingArgs.previousShapeSettings.startY,
                width: shapeChangingArgs.previousShapeSettings.width,
                height: shapeChangingArgs.previousShapeSettings.height
              },
              currentSelectionSettings: {
                type: parent.getSelectionType(parent.activeObj.shape),
                startX: shapeChangingArgs.currentShapeSettings.startX,
                startY: shapeChangingArgs.currentShapeSettings.startY,
                width: shapeChangingArgs.currentShapeSettings.width,
                height: shapeChangingArgs.currentShapeSettings.height
              }
            };
            parent.trigger("selectionChanging", selectionChangingArgs);
            parent.editCompleteArgs = selectionChangingArgs;
            shapeChangingArgs.currentShapeSettings.startX = selectionChangingArgs.currentSelectionSettings.startX;
            shapeChangingArgs.currentShapeSettings.startY = selectionChangingArgs.currentSelectionSettings.startY;
            shapeChangingArgs.currentShapeSettings.width = selectionChangingArgs.currentSelectionSettings.width;
            shapeChangingArgs.currentShapeSettings.height = selectionChangingArgs.currentSelectionSettings.height;
            this.shapeEvent(shapeChangingArgs);
          }
          isShape = true;
        }
      }
      return isShape;
    };
    Selection2.prototype.shapeEvent = function(shapeChangingArgs) {
      var parent = this.parent;
      parent.notify("shape", {
        prop: "updateShapeChangeEventArgs",
        onPropertyChange: false,
        value: { shapeSettings: shapeChangingArgs.currentShapeSettings, allowShapeOverflow: shapeChangingArgs.allowShapeOverflow }
      });
      if (parent.activeObj.activePoint) {
        var obj = { prevActObj: null };
        parent.notify("draw", { prop: "getPrevActObj", onPropertyChange: false, value: { obj } });
        if (isNullOrUndefined(obj["prevActObj"])) {
          parent.notify("draw", {
            prop: "setPrevActObj",
            onPropertyChange: false,
            value: { prevActObj: extend({}, parent.activeObj, {}, true) }
          });
        }
        if (parent.activeObj.shape === "image" && !this.isImageClarity) {
          this.upgradeImageQuality();
          this.isImageClarity = true;
        }
        parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: {
          canvas: "duplicate",
          obj: parent.activeObj,
          isCropRatio: null,
          points: null,
          isPreventDrag: true,
          saveContext: null,
          isPreventSelection: true
        } });
        if (!this.isShapeInserted) {
          this.isPreventDragging = this.isShapeDragOut();
        }
      }
    };
    Selection2.prototype.upgradeImageQuality = function() {
      var parent = this.parent;
      if (!parent.activeObj.imageCanvas) {
        return;
      }
      var activeObj = extend({}, parent.activeObj, null, true);
      var ctx = parent.activeObj.imageCanvas.getContext("2d");
      var dimObj = { width: 0, height: 0 };
      parent.notify("transform", { prop: "calcMaxDimension", onPropertyChange: false, value: {
        width: parent.activeObj.imageElement.width,
        height: parent.activeObj.imageElement.height,
        obj: dimObj,
        isImgShape: null
      } });
      parent.notify("shape", { prop: "updateObj", onPropertyChange: false, value: { dimObj, x: null, y: null } });
      ctx.clearRect(0, 0, parent.activeObj.imageCanvas.width, parent.activeObj.imageCanvas.height);
      this.applyTransformToImg(ctx);
      parent.activeObj = activeObj;
    };
    Selection2.prototype.applyTransformToImg = function(ctx) {
      var parent = this.parent;
      if (parent.activeObj.isHorImageFlip && parent.activeObj.isVerImageFlip) {
        parent.activeObj.isHorImageFlip = parent.activeObj.isVerImageFlip = false;
        parent.notify("draw", {
          prop: "downScaleImgCanvas",
          onPropertyChange: false,
          value: { ctx, isImgAnnotation: true, isHFlip: true, isVFlip: true }
        });
      } else if (parent.activeObj.isHorImageFlip) {
        parent.activeObj.isHorImageFlip = false;
        parent.notify("draw", {
          prop: "downScaleImgCanvas",
          onPropertyChange: false,
          value: { ctx, isImgAnnotation: true, isHFlip: true, isVFlip: false }
        });
      } else if (parent.activeObj.isVerImageFlip) {
        parent.activeObj.isVerImageFlip = false;
        parent.notify("draw", {
          prop: "downScaleImgCanvas",
          onPropertyChange: false,
          value: { ctx, isImgAnnotation: true, isHFlip: false, isVFlip: true }
        });
      } else {
        parent.notify("draw", {
          prop: "downScaleImgCanvas",
          onPropertyChange: false,
          value: { ctx, isImgAnnotation: true, isHFlip: false, isVFlip: false }
        });
      }
    };
    Selection2.prototype.targetTouches = function(touches) {
      var bbox = this.parent.lowerCanvas.getBoundingClientRect();
      var p1 = { x: touches[0].pageX - bbox.left, y: touches[0].pageY - bbox.top };
      var p2 = { x: touches[1].pageX - bbox.left, y: touches[1].pageY - bbox.top };
      var points = [p1, p2];
      return points;
    };
    Selection2.prototype.calculateScale = function(startTouches, endTouches) {
      var startDistance = this.getDistance(startTouches[0], startTouches[1]);
      var endDistance = this.getDistance(endTouches[0], endTouches[1]);
      return endDistance / startDistance;
    };
    Selection2.prototype.getDistance = function(a, b) {
      var x = 0;
      var y = 0;
      if (a && b) {
        x = a.x - b.x;
        y = a.y - b.y;
      }
      return Math.sqrt(x * x + y * y);
    };
    Selection2.prototype.redrawShape = function(obj, isMouseUp) {
      var parent = this.parent;
      for (var i = 0, len = parent.objColl.length; i < len; i++) {
        if (JSON.stringify(obj) === JSON.stringify(parent.objColl[i])) {
          parent.objColl.splice(i, 1);
          if (obj.shape && parent.textArea.style.display === "none") {
            var actObj = extend({}, obj, {}, true);
            parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
            this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
            parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null } });
            if (parent.rotateFlipColl.length > 0 && (parent.panPoint.totalPannedClientPoint.x !== 0 || parent.panPoint.totalPannedClientPoint.y !== 0)) {
              parent.notify("draw", { prop: "redrawImgWithObj", onPropertyChange: false });
            }
            obj = parent.activeObj = actObj;
          }
          break;
        }
      }
      if (obj.shape === "path" && obj.pointColl.length === 0 || obj.shape !== "path" && (obj.activePoint.width === 0 && obj.activePoint.height === 0)) {
        return;
      }
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      if (this.isPreventDragging) {
        if (parent.activeObj.activePoint.startX > parent.img.destLeft) {
          this.isPreventDragging = false;
        }
        if (isMouseUp && parent.activeObj.rotatedAngle !== 0) {
          parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: {
            canvas: "duplicate",
            obj: null,
            isCropRatio: null,
            points: null,
            isPreventDrag: true,
            saveContext: null,
            isPreventSelection: null
          } });
        } else {
          parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: {
            canvas: "duplicate",
            obj: null,
            isCropRatio: null,
            points: null,
            isPreventDrag: true,
            saveContext: null,
            isPreventSelection: null
          } });
        }
      } else {
        if (isMouseUp && parent.activeObj.rotatedAngle !== 0) {
          parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: {
            canvas: "duplicate",
            obj: null,
            isCropRatio: null,
            points: null,
            isPreventDrag: true,
            saveContext: null,
            isPreventSelection: null
          } });
        } else {
          if (parent.activeObj.shape === "redact") {
            this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
            parent.notify("draw", { prop: "redrawImgWithObj", onPropertyChange: false });
            parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
          }
          parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: {
            canvas: "duplicate",
            obj: null,
            isCropRatio: null,
            points: null,
            isPreventDrag: true,
            saveContext: null,
            isPreventSelection: null
          } });
        }
      }
    };
    Selection2.prototype.setTimer = function(e) {
      var parent = this.parent;
      if (this.timer > 10) {
        clearTimeout(this.timer);
        this.timer = 0;
        parent.notify("shape", { prop: "findTextTarget", onPropertyChange: false, value: { e } });
        if (Browser.isDevice) {
          this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        }
      }
    };
    Selection2.prototype.applyCurrActObj = function(x, y) {
      var parent = this.parent;
      var isInside = false;
      var actObj = extend({}, parent.activeObj, {}, true);
      if (isNullOrUndefined(actObj.activePoint)) {
        return;
      }
      var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
      var radius = actObj.topLeftCircle ? actObj.topLeftCircle.radius : 0;
      if (x >= Math.floor(startX) && x <= Math.ceil(endX) && y >= Math.floor(startY) && y <= Math.ceil(endY)) {
        isInside = true;
      } else if (radius !== 0 && (x >= Math.floor(startX) - radius && x <= Math.ceil(endX) + radius && y >= Math.floor(startY) - radius && y <= Math.ceil(endY) + radius)) {
        isInside = true;
        this.tempActiveObj = {
          activePoint: { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 },
          flipObjColl: [],
          triangle: [],
          triangleRatio: []
        };
      } else if ((actObj.shape === "text" || actObj.shape === "image") && this.dragElement !== "") {
        isInside = true;
      } else if (actObj.shape === "line" || actObj.shape === "arrow") {
        var smallPoint = { x: startX < endX ? startX : endX, y: startY < endY ? startY : endY };
        var largePoint = { x: startX > endX ? startX : endX, y: startY > endY ? startY : endY };
        if (x >= Math.floor(smallPoint.x) - 5 && x <= Math.ceil(largePoint.x) + 5 && y >= Math.floor(smallPoint.y) - 5 && y <= Math.ceil(largePoint.y) + 5 || parent.activeObj.preventShapeDragOut) {
          isInside = true;
        }
      } else if (actObj.shape === "path") {
        var cursor = this.setCursorForPath(actObj, x, y, parent.upperCanvas);
        if (cursor === "move") {
          isInside = true;
        }
      } else if (this.dragElement === "grabbing") {
        isInside = true;
      } else if (actObj.rotatedAngle !== 0) {
        var cursor = this.setCursorForRotatedObject(actObj, x, y, parent.upperCanvas);
        if (cursor !== "default" && cursor !== "grab" || this.dragElement === "n-resize" || this.dragElement === "e-resize" || this.dragElement === "s-resize" || this.dragElement === "w-resize") {
          isInside = true;
        }
      } else if (parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block") {
        isInside = true;
      }
      if (!isInside) {
        if (isNullOrUndefined(parent.activeObj.currIndex)) {
          var shapeIDObj = { id: "shape_" + (parent.objColl.length + 1) };
          parent.notify("shape", { prop: "getNewShapeId", onPropertyChange: false, value: { obj: shapeIDObj } });
          parent.activeObj.currIndex = shapeIDObj["id"];
        }
        parent.notify("shape", { prop: "updImgRatioForActObj", onPropertyChange: false });
        if (parent.activeObj.horTopLine !== undefined && parent.activeObj.horTopLine.startX !== 0 && parent.activeObj.horTopLine.endX !== 0 && !parent.currObjType.isCustomCrop && parent.currObjType.shape !== "") {
          if (parent.objColl.length > 0 && JSON.stringify(parent.objColl[parent.objColl.length - 1].activePoint) !== JSON.stringify(parent.activeObj.activePoint)) {
            parent.objColl.push(extend({}, parent.activeObj, {}, true));
          }
        }
        var shapeColl = ["rectangle", "ellipse", "line", "arrow", "path", "text", "image"];
        if (shapeColl.indexOf(parent.activeObj.shape) > -1) {
          var tempFilter = this.lowerContext.filter;
          this.lowerContext.filter = "brightness(1) contrast(100%) hue-rotate(0deg) saturate(100%) opacity(1) blur(0px) sepia(0%) grayscale(0%) invert(0%)";
          parent.notify("shape", {
            prop: "drawAnnotations",
            onPropertyChange: false,
            value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
          });
          this.lowerContext.filter = tempFilter;
          if (parent.activeObj.shape) {
            parent.notify("shape", {
              prop: "apply",
              onPropertyChange: false,
              value: { shape: null, obj: null, canvas: null }
            });
          }
          parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
          parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.upperContext } });
          if (parent.isCircleCrop) {
            parent.notify("crop", {
              prop: "cropCircle",
              onPropertyChange: false,
              value: { context: this.lowerContext, isSave: null, isFlip: null }
            });
          }
        }
        parent.notify("toolbar", { prop: "refresh-main-toolbar", onPropertyChange: false });
      }
    };
    Selection2.prototype.getCurrentFlipState = function() {
      var parent = this.parent;
      if (parent.rotateFlipColl.length !== 0) {
        var totalPannedInternalPoint = extend({}, parent.panPoint.totalPannedInternalPoint, {}, true);
        parent.notify("draw", { prop: "callUpdateCurrTransState", onPropertyChange: false });
        parent.panPoint.totalPannedInternalPoint = totalPannedInternalPoint;
      } else {
        parent.notify("draw", { prop: "callUpdateCurrTransState", onPropertyChange: false });
      }
    };
    Selection2.prototype.setTextBoxStylesToActObj = function() {
      var parent = this.parent;
      parent.activeObj.textSettings.fontFamily = parent.textArea.style.fontFamily;
      parent.activeObj.strokeSettings.strokeColor = parent.textArea.style.color !== "" && parent.textArea.style.color.split("(")[1] && parent.textArea.style.color.split("(")[1].split(",")[0] && parent.textArea.style.color.split("(")[1].split(",")[1] && parent.textArea.style.color.split("(")[1].split(",")[2] && parent.textArea.style.color.split("(")[1].split(",")[3] ? this.rgbToHex(parseFloat(parent.textArea.style.color.split("(")[1].split(",")[0]), parseFloat(parent.textArea.style.color.split("(")[1].split(",")[1]), parseFloat(parent.textArea.style.color.split("(")[1].split(",")[2]), parseFloat(parent.textArea.style.color.split("(")[1].split(",")[3])) : parent.textArea.style.color;
      parent.activeObj.strokeSettings.fillColor = parent.textArea.style.backgroundColor !== "" && parent.textArea.style.backgroundColor.split("(")[1] && parent.textArea.style.backgroundColor.split("(")[1].split(",")[0] && parent.textArea.style.backgroundColor.split("(")[1].split(",")[1] && parent.textArea.style.backgroundColor.split("(")[1].split(",")[2] && parent.textArea.style.backgroundColor.split("(")[1].split(",")[3] ? this.rgbToHex(parseFloat(parent.textArea.style.backgroundColor.split("(")[1].split(",")[0]), parseFloat(parent.textArea.style.backgroundColor.split("(")[1].split(",")[1]), parseFloat(parent.textArea.style.backgroundColor.split("(")[1].split(",")[2]), parseFloat(parent.textArea.style.backgroundColor.split("(")[1].split(",")[3])) : parent.textArea.style.backgroundColor;
      parent.activeObj.strokeSettings.outlineColor = parent.textArea.style.textShadow !== "" && parent.textArea.style.textShadow.split("(")[1] && parent.textArea.style.textShadow.split("(")[1].split(",")[0] && parent.textArea.style.textShadow.split("(")[1].split(",")[1] && parent.textArea.style.textShadow.split("(")[1].split(",")[2] && parent.textArea.style.textShadow.split("(")[1].split(",")[3] ? this.rgbToHex(parseFloat(parent.textArea.style.textShadow.split("(")[1].split(",")[0]), parseFloat(parent.textArea.style.textShadow.split("(")[1].split(",")[1]), parseFloat(parent.textArea.style.textShadow.split("(")[1].split(",")[2]), parseFloat(parent.textArea.style.textShadow.split("(")[1].split(",")[3])) : parent.textArea.style.textShadow.match(/^(\s*[\w#]+)\s/) ? parent.textArea.style.textShadow.match(/^(\s*[\w#]+)\s/)[1].trim() : parent.textArea.style.textShadow;
      if (parent.textArea.style.fontWeight === "bold") {
        parent.activeObj.textSettings.bold = true;
      } else {
        parent.activeObj.textSettings.bold = false;
      }
      if (parent.textArea.style.fontStyle === "italic") {
        parent.activeObj.textSettings.italic = true;
      } else {
        parent.activeObj.textSettings.italic = false;
      }
      parent.activeObj.textSettings.fontSize = parseFloat(parent.textArea.style.fontSize);
    };
    Selection2.prototype.rgbToHex = function(r, g, b, a) {
      r = Math.max(0, Math.min(255, Math.round(r)));
      g = Math.max(0, Math.min(255, Math.round(g)));
      b = Math.max(0, Math.min(255, Math.round(b)));
      a = Math.max(0, Math.min(1, a));
      var hexR = this.padLeft(r.toString(16), 2, "0");
      var hexG = this.padLeft(g.toString(16), 2, "0");
      var hexB = this.padLeft(b.toString(16), 2, "0");
      var hexA = this.padLeft(Math.round(a * 255).toString(16), 2, "0");
      var hex;
      if (isNaN(Number(hexA))) {
        hex = "#" + hexR + hexG + hexB;
      } else {
        hex = "#" + hexR + hexG + hexB + hexA;
      }
      return hex;
    };
    Selection2.prototype.padLeft = function(value, length, padChar) {
      while (value.length < length) {
        value = padChar + value;
      }
      return value;
    };
    Selection2.prototype.deleteItem = function() {
      var parent = this.parent;
      var shapeChangingArgs = { cancel: false };
      var previousShapeSettings = {};
      if (this.isFhdEditing) {
        this.updateFreehandDrawColorChange();
        var prevCropObj = extend({}, parent.cropObj, {}, true);
        var object = { currObj: {} };
        parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
        var prevObj = object["currObj"];
        prevObj.objColl = extend([], parent.objColl, [], true);
        prevObj.pointColl = extend([], parent.pointColl, [], true);
        prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        parent.notify("freehand-draw", {
          prop: "getSelPointColl",
          onPropertyChange: false,
          value: { obj: selPointCollObj }
        });
        prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
        var obj = { freehandDrawSelectedId: null };
        parent.notify("freehand-draw", { prop: "getFreehandDrawSelectedId", onPropertyChange: false, value: { obj } });
        parent.notify("freehand-draw", { prop: "deleteFhd", value: { id: obj["freehandDrawSelectedId"] } });
        parent.notify("undo-redo", {
          prop: "updateUndoRedoColl",
          onPropertyChange: false,
          value: {
            operation: "deleteFreehandDrawing",
            previousObj: prevObj,
            previousObjColl: this.tempObjColl,
            previousPointColl: prevObj.pointColl,
            previousSelPointColl: prevObj.selPointColl,
            previousCropObj: prevCropObj,
            previousText: null,
            currentText: null,
            previousFilter: null,
            isCircleCrop: null
          }
        });
        parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
        parent.notify("freehand-draw", { prop: "resetFreehandDrawSelectedId" });
      } else if (parent.textArea.style.display === "none") {
        var obj = { prevActObj: null };
        parent.notify("draw", { prop: "getPrevActObj", onPropertyChange: false, value: { obj } });
        if (obj["prevActObj"]) {
          obj["prevActObj"]["activePoint"]["width"] = Math.abs(obj["prevActObj"]["activePoint"]["width"]);
          obj["prevActObj"]["activePoint"]["height"] = Math.abs(obj["prevActObj"]["activePoint"]["height"]);
        }
        if (obj["prevActObj"] && JSON.stringify(obj["prevActObj"]) !== JSON.stringify(parent.activeObj)) {
          var index = parent.activeObj.currIndex;
          parent.notify("draw", { prop: "performCancel", value: { isContextualToolbar: null, isFinalCancel: true } });
          for (var i = 0, len = parent.objColl.length; i < len; i++) {
            if (parent.objColl[i].currIndex === index) {
              parent.objColl.splice(i, 1);
              parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null } });
              break;
            }
          }
        }
        var object = { isNewPath: null };
        parent.notify("draw", { prop: "getNewPath", value: { obj: object } });
        if (object["isNewPath"]) {
          parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
          this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
          parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null } });
          parent.notify("toolbar", { prop: "refresh-main-toolbar", onPropertyChange: false });
        } else if (parent.activeObj.shape) {
          parent.objColl.push(parent.activeObj);
          var prevCropObj = extend({}, parent.cropObj, {}, true);
          var object_2 = { currObj: {} };
          parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object: object_2 } });
          var prevObj = object_2["currObj"];
          prevObj.objColl = extend([], parent.objColl, [], true);
          prevObj.pointColl = extend([], parent.pointColl, [], true);
          prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
          var selPointCollObj = { selPointColl: null };
          parent.notify("freehand-draw", {
            prop: "getSelPointColl",
            onPropertyChange: false,
            value: { obj: selPointCollObj }
          });
          prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
          parent.objColl.pop();
          previousShapeSettings = this.updatePrevShapeSettings();
          shapeChangingArgs = { cancel: false, action: "delete", previousShapeSettings, currentShapeSettings: null };
          parent.notify("shape", { prop: "setKeyHistory", onPropertyChange: false, value: { keyHistory: "" } });
          parent.clearSelection();
          parent.trigger("shapeChanging", shapeChangingArgs);
          parent.editCompleteArgs = shapeChangingArgs;
          parent.notify("toolbar", { prop: "refresh-main-toolbar", onPropertyChange: false });
          parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null } });
          if (!isNullOrUndefined(prevObj.objColl[prevObj.objColl.length - 1].currIndex)) {
            parent.notify("undo-redo", {
              prop: "updateUndoRedoColl",
              onPropertyChange: false,
              value: {
                operation: "deleteObj",
                previousObj: prevObj,
                previousObjColl: this.tempObjColl,
                previousPointColl: prevObj.pointColl,
                previousSelPointColl: prevObj.selPointColl,
                previousCropObj: prevCropObj,
                previousText: null,
                currentText: null,
                previousFilter: null,
                isCircleCrop: null
              }
            });
            parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
          }
        }
        parent.notify("draw", { prop: "setPrevActObj", onPropertyChange: false, value: { prevActObj: null } });
        if (parent.drawingShape) {
          this.currentDrawingShape = parent.drawingShape.toLowerCase();
          parent.enableShapeDrawing(parent.toPascalCase(parent.drawingShape), true);
          parent.upperCanvas.style.cursor = "crosshair";
        }
      }
      if ((undefined).getElementById(parent.element.id + "_quickAccessToolbarArea")) {
        (undefined).getElementById(parent.element.id + "_quickAccessToolbarArea").style.display = "none";
      }
    };
    Selection2.prototype.updateFreehandDrawColorChange = function() {
      var parent = this.parent;
      var indexObj = { freehandSelectedIndex: null };
      parent.notify("freehand-draw", { prop: "getFreehandSelectedIndex", onPropertyChange: false, value: { obj: indexObj } });
      if (!isNullOrUndefined(indexObj["freehandSelectedIndex"]) && !isNullOrUndefined(parent.pointColl[indexObj["freehandSelectedIndex"]]) && parent.pointColl[indexObj["freehandSelectedIndex"]].strokeColor === "#42a5f5") {
        var obj = { tempFreeHandDrawEditingStyles: null };
        parent.notify("freehand-draw", { prop: "getTempFreeHandDrawEditingStyles", value: { obj } });
        parent.pointColl[indexObj["freehandSelectedIndex"]].strokeColor = obj["tempFreeHandDrawEditingStyles"].strokeColor;
      }
    };
    Selection2.prototype.updatePrevShapeSettings = function(obj) {
      var parent = this.parent;
      var fontStyle = [];
      if (isNullOrUndefined(parent.activeObj.currIndex)) {
        var shapeIDObj = { id: "shape_" + (parent.objColl.length + 1) };
        parent.notify("shape", { prop: "getNewShapeId", onPropertyChange: false, value: { obj: shapeIDObj } });
        parent.activeObj.currIndex = shapeIDObj["id"];
      }
      if (parent.activeObj.shape === "text" && parent.activeObj.textSettings) {
        if (parent.activeObj.textSettings.bold) {
          fontStyle.push("bold");
        }
        if (parent.activeObj.textSettings.italic) {
          fontStyle.push("italic");
        }
        if (parent.activeObj.textSettings.underline) {
          fontStyle.push("underline");
        }
      }
      var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY, width = _a.width, height = _a.height;
      var _b = parent.activeObj, keyHistory = _b.keyHistory, currIndex = _b.currIndex, shape = _b.shape, textSettings = _b.textSettings, strokeSettings = _b.strokeSettings, rotatedAngle = _b.rotatedAngle, imageElement = _b.imageElement, opacity = _b.opacity;
      var shapeSettingsObj = {
        id: !isNullOrUndefined(currIndex) ? currIndex : null,
        type: parent.toPascalCase(shape),
        startX,
        startY,
        width,
        height,
        strokeColor: strokeSettings ? shape === "text" ? strokeSettings.outlineColor : strokeSettings.strokeColor : null,
        strokeWidth: strokeSettings ? shape === "text" ? strokeSettings.outlineWidth : strokeSettings.strokeWidth : null,
        fillColor: strokeSettings ? strokeSettings.fillColor : null,
        radius: shape === "ellipse" ? width / 2 : null,
        length: shape === "line" || shape === "arrow" ? width : null,
        text: shape === "text" ? keyHistory ? keyHistory : textSettings.text ? textSettings.text : null : null,
        fontSize: shape === "text" ? textSettings ? textSettings.fontSize : null : null,
        fontFamily: shape === "text" ? textSettings ? textSettings.fontFamily : null : null,
        fontStyle: shape === "text" ? fontStyle : null,
        color: shape === "text" ? strokeSettings ? strokeSettings.strokeColor : null : null,
        degree: shape === "ellipse" || shape === "rectangle" || shape === "image" || shape === "text" ? rotatedAngle * (180 / Math.PI) : null,
        imageData: shape === "image" ? imageElement.src : null,
        opacity: shape === "image" ? opacity : null,
        radiusX: shape === "ellipse" ? width / 2 : null,
        radiusY: shape === "ellipse" ? height / 2 : null,
        endX: shape === "line" || shape === "arrow" ? endX : null,
        endY: shape === "line" || shape === "arrow" ? endY : null,
        arrowHead: shape === "arrow" ? this.getArrowType(parent.activeObj.start) : null,
        arrowTail: shape === "arrow" ? this.getArrowType(parent.activeObj.end) : null,
        points: shape === "path" ? parent.activeObj.pointColl : null,
        index: parent.activeObj.order,
        transformCollection: shape === "text" ? this.updateTransColl(parent.activeObj) : null
      };
      if (obj) {
        obj["shapeSettingsObj"] = shapeSettingsObj;
      }
      return shapeSettingsObj;
    };
    Selection2.prototype.updateTransColl = function(object) {
      var parent = this.parent;
      var coll;
      var tempColl = object.rotateFlipColl;
      if (tempColl && tempColl.length > 0) {
        var value = undefined;
        coll = [];
        for (var i = 0; i < tempColl.length; i++) {
          value = tempColl[i];
          if (typeof value === "number") {
            coll.push({ degree: value });
          } else {
            coll.push({ flip: parent.toPascalCase(value) });
          }
        }
      }
      return coll;
    };
    Selection2.prototype.getArrowType = function(type) {
      var typeToArrowType = {
        "none": "None",
        "arrow": "Arrow",
        "arrowSolid": "SolidArrow",
        "circle": "Circle",
        "circleSolid": "SolidCircle",
        "square": "Square",
        "squareSolid": "SolidSquare",
        "bar": "Bar"
      };
      return typeToArrowType["" + type];
    };
    Selection2.prototype.getRectanglePoints = function(rectX, rectY, rectWidth, rectHeight, rectAngle, pointX, pointY) {
      var centerX = rectX + rectWidth / 2;
      var centerY = rectY + rectHeight / 2;
      var angleRad = rectAngle * (Math.PI / 180);
      var cosAngle = Math.cos(angleRad);
      var sinAngle = Math.sin(angleRad);
      var localX = pointX - centerX;
      var localY = pointY - centerY;
      var rotatedX = localX * cosAngle + localY * sinAngle;
      var rotatedY = -localX * sinAngle + localY * cosAngle;
      var halfWidth = rectWidth / 2;
      var halfHeight = rectHeight / 2;
      if (rotatedX >= -halfWidth && rotatedX <= halfWidth && rotatedY >= -halfHeight && rotatedY <= halfHeight) {
        return true;
      } else {
        return false;
      }
    };
    Selection2.prototype.getTransRotationPoint = function(obj, object) {
      var rotationCirclePoint;
      var degree;
      var isHorizontalflip = false;
      var isVerticalflip = false;
      degree = obj.shapeDegree === 0 ? this.parent.transform.degree : this.parent.transform.degree - obj.shapeDegree;
      if (degree < 0) {
        degree = 360 + degree;
      }
      if (obj.flipObjColl) {
        for (var i = 0, iLen = obj.flipObjColl.length; i < iLen; i++) {
          if (obj.flipObjColl[i].toLowerCase() === "horizontal") {
            isHorizontalflip = true;
          } else if (obj.flipObjColl[i].toLowerCase() === "vertical") {
            isVerticalflip = true;
          }
        }
      }
      if (degree === 0 || degree === 360) {
        if (isVerticalflip) {
          rotationCirclePoint = { x: obj.topCenterCircle.startX, y: obj.topCenterCircle.startY - obj.rotationCircleLine };
        } else {
          rotationCirclePoint = { x: obj.bottomCenterCircle.startX, y: obj.bottomCenterCircle.startY + obj.rotationCircleLine };
        }
      } else if (degree === 90 || degree === -270) {
        if (isHorizontalflip) {
          rotationCirclePoint = { x: obj.centerRightCircle.startX + obj.rotationCircleLine, y: obj.centerLeftCircle.startY };
        } else {
          rotationCirclePoint = { x: obj.centerLeftCircle.startX - obj.rotationCircleLine, y: obj.centerLeftCircle.startY };
        }
      } else if (degree === 180 || degree === -180) {
        if (isVerticalflip) {
          rotationCirclePoint = { x: obj.bottomCenterCircle.startX, y: obj.bottomCenterCircle.startY + obj.rotationCircleLine };
        } else {
          rotationCirclePoint = { x: obj.topCenterCircle.startX, y: obj.topCenterCircle.startY - obj.rotationCircleLine };
        }
      } else if (degree === 270 || degree === -90) {
        if (isHorizontalflip) {
          rotationCirclePoint = { x: obj.centerLeftCircle.startX - obj.rotationCircleLine, y: obj.centerLeftCircle.startY };
        } else {
          rotationCirclePoint = { x: obj.centerRightCircle.startX + obj.rotationCircleLine, y: obj.centerLeftCircle.startY };
        }
      }
      if (object) {
        object["rotationCirclePoint"] = rotationCirclePoint;
      }
      return rotationCirclePoint;
    };
    Selection2.prototype.getNumTextValue = function(obj) {
      var parent = this.parent;
      var elem = parent.element;
      var height;
      var width;
      var widthElement;
      var heightElement;
      widthElement = elem.querySelector("#" + elem.id + "_resizeWidth");
      heightElement = elem.querySelector("#" + elem.id + "_resizeHeight");
      if (widthElement && heightElement) {
        var heightString = heightElement.value.replace(/,/g, "");
        var widthString = widthElement.value.replace(/,/g, "");
        if (heightString === "") {
          heightString = heightElement.placeholder.replace(/,/g, "");
        }
        if (widthString === "") {
          widthString = widthElement.placeholder.replace(/,/g, "");
        }
        height = parseFloat(heightString);
        width = parseFloat(widthString);
      }
      if (obj) {
        obj["width"] = width;
        obj["height"] = height;
      }
      return { x: width, y: height };
    };
    Selection2.prototype.isValueUpdated = function() {
      var isValue = true;
      var widthElement;
      var heightElement;
      widthElement = this.parent.element.querySelector("#" + this.parent.element.id + "_resizeWidth");
      heightElement = this.parent.element.querySelector("#" + this.parent.element.id + "_resizeHeight");
      if (widthElement && heightElement) {
        if (heightElement.value.replace(/,/g, "") === "" && widthElement.value.replace(/,/g, "") === "") {
          isValue = false;
        }
      }
      return isValue;
    };
    Selection2.prototype.allowOutofBound = function() {
      var shapes = ["ellipse", "rectangle", "text", "image", "redact"];
      var allowOutofBound = shapes.indexOf(this.parent.activeObj.shape) !== -1 && this.parent.activeObj.rotatedAngle === 0 ? false : true;
      return allowOutofBound;
    };
    return Selection2;
  }()
);
var Shape = (
  /** @class */
  function() {
    function Shape2(parent) {
      this.textSettings = { text: "Enter Text", fontFamily: "", fontSize: null, fontRatio: null, bold: false, italic: false, underline: false };
      this.strokeSettings = { strokeColor: "#fff", fillColor: "", strokeWidth: null, radius: null, outlineColor: "", outlineWidth: null };
      this.keyHistory = "";
      this.preventFrameAnnotation = false;
      this.redactType = "blur";
      this.parent = parent;
      this.addEventListener();
    }
    Shape2.prototype.destroy = function() {
      if (this.parent.isDestroyed) {
        return;
      }
      this.removeEventListener();
    };
    Shape2.prototype.addEventListener = function() {
      this.parent.on("shape", this.shape, this);
      this.parent.on("destroyed", this.destroy, this);
    };
    Shape2.prototype.removeEventListener = function() {
      this.parent.off("shape", this.shape);
      this.parent.off("destroyed", this.destroy);
    };
    Shape2.prototype.shape = function(args) {
      var parent = this.parent;
      this.initShapePvtProps();
      var uploader;
      switch (args.prop) {
        case "drawEllipse":
          this.drawEllipse(args.value["x"], args.value["y"], args.value["radiusX"], args.value["radiusY"], args.value["strokeWidth"], args.value["strokeColor"], args.value["fillColor"], args.value["degree"], args.value["isSelected"]);
          break;
        case "drawLine":
          this.drawLine(args.value["startX"], args.value["startY"], args.value["endX"], args.value["endY"], args.value["strokeWidth"], args.value["strokeColor"], args.value["isSelected"]);
          break;
        case "drawArrow":
          this.drawArrow(args.value["startX"], args.value["startY"], args.value["endX"], args.value["endY"], args.value["strokeWidth"], args.value["strokeColor"], args.value["arrowStart"], args.value["arrowEnd"], args.value["isSelected"]);
          break;
        case "drawPath":
          this.drawPath(args.value["pointColl"], args.value["strokeWidth"], args.value["strokeColor"], args.value["isSelected"]);
          break;
        case "drawRectangle":
          this.drawRectangle(args.value["x"], args.value["y"], args.value["width"], args.value["height"], args.value["strokeWidth"], args.value["strokeColor"], args.value["fillColor"], args.value["degree"], args.value["isSelected"], args.value["radius"]);
          break;
        case "drawText":
          this.drawText(args.value["x"], args.value["y"], args.value["text"], args.value["fontFamily"], args.value["fontSize"], args.value["bold"], args.value["italic"], args.value["color"], args.value["isSelected"], args.value["degree"], args.value["fillColor"], args.value["outlineColor"], args.value["outlineWidth"], args.value["transformCollection"]);
          break;
        case "redrawActObj":
          this.redrawActObj(args.value["x"], args.value["y"], args.value["isMouseDown"]);
          break;
        case "apply":
          this.apply(args.value["shape"], args.value["obj"], args.value["canvas"]);
          break;
        case "updateShapeChangeEventArgs":
          this.updateShapeChangeEventArgs(args.value["shapeSettings"], args.value["allowShapeOverflow"]);
          break;
        case "updSelChangeEventArgs":
          this.updSelChangeEventArgs(args.value["selectionSettings"]);
          break;
        case "iterateObjColl":
          this.iterateObjColl();
          break;
        case "updImgRatioForActObj":
          this.updImgRatioForActObj();
          break;
        case "redrawObj":
          this.redrawObj(args.value["degree"]);
          break;
        case "redraw-text":
          this.redrawText();
          break;
        case "draw-shape":
          this.drawShape(args.value["obj"], args.value["strokeWidth"], args.value["strokeColor"], args.value["fillColor"], args.value["start"], args.value["width"], args.value["height"]);
          break;
        case "renderTextArea":
          this.renderTextArea(args.value["x"], args.value["y"], args.value["actObj"]);
          break;
        case "setTextBoxWidth":
          this.setTextBoxWidth(args.value["e"]);
          break;
        case "findTextTarget":
          this.findTextTarget(args.value["e"]);
          break;
        case "updateFontStyles":
          this.updateFontStyles(args.value["isTextBox"]);
          break;
        case "applyFontStyle":
          this.applyFontStyle(args.value["item"]);
          break;
        case "updateFontRatio":
          this.updateFontRatio(args.value["obj"], args.value["isTextArea"]);
          break;
        case "updateFontSize":
          this.updateFontSize(args.value["obj"]);
          break;
        case "pushActItemIntoObj":
          this.pushActItemIntoObj();
          break;
        case "clearActObj":
          this.clearActObj();
          break;
        case "refreshActiveObj":
          this.refreshActiveObj();
          break;
        case "applyActObj":
          this.applyActObj(args.value["isMouseDown"]);
          break;
        case "wireEvent":
          EventHandler.add(parent.upperCanvas, "dblclick", this.findTextTarget, this);
          EventHandler.add(parent.textArea, "mousedown", this.findTextTarget, this);
          uploader = (undefined).getElementById(parent.element.id + "_fileUpload");
          if (uploader) {
            EventHandler.add(uploader, "change", this.fileChanged, this);
          }
          break;
        case "unWireEvent":
          EventHandler.remove(parent.upperCanvas, "dblclick", this.findTextTarget);
          EventHandler.remove(parent.textArea, "mousedown", this.findTextTarget);
          uploader = (undefined).getElementById(parent.element.id + "_fileUpload");
          if (uploader) {
            EventHandler.remove(uploader, "change", this.fileChanged);
          }
          break;
        case "getShapeSetting":
          this.getShapeSetting(args.value["id"], args.value["obj"]);
          break;
        case "getShapeSettings":
          this.getShapeSettings(args.value["obj"]);
          break;
        case "getRedactSettings":
          this.getRedactSettings(args.value["obj"]);
          break;
        case "isPointsInRange":
          this.isPointsInRange(args.value["x"], args.value["y"], args.value["obj"]);
          break;
        case "alignRotateFlipColl":
          this.alignRotateFlipColl(args.value["collection"], args.value["isRotateFlipCollection"], args.value["obj"]);
          break;
        case "selectShape":
          this.selectShape(args.value["id"], args.value["obj"]);
          break;
        case "deleteShape":
          this.deleteShape(args.value["id"]);
          break;
        case "getMaxText":
          this.getMaxText(args.value["isTextBox"], args.value["text"], args.value["obj"]);
          break;
        case "setPointCollForLineArrow":
          args.value["obj"].pointColl = this.getLinePoints(args.value["obj"].activePoint.startX, args.value["obj"].activePoint.startY, args.value["obj"].activePoint.endX, args.value["obj"].activePoint.endY);
          break;
        case "setPointCollForShapeRotation":
          this.setPointCollForShapeRotation(args.value["obj"]);
          break;
        case "setTextSettings":
          if (args.value["textSettings"]) {
            this.textSettings = args.value["textSettings"];
          } else if (args.value["fontFamily"]) {
            this.textSettings.fontFamily = args.value["fontFamily"];
          } else if (args.value["fontSize"]) {
            this.textSettings.fontSize = args.value["fontSize"];
          } else if (args.value["radius"]) {
            this.strokeSettings.radius = args.value["radius"];
          }
          break;
        case "setStrokeSettings":
          if (args.value["strokeSettings"]) {
            this.strokeSettings = args.value["strokeSettings"];
          } else if (args.value["strokeColor"]) {
            this.strokeSettings.strokeColor = args.value["strokeColor"];
          } else if (args.value["fillColor"]) {
            this.strokeSettings.fillColor = args.value["fillColor"];
          } else if (args.value["strokeWidth"]) {
            this.strokeSettings.strokeWidth = args.value["strokeWidth"];
          } else if (args.value["outlineColor"]) {
            this.strokeSettings.outlineColor = args.value["outlineColor"];
          } else if (args.value["radius"]) {
            this.strokeSettings.radius = args.value["radius"];
          } else if (args.value["outlineWidth"]) {
            this.strokeSettings.outlineWidth = args.value["outlineWidth"];
          }
          break;
        case "getStrokeSettings":
          args.value["obj"]["strokeSettings"] = this.strokeSettings;
          break;
        case "setKeyHistory":
          this.keyHistory = args.value["keyHistory"];
          break;
        case "getKeyHistory":
          args.value["obj"]["keyHistory"] = this.keyHistory;
          break;
        case "setTextBoxPos":
          this.setTextBoxPos(args.value["actObj"], args.value["degree"], args.value["flip"], args.value["x"], args.value["y"]);
          break;
        case "setTextBoxPoints":
          this.setTextBoxPoints(args.value["actObj"], args.value["degree"], args.value["flip"], args.value["x"], args.value["y"]);
          break;
        case "alignTextAreaIntoCanvas":
          this.alignTextAreaIntoCanvas();
          break;
        case "initializeTextShape":
          this.initializeTextShape(args.value["text"], args.value["fontFamily"], args.value["fontSize"], args.value["bold"], args.value["italic"], args.value["strokeColor"], args.value["fillColor"], args.value["outlineColor"], args.value["outlineWidth"]);
          break;
        case "stopPathDrawing":
          this.stopPathDrawing(args.value["e"], args.value["isApply"]);
          break;
        case "updateArrowRatio":
          this.updateArrowRatio(args.value["obj"]);
          break;
        case "getSquarePointForRotatedShape":
          this.getSquarePointForRotatedShape(args.value["obj"], args.value["object"]);
          break;
        case "drawImage":
          this.drawImage(args.value["x"], args.value["y"], args.value["width"], args.value["height"], args.value["src"], args.value["degree"], args.value["isAspectRatio"], args.value["opacity"], args.value["isSelected"]);
          break;
        case "reset":
          this.reset();
          break;
        case "updateObj":
          this.updateObj(args.value["dimObj"], args.value["x"], args.value["y"]);
          break;
        case "straightenShapes":
          this.straightenShapes();
          break;
        case "straightenShapePoints":
          this.straightenShapePoints(args.value["obj"], args.value["isReverse"]);
          break;
        case "straightenPath":
          this.straightenPath(args.value["obj"]);
          break;
        case "straightenFHD":
          this.straightenFHD();
          break;
        case "getTextBoxPosition":
          this.getTextBoxPosition(args.value["obj"], args.value["object"]);
          break;
        case "setFlipState":
          this.setFlipState(args.value["x"], args.value["y"], args.value["obj"], args.value["object"]);
          break;
        case "getNewShapeId":
          args.value["obj"]["id"] = this.getNewShapeId();
          break;
        case "z-order":
          this.updateZOrder(args.value["obj"], args.value["value"]);
          break;
        case "getSmallestIndex":
          args.value["obj"]["index"] = this.getSmallestIndex();
          break;
        case "isIndexInObjColl":
          args.value["obj"]["bool"] = this.isIndexInObjColl(args.value["index"]);
          break;
        case "drawAnnotations":
          this.drawAnnotations(args.value["ctx"], args.value["shape"], args.value["pen"], args.value["isPreventApply"], args.value["x"], args.value["y"], args.value["panRegion"]);
          break;
        case "updateShapeColl":
          this.updateShapeColl();
          break;
        case "getNewOrder":
          args.value["obj"]["order"] = this.getNewOrder();
          break;
        case "getHighestOrder":
          args.value["obj"]["order"] = this.getHighestOrder();
          break;
        case "getLowestOrder":
          args.value["obj"]["order"] = this.getLowestOrder();
          break;
        case "drawRedact":
          this.drawRedact(args.value["x"], args.value["y"], args.value["width"], args.value["height"], args.value["type"], args.value["value"]);
          break;
        case "setRedactType":
          this.redactType = args.value["redactType"];
          break;
      }
    };
    Shape2.prototype.getModuleName = function() {
      return "shape";
    };
    Shape2.prototype.initShapePvtProps = function() {
      var parent = this.parent;
      if (parent.lowerCanvas) {
        this.lowerContext = parent.lowerCanvas.getContext("2d");
      }
      if (parent.upperCanvas) {
        this.upperContext = parent.upperCanvas.getContext("2d");
      }
      if (isNullOrUndefined(this.shapeImg)) {
        this.shapeImg = parent.createElement("img", {
          id: parent.element.id + "_shapeImg",
          attrs: { name: "Image", crossorigin: "anonymous" }
        });
      }
      if (this.textSettings.fontFamily === "") {
        this.textSettings.fontFamily = parent.fontFamily.default;
      }
    };
    Shape2.prototype.reset = function() {
      this.textSettings = { text: "Enter Text", fontFamily: this.parent.fontFamily.default, fontSize: null, fontRatio: null, bold: false, italic: false, underline: false };
      this.strokeSettings = { strokeColor: "#fff", fillColor: "", strokeWidth: null, radius: null, outlineColor: "", outlineWidth: null };
      this.preventFrameAnnotation = false;
    };
    Shape2.prototype.drawEllipse = function(x, y, radiusX, radiusY, strokeWidth, strokeColor, fillColor, degree, isSelected) {
      this.initializeShape("ellipse");
      var start = x && y ? { x, y } : null;
      this.drawShape("ellipse", strokeWidth, strokeColor, fillColor, start, radiusX, radiusY, null, null, null, degree, null, isSelected);
    };
    Shape2.prototype.drawLine = function(startX, startY, endX, endY, strokeWidth, strokeColor, isSelected) {
      this.initializeShape("line");
      var start = startX && startY ? { x: startX, y: startY } : null;
      var width = endX - startX;
      var height = endY - startY;
      this.drawShape("line", strokeWidth, strokeColor, null, start, width, height, null, null, null, null, null, isSelected);
    };
    Shape2.prototype.drawPath = function(pointColl, strokeWidth, strokeColor, isSelected) {
      this.initializeShape("path");
      if (pointColl) {
        this.drawShape("path", strokeWidth, strokeColor, null, null, null, null, pointColl, null, null, null, null, isSelected);
      }
    };
    Shape2.prototype.drawArrow = function(startX, startY, endX, endY, strokeWidth, strokeColor, arrowStart, arrowEnd, isSelected) {
      this.initializeShape("arrow");
      var start = startX && startY ? { x: startX, y: startY } : null;
      var width = endX - startX;
      var height = endY - startY;
      this.drawShape("arrow", strokeWidth, strokeColor, null, start, width, height, null, arrowStart, arrowEnd, null, null, isSelected);
    };
    Shape2.prototype.drawRectangle = function(x, y, width, height, strokeWidth, strokeColor, fillColor, degree, isSelected, radius) {
      this.initializeShape("rectangle");
      var start = x && y ? { x, y } : null;
      this.drawShape("rectangle", strokeWidth, strokeColor, fillColor, start, width, height, null, null, null, degree, null, isSelected, radius);
    };
    Shape2.prototype.drawRedact = function(x, y, width, height, type, value) {
      this.initializeShape("redact");
      var start = x && y ? { x, y } : null;
      this.drawShape("redact", null, null, null, start, width, height, null, null, null, null, null, null, null, type, value);
    };
    Shape2.prototype.drawText = function(x, y, text, fontFamily, fontSize, bold, italic, color, isSelected, degree, fillColor, outlineColor, outlineWidth, transformCollection) {
      this.drawShapeText(text, fontFamily, fontSize, bold, italic, color, x, y, isSelected, degree, fillColor, outlineColor, outlineWidth, transformCollection);
    };
    Shape2.prototype.initializeShape = function(type) {
      var parent = this.parent;
      this.redrawActObj();
      parent.activeObj.shape = type;
      parent.currObjType.isCustomCrop = false;
    };
    Shape2.prototype.updateWidthHeight = function(obj) {
      obj.activePoint.width = obj.activePoint.endX - obj.activePoint.startX;
      obj.activePoint.height = obj.activePoint.endY - obj.activePoint.startY;
      return obj;
    };
    Shape2.prototype.setDimension = function(width, height) {
      var parent = this.parent;
      var shape = parent.activeObj.shape;
      if (width && height || (shape === "line" || shape === "arrow") && (width || height)) {
        parent.activeObj.activePoint.width = width;
        parent.activeObj.activePoint.height = height;
        if (parent.currObjType.shape.toLowerCase() === "ellipse") {
          parent.activeObj.activePoint.width = 2 * width;
          parent.activeObj.activePoint.height = 2 * height;
        }
      }
    };
    Shape2.prototype.getArrowType = function(type) {
      var arrowType = type;
      if (type) {
        var typeToArrowType = {
          "None": "none",
          "Arrow": "arrow",
          "SolidArrow": "arrowSolid",
          "Circle": "circle",
          "SolidCircle": "circleSolid",
          "Square": "square",
          "SolidSquare": "squareSolid",
          "Bar": "bar"
        };
        arrowType = typeToArrowType["" + type];
      }
      return arrowType;
    };
    Shape2.prototype.drawShape = function(type, strokeWidth, strokeColor, fillColor, start, width, height, pointColl, arrowStart, arrowEnd, degree, opacity, isSelected, radius, redactType, value) {
      var parent = this.parent;
      if (!parent.disabled && parent.isImageLoaded) {
        parent.notify("draw", { prop: "setImageEdited", onPropertyChange: false });
        this.redrawActObj();
        var objColl = extend([], parent.objColl, [], true);
        parent.togglePen = false;
        this.keyHistory = "";
        parent.upperCanvas.style.display = "block";
        this.refreshActiveObj();
        parent.currObjType.shape = type = type.toLowerCase();
        if (type !== "freehanddraw" && type !== "") {
          parent.activeObj.shape = type;
          var strokeSettings = parent.activeObj.strokeSettings;
          this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
          if (isNullOrUndefined(strokeSettings)) {
            strokeSettings = this.strokeSettings;
          }
          if (type === "path" && pointColl) {
            parent.activeObj.pointColl = pointColl;
          }
          if (opacity !== null && opacity !== undefined) {
            parent.activeObj.opacity = opacity;
          }
          strokeSettings.strokeWidth = strokeWidth ? strokeWidth : strokeSettings.strokeWidth;
          var shape = parent.activeObj.shape;
          if ((shape === "rectangle" || shape === "ellipse") && strokeWidth === 0) {
            strokeSettings.strokeWidth = 0;
          }
          strokeSettings.strokeColor = strokeColor ? strokeColor : strokeSettings.strokeColor;
          strokeSettings.fillColor = fillColor || fillColor === "" ? fillColor : strokeSettings.fillColor;
          strokeSettings.radius = radius ? radius : strokeSettings.radius;
          var tempWidth = parent.img.destWidth > 100 ? 100 : parent.img.destWidth / 2;
          var tempHeight = parent.img.destHeight > 100 ? 100 : parent.img.destHeight / 2;
          parent.activeObj.activePoint.width = tempWidth;
          parent.activeObj.activePoint.height = tempHeight;
          if (type === "line" || type === "arrow") {
            parent.activeObj.lineDraw = "horizontal";
            parent.activeObj.activePoint.height = 0;
            if (type === "arrow") {
              parent.activeObj.activePoint.width += 50;
              parent.activeObj.start = this.getArrowType(arrowStart);
              parent.activeObj.end = this.getArrowType(arrowEnd);
            }
          } else if (type === "rectangle") {
            parent.activeObj.activePoint.width += parent.activeObj.activePoint.width / 2;
          } else if (type === "redact") {
            if (redactType) {
              parent.activeObj.redactType = redactType.toLowerCase();
              if (redactType === RedactType.Blur) {
                if (value) {
                  parent.activeObj.redactBlur = value;
                }
              } else {
                if (value) {
                  parent.activeObj.redactPixelate = value;
                }
              }
              parent.activeObj.redactImage = parent.createElement("canvas");
            }
          }
          this.setDimension(width, height);
          if (start) {
            parent.activeObj.activePoint.startX = start.x;
            parent.activeObj.activePoint.startY = start.y;
            parent.activeObj.activePoint.endX = parent.activeObj.activePoint.startX + parent.activeObj.activePoint.width;
            parent.activeObj.activePoint.endY = parent.activeObj.activePoint.startY + parent.activeObj.activePoint.height;
          } else {
            this.setCenterPoints();
          }
          this.setPointCollForLineAndArrow();
          if (type === "arrow") {
            parent.activeObj.triangleDirection = "right";
          }
          parent.currObjType.isDragging = parent.currObjType.isCustomCrop = false;
          this.initShapeProps();
          var obj = { shapeSettingsObj: {} };
          parent.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj } });
          var shapeSettings = obj["shapeSettingsObj"];
          var shapeChangingArgs = {
            cancel: false,
            action: "insert",
            previousShapeSettings: shapeSettings,
            currentShapeSettings: shapeSettings
          };
          parent.trigger("shapeChanging", shapeChangingArgs);
          parent.editCompleteArgs = shapeChangingArgs;
          this.updateShapeChangeEventArgs(shapeChangingArgs.currentShapeSettings, shapeChangingArgs.allowShapeOverflow);
          this.setDimension(width, height);
          parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate" } });
          if (degree) {
            parent.activeObj.rotatedAngle = degree * (Math.PI / 180);
            parent.notify("selection", { prop: "updPtCollForShpRot", onPropertyChange: false, value: { obj: parent.activeObj } });
          }
          parent.notify("toolbar", { prop: "renderQAT", onPropertyChange: false, value: { isPenEdit: null } });
          parent.notify("selection", { prop: "isShapeInserted", onPropertyChange: false, value: { bool: true } });
          parent.notify("undo-redo", { prop: "updateUrObj", onPropertyChange: false, value: { objColl } });
          if (type === "redact") {
            parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
              type: "redact",
              isApplyBtn: null,
              isCropping: null,
              isZooming: null,
              cType: null
            } });
          } else {
            parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
              type: "shapes",
              isApplyBtn: null,
              isCropping: null,
              isZooming: null,
              cType: null
            } });
          }
          parent.notify("toolbar", { prop: "update-toolbar-items", onPropertyChange: false });
          if (parent.isPublicMethod && !isSelected) {
            parent.notify("undo-redo", { prop: "updateUndoRedo", value: { operation: "shapeInsert" }, onPropertyChange: false });
          }
          parent.isPublicMethod = false;
        }
      }
    };
    Shape2.prototype.initShapeProps = function() {
      var parent = this.parent;
      parent.activeObj.shapeDegree = parent.transform.degree;
      parent.activeObj.shapeFlip = parent.transform.currFlipState;
      parent.activeObj.textFlip = parent.transform.currFlipState;
      parent.activeObj.flipObjColl = [];
      parent.activeObj.order = this.getNewOrder();
    };
    Shape2.prototype.setPointCollForLineAndArrow = function() {
      var parent = this.parent;
      var shape = parent.activeObj.shape;
      var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
      if (shape === "line" || shape === "arrow") {
        parent.activeObj.pointColl = this.getLinePoints(startX, startY, endX, endY);
        if (parent.activeObj.pointColl) {
          for (var i = 0, len = parent.activeObj.pointColl.length; i < len; i++) {
            parent.activeObj.pointColl[i].ratioX = (parent.activeObj.pointColl[i].x - parent.img.destLeft) / parent.img.destWidth;
            parent.activeObj.pointColl[i].ratioY = (parent.activeObj.pointColl[i].y - parent.img.destTop) / parent.img.destHeight;
          }
        }
      }
    };
    Shape2.prototype.prevObjColl = function() {
      var parent = this.parent;
      var object = { currObj: {} };
      parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
      this.prevObj = object["currObj"];
      this.prevObj.objColl = extend([], parent.objColl, [], true);
      this.prevObj.pointColl = extend([], parent.pointColl, [], true);
      this.prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      parent.notify("freehand-draw", {
        prop: "getSelPointColl",
        onPropertyChange: false,
        value: { obj: selPointCollObj }
      });
      this.prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
    };
    Shape2.prototype.drawShapeText = function(text, fontFamily, fontSize, bold, italic, strokeColor, x, y, isSelected, degree, fillColor, outlineColor, outlineWidth, transformCollection) {
      var parent = this.parent;
      if (!parent.disabled && parent.isImageLoaded) {
        if (parent.currObjType.shape === "freehanddraw") {
          this.apply();
          parent.upperCanvas.style.cursor = parent.cursor = "default";
          parent.currObjType.shape = "";
        }
        parent.notify("draw", { prop: "setImageEdited", onPropertyChange: false });
        parent.togglePen = false;
        this.redrawActObj();
        this.prevObjColl();
        this.refreshActiveObj();
        parent.activeObj.shape = parent.currObjType.shape = "text";
        parent.currObjType.isCustomCrop = false;
        this.initializeTextShape(text, fontFamily, fontSize, bold, italic, strokeColor, fillColor, outlineColor, outlineWidth);
        parent.currObjType.isText = parent.currObjType.isInitialText = true;
        if (isNullOrUndefined(parent.activeObj.textSettings.fontSize)) {
          parent.getFontSizes();
          parent.activeObj.textSettings.fontSize = parseInt(parent.fontSizeColl[parseInt("3", 10) - 1].text, 10);
        }
        if (parent.img.destWidth < 100) {
          parent.activeObj.textSettings.fontSize = Math.floor(parent.img.destWidth / 20);
        } else if (parent.img.destHeight < 100) {
          parent.activeObj.textSettings.fontSize = Math.floor(parent.img.destHeight / 20);
        }
        parent.activeObj.shapeDegree = parent.transform.degree;
        parent.activeObj.shapeFlip = parent.transform.currFlipState;
        parent.activeObj.flipObjColl = [];
        this.updateFontStyles();
        parent.activeObj.order = this.getNewOrder();
        var width = this.upperContext.measureText(parent.activeObj.textSettings.text).width + parent.activeObj.textSettings.fontSize * 0.5;
        var height = parent.activeObj.textSettings.fontSize;
        if (text) {
          parent.activeObj.keyHistory = text;
          var maxText = this.getMaxText();
          maxText = maxText ? maxText : parent.activeObj.textSettings.text;
          width = this.upperContext.measureText(maxText).width + parent.activeObj.textSettings.fontSize * 0.5;
          var rows = text.split("\n");
          if (rows.length > 1) {
            height = rows.length * parent.activeObj.textSettings.fontSize;
            height += fontSize * 0.25;
          }
        }
        if (!isNullOrUndefined(x) && !isNullOrUndefined(y)) {
          parent.activeObj.activePoint.startX = x;
          parent.activeObj.activePoint.startY = y;
          parent.activeObj.activePoint.endX = parent.activeObj.activePoint.startX + width;
          parent.activeObj.activePoint.endY = parent.activeObj.activePoint.startY + height;
        } else {
          this.setCenterPoints(true, width, height);
        }
        if (transformCollection) {
          parent.notify("selection", { prop: "setTransformedShape", onPropertyChange: false, value: { bool: true } });
          this.setTransformColl(transformCollection);
          var actObj = parent.activeObj;
          actObj.shapeDegree = 0;
          actObj.shapeFlip = "";
          var tempDegree = 0;
          var coll = actObj.rotateFlipColl;
          for (var i = 0; i < coll.length; i++) {
            if (typeof coll[i] === "number") {
              tempDegree += coll[i];
            }
          }
          if (tempDegree % 90 === 0 && Math.abs(tempDegree) % 180 === 90) {
            actObj.activePoint.endX = actObj.activePoint.startX + height;
            actObj.activePoint.endY = actObj.activePoint.startY + width;
            actObj.activePoint.width = actObj.activePoint.endX - actObj.activePoint.startX;
            actObj.activePoint.height = actObj.activePoint.endY - actObj.activePoint.startY;
          }
        }
        var obj = { shapeSettingsObj: {} };
        parent.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj } });
        var shapeSettings = obj["shapeSettingsObj"];
        var shapeChangingArgs = {
          cancel: false,
          action: "insert",
          previousShapeSettings: shapeSettings,
          currentShapeSettings: shapeSettings
        };
        parent.trigger("shapeChanging", shapeChangingArgs);
        parent.editCompleteArgs = shapeChangingArgs;
        this.drawShapeTextEvent(shapeChangingArgs);
        if (degree) {
          parent.activeObj.rotatedAngle = degree * (Math.PI / 180);
          parent.notify("selection", { prop: "updPtCollForShpRot", onPropertyChange: false, value: { obj: parent.activeObj } });
          this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
          parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: {
            canvas: "duplicate",
            obj: parent.activeObj,
            isCropRatio: null,
            points: null,
            isPreventDrag: true,
            saveContext: null,
            isPreventSelection: null
          } });
          parent.notify("toolbar", { prop: "destroy-qa-toolbar", onPropertyChange: false });
          parent.notify("toolbar", { prop: "renderQAT", onPropertyChange: false, value: { isPenEdit: null } });
        }
        if (text && text.indexOf("\n") > -1 && parent.isPublicMethod) {
          var fontSizeInd = String(parent.fontSizeColl.findIndex(function(item) {
            return item.text === String(parent.activeObj.textSettings.fontSize);
          }) + 1);
          parent.noPushUndo = true;
          parent.updateFontSize("5");
          if (parseInt(fontSizeInd, 10) > 0) {
            parent.updateFontSize(fontSizeInd);
          }
          parent.noPushUndo = false;
        }
        if (parent.isPublicMethod && !isSelected) {
          parent.notify("undo-redo", { prop: "updateUndoRedo", value: { operation: "shapeInsert" }, onPropertyChange: false });
        }
        parent.isPublicMethod = false;
      }
    };
    Shape2.prototype.drawShapeImageEvent = function(shapeChangingArgs, isSelect) {
      var parent = this.parent;
      this.updateShapeChangeEventArgs(shapeChangingArgs.currentShapeSettings, shapeChangingArgs.allowShapeOverflow);
      parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate" } });
      parent.objColl.push(parent.activeObj);
      var prevCropObj = extend({}, parent.cropObj, {}, true);
      parent.notify("undo-redo", {
        prop: "updateUndoRedoColl",
        onPropertyChange: false,
        value: {
          operation: "shapeInsert",
          previousObj: this.prevObj,
          previousObjColl: this.prevObj.objColl,
          previousPointColl: this.prevObj.pointColl,
          previousSelPointColl: this.prevObj.selPointColl,
          previousCropObj: prevCropObj,
          previousText: null,
          currentText: null,
          previousFilter: null,
          isCircleCrop: null
        }
      });
      parent.notify("selection", {
        prop: "redrawShape",
        onPropertyChange: false,
        value: { obj: parent.objColl[parent.objColl.length - 1] }
      });
      if (isSelect) {
        parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
          type: "shapes",
          isApplyBtn: null,
          isCropping: null,
          isZooming: null,
          cType: null
        } });
        parent.notify("toolbar", { prop: "update-toolbar-items", onPropertyChange: false });
        parent.notify("toolbar", { prop: "renderQAT", onPropertyChange: false, value: { isPenEdit: null } });
      } else {
        parent.okBtn(null, true);
      }
      parent.notify("selection", { prop: "isShapeInserted", onPropertyChange: false, value: { bool: true } });
    };
    Shape2.prototype.setTransformColl = function(transformCollection) {
      var parent = this.parent;
      parent.activeObj.rotateFlipColl = [];
      if (transformCollection) {
        for (var i = 0; i < transformCollection.length; i++) {
          if (transformCollection[i].degree) {
            parent.activeObj.rotateFlipColl.push(transformCollection[i].degree);
          } else {
            parent.activeObj.rotateFlipColl.push(transformCollection[i].flip.toLowerCase());
          }
        }
      }
    };
    Shape2.prototype.drawShapeTextEvent = function(shapeChangingArgs) {
      var parent = this.parent;
      this.updateShapeChangeEventArgs(shapeChangingArgs.currentShapeSettings, shapeChangingArgs.allowShapeOverflow);
      this.addLetter(parent.activeObj.textSettings.text);
      parent.activeObj.textFlip = parent.transform.currFlipState;
      this.updateFontRatio(parent.activeObj);
      parent.objColl.push(parent.activeObj);
      var prevCropObj = extend({}, parent.cropObj, {}, true);
      parent.notify("undo-redo", {
        prop: "updateUndoRedoColl",
        onPropertyChange: false,
        value: {
          operation: "shapeInsert",
          previousObj: this.prevObj,
          previousObjColl: this.prevObj.objColl,
          previousPointColl: this.prevObj.pointColl,
          previousSelPointColl: this.prevObj.selPointColl,
          previousCropObj: prevCropObj,
          previousText: null,
          currentText: null,
          previousFilter: null,
          isCircleCrop: null
        }
      });
      parent.notify("selection", {
        prop: "redrawShape",
        onPropertyChange: false,
        value: { obj: parent.objColl[parent.objColl.length - 1] }
      });
      parent.notify("toolbar", { prop: "renderQAT", onPropertyChange: false, value: { isPenEdit: null } });
      parent.notify("selection", { prop: "isShapeInserted", onPropertyChange: false, value: { bool: true } });
      parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
        type: "text",
        isApplyBtn: null,
        isCropping: null,
        isZooming: null,
        cType: null
      } });
      parent.notify("toolbar", { prop: "update-toolbar-items", onPropertyChange: false });
    };
    Shape2.prototype.initializeTextShape = function(text, fontFamily, fontSize, bold, italic, strokeColor, fillColor, outlineColor, outlineWidth) {
      var parent = this.parent;
      this.keyHistory = "";
      parent.upperCanvas.style.display = "block";
      parent.activeObj.strokeSettings.strokeColor = strokeColor || parent.activeObj.strokeSettings.strokeColor;
      parent.activeObj.strokeSettings.fillColor = fillColor || parent.activeObj.strokeSettings.fillColor;
      parent.activeObj.textSettings.text = text || parent.activeObj.textSettings.text;
      parent.activeObj.textSettings.fontFamily = fontFamily || parent.activeObj.textSettings.fontFamily;
      parent.activeObj.textSettings.fontSize = fontSize || parent.activeObj.textSettings.fontSize;
      parent.activeObj.textSettings.bold = bold || parent.activeObj.textSettings.bold;
      parent.activeObj.textSettings.italic = italic || parent.activeObj.textSettings.italic;
      parent.activeObj.strokeSettings.outlineColor = outlineColor || parent.activeObj.strokeSettings.outlineColor;
      parent.activeObj.strokeSettings.outlineWidth = outlineWidth || parent.activeObj.strokeSettings.outlineWidth;
    };
    Shape2.prototype.drawImage = function(x, y, width, height, src, degree, isAspectRatio, opacity, isSelected) {
      this.initializeShape("image");
      this.onLoadImgShape(x, y, width, height, src, null, degree, isAspectRatio, opacity, isSelected);
    };
    Shape2.prototype.redrawActObj = function(x, y, isMouseDown) {
      var splitWords;
      var parent = this.parent;
      if (parent.activeObj.shape) {
        splitWords = parent.activeObj.shape.split("-");
      }
      if (parent.activeObj.horTopLine && (parent.activeObj.shape && splitWords[0] !== "crop")) {
        if (parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block") {
          parent.notify("selection", { prop: "setTextBoxStylesToActObj", onPropertyChange: false });
          this.updateFontRatio(parent.activeObj, true);
          if (x && y) {
            if (x !== parent.activeObj.activePoint.startX && y !== parent.activeObj.activePoint.startY) {
              this.updateTextFromTextArea();
            }
          } else {
            this.updateTextFromTextArea();
            parent.textArea.style.transform = "";
            parent.notify("toolbar", { prop: "refresh-main-toolbar", onPropertyChange: false });
          }
          this.refreshActiveObj();
        } else {
          this.applyActObj(isMouseDown);
        }
      }
    };
    Shape2.prototype.apply = function(shape, obj, canvas) {
      var parent = this.parent;
      if (!parent.disabled) {
        if (parent.togglePen && !parent.currObjType.isCustomCrop) {
          var destLeft = parent.img.destLeft;
          var destTop = parent.img.destTop;
          var destWidth = parent.img.destWidth;
          var destHeight = parent.img.destHeight;
          parent.notify("draw", { prop: "callUpdateCurrTransState", onPropertyChange: false });
          var temp = this.lowerContext.filter;
          this.lowerContext.filter = "none";
          parent.togglePen = false;
          if (parent.isCircleCrop || parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle") {
            parent.notify("crop", {
              prop: "cropCircle",
              onPropertyChange: false,
              value: { context: this.lowerContext, isSave: null, isFlip: null }
            });
          }
          parent.img.destLeft = destLeft;
          parent.img.destTop = destTop;
          parent.img.destWidth = destWidth;
          parent.img.destHeight = destHeight;
          this.lowerContext.filter = temp;
        } else {
          canvas = canvas ? canvas : "original";
          if (isNullOrUndefined(parent.activeObj.shape) && isNullOrUndefined(shape)) {
            parent.currObjType.shape = "";
          } else {
            parent.currObjType.shape = shape || parent.currObjType.shape;
          }
          if (parent.currObjType.shape !== "") {
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            if (parent.activeObj.shape === "text") {
              parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: {
                canvas,
                obj,
                isCropRatio: null,
                points: null,
                isPreventDrag: true,
                saveContext: null,
                isPreventSelection: null
              } });
            } else {
              parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas, obj } });
            }
            parent.activeObj.shape = parent.currObjType.shape.toLowerCase();
            if (!shape && parent.currObjType.shape !== "" && !parent.currObjType.isCustomCrop) {
              parent.objColl.push(extend({}, parent.activeObj, {}, true));
            }
            this.keyHistory = "";
          }
        }
      }
    };
    Shape2.prototype.setCenterPoints = function(text, width, height) {
      var parent = this.parent;
      var renderWidth;
      var renderHeight;
      if (text && width && height) {
        renderWidth = width;
        renderHeight = height;
      } else {
        renderWidth = parent.activeObj.activePoint.width;
        renderHeight = parent.activeObj.activePoint.height;
      }
      parent.activeObj.activePoint.startX = parent.lowerCanvas.width / 2 - renderWidth / 2;
      parent.activeObj.activePoint.startY = parent.lowerCanvas.height / 2 - renderHeight / 2;
      parent.activeObj.activePoint.endX = parent.lowerCanvas.width / 2 + renderWidth / 2;
      parent.activeObj.activePoint.endY = parent.lowerCanvas.height / 2 + renderHeight / 2;
    };
    Shape2.prototype.updSelChangeEventArgs = function(selectionSettings) {
      var parent = this.parent;
      parent.activeObj.activePoint = {
        startX: selectionSettings.startX,
        startY: selectionSettings.startY,
        endX: parent.activeObj.activePoint.startX + parent.activeObj.activePoint.width,
        endY: parent.activeObj.activePoint.startY + parent.activeObj.activePoint.height,
        width: selectionSettings.width,
        height: selectionSettings.height
      };
      parent.activeObj.activePoint.endX = parent.activeObj.activePoint.startX + parent.activeObj.activePoint.width;
      parent.activeObj.activePoint.endY = parent.activeObj.activePoint.startY + parent.activeObj.activePoint.height;
    };
    Shape2.prototype.updateShapeChangeEventArgs = function(shapeSettings, allowShapeOverflow) {
      var parent = this.parent;
      var shapeId;
      if (shapeSettings.id && shapeSettings.id.indexOf("shape_") === -1 && shapeSettings.id.indexOf("pen_") === -1) {
        if (parent.activeObj.currIndex) {
          parent.activeObj.currIndex = "shape_" + shapeSettings.id;
        } else {
          parent.pointColl[shapeId].id = "pen_" + shapeSettings.id;
        }
      }
      if (shapeSettings.id && shapeSettings.id.split("_")[0] && shapeSettings.id.split("_")[0] === "pen") {
        shapeId = parseInt(shapeSettings.id.split("_")[1], 10) - 1;
        parent.pointColl[shapeId].points = shapeSettings.points;
        parent.pointColl[shapeId].strokeColor = shapeSettings.strokeColor;
        parent.pointColl[shapeId].strokeWidth = shapeSettings.strokeWidth;
        parent.pointColl[shapeId].opacity = shapeSettings.opacity;
        if (shapeSettings.index) {
          parent.pointColl[shapeId].order = shapeSettings.index;
        }
      } else {
        parent.activeObj.activePoint.startX = shapeSettings.startX;
        parent.activeObj.activePoint.startY = shapeSettings.startY;
        if (shapeSettings.width && shapeSettings.height) {
          parent.activeObj.activePoint.width = shapeSettings.width;
          parent.activeObj.activePoint.height = shapeSettings.height;
          parent.activeObj.activePoint.endX = parent.activeObj.activePoint.startX + parent.activeObj.activePoint.width;
          parent.activeObj.activePoint.endY = parent.activeObj.activePoint.startY + parent.activeObj.activePoint.height;
        }
        if (parent.activeObj.shape !== "text") {
          parent.activeObj.strokeSettings.strokeColor = shapeSettings.strokeColor;
          parent.activeObj.strokeSettings.strokeWidth = shapeSettings.strokeWidth;
        }
        parent.activeObj.strokeSettings.fillColor = shapeSettings.fillColor;
        parent.activeObj.opacity = shapeSettings.opacity;
        if (shapeSettings.index) {
          parent.activeObj.order = shapeSettings.index;
        }
        parent.activeObj.preventShapeDragOut = !allowShapeOverflow;
        if (isNullOrUndefined(shapeSettings.degree)) {
          shapeSettings.degree = 0;
        }
        switch (parent.activeObj.shape) {
          case "ellipse":
            parent.activeObj.activePoint.width = shapeSettings.radiusX * 2;
            parent.activeObj.activePoint.height = shapeSettings.radiusY * 2;
            parent.activeObj.activePoint.endX = parent.activeObj.activePoint.startX + parent.activeObj.activePoint.width;
            parent.activeObj.activePoint.endY = parent.activeObj.activePoint.startY + parent.activeObj.activePoint.height;
            if (shapeSettings.degree) {
              parent.activeObj.rotatedAngle = shapeSettings.degree * (Math.PI / 180);
            }
            break;
          case "line":
          case "arrow":
            parent.activeObj.activePoint.width = shapeSettings.length;
            parent.activeObj.activePoint.endX = shapeSettings.endX;
            parent.activeObj.activePoint.endY = shapeSettings.endY;
            parent.activeObj.activePoint.width = parent.activeObj.activePoint.startX + parent.activeObj.activePoint.width;
            parent.activeObj.activePoint.height = parent.activeObj.activePoint.startY + parent.activeObj.activePoint.height;
            if (parent.activeObj.shape === "arrow") {
              parent.activeObj.start = this.getArrowType(shapeSettings.arrowHead);
              parent.activeObj.end = this.getArrowType(shapeSettings.arrowTail);
            }
            break;
          case "text":
            parent.activeObj.keyHistory = parent.activeObj.textSettings.text = shapeSettings.text;
            parent.activeObj.textSettings.fontSize = shapeSettings.fontSize;
            parent.activeObj.strokeSettings.strokeColor = shapeSettings.color;
            parent.activeObj.strokeSettings.outlineColor = shapeSettings.strokeColor;
            parent.activeObj.strokeSettings.outlineWidth = shapeSettings.strokeWidth;
            parent.activeObj.strokeSettings.fillColor = shapeSettings.fillColor;
            parent.activeObj.textSettings.fontFamily = shapeSettings.fontFamily;
            this.setTransformColl(shapeSettings.transformCollection);
            if (shapeSettings.degree) {
              parent.activeObj.rotatedAngle = shapeSettings.degree * (Math.PI / 180);
            }
            this.updateFontRatio(parent.activeObj);
            break;
          case "rectangle":
          case "image":
            if (shapeSettings.degree) {
              parent.activeObj.rotatedAngle = shapeSettings.degree * (Math.PI / 180);
            }
            break;
          case "path":
            parent.activeObj.pointColl = shapeSettings.points;
            break;
        }
        if (parent.activeObj.shape === "text" && parent.activeObj.textSettings) {
          parent.activeObj.textSettings.bold = false;
          parent.activeObj.textSettings.italic = false;
          parent.activeObj.textSettings.underline = false;
          for (var i = 0; i < shapeSettings.fontStyle.length; i++) {
            switch (shapeSettings.fontStyle[i]) {
              case "bold":
                parent.activeObj.textSettings.bold = true;
                break;
              case "italic":
                parent.activeObj.textSettings.italic = true;
                break;
            }
          }
        }
      }
    };
    Shape2.prototype.addLetter = function(letter) {
      var parent = this.parent;
      if (parent.textArea.style.display === "none" && (parent.currObjType.isText || parent.activeObj.shape === "text")) {
        var fontSize = parent.activeObj.textSettings.fontSize;
        if (letter === "Backspace") {
          this.keyHistory = this.keyHistory.slice(0, -1);
        } else {
          this.keyHistory += letter;
        }
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        this.updateFontStyles();
        var width = this.upperContext.measureText(this.keyHistory).width + fontSize * 0.5;
        var height = fontSize;
        this.upperContext.fillText(this.keyHistory, parent.activeObj.activePoint.startX, parent.activeObj.activePoint.startY + fontSize);
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        parent.currObjType.isText = true;
        parent.notify("selection", {
          prop: "setActivePoint",
          onPropertyChange: false,
          value: { startX: width, startY: height }
        });
      }
    };
    Shape2.prototype.redrawText = function() {
      var parent = this.parent;
      var _a = parent.activeObj.textSettings, fontSize = _a.fontSize, fontFamily = _a.fontFamily, bold = _a.bold, italic = _a.italic;
      var fontStyle = "";
      if (bold) {
        fontStyle += "bold ";
      }
      if (italic) {
        fontStyle += "italic ";
      }
      this.upperContext.font = fontStyle + fontSize + "px " + fontFamily;
      var rows = parent.activeObj.keyHistory.split("\n");
      var text = parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block" ? this.getMaxText(true) : this.getMaxText();
      var width = this.upperContext.measureText(text).width + fontSize * 0.5;
      var height = rows.length * fontSize;
      if (rows.length > 1) {
        height += fontSize * 0.5;
      }
      parent.notify("selection", {
        prop: "setTextSelection",
        onPropertyChange: false,
        value: { width, height }
      });
      parent.notify("draw", { prop: "updateActiveObject", onPropertyChange: false, value: {
        actPoint: parent.activeObj.activePoint,
        obj: parent.activeObj,
        isMouseMove: null,
        x: null,
        y: null
      } });
      parent.notify("selection", {
        prop: "redrawShape",
        onPropertyChange: false,
        value: { obj: parent.activeObj }
      });
    };
    Shape2.prototype.updateTextFromTextArea = function() {
      var parent = this.parent;
      var allowUndoRedo = false;
      var fontSize = parent.activeObj.textSettings.fontSize;
      var tempActiveObj = extend({}, parent.activeObj, {}, true);
      var prevCropObj = extend({}, parent.cropObj, {}, true);
      var object = { currObj: {} };
      parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
      var prevObj = object["currObj"];
      prevObj.objColl = extend([], parent.objColl, [], true);
      prevObj.pointColl = extend([], parent.pointColl, [], true);
      prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      parent.notify("freehand-draw", {
        prop: "getSelPointColl",
        onPropertyChange: false,
        value: { obj: selPointCollObj }
      });
      prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
      if (parent.activeObj.keyHistory !== parent.textArea.value) {
        allowUndoRedo = true;
      }
      parent.activeObj.keyHistory = parent.textArea.value;
      parent.textArea.style.display = "none";
      parent.textArea.value = "";
      this.updateFontStyles();
      var width = this.upperContext.measureText(parent.activeObj.keyHistory).width + fontSize * 0.5;
      var height = fontSize;
      var rows = parent.activeObj.keyHistory.split("\n");
      if (rows.length > 1) {
        height *= rows.length;
        height += fontSize * 0.1 * rows.length;
        var widthColl = [];
        for (var i = 0, len = rows.length; i < len; i++) {
          widthColl.push(this.upperContext.measureText(rows[i]).width + fontSize * 0.5);
        }
        width = Math.max.apply(Math, widthColl);
      }
      parent.notify("selection", {
        prop: "setTextSelection",
        onPropertyChange: false,
        value: { width, height }
      });
      if (parent.activeObj.rotatedAngle !== 0) {
        var width_1 = parent.activeObj.activePoint.width - tempActiveObj.activePoint.width;
        var height_1 = parent.activeObj.activePoint.height - tempActiveObj.activePoint.height;
        var value = "";
        if (width_1 > 0 && height_1 > 0) {
          value = "widthHeight";
        } else if (width_1 !== 0) {
          value = "width";
        } else if (height_1 !== 0) {
          value = "height";
        }
        parent.activeObj.activePoint = extend({}, tempActiveObj.activePoint, {}, true);
        parent.notify("selection", { prop: "adjustRotationPoints", onPropertyChange: false, value: {
          rectangle: parent.activeObj.activePoint,
          x: width_1,
          y: height_1,
          angle: parent.activeObj.rotatedAngle,
          type: "text",
          elem: value
        } });
        parent.notify("shape", {
          prop: "updateFontSize",
          onPropertyChange: false,
          value: { obj: parent.activeObj }
        });
      }
      parent.notify("draw", { prop: "updateActiveObject", onPropertyChange: false, value: {
        actPoint: parent.activeObj.activePoint,
        obj: parent.activeObj,
        isMouseMove: null,
        x: null,
        y: null
      } });
      this.updImgRatioForActObj();
      if (parent.activeObj.rotatedAngle !== 0) {
        parent.notify("selection", { prop: "updPtCollForShpRot", onPropertyChange: false, value: { obj: parent.activeObj } });
      }
      if (allowUndoRedo) {
        this.apply(parent.activeObj.shape, parent.activeObj);
        parent.objColl.push(extend({}, parent.activeObj, {}, true));
        parent.notify("undo-redo", {
          prop: "updateUndoRedoColl",
          onPropertyChange: false,
          value: {
            operation: "text",
            previousObj: prevObj,
            previousObjColl: prevObj.objColl,
            previousPointColl: prevObj.pointColl,
            previousSelPointColl: prevObj.selPointColl,
            previousCropObj: prevCropObj,
            previousText: parent.activeObj.keyHistory,
            currentText: parent.textArea.value,
            previousFilter: null,
            isCircleCrop: null
          }
        });
      } else {
        this.apply(parent.activeObj.shape, parent.activeObj);
        parent.objColl.push(extend({}, parent.activeObj, {}, true));
      }
    };
    Shape2.prototype.iterateObjColl = function() {
      var parent = this.parent;
      if (parent.objColl.length > 0) {
        var index = this.getSmallestIndex();
        var objColl = extend([], parent.objColl, [], true);
        while (objColl.length > 0) {
          var found = false;
          for (var i = 0; i < objColl.length; i++) {
            var currentObj = objColl[i];
            if (isNullOrUndefined(currentObj.order)) {
              objColl.splice(i, 1);
              i--;
              continue;
            }
            if (currentObj.order === index) {
              this.apply(currentObj.shape, currentObj);
              if (currentObj.shape === "redact" && JSON.stringify(currentObj.activePoint) === JSON.stringify(parent.activeObj.activePoint) && currentObj.redactImage !== parent.activeObj.redactImage) {
                currentObj.redactImage = parent.activeObj.redactImage;
                if (parent.objColl[i] && JSON.stringify(parent.objColl[i].activePoint) === JSON.stringify(currentObj.activePoint)) {
                  parent.objColl[i].redactImage = parent.activeObj.redactImage;
                }
              }
              this.refreshActiveObj();
              index++;
              if (!this.isIndexInObjColl(index)) {
                index++;
              }
              objColl.splice(i, 1);
              found = true;
              break;
            }
          }
          if (!found) {
            break;
          }
        }
      }
    };
    Shape2.prototype.getSmallestIndex = function() {
      var parent = this.parent;
      var smallestIndex;
      for (var i = 0, len = parent.objColl.length; i < len; i++) {
        var currentObj = parent.objColl[i];
        if (isNullOrUndefined(currentObj.order)) {
          continue;
        }
        if (isNullOrUndefined(smallestIndex) || currentObj.order < smallestIndex) {
          smallestIndex = currentObj.order;
        }
      }
      return smallestIndex;
    };
    Shape2.prototype.isIndexInObjColl = function(index) {
      var parent = this.parent;
      for (var i = 0, len = parent.objColl.length; i < len; i++) {
        var currentObj = parent.objColl[i];
        if (isNullOrUndefined(currentObj.order)) {
          continue;
        }
        if (currentObj.order === index) {
          return true;
        }
      }
      return false;
    };
    Shape2.prototype.updImgRatioForActObj = function() {
      var parent = this.parent;
      var destPoints = {
        startX: parent.img.destLeft,
        startY: parent.img.destTop,
        width: parent.img.destWidth,
        height: parent.img.destHeight
      };
      this.straightenShapes();
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      var activePoint = parent.activeObj.activePoint;
      parent.activeObj.imageRatio = {
        startX: (activePoint.startX - destLeft) / destWidth,
        startY: (activePoint.startY - destTop) / destHeight,
        endX: (activePoint.endX - destLeft) / destWidth,
        endY: (activePoint.endY - destTop) / destHeight,
        width: destWidth / activePoint.width,
        height: destHeight / activePoint.height
      };
      if (parent.activeObj.rotationCirclePointColl) {
        parent.activeObj.rotationCirclePointColl.ratioX = (parent.activeObj.rotationCirclePointColl.x - destLeft) / destWidth;
        parent.activeObj.rotationCirclePointColl.ratioY = (parent.activeObj.rotationCirclePointColl.y - destTop) / destHeight;
      }
      if (parent.activeObj.shape === "path") {
        this.updatePathRatio(parent.activeObj);
      } else if (parent.activeObj.shape === "arrow") {
        this.updateArrowRatio(parent.activeObj);
      }
      parent.img.destLeft = destPoints.startX;
      parent.img.destTop = destPoints.startY;
      parent.img.destWidth = destPoints.width;
      parent.img.destHeight = destPoints.height;
    };
    Shape2.prototype.zoomObjColl = function(preventApply) {
      var parent = this.parent;
      var destPoints = {
        startX: parent.img.destLeft,
        startY: parent.img.destTop,
        width: parent.img.destWidth,
        height: parent.img.destHeight
      };
      this.straightenShapes();
      if (parent.objColl.length > 0) {
        for (var i = 0, len = parent.objColl.length; i < len; i++) {
          var currObj = parent.objColl[i];
          if (currObj.imageRatio) {
            currObj.activePoint.startX = currObj.imageRatio.startX * parent.img.destWidth + parent.img.destLeft;
            currObj.activePoint.startY = currObj.imageRatio.startY * parent.img.destHeight + parent.img.destTop;
            currObj.activePoint.endX = currObj.imageRatio.endX * parent.img.destWidth + parent.img.destLeft;
            currObj.activePoint.endY = currObj.imageRatio.endY * parent.img.destHeight + parent.img.destTop;
          }
          currObj = this.updateWidthHeight(currObj);
          if (currObj.shape === "text") {
            this.updateFontSize(currObj);
          } else if (currObj.shape === "line" || currObj.shape === "arrow") {
            currObj.pointColl = this.getLinePoints(currObj.activePoint.startX, currObj.activePoint.startY, currObj.activePoint.endX, currObj.activePoint.endY);
            for (var n = 0, len_1 = currObj.pointColl.length; n < len_1; n++) {
              currObj.pointColl[n].ratioX = (currObj.pointColl[n].x - parent.img.destLeft) / parent.img.destWidth;
              currObj.pointColl[n].ratioY = (currObj.pointColl[n].y - parent.img.destTop) / parent.img.destHeight;
            }
            if (currObj.shape === "arrow") {
              this.updateArrowSize(currObj);
            }
            if (parent.transform.straighten !== 0 && (currObj.shape === "line" || currObj.shape === "arrow")) {
              this.straightenShapePoints(currObj);
            }
          } else if (currObj.shape === "path") {
            for (var l = 0, len_2 = currObj.pointColl.length; l < len_2; l++) {
              currObj.pointColl[l].x = currObj.pointColl[l].ratioX * parent.img.destWidth + parent.img.destLeft;
              currObj.pointColl[l].y = currObj.pointColl[l].ratioY * parent.img.destHeight + parent.img.destTop;
            }
            this.updatePathRatio(currObj);
            if (parent.transform.straighten !== 0) {
              this.straightenPath(currObj);
            }
          }
          parent.notify("draw", { prop: "updateActiveObject", onPropertyChange: false, value: {
            actPoint: currObj.activePoint,
            obj: currObj
          } });
          if (currObj.shape !== "line" && currObj.shape !== "arrow" && currObj.shape !== "path" && currObj.rotatedAngle !== 0) {
            this.setPointCollForShapeRotation(currObj);
            currObj.rotationCirclePoint.x = currObj.rotationCirclePoint.ratioX * parent.img.destWidth + parent.img.destLeft;
            currObj.rotationCirclePoint.y = currObj.rotationCirclePoint.ratioY * parent.img.destHeight + parent.img.destTop;
            if (currObj.rotationCirclePointColl) {
              currObj.rotationCirclePointColl.x = currObj.rotationCirclePointColl.ratioX * parent.img.destWidth + parent.img.destLeft;
              currObj.rotationCirclePointColl.y = currObj.rotationCirclePointColl.ratioY * parent.img.destHeight + parent.img.destTop;
            }
          }
        }
        if (isNullOrUndefined(preventApply)) {
          var temp = this.lowerContext.filter;
          this.lowerContext.filter = "none";
          this.iterateObjColl();
          this.lowerContext.filter = temp;
        }
      }
      parent.img.destLeft = destPoints.startX;
      parent.img.destTop = destPoints.startY;
      parent.img.destWidth = destPoints.width;
      parent.img.destHeight = destPoints.height;
    };
    Shape2.prototype.straightenPath = function(obj) {
      var point;
      for (var j = 0, len = obj.pointColl.length; j < len; j++) {
        point = this.straightenPoints(obj.pointColl[j].x, obj.pointColl[j].y);
        obj.pointColl[j].x = point.x;
        obj.pointColl[j].y = point.y;
      }
    };
    Shape2.prototype.straightenFHD = function() {
      var parent = this.parent;
      for (var i = 0, fLen = parent.freehandCounter; i < fLen; i++) {
        parent.points = extend([], parent.pointColl[i].points, []);
        var len = parent.points.length;
        var point = undefined;
        for (var l = 0; l < len; l++) {
          point = this.straightenPoints(parent.points[l].x, parent.points[l].y);
          parent.points[l].x = point.x;
          parent.points[l].y = point.y;
        }
      }
      var selPointCollObj = { selPointColl: null };
      parent.notify("freehand-draw", { prop: "getSelPointColl", onPropertyChange: false, value: { obj: selPointCollObj } });
      for (var i = 0, fLen = parent.freehandCounter; i < fLen; i++) {
        if (selPointCollObj["selPointColl"][i] && selPointCollObj["selPointColl"][i].points) {
          var len = selPointCollObj["selPointColl"][i].points.length;
          var point = undefined;
          for (var l = 0; l < len; l++) {
            point = this.straightenPoints(selPointCollObj["selPointColl"][i].points[l].x, selPointCollObj["selPointColl"][i].points[l].y);
            selPointCollObj["selPointColl"][i].points[l].x = point.x;
            selPointCollObj["selPointColl"][i].points[l].y = point.y;
          }
        }
      }
      var straightenObj = { straightenPoint: null };
      parent.notify("freehand-draw", { prop: "getStraightenPoint", onPropertyChange: false, value: { obj: straightenObj } });
      if (straightenObj["straightenPoint"]["x"] && straightenObj["straightenPoint"]["y"]) {
        var obj = { angle: 0 };
        parent.notify("freehand-draw", { prop: "getStraightenPointAngle", onPropertyChange: false, value: { obj } });
        var angle = ((parent.transform.straighten === 360 ? 0 : parent.transform.straighten) - obj["angle"]) * (Math.PI / 180);
        var point = this.straightenPoints(straightenObj["straightenPoint"]["x"], straightenObj["straightenPoint"]["y"], angle);
        if (angle === 0) {
          point.x = straightenObj["straightenPoint"]["x"];
          point.y = straightenObj["straightenPoint"]["y"];
        }
        parent.notify("freehand-draw", { prop: "setStraightenPoint", onPropertyChange: false, value: { x: point.x, y: point.y } });
      }
    };
    Shape2.prototype.straightenPoints = function(x, y, angle) {
      var parent = this.parent;
      var center = { x: parent.img.destLeft + parent.img.destWidth / 2, y: parent.img.destTop + parent.img.destHeight / 2 };
      angle = angle ? angle : parent.transform.straighten * (Math.PI / 180);
      var point = {
        x: Math.cos(angle) * (x - center.x) - Math.sin(angle) * (y - center.y) + center.x,
        y: Math.sin(angle) * (x - center.x) + Math.cos(angle) * (y - center.y) + center.y
      };
      return point;
    };
    Shape2.prototype.straightenShapes = function() {
      var parent = this.parent;
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      var straightenObj = { bool: parent.isStraightening };
      if (!straightenObj["bool"] || parent.transform.straighten === 0) {
        return;
      }
      parent.notify("draw", { prop: "updateImgCanvasPoints" });
      var object = { points: null };
      parent.notify("draw", { prop: "getImageCanvasPoints", value: { obj: object } });
      var center = { x: destLeft + destWidth / 2, y: destTop + destHeight / 2 };
      var angle = -(parent.transform.straighten * (Math.PI / 180));
      var p1 = {
        x: Math.cos(angle) * (object["points"][0]["x"] - center.x) - Math.sin(angle) * (object["points"][0]["y"] - center.y) + center.x,
        y: Math.sin(angle) * (object["points"][0]["x"] - center.x) + Math.cos(angle) * (object["points"][0]["y"] - center.y) + center.y
      };
      var p2 = {
        x: Math.cos(angle) * (object["points"][1]["x"] - center.x) - Math.sin(angle) * (object["points"][1]["y"] - center.y) + center.x,
        y: Math.sin(angle) * (object["points"][1]["x"] - center.x) + Math.cos(angle) * (object["points"][1]["y"] - center.y) + center.y
      };
      var p3 = {
        x: Math.cos(angle) * (object["points"][2]["x"] - center.x) - Math.sin(angle) * (object["points"][2]["y"] - center.y) + center.x,
        y: Math.sin(angle) * (object["points"][2]["x"] - center.x) + Math.cos(angle) * (object["points"][2]["y"] - center.y) + center.y
      };
      parent.img.destWidth = p2.x - p1.x;
      parent.img.destHeight = p3.y - p2.y;
      parent.img.destLeft = p1.x;
      parent.img.destTop = p1.y;
    };
    Shape2.prototype.straightenShapePoints = function(obj, isReverse) {
      var parent = this.parent;
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      var straightenObj = { bool: parent.isStraightening };
      if (!straightenObj["bool"]) {
        return;
      }
      if (obj.shape === "line" || obj.shape === "arrow") {
        obj.activePoint.width = obj.activePoint.endX > obj.activePoint.startX ? obj.activePoint.endX - obj.activePoint.startX : obj.activePoint.startX - obj.activePoint.endX;
        obj.activePoint.height = obj.activePoint.endY > obj.activePoint.startY ? obj.activePoint.endY - obj.activePoint.startY : obj.activePoint.startY - obj.activePoint.endY;
        var center = { x: destLeft + destWidth / 2, y: destTop + destHeight / 2 };
        var angle = (isReverse ? -parent.transform.straighten : parent.transform.straighten) * (Math.PI / 180);
        var start = { x: Math.cos(angle) * (obj.activePoint.startX - center.x) - Math.sin(angle) * (obj.activePoint.startY - center.y) + center.x, y: Math.sin(angle) * (obj.activePoint.startX - center.x) + Math.cos(angle) * (obj.activePoint.startY - center.y) + center.y };
        var end = { x: Math.cos(angle) * (obj.activePoint.endX - center.x) - Math.sin(angle) * (obj.activePoint.endY - center.y) + center.x, y: Math.sin(angle) * (obj.activePoint.endX - center.x) + Math.cos(angle) * (obj.activePoint.endY - center.y) + center.y };
        obj.activePoint.startX = start.x;
        obj.activePoint.startY = start.y;
        obj.activePoint.endX = end.x;
        obj.activePoint.endY = end.y;
        obj.activePoint.width = obj.activePoint.endX > obj.activePoint.startX ? obj.activePoint.endX - obj.activePoint.startX : obj.activePoint.startX - obj.activePoint.endX;
        obj.activePoint.height = obj.activePoint.endY > obj.activePoint.startY ? obj.activePoint.endY - obj.activePoint.startY : obj.activePoint.startY - obj.activePoint.endY;
        parent.notify("selection", { prop: "adjustActObjForLineArrow", onPropertyChange: false, value: { obj } });
      }
    };
    Shape2.prototype.redrawObj = function(degree) {
      var parent = this.parent;
      var isShape = false;
      if (parent.objColl.length > 0) {
        if (degree === "horizontal" || degree === "vertical" || degree === "Horizontal" || degree === "Vertical" || degree === "horizontalVertical" || degree === "verticalHorizontal") {
          this.updateCurrentActiveObjPoint(degree.toLowerCase());
        } else if (typeof degree === "number") {
          this.updateCurrentActiveObjPoint(degree);
          var tempFilter = this.lowerContext.filter;
          this.lowerContext.filter = "brightness(1) contrast(100%) hue-rotate(0deg) saturate(100%) opacity(1) blur(0px) sepia(0%) grayscale(0%) invert(0%)";
          for (var i = 0, len = parent.objColl.length; i < len; i++) {
            var splitWords = parent.objColl[i].shape.split("-");
            if (splitWords[0] !== "crop") {
              this.apply(parent.objColl[i].shape, parent.objColl[i]);
              isShape = true;
            }
          }
          if (isShape) {
            parent.notify("draw", { prop: "applyFrame", value: { ctx: this.lowerContext, frame: parent.frameObj.type, preventImg: true } });
          }
          this.lowerContext.filter = tempFilter;
        }
      }
    };
    Shape2.prototype.updateCurrentActiveObjPoint = function(degree) {
      var parent = this.parent;
      var currActObjIndex;
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      for (var index = 0, len = parent.objColl.length; index < len; index++) {
        var currObj = parent.objColl[index];
        if (parent.activeObj.shape === currObj.shape && parent.activeObj.activePoint.startX === currObj.activePoint.startX && parent.activeObj.activePoint.startY === currObj.activePoint.startY && parent.activeObj.activePoint.endX === currObj.activePoint.endX && parent.activeObj.activePoint.endY === currObj.activePoint.endY && parent.activeObj.currIndex === currObj.currIndex) {
          currActObjIndex = index;
          break;
        }
      }
      if (degree === "horizontal" || degree === "vertical" || degree === "Horizontal" || degree === "Vertical" || degree === "horizontalvertical" || degree === "verticalhorizontal") {
        if (degree === "horizontal" || degree === "Horizontal") {
          for (var i = 0, len = parent.objColl.length; i < len; i++) {
            var currObj = parent.objColl[i];
            if (currObj.shapeFlip !== parent.transform.currFlipState) {
              if (currObj.activePoint.startX <= destLeft + destWidth / 2) {
                currObj.activePoint.endX = destLeft + destWidth - (currObj.activePoint.startX - destLeft);
                currObj.activePoint.startX = currObj.activePoint.endX - currObj.activePoint.width;
                parent.notify("draw", { prop: "updateActiveObject", onPropertyChange: false, value: { actPoint: currObj.activePoint, obj: currObj } });
              } else if (currObj.activePoint.startX >= destLeft + destWidth / 2) {
                currObj.activePoint.startX = destLeft + (destLeft + destWidth - currObj.activePoint.endX);
                currObj.activePoint.endX = currObj.activePoint.startX + currObj.activePoint.width;
                parent.notify("draw", { prop: "updateActiveObject", onPropertyChange: false, value: { actPoint: currObj.activePoint, obj: currObj } });
              }
              if (currObj.shape === "line" || currObj.shape === "arrow" || currObj.shape === "path") {
                this.flipLineArrowObj(currObj, "horizontal");
              } else if (currObj.rotatedAngle !== 0) {
                currObj.rotatedAngle = currObj.rotatedAngle + (Math.PI - currObj.rotatedAngle) * 2;
                if (currObj.rotationCirclePointColl.x <= destLeft + destWidth / 2) {
                  currObj.rotationCirclePointColl.x = destLeft + destWidth - (currObj.rotationCirclePointColl.x - destLeft);
                } else if (currObj.rotationCirclePointColl.x >= destLeft + destWidth / 2) {
                  currObj.rotationCirclePointColl.x = destLeft + (destLeft + destWidth - currObj.rotationCirclePointColl.x);
                }
                currObj.rotationCirclePointColl.ratioX = (currObj.rotationCirclePointColl.x - destLeft) / destWidth;
              }
              currObj.shapeFlip = parent.transform.currFlipState;
              currObj.imageRatio = {
                startX: (currObj.activePoint.startX - destLeft) / destWidth,
                startY: (currObj.activePoint.startY - destTop) / destHeight,
                endX: (currObj.activePoint.endX - destLeft) / destWidth,
                endY: (currObj.activePoint.endY - destTop) / destHeight,
                width: destWidth / currObj.activePoint.width,
                height: destHeight / currObj.activePoint.height
              };
            }
          }
        } else if (degree === "vertical" || degree === "Vertical") {
          for (var i = 0; i < parent.objColl.length; i++) {
            var currObj = parent.objColl[i];
            if (currObj.shapeFlip !== parent.transform.currFlipState) {
              if (currObj.activePoint.startY <= destTop + destHeight / 2) {
                currObj.activePoint.endY = destTop + destHeight - (currObj.activePoint.startY - destTop);
                currObj.activePoint.startY = currObj.activePoint.endY - currObj.activePoint.height;
                parent.notify("draw", { prop: "updateActiveObject", onPropertyChange: false, value: {
                  actPoint: currObj.activePoint,
                  obj: currObj
                } });
              } else if (currObj.activePoint.startY >= parent.lowerCanvas.height / 2) {
                currObj.activePoint.startY = destTop + (destTop + destHeight - currObj.activePoint.endY);
                currObj.activePoint.endY = currObj.activePoint.startY + currObj.activePoint.height;
                parent.notify("draw", { prop: "updateActiveObject", onPropertyChange: false, value: {
                  actPoint: currObj.activePoint,
                  obj: currObj
                } });
              }
              if (currObj.shape === "line" || currObj.shape === "arrow" || currObj.shape === "path") {
                this.flipLineArrowObj(currObj, "vertical");
              } else if (currObj.rotatedAngle !== 0) {
                currObj.rotatedAngle = -currObj.rotatedAngle;
                if (currObj.rotationCirclePointColl.y <= destTop + destHeight / 2) {
                  currObj.rotationCirclePointColl.y = destTop + destHeight - (currObj.rotationCirclePointColl.y - destTop);
                } else if (currObj.rotationCirclePointColl.y >= destTop + destHeight / 2) {
                  currObj.rotationCirclePointColl.y = destTop + (destTop + destHeight - currObj.rotationCirclePointColl.y);
                }
                currObj.rotationCirclePointColl.ratioY = (currObj.rotationCirclePointColl.y - destTop) / destHeight;
              }
              currObj.shapeFlip = parent.transform.currFlipState;
              currObj.imageRatio = {
                startX: (currObj.activePoint.startX - destLeft) / destWidth,
                startY: (currObj.activePoint.startY - destTop) / destHeight,
                endX: (currObj.activePoint.endX - destLeft) / destWidth,
                endY: (currObj.activePoint.endY - destTop) / destHeight,
                width: destWidth / currObj.activePoint.width,
                height: destHeight / currObj.activePoint.height
              };
            }
          }
        } else if (degree === "verticalhorizontal" || degree === "horizontalvertical") {
          for (var i = 0, len = parent.objColl.length; i < len; i++) {
            var currObj = parent.objColl[i];
            if (currObj.shapeFlip !== parent.transform.currFlipState) {
              if (currObj.activePoint.startX <= destLeft + destWidth / 2) {
                currObj.activePoint.endX = destLeft + destWidth - (currObj.activePoint.startX - destLeft);
                currObj.activePoint.startX = currObj.activePoint.endX - currObj.activePoint.width;
                parent.notify("draw", { prop: "updateActiveObject", onPropertyChange: false, value: { actPoint: currObj.activePoint, obj: currObj } });
              } else if (currObj.activePoint.startX >= destLeft + destWidth / 2) {
                currObj.activePoint.startX = destLeft + (destLeft + destWidth - currObj.activePoint.endX);
                currObj.activePoint.endX = currObj.activePoint.startX + currObj.activePoint.width;
                parent.notify("draw", { prop: "updateActiveObject", onPropertyChange: false, value: { actPoint: currObj.activePoint, obj: currObj } });
              }
              if (currObj.activePoint.startY <= destTop + destHeight / 2) {
                currObj.activePoint.endY = destTop + destHeight - (currObj.activePoint.startY - destTop);
                currObj.activePoint.startY = currObj.activePoint.endY - currObj.activePoint.height;
                parent.notify("draw", { prop: "updateActiveObject", onPropertyChange: false, value: { actPoint: currObj.activePoint, obj: currObj } });
              } else if (currObj.activePoint.startY >= parent.lowerCanvas.height / 2) {
                currObj.activePoint.startY = destTop + (destTop + destHeight - currObj.activePoint.endY);
                currObj.activePoint.endY = currObj.activePoint.startY + currObj.activePoint.height;
                parent.notify("draw", { prop: "updateActiveObject", onPropertyChange: false, value: { actPoint: currObj.activePoint, obj: currObj } });
              }
              if (currObj.shape === "line" || currObj.shape === "arrow" || currObj.shape === "path") {
                this.flipLineArrowObj(currObj, degree);
              }
              currObj.shapeFlip = parent.transform.currFlipState;
              currObj.imageRatio = {
                startX: (currObj.activePoint.startX - destLeft) / destWidth,
                startY: (currObj.activePoint.startY - destTop) / destHeight,
                endX: (currObj.activePoint.endX - destLeft) / destWidth,
                endY: (currObj.activePoint.endY - destTop) / destHeight,
                width: destWidth / currObj.activePoint.width,
                height: destHeight / currObj.activePoint.height
              };
            }
          }
        }
        if (currActObjIndex !== undefined) {
          parent.activeObj = extend({}, parent.objColl[currActObjIndex], {}, true);
        }
      } else if (degree === 90) {
        this.rotateObjColl();
      } else if (degree === -90) {
        for (var i = 0; i < 3; i++) {
          this.rotateObjColl();
        }
      } else if (typeof degree === "number") {
        if (degree > 0) {
          this.rotateObjColl();
        } else {
          for (var i = 0; i < 3; i++) {
            this.rotateObjColl();
          }
        }
      }
    };
    Shape2.prototype.rotateObjColl = function() {
      var parent = this.parent;
      var _a = parent.img, destWidth = _a.destWidth, destHeight = _a.destHeight, destLeft = _a.destLeft, destTop = _a.destTop;
      for (var i = 0, len = parent.objColl.length; i < len; i++) {
        var currObj = parent.objColl[i];
        var shape = currObj.shape;
        currObj.activePoint.startY = destTop + destHeight * currObj.imageRatio.startX;
        currObj.activePoint.endY = destTop + destHeight * currObj.imageRatio.endX;
        currObj.activePoint.startX = destLeft + destWidth - destWidth * currObj.imageRatio.endY;
        currObj.activePoint.endX = destLeft + destWidth - destWidth * currObj.imageRatio.startY;
        currObj = this.updateWidthHeight(parent.objColl[i]);
        this.updateFontSize(currObj);
        if (shape === "line" || shape === "arrow" || shape === "path") {
          this.rotateLineArrowObj(currObj);
          if (shape === "arrow") {
            this.updateArrowSize(currObj);
          }
        } else if (currObj.rotatedAngle !== 0) {
          currObj.rotationCirclePointColl.y = destTop + destHeight * currObj.rotationCirclePointColl.ratioX;
          currObj.rotationCirclePointColl.x = destLeft + destWidth - destWidth * currObj.rotationCirclePointColl.ratioY;
          currObj.rotationCirclePointColl.ratioX = (currObj.rotationCirclePointColl.x - destLeft) / destWidth;
          currObj.rotationCirclePointColl.ratioY = (currObj.rotationCirclePointColl.y - destTop) / destHeight;
        }
      }
      for (var i = 0, len = parent.objColl.length; i < len; i++) {
        parent.notify("draw", { prop: "updateActiveObject", onPropertyChange: false, value: { actPoint: parent.objColl[i].activePoint, obj: parent.objColl[i] } });
      }
      for (var i = 0, len = parent.objColl.length; i < len; i++) {
        var currObj = parent.objColl[i];
        currObj.imageRatio = {
          startX: (currObj.activePoint.startX - destLeft) / destWidth,
          startY: (currObj.activePoint.startY - destTop) / destHeight,
          endX: (currObj.activePoint.endX - destLeft) / destWidth,
          endY: (currObj.activePoint.endY - destTop) / destHeight,
          width: destWidth / currObj.activePoint.width,
          height: destHeight / currObj.activePoint.height
        };
      }
    };
    Shape2.prototype.rotateLineArrowObj = function(obj) {
      if (isNullOrUndefined(obj.pointColl)) {
        return;
      }
      var parent = this.parent;
      var _a = parent.img, destWidth = _a.destWidth, destHeight = _a.destHeight, destLeft = _a.destLeft, destTop = _a.destTop;
      if (obj.pointColl.length > 0) {
        for (var n = 0; n < obj.pointColl.length; n++) {
          obj.pointColl[n].y = destTop + destHeight * obj.pointColl[n].ratioX;
          obj.pointColl[n].x = destLeft + destWidth - destWidth * obj.pointColl[n].ratioY;
        }
        for (var n = 0; n < obj.pointColl.length; n++) {
          obj.pointColl[n].ratioX = (obj.pointColl[n].x - destLeft) / destWidth;
          obj.pointColl[n].ratioY = (obj.pointColl[n].y - destTop) / destHeight;
        }
        var prevPoint = undefined;
        if (isNullOrUndefined(obj.pointColl[obj.pointColl.length - 2])) {
          prevPoint = { x: 0, y: 0 };
        } else {
          prevPoint = { x: obj.pointColl[obj.pointColl.length - 2].x, y: obj.pointColl[obj.pointColl.length - 2].y };
        }
        var diffX = obj.pointColl[obj.pointColl.length - 1].x - prevPoint.x;
        var diffY = obj.pointColl[obj.pointColl.length - 1].y - prevPoint.y;
        obj.activePoint.startX = obj.pointColl[0].x;
        obj.activePoint.startY = obj.pointColl[0].y;
        obj.activePoint.endX = obj.pointColl[obj.pointColl.length - 1].x + diffX / 2;
        obj.activePoint.endY = obj.pointColl[obj.pointColl.length - 1].y + diffY / 2;
        obj = this.updateWidthHeight(obj);
      }
    };
    Shape2.prototype.flipLineArrowObj = function(obj, value) {
      value = value.toLowerCase();
      if (isNullOrUndefined(obj.pointColl)) {
        return;
      }
      if (value === "horizontal") {
        this.lineArrowHorizontalFlip(obj);
      } else if (value === "vertical") {
        this.lineArrowVerticalFlip(obj);
      } else {
        this.lineArrowHorizontalFlip(obj);
        obj.shapeFlip = "";
        this.lineArrowVerticalFlip(obj);
      }
      obj.activePoint.startX = obj.pointColl[0].x;
      obj.activePoint.startY = obj.pointColl[0].y;
      obj.activePoint.endX = obj.pointColl[obj.pointColl.length - 1].x;
      obj.activePoint.endY = obj.pointColl[obj.pointColl.length - 1].y;
      if (obj.activePoint.startX > obj.activePoint.endX) {
        var temp = obj.activePoint.startX;
        obj.activePoint.startX = obj.activePoint.endX;
        obj.activePoint.endX = temp;
        temp = obj.activePoint.startY;
        obj.activePoint.startY = obj.activePoint.endY;
        obj.activePoint.endY = temp;
      }
    };
    Shape2.prototype.lineArrowHorizontalFlip = function(obj) {
      var parent = this.parent;
      var _a = parent.img, destWidth = _a.destWidth, destHeight = _a.destHeight, destLeft = _a.destLeft, destTop = _a.destTop;
      if (obj.shapeFlip !== parent.transform.currFlipState) {
        for (var l = 0, len = obj.pointColl.length; l < len; l++) {
          var currPoint = obj.pointColl[l];
          if (currPoint.x <= destLeft + destWidth / 2) {
            currPoint.x = destLeft + destWidth - (currPoint.x - destLeft);
          } else if (currPoint.x >= destLeft + destWidth / 2) {
            currPoint.x = destLeft + (destLeft + destWidth - currPoint.x);
          }
          currPoint.ratioX = (currPoint.x - destLeft) / destWidth;
          currPoint.ratioY = (currPoint.y - destTop) / destHeight;
        }
        if (obj.shape === "arrow") {
          var value = obj.start;
          obj.start = obj.end;
          obj.end = value;
        }
        obj.shapeFlip = parent.transform.currFlipState;
      }
    };
    Shape2.prototype.lineArrowVerticalFlip = function(obj) {
      var parent = this.parent;
      var _a = parent.img, destWidth = _a.destWidth, destHeight = _a.destHeight, destLeft = _a.destLeft, destTop = _a.destTop;
      if (obj.shapeFlip !== parent.transform.currFlipState) {
        for (var l = 0, len = obj.pointColl.length; l < len; l++) {
          var currPoint = obj.pointColl[l];
          if (currPoint.y <= destTop + destHeight / 2) {
            currPoint.y = destTop + destHeight - (currPoint.y - destTop);
          } else if (currPoint.y >= destTop + destHeight / 2) {
            currPoint.y = destTop + (destTop + destHeight - currPoint.y);
          }
          currPoint.ratioX = (currPoint.x - destLeft) / destWidth;
          currPoint.ratioY = (currPoint.y - destTop) / destHeight;
        }
        obj.shapeFlip = parent.transform.currFlipState;
      }
    };
    Shape2.prototype.getRotDegOfShape = function(obj, value) {
      var parent = this.parent;
      var degree;
      if (obj.shapeDegree === 0) {
        degree = this.parent.transform.degree;
      } else {
        degree = this.parent.transform.degree - obj.shapeDegree;
      }
      if (degree < 0) {
        degree = 360 + degree;
      }
      var transformObj = { bool: false };
      parent.notify("selection", { prop: "getTransformedShape", onPropertyChange: false, value: { obj: transformObj } });
      if (transformObj["bool"] && !value && parent.activeObj.rotateFlipColl) {
        degree = 0;
        for (var i = 0; i < parent.activeObj.rotateFlipColl.length; i++) {
          if (typeof parent.activeObj.rotateFlipColl[i] === "number") {
            degree += parent.activeObj.rotateFlipColl[i];
          }
        }
      }
      return degree;
    };
    Shape2.prototype.renderTextArea = function(x, y, actObj) {
      var parent = this.parent;
      var shapeObj = { shapeSettingsObj: {} };
      parent.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj: shapeObj } });
      var shapeSettings = shapeObj["shapeSettingsObj"];
      var shapeChangingArgs = {
        cancel: false,
        action: "text-edit",
        previousShapeSettings: shapeSettings,
        currentShapeSettings: shapeSettings
      };
      parent.trigger("shapeChanging", shapeChangingArgs);
      this.updateShapeChangeEventArgs(shapeChangingArgs.currentShapeSettings, shapeChangingArgs.allowShapeOverflow);
      var degree = this.getRotDegOfShape(parent.activeObj);
      this.transformTextArea();
      parent.notify("toolbar", { prop: "destroy-qa-toolbar", onPropertyChange: false });
      var zOrderElem = parent.element.querySelector("#" + parent.element.id + "_zOrderBtn");
      var dupElem = parent.element.querySelector("#" + parent.element.id + "_duplicate");
      var removeElem = parent.element.querySelector("#" + parent.element.id + "_remove");
      var editTextElem = parent.element.querySelector("#" + parent.element.id + "_editText");
      var shadowColor = actObj.strokeSettings.outlineColor;
      var outlineWidth = actObj.strokeSettings.outlineWidth;
      var shadows = [];
      if (zOrderElem) {
        zOrderElem.classList.add("e-overlay");
      }
      if (dupElem) {
        dupElem.classList.add("e-overlay");
      }
      if (removeElem) {
        removeElem.classList.add("e-overlay");
      }
      if (editTextElem) {
        editTextElem.classList.add("e-overlay");
      }
      if (actObj.strokeSettings.fillColor !== "") {
        parent.textArea.style.backgroundColor = actObj.strokeSettings.fillColor;
      } else {
        parent.textArea.style.backgroundColor = "transparent";
      }
      parent.textArea.style.display = "block";
      parent.textArea.style.left = x + "px";
      parent.textArea.style.top = y + "px";
      parent.textArea.style.fontFamily = actObj.textSettings.fontFamily;
      parent.textArea.style.fontSize = actObj.textSettings.fontSize + "px";
      parent.textArea.style.color = actObj.strokeSettings.strokeColor;
      var fontSize = actObj.textSettings.fontSize;
      var baseWidth = Math.max(1, outlineWidth / 2);
      var adjustedOutlineWidth = baseWidth * (Math.floor((fontSize - 1) / 16) * 0.5 + 0.5);
      if (/^#([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6}|[0-9A-Fa-f]{8})$|^[a-zA-Z]+$/.test(actObj.strokeSettings.outlineColor)) {
        for (var x_1 = -adjustedOutlineWidth; x_1 <= adjustedOutlineWidth; x_1++) {
          for (var y_1 = -adjustedOutlineWidth; y_1 <= adjustedOutlineWidth; y_1++) {
            if (x_1 !== 0 || y_1 !== 0) {
              shadows.push(x_1 / 2 + "px " + y_1 / 2 + "px 0 " + shadowColor);
            }
          }
        }
        parent.textArea.style.textShadow = shadows.join(", ");
      } else {
        parent.textArea.style.textShadow = null;
      }
      parent.textArea.style.fontWeight = actObj.textSettings.bold ? "bold" : "normal";
      parent.textArea.style.fontStyle = actObj.textSettings.italic ? "italic" : "normal";
      parent.textArea.style.border = "2px solid " + parent.themeColl[parent.theme]["primaryColor"];
      parent.textArea.value = actObj.keyHistory;
      parent.textArea.style.overflow = "hidden";
      parent.textArea.style.width = "auto";
      parent.textArea.style.height = "auto";
      parent.textArea.focus();
      var _a = actObj.activePoint, width = _a.width, height = _a.height;
      if (degree % 90 === 0 && degree % 180 !== 0 && degree !== 0) {
        parent.textArea.style.width = height + height * 0.25 + "px";
        parent.textArea.style.height = width + width * 0.25 + "px";
      } else {
        parent.textArea.style.width = width + width * 0.25 + "px";
        parent.textArea.style.height = height + height * 0.25 + "px";
      }
      this.setTextBoxWidth();
      var obj = { flipColl: null };
      parent.notify("transform", { prop: "getFlipColl", onPropertyChange: false, value: { obj } });
      if (obj["flipColl"].length <= 1) {
        this.setTextBoxHeight();
      }
      if (parseFloat(parent.textArea.style.maxHeight) < parent.activeObj.textSettings.fontSize) {
        parent.textArea.style.maxHeight = parent.activeObj.textSettings.fontSize + "px";
      }
      if (degree % 90 === 0 && degree % 180 !== 0) {
        if (parseFloat(parent.textArea.style.left) + parseFloat(parent.textArea.style.width) > parent.img.destTop + parent.img.destHeight) {
          this.alignTextAreaIntoCanvas();
        }
      } else {
        if (parseFloat(parent.textArea.style.left) + parseFloat(parent.textArea.style.width) > parent.img.destLeft + parent.img.destWidth) {
          this.alignTextAreaIntoCanvas();
        }
      }
      if (actObj.rotatedAngle !== 0) {
        var tempLeft = parseFloat(parent.textArea.style.left);
        var tempTop = parseFloat(parent.textArea.style.top);
        if (actObj.flipObjColl.length > 0) {
          var panObj = { panRegion: "" };
          var _b = parent.lowerCanvas, clientWidth = _b.clientWidth, clientHeight = _b.clientHeight;
          var center_1 = { x: 0, y: 0 };
          parent.notify("crop", {
            prop: "getCurrFlipState",
            onPropertyChange: false,
            value: { panObj }
          });
          if (panObj["panRegion"] !== "") {
            if (panObj["panRegion"] === "horizontal") {
              center_1.x = clientWidth - clientWidth / 2;
              tempLeft = center_1.x - tempLeft + center_1.x;
            } else if (panObj["panRegion"] === "vertical") {
              center_1.y = clientHeight - clientHeight / 2;
              tempTop = center_1.y - tempTop + center_1.y;
            } else {
              center_1 = { x: clientWidth - clientWidth / 2, y: clientHeight - clientHeight / 2 };
              tempLeft = center_1.x - tempLeft + center_1.x;
              tempTop = center_1.y - tempTop + center_1.y;
            }
          }
        }
        var left = tempLeft + parseFloat(parent.textArea.style.width);
        var top_1 = tempTop + parseFloat(parent.textArea.style.height);
        var width1 = parseFloat(parent.textArea.style.width);
        var height1 = parseFloat(parent.textArea.style.height);
        var center = { x: left - width1 / 2, y: top_1 - height1 / 2 };
        var cosAngle = Math.cos(actObj.rotatedAngle);
        var sinAngle = Math.sin(actObj.rotatedAngle);
        var p1 = {
          x: cosAngle * (left - center.x) - sinAngle * (top_1 - center.y) + center.x,
          y: sinAngle * (left - center.x) + cosAngle * (top_1 - center.y) + center.y
        };
        if (p1.x > parent.img.destLeft && p1.x < parent.img.destLeft + parent.img.destWidth && // eslint-disable-next-line max-len
        p1.y > parent.img.destTop && p1.y + parseFloat(parent.textArea.style.fontSize) < parent.img.destTop + parent.img.destHeight) {
          parent.textArea.style.width = parent.textArea.style.width;
        } else {
          var count = 0;
          var width2 = parseFloat(parent.textArea.style.width);
          while (true) {
            count++;
            width1 -= 1;
            left = tempLeft + width1;
            center = { x: left - width1 / 2, y: top_1 - height1 / 2 };
            p1 = {
              x: cosAngle * (left - center.x) - sinAngle * (top_1 - center.y) + center.x,
              y: sinAngle * (left - center.x) + cosAngle * (top_1 - center.y) + center.y
            };
            if (p1.x > parent.img.destLeft && p1.x < parent.img.destLeft + parent.img.destWidth && // eslint-disable-next-line max-len
            p1.y > parent.img.destTop && p1.y + parseFloat(parent.textArea.style.fontSize) < parent.img.destTop + parent.img.destHeight || count === width2) {
              parent.textArea.style.width = width1 + "px";
              break;
            }
          }
        }
      }
      parent.notify("selection", { prop: "clearUpperCanvas", onPropertyChange: false });
    };
    Shape2.prototype.setTextBoxWidth = function(e) {
      var parent = this.parent;
      if (parent.activeObj.rotatedAngle !== 0) {
        parent.textArea.style.whiteSpace = "nowrap";
        parent.textArea.style.textOverflow = "ellipsis";
        parent.textArea.style.display = "inline-block";
        return;
      } else {
        parent.textArea.style.whiteSpace = "";
        parent.textArea.style.textOverflow = "";
        if (parent.textArea.style.display === "inline-block") {
          parent.textArea.style.display = "block";
        }
      }
      var text = this.getMaxText(true);
      if (parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block") {
        this.updateFontStyles(true);
      } else {
        this.updateFontStyles();
      }
      var textAreaWidth = this.upperContext.measureText(text).width + parseFloat(parent.textArea.style.fontSize) / 2;
      var letterWidth = e ? this.upperContext.measureText(String.fromCharCode(e.which)).width : 0;
      var actObj = extend({}, parent.activeObj, {}, true);
      var flip2 = "";
      var degree = this.getRotDegOfShape(actObj);
      if (actObj.shapeFlip !== parent.transform.currFlipState) {
        flip2 = "";
      } else {
        flip2 = parent.transform.currFlipState;
      }
      if (e && parseFloat(parent.textArea.style.width) < textAreaWidth + letterWidth || isNullOrUndefined(e)) {
        if (degree === 0) {
          if (flip2.toLowerCase() === "horizontal") {
            if (parseFloat(parent.textArea.style.left) - parent.img.destLeft - textAreaWidth - letterWidth > 0) {
              parent.textArea.style.width = textAreaWidth + letterWidth + "px";
            }
          } else if (parent.img.destWidth - (parseFloat(parent.textArea.style.left) - parent.img.destLeft) > textAreaWidth + letterWidth) {
            parent.textArea.style.width = textAreaWidth + letterWidth + "px";
          }
        } else if (degree === 90) {
          if (flip2.toLowerCase() === "vertical") {
            if (parseFloat(parent.textArea.style.top) - parent.img.destTop - textAreaWidth - letterWidth > 0) {
              parent.textArea.style.width = textAreaWidth + letterWidth + "px";
            }
          } else if (parent.img.destHeight - (parseFloat(parent.textArea.style.top) - parent.img.destTop) > textAreaWidth + letterWidth) {
            parent.textArea.style.width = textAreaWidth + letterWidth + "px";
          }
        } else if (degree === 180) {
          var textAreaLeft = parseFloat(parent.textArea.style.left);
          var destLeft = parent.img.destLeft;
          if (flip2.toLowerCase() === "horizontal") {
            var remainingWidth = parent.img.destWidth - (textAreaLeft - destLeft);
            if (remainingWidth > textAreaWidth + letterWidth) {
              parent.textArea.style.width = textAreaWidth + letterWidth + "px";
            }
          } else {
            var distanceToLeft = textAreaLeft - destLeft;
            if (distanceToLeft - textAreaWidth - letterWidth > 0) {
              parent.textArea.style.width = textAreaWidth + letterWidth + "px";
            }
          }
        } else if (degree === 270) {
          var textAreaTop = parseFloat(parent.textArea.style.top);
          var destTop = parent.img.destTop;
          if (flip2.toLowerCase() === "vertical") {
            var remainingHeight = parent.img.destHeight - (textAreaTop - destTop);
            if (remainingHeight > textAreaWidth + letterWidth) {
              parent.textArea.style.width = textAreaWidth + letterWidth + "px";
            }
          } else {
            var distanceToTop = textAreaTop - destTop;
            if (distanceToTop - textAreaWidth - letterWidth > 0) {
              parent.textArea.style.width = textAreaWidth + letterWidth + "px";
            }
          }
        }
      }
    };
    Shape2.prototype.setTextBoxHeight = function() {
      var parent = this.parent;
      var textAreaTop;
      var actObj = extend({}, parent.activeObj, {}, true);
      var flip2 = "";
      var degree = this.getRotDegOfShape(actObj);
      if (actObj.textFlip === parent.transform.currFlipState) {
        flip2 = "";
      } else if (actObj.textFlip === "") {
        flip2 = parent.transform.currFlipState;
      } else {
        flip2 = actObj.textFlip;
      }
      switch (degree) {
        case 0:
          if (flip2.toLowerCase() === "vertical") {
            parent.textArea.style.maxHeight = parent.img.destHeight - (parent.img.destHeight - parseFloat(parent.textArea.style.top)) + "px";
          } else {
            textAreaTop = parseFloat(parent.textArea.style.top) - parent.img.destTop;
            parent.textArea.style.maxHeight = parent.img.destHeight - textAreaTop + "px";
          }
          break;
        case 90:
          if (flip2.toLowerCase() === "horizontal") {
            parent.textArea.style.maxHeight = parent.img.destWidth - (parseFloat(parent.textArea.style.left) - parent.img.destLeft) + "px";
          } else {
            parent.textArea.style.maxHeight = parseFloat(parent.textArea.style.left) - parent.img.destLeft + "px";
          }
          break;
        case 180:
          if (flip2.toLowerCase() === "vertical") {
            textAreaTop = parseFloat(parent.textArea.style.top) - parent.img.destTop;
            parent.textArea.style.maxHeight = parent.img.destHeight - textAreaTop + "px";
          } else {
            parent.textArea.style.maxHeight = parseFloat(parent.textArea.style.top) - parent.img.destTop + "px";
          }
          break;
        case 270:
          if (flip2.toLowerCase() === "horizontal") {
            parent.textArea.style.maxHeight = parseFloat(parent.textArea.style.left) - parent.img.destLeft + "px";
          } else {
            parent.textArea.style.maxHeight = parent.img.destWidth - (parseFloat(parent.textArea.style.left) - parent.img.destLeft) + "px";
          }
          break;
      }
    };
    Shape2.prototype.updatePathRatio = function(obj) {
      var parent = this.parent;
      for (var i = 0, len = obj.pointColl.length; i < len; i++) {
        var currPoint = obj.pointColl[i];
        currPoint.ratioX = (currPoint.x - parent.img.destLeft) / parent.img.destWidth;
        currPoint.ratioY = (currPoint.y - parent.img.destTop) / parent.img.destHeight;
      }
    };
    Shape2.prototype.stopPathDrawing = function(e, isApply) {
      var parent = this.parent;
      if (parent.activeObj.shape === "path") {
        var obj = { shape: null };
        parent.notify("selection", { prop: "getCurrentDrawingShape", value: { obj } });
        if (obj["shape"] === "path") {
          var prevCropObj = extend({}, parent.cropObj, {}, true);
          var object = { currObj: {} };
          parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
          var prevObj = object["currObj"];
          prevObj.objColl = extend([], parent.objColl, [], true);
          prevObj.pointColl = extend([], parent.pointColl, [], true);
          prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
          var selPointCollObj = { selPointColl: null };
          parent.notify("freehand-draw", {
            prop: "getSelPointColl",
            onPropertyChange: false,
            value: { obj: selPointCollObj }
          });
          prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
          parent.notify("selection", { prop: "setCurrentDrawingShape", value: { value: "" } });
          parent.currObjType.isDragging = false;
          if (e && e.type !== "touchstart" && isNullOrUndefined(isApply)) {
            parent.activeObj.pointColl.pop();
          }
          this.updatePathRatio(parent.activeObj);
          if (isNullOrUndefined(parent.activeObj.imageRatio)) {
            parent.notify("shape", { prop: "updImgRatioForActObj", onPropertyChange: false });
          }
          parent.objColl.push(parent.activeObj);
          parent.notify("undo-redo", {
            prop: "updateUndoRedoColl",
            onPropertyChange: false,
            value: {
              operation: "shapeTransform",
              previousObj: prevObj,
              previousObjColl: prevObj.objColl,
              previousPointColl: prevObj.pointColl,
              previousSelPointColl: prevObj.selPointColl,
              previousCropObj: prevCropObj,
              previousText: null,
              currentText: null,
              previousFilter: null,
              isCircleCrop: null
            }
          });
          parent.objColl.pop();
          if (e) {
            parent.notify("selection", { prop: "mouseUpEventHandler", value: { e } });
            this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
            parent.notify("draw", { prop: "redrawImgWithObj", onPropertyChange: false });
            if (parent.objColl.length > 0) {
              var obj1 = parent.activeObj.activePoint;
              var obj2 = parent.objColl[parent.objColl.length - 1].activePoint;
              if (Math.floor(obj1.startX) === Math.floor(obj2.startX) && Math.floor(obj1.startY) === Math.floor(obj2.startY) && Math.floor(obj1.endX) === Math.floor(obj2.endX) && Math.floor(obj1.endY) === Math.floor(obj2.endY)) {
                this.refreshActiveObj();
              }
            }
          }
          parent.notify("draw", { prop: "setNewPath", value: { bool: true } });
          if (parent.objColl[parent.objColl.length - 1]) {
            var shape = parent.drawingShape;
            parent.notify("selection", { prop: "setCurrentDrawingShape", value: { value: "" } });
            parent.noRedact = true;
            parent.selectShape(parent.objColl[parent.objColl.length - 1].currIndex);
            parent.notify("selection", { prop: "setCurrentDrawingShape", value: { value: "path" } });
            parent.drawingShape = shape;
          }
          parent.notify("toolbar", { prop: "renderQAT", onPropertyChange: false, value: { isPenEdit: null } });
          var obj_1 = { shapeSettingsObj: {} };
          parent.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj: obj_1 } });
          var shapeSettings = obj_1["shapeSettingsObj"];
          var shapeResizingArgs = { cancel: false, action: "draw-end", previousShapeSettings: shapeSettings };
          var shapeMovingArgs = { cancel: false, action: "move", previousShapeSettings: shapeSettings };
          parent.notify("selection", {
            prop: "triggerShapeChange",
            onPropertyChange: false,
            value: { shapeResizingArgs, shapeMovingArgs, type: "mouse-up" }
          });
          parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
        }
      }
    };
    Shape2.prototype.findTextTarget = function(e) {
      var parent = this.parent;
      if (!e) {
        return;
      }
      if (parent.activeObj.shape !== "text") {
        if (parent.activeObj.shape === "path") {
          this.stopPathDrawing(e, null);
          return;
        } else if (e.type === "dblclick") {
          parent.notify("selection", { prop: "setPanDown", onPropertyChange: false, value: { panDown: null } });
          var activeObj = extend({}, parent.activeObj, {}, true);
          var objColl = extend([], parent.objColl, [], true);
          var obj = { bool: null };
          parent.notify("selection", {
            prop: "findTargetObj",
            onPropertyChange: false,
            value: { x: e.clientX, y: e.clientY, isCrop: false, obj }
          });
          parent.objColl = objColl;
          if (!obj["bool"] || parent.activeObj.shape !== "text") {
            parent.activeObj = extend({}, activeObj, {}, true);
            return;
          }
        } else {
          return;
        }
      }
      var x;
      var y;
      if (e.type === "dblclick") {
        x = e.clientX;
        y = e.clientY;
      } else if (e.type === "touchstart") {
        x = e.touches[0].clientX;
        y = e.touches[0].clientY;
        parent.notify("selection", {
          prop: "setTouchEndPoint",
          onPropertyChange: false,
          value: { x: e.touches[0].clientX, y: e.touches[0].clientY }
        });
      }
      parent.notify("toolbar", { prop: "setPreventZoomBtn", onPropertyChange: false, value: { isPrevent: true } });
      parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
        type: "text",
        isApplyBtn: null,
        isCropping: null,
        isZooming: null,
        cType: null
      } });
      parent.notify("toolbar", { prop: "setPreventZoomBtn", onPropertyChange: false, value: { isPrevent: false } });
      parent.notify("toolbar", { prop: "update-toolbar-items", onPropertyChange: false });
      if (!isNullOrUndefined(x) && !isNullOrUndefined(y)) {
        var bbox = parent.lowerCanvas.getBoundingClientRect();
        x -= bbox.left;
        y -= bbox.top;
        var flip2 = "";
        var degree = this.getRotDegOfShape(parent.activeObj);
        if (parent.activeObj.textFlip === "") {
          if (parent.activeObj.textFlip === parent.transform.currFlipState) {
            flip2 = "";
          } else {
            flip2 = parent.transform.currFlipState;
          }
        } else {
          if (parent.activeObj.textFlip === parent.transform.currFlipState) {
            flip2 = "";
          } else if (parent.transform.currFlipState === "") {
            flip2 = parent.activeObj.textFlip;
          } else {
            flip2 = parent.transform.currFlipState;
          }
        }
        var temp = undefined;
        if (parent.textArea.style.display === "none") {
          temp = extend({}, parent.activeObj, {}, true);
          for (var i = 0; i < parent.objColl.length; i++) {
            if (JSON.stringify(parent.activeObj) === JSON.stringify(parent.objColl[i])) {
              parent.objColl.splice(i, 1);
            }
          }
          this.refreshActiveObj();
          this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
          this.lowerContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
          parent.notify("draw", { prop: "redrawImgWithObj", onPropertyChange: false });
          parent.notify("draw", { prop: "redrawDownScale" });
          parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
          parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.upperContext } });
          if (parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle" || parent.isCircleCrop) {
            parent.notify("crop", {
              prop: "cropCircle",
              onPropertyChange: false,
              value: { context: this.lowerContext, isSave: null, isFlip: null }
            });
          }
          parent.activeObj = temp;
          this.updateFontStyles();
          var actObj = extend({}, parent.activeObj, {}, true);
          var radius = actObj.topLeftCircle.radius;
          var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY, width = _a.width, height = _a.height;
          var center = { x: startX + width / 2, y: startY + height / 2 };
          var cosAngle = Math.cos(actObj.rotatedAngle);
          var sinAngle = Math.sin(actObj.rotatedAngle);
          var p1 = {
            x: cosAngle * (startX - center.x) - sinAngle * (startY - center.y) + center.x,
            y: sinAngle * (startX - center.x) + cosAngle * (startY - center.y) + center.y
          };
          var p2 = {
            x: cosAngle * (endX - center.x) - sinAngle * (startY - center.y) + center.x,
            y: sinAngle * (endX - center.x) + cosAngle * (startY - center.y) + center.y
          };
          var p3 = {
            x: cosAngle * (startX - center.x) - sinAngle * (endY - center.y) + center.x,
            y: sinAngle * (startX - center.x) + cosAngle * (endY - center.y) + center.y
          };
          var p4 = {
            x: cosAngle * (endX - center.x) - sinAngle * (endY - center.y) + center.x,
            y: sinAngle * (endX - center.x) + cosAngle * (endY - center.y) + center.y
          };
          var obj = {
            position: null,
            x,
            y,
            x1: p1.x,
            y1: p1.y,
            x2: p2.x,
            y2: p2.y,
            x3: p3.x,
            y3: p3.y,
            x4: p4.x,
            y4: p4.y
          };
          parent.notify("draw", { prop: "checkPointPosition", onPropertyChange: false, value: { obj } });
          if (actObj.rotatedAngle !== 0 && (obj["position"] === "inside" || obj["position"] === "on") || actObj.rotatedAngle === 0 && x >= actObj.activePoint.startX - radius * 2 && x <= actObj.activePoint.endX + radius * 2 && y >= actObj.activePoint.startY - radius * 2 && y <= actObj.activePoint.endY + radius * 2) {
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            if (actObj.flipObjColl.length === 4) {
              actObj.flipObjColl = [];
              flip2 = "";
              actObj.shapeFlip = "";
            }
            if (flip2 === "" && actObj.flipObjColl.length > 1) {
              flip2 = actObj.flipObjColl[actObj.flipObjColl.length - 1];
            }
            if (actObj.flipObjColl.length <= 1) {
              var points = this.setTextBoxPos(actObj, degree, flip2, x, y);
              x = points.x;
              y = points.y;
            } else {
              var points = this.setTextBoxPoints(actObj, degree, flip2, x, y);
              x = points.x;
              y = points.y;
            }
            if (parent.activeObj.rotatedAngle !== 0) {
              var point = this.getTextBoxPosition(parent.activeObj);
              x = point.x;
              y = point.y;
              point = this.setFlipState(x, y, parent.activeObj);
              x = point.x;
              y = point.y;
            }
            this.renderTextArea(x, y, actObj);
          } else {
            this.applyActObj();
          }
        }
      } else if ((parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block") && this.selectedText() !== "" && e.type === "mousedown") {
        var temp = parent.textArea.value;
        parent.textArea.value += "a";
        parent.textArea.value = temp;
      } else if (parent.textArea.style.display === "none") {
        parent.textArea.style.display = "block";
      }
    };
    Shape2.prototype.getTextBoxPosition = function(obj, object) {
      var point = { x: 0, y: 0 };
      var _a = obj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY, width = _a.width, height = _a.height;
      var center = { x: startX + width / 2, y: startY + height / 2 };
      var cosAngle = Math.cos(obj.rotatedAngle);
      var sinAngle = Math.sin(obj.rotatedAngle);
      var p1 = {
        x: cosAngle * (startX - center.x) - sinAngle * (startY - center.y) + center.x,
        y: sinAngle * (startX - center.x) + cosAngle * (startY - center.y) + center.y
      };
      var p2 = {
        x: cosAngle * (endX - center.x) - sinAngle * (startY - center.y) + center.x,
        y: sinAngle * (endX - center.x) + cosAngle * (startY - center.y) + center.y
      };
      var p3 = {
        x: cosAngle * (startX - center.x) - sinAngle * (endY - center.y) + center.x,
        y: sinAngle * (startX - center.x) + cosAngle * (endY - center.y) + center.y
      };
      var p4 = {
        x: cosAngle * (endX - center.x) - sinAngle * (endY - center.y) + center.x,
        y: sinAngle * (endX - center.x) + cosAngle * (endY - center.y) + center.y
      };
      var degree = this.getRotDegOfShape(obj);
      if (degree === 0 || degree === 360) {
        point = { x: p1.x, y: p1.y };
      } else if (degree === 90 || degree === -270) {
        point = { x: p2.x, y: p2.y };
      } else if (degree === 180 || degree === -180) {
        point = { x: p4.x, y: p4.y };
      } else if (degree === 270 || degree === -90) {
        point = { x: p3.x, y: p3.y };
      }
      if (object) {
        object["x"] = point.x;
        object["y"] = point.y;
      }
      return point;
    };
    Shape2.prototype.setFlipState = function(x, y, obj, object) {
      var parent = this.parent;
      var panObj = { panRegion: "" };
      var _a = parent.lowerCanvas, clientWidth = _a.clientWidth, clientHeight = _a.clientHeight;
      var center = { x: 0, y: 0 };
      parent.notify("crop", {
        prop: "getCurrFlipState",
        onPropertyChange: false,
        value: { panObj }
      });
      if (panObj["panRegion"] !== "") {
        if (panObj["panRegion"] === "horizontal") {
          center.x = clientWidth - clientWidth / 2;
          x = center.x - x + center.x;
        } else if (panObj["panRegion"] === "vertical") {
          center.y = clientHeight - clientHeight / 2;
          y = center.y - y + center.y;
        } else {
          center = { x: clientWidth - clientWidth / 2, y: clientHeight - clientHeight / 2 };
          x = center.x - x + center.x;
          y = center.y - y + center.y;
        }
      }
      if (object) {
        object["x"] = x;
        object["y"] = y;
      }
      return { x, y };
    };
    Shape2.prototype.fileChanged = function(e) {
      var filesData = e.target.files[0];
      var fileData = filesData;
      var fileExtension = fileData.name && fileData.name.split(".").pop().toLowerCase();
      if (fileExtension && ["jpg", "jpeg", "png", "svg", "webp"].indexOf(fileExtension) === -1) {
        this.refreshActiveObj();
        return;
      }
      var URL2 = (undefined).URL;
      var url = URL2.createObjectURL(e.target.files[0]);
      this.onLoadImgShape(null, null, null, null, url.toString(), true);
      (undefined).getElementById(this.parent.element.id + "_fileUpload").value = "";
    };
    Shape2.prototype.onLoadImgShape = function(x, y, width, height, url, isSelect, degree, isAspectRatio, opacity, isSelected) {
      var proxy = this;
      var parent = this.parent;
      if (typeof url === "string") {
        this.shapeImg.src = url;
      } else {
        parent.inMemoryCanvas.width = url.width;
        parent.inMemoryCanvas.height = url.height;
        parent.inMemoryCanvas.getContext("2d").putImageData(url, 0, 0);
        this.shapeImg.src = parent.inMemoryCanvas.toDataURL();
      }
      this.prevObjColl();
      parent.activeObj.shape = "image";
      this.initShapeProps();
      this.shapeImg.onload = function() {
        proxy.upperContext.drawImage(proxy.shapeImg, 0, 0, proxy.shapeImg.width, proxy.shapeImg.height);
        proxy.updateImgCanvas(isSelect, x, y, width, height, degree, isAspectRatio, opacity, isSelected);
      };
    };
    Shape2.prototype.updateImgCanvas = function(isSelect, x, y, width, height, degree, isAspectRatio, opacity, isSelected) {
      var parent = this.parent;
      parent.activeObj.imageElement = this.shapeImg;
      parent.activeObj.imageCanvas = parent.createElement("canvas");
      var dimObj = { width: 0, height: 0 };
      parent.notify("transform", {
        prop: "calcMaxDimension",
        onPropertyChange: false,
        value: { width: this.shapeImg.width, height: this.shapeImg.height, obj: dimObj, isImgShape: null }
      });
      if (width && height) {
        if (isAspectRatio) {
          var obj_2 = { ratio: null };
          parent.notify("selection", {
            prop: "findImageRatio",
            onPropertyChange: false,
            value: { width: this.shapeImg.width, height: this.shapeImg.height, obj: obj_2 }
          });
          dimObj = this.resizeImage(width, obj_2["ratio"]);
        } else {
          dimObj = { width, height };
        }
      }
      this.updateObj(dimObj, x, y);
      parent.notify("draw", {
        prop: "downScaleImgCanvas",
        onPropertyChange: false,
        value: { ctx: parent.activeObj.imageCanvas.getContext("2d"), isImgAnnotation: true, isHFlip: null, isVFlip: null }
      });
      parent.notify("transform", {
        prop: "calcMaxDimension",
        onPropertyChange: false,
        value: { width: this.shapeImg.width, height: this.shapeImg.height, obj: dimObj, isImgShape: true }
      });
      if (width && height) {
        if (isAspectRatio) {
          var obj_3 = { ratio: null };
          parent.notify("selection", {
            prop: "findImageRatio",
            onPropertyChange: false,
            value: { width: this.shapeImg.width, height: this.shapeImg.height, obj: obj_3 }
          });
          dimObj = this.resizeImage(width, obj_3["ratio"]);
        } else {
          dimObj = { width, height };
        }
      }
      if (opacity !== null && opacity !== undefined) {
        parent.activeObj.opacity = opacity;
      }
      this.updateObj(dimObj, x, y);
      parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate" } });
      this.shapeImg = null;
      if (degree) {
        parent.activeObj.rotatedAngle = degree * (Math.PI / 180);
        parent.notify("selection", { prop: "updPtCollForShpRot", onPropertyChange: false, value: { obj: parent.activeObj } });
      }
      var obj = { shapeSettingsObj: {} };
      parent.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj } });
      var shapeSettings = obj["shapeSettingsObj"];
      var shapeChangingArgs = {
        cancel: false,
        action: "insert",
        previousShapeSettings: shapeSettings,
        currentShapeSettings: shapeSettings
      };
      parent.trigger("shapeChanging", shapeChangingArgs);
      parent.editCompleteArgs = shapeChangingArgs;
      isSelect = isSelect ? isSelect : isSelected;
      this.drawShapeImageEvent(shapeChangingArgs, isSelect);
      if (parent.isPublicMethod && !isSelected) {
        parent.notify("undo-redo", { prop: "updateUndoRedo", onPropertyChange: false });
      } else if (!parent.isPublicMethod) {
        parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
      }
      parent.isPublicMethod = false;
    };
    Shape2.prototype.updateObj = function(dimObj, x, y) {
      var parent = this.parent;
      parent.activeObj.activePoint.width = dimObj["width"];
      parent.activeObj.activePoint.height = dimObj["height"];
      parent.activeObj.activePoint.startX = x ? x : parent.lowerCanvas.width / 2 - dimObj["width"] / 2;
      parent.activeObj.activePoint.startY = y ? y : parent.lowerCanvas.height / 2 - dimObj["height"] / 2;
      parent.activeObj.activePoint.endX = parent.activeObj.activePoint.startX + dimObj["width"];
      parent.activeObj.activePoint.endY = parent.activeObj.activePoint.startY + dimObj["height"];
    };
    Shape2.prototype.resizeImage = function(newWidth, aspectRatio) {
      var aspectRatioArray = aspectRatio.split(":");
      var aspectRatioWidth = parseInt(aspectRatioArray[0], 10);
      var aspectRatioHeight = parseInt(aspectRatioArray[1], 10);
      var newHeight = Math.round(newWidth * aspectRatioHeight / aspectRatioWidth);
      return { width: newWidth, height: newHeight };
    };
    Shape2.prototype.setTextBoxPos = function(actObj, degree, flip2, x, y) {
      var point = { x, y };
      var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
      flip2 = flip2.toLowerCase();
      switch (degree) {
        case 0:
          if (flip2 === "horizontal") {
            point.x = endX;
            point.y = startY;
          } else if (flip2 === "vertical") {
            point.x = startX;
            point.y = endY;
          } else {
            point.x = startX;
            point.y = startY;
          }
          break;
        case 90:
          if (flip2 === "horizontal") {
            point.x = startX;
            point.y = startY;
          } else if (flip2 === "vertical") {
            point.x = endX;
            point.y = endY;
          } else {
            point.x = endX;
            point.y = startY;
          }
          break;
        case 180:
          if (flip2 === "horizontal") {
            point.x = startX;
            point.y = endY;
          } else if (flip2 === "vertical") {
            point.x = endX;
            point.y = startY;
          } else {
            point.x = endX;
            point.y = endY;
          }
          break;
        case 270:
          if (flip2 === "horizontal") {
            point.x = endX;
            point.y = endY;
          } else if (flip2 === "vertical") {
            point.x = startX;
            point.y = startY;
          } else {
            point.x = startX;
            point.y = endY;
          }
          break;
      }
      return point;
    };
    Shape2.prototype.setTextBoxPoints = function(actObj, degree, flip2, x, y) {
      var point = { x, y };
      var _a = actObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
      flip2 = flip2.toLowerCase();
      switch (degree) {
        case 0:
          if (actObj.flipObjColl[0] && actObj.flipObjColl[0].toLowerCase() === "horizontal") {
            if (flip2 === "horizontal") {
              point.x = startX;
              point.y = startY;
            } else if (flip2 === "vertical") {
              point.x = endX;
              point.y = endY;
            }
          } else {
            if (flip2 === "horizontal") {
              point.x = endX;
              point.y = endY;
            } else if (flip2 === "vertical") {
              point.x = endX;
              point.y = startY;
            }
          }
          break;
        case 90:
          if (actObj.flipObjColl[0] && actObj.flipObjColl[0].toLowerCase() === "horizontal") {
            if (flip2 === "horizontal") {
              point.x = endX;
              point.y = endY;
            } else if (flip2 === "vertical") {
              point.x = startX;
              point.y = endY;
            }
          } else {
            if (flip2 === "horizontal") {
              point.x = startX;
              point.y = endY;
            } else if (flip2 === "vertical") {
              point.x = startX;
              point.y = startY;
            }
          }
          break;
        case 180:
          if (actObj.flipObjColl[0] && actObj.flipObjColl[0].toLowerCase() === "horizontal") {
            if (flip2 === "horizontal") {
              point.x = startX;
              point.y = startY;
            } else if (flip2 === "vertical") {
              point.x = startX;
              point.y = startY;
            }
          } else {
            if (flip2 === "horizontal") {
              point.x = startX;
              point.y = startY;
            } else if (flip2 === "vertical") {
              point.x = startX;
              point.y = endY;
            }
          }
          break;
        case 270:
          if (actObj.flipObjColl[0] && actObj.flipObjColl[0].toLowerCase() === "horizontal") {
            if (flip2 === "horizontal") {
              point.x = startX;
              point.y = startY;
            } else if (flip2 === "vertical") {
              point.x = endX;
              point.y = startY;
            }
          } else {
            if (flip2 === "horizontal") {
              point.x = endX;
              point.y = startY;
            } else if (flip2 === "vertical") {
              point.x = endX;
              point.y = endY;
            }
          }
          break;
      }
      return point;
    };
    Shape2.prototype.selectedText = function() {
      var parent = this.parent;
      var start = parent.textArea.selectionStart;
      var finish = parent.textArea.selectionEnd;
      return parent.textArea.value.substring(start, finish);
    };
    Shape2.prototype.panObjColl = function(xDiff, yDiff, panRegion) {
      var parent = this.parent;
      if (parent.objColl.length > 0) {
        for (var i = 0, len = parent.objColl.length; i < len; i++) {
          var currObj = parent.objColl[i];
          if (panRegion === "") {
            currObj.activePoint.startX += xDiff;
            currObj.activePoint.endX += xDiff;
            if (currObj.rotationCirclePointColl) {
              currObj.rotationCirclePointColl.x += xDiff;
            }
            if (currObj.shape === "path") {
              for (var l = 0, len_3 = currObj.pointColl.length; l < len_3; l++) {
                currObj.pointColl[l].x += xDiff;
              }
            }
            currObj.activePoint.startY += yDiff;
            currObj.activePoint.endY += yDiff;
            if (currObj.rotationCirclePointColl) {
              currObj.rotationCirclePointColl.y += yDiff;
            }
            if (currObj.shape === "path") {
              for (var l = 0; l < currObj.pointColl.length; l++) {
                currObj.pointColl[l].y += yDiff;
              }
            }
          }
          currObj = this.updateWidthHeight(currObj);
          parent.notify("draw", { prop: "updateActiveObject", onPropertyChange: false, value: {
            actPoint: currObj.activePoint,
            obj: currObj
          } });
          if (currObj.shape === "line" || currObj.shape === "arrow") {
            currObj.pointColl = this.getLinePoints(currObj.activePoint.startX, currObj.activePoint.startY, currObj.activePoint.endX, currObj.activePoint.endY);
            for (var j = 0, len_4 = currObj.pointColl.length; j < len_4; j++) {
              currObj.pointColl[j].ratioX = (currObj.pointColl[j].x - parent.img.destLeft) / parent.img.destWidth;
              currObj.pointColl[j].ratioY = (currObj.pointColl[j].y - parent.img.destTop) / parent.img.destHeight;
            }
          }
          this.refreshActiveObj();
        }
        var temp = this.lowerContext.filter;
        this.lowerContext.filter = "none";
        this.iterateObjColl();
        this.lowerContext.filter = temp;
        this.refreshActiveObj();
        parent.notify("draw", { prop: "applyFrame", value: { ctx: this.lowerContext, frame: parent.frameObj.type, preventImg: true } });
      }
    };
    Shape2.prototype.updateFontStyles = function(isTextBox) {
      var parent = this.parent;
      this.upperContext.strokeStyle = parent.activeObj.strokeSettings.strokeColor;
      this.upperContext.fillStyle = parent.activeObj.strokeSettings.strokeColor;
      var textStyle = "";
      if (parent.activeObj.textSettings.bold) {
        textStyle = "bold ";
      }
      if (parent.activeObj.textSettings.italic) {
        textStyle = "italic ";
      }
      if (parent.activeObj.textSettings.bold && parent.activeObj.textSettings.italic) {
        textStyle = "italic bold ";
      }
      var fontSize = isTextBox ? parseFloat(parent.textArea.style.fontSize) : parent.activeObj.textSettings.fontSize;
      var fontFamily = parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block" ? parent.textArea.style.fontFamily : parent.activeObj.textSettings.fontFamily;
      this.upperContext.font = textStyle + fontSize + "px " + fontFamily;
    };
    Shape2.prototype.applyFontStyle = function(item) {
      var parent = this.parent;
      var obj = { shapeSettingsObj: {} };
      parent.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj } });
      var shapeSettings = obj["shapeSettingsObj"];
      this.pushActItemIntoObj();
      var objColl = extend([], parent.objColl, [], true);
      parent.objColl.pop();
      if (parent.textArea.style.display === "none") {
        this.updateFontRatio(parent.activeObj);
      } else {
        this.updateFontRatio(parent.activeObj, true);
      }
      switch (item) {
        case "default":
          this.updateFontStyle(item, objColl, "normal", "normal");
          break;
        case "bold":
          this.updateFontStyle(item, objColl, "bold", "normal");
          break;
        case "italic":
          this.updateFontStyle(item, objColl, "normal", "italic");
          break;
        case "bolditalic":
          this.updateFontStyle(item, objColl, "bold", "italic");
          break;
      }
      var shapeChangedArgs = { action: "font-style", currentShapeSettings: extend({}, shapeSettings, {}, true) };
      shapeChangedArgs.currentShapeSettings.fontStyle = [item];
      parent.trigger("shapeChange", shapeChangedArgs);
      parent.editCompleteArgs = shapeChangedArgs;
    };
    Shape2.prototype.updateFontStyle = function(item, objColl, fontWeight, fontStyle) {
      var parent = this.parent;
      var style = parent.textArea.style;
      if (style.display === "block" || style.display === "inline-block") {
        if (fontWeight === "bold") {
          style.fontWeight = "bold";
        } else {
          style.fontWeight = "normal";
        }
        if (fontStyle === "italic") {
          style.fontStyle = "italic";
        } else {
          style.fontStyle = "normal";
        }
        var value = style.fontWeight === "normal" && style.fontStyle === "normal" ? "default" : style.fontWeight === "bold" && style.fontStyle === "normal" ? "bold" : style.fontWeight === "normal" && style.fontStyle === "italic" ? "italic" : "bolditalic";
        var width = this.getTextAreaWidth(value);
        style.width = width + "px";
        this.updateObjColl(item, objColl);
      } else {
        this.textSettings.bold = parent.activeObj.textSettings.bold = fontWeight === "normal" ? false : true;
        this.textSettings.italic = parent.activeObj.textSettings.italic = fontStyle === "normal" ? false : true;
        if (parent.activeObj.activePoint.width !== 0 || parent.activeObj.activePoint.height !== 0) {
          this.redrawText();
        }
        parent.notify("undo-redo", { prop: "updateUrObj", onPropertyChange: false, value: { objColl } });
      }
    };
    Shape2.prototype.updateArrowRatio = function(obj) {
      var parent = this.parent;
      var object = { arrowDimension: null };
      parent.notify("draw", { prop: "getArrowDimension", onPropertyChange: false, value: { obj: object } });
      var length;
      if (Math.abs(obj.activePoint.width) > Math.abs(obj.activePoint.height)) {
        length = Math.abs(obj.activePoint.width);
      } else {
        length = Math.abs(obj.activePoint.height);
      }
      var dimension;
      var dimensions = ["bar", "arrow", "arrowSolid", "circle", "square"];
      for (var _i = 0, dimensions_1 = dimensions; _i < dimensions_1.length; _i++) {
        dimension = dimensions_1[_i];
        var ratioX = length / object["arrowDimension"][dimension]["width"];
        var ratioY = length / object["arrowDimension"][dimension]["height"];
        object["arrowDimension"][dimension]["ratioX"] = ratioX;
        object["arrowDimension"][dimension]["ratioY"] = ratioY;
      }
    };
    Shape2.prototype.updateArrowSize = function(obj) {
      var object = { arrowDimension: null };
      this.parent.notify("draw", { prop: "getArrowDimension", onPropertyChange: false, value: { obj: object } });
      var length;
      if (Math.abs(obj.activePoint.width) > Math.abs(obj.activePoint.height)) {
        length = Math.abs(obj.activePoint.width);
      } else {
        length = Math.abs(obj.activePoint.height);
      }
      var dimension;
      var dimensions = ["bar", "arrow", "arrowSolid", "circle", "square"];
      for (var _i = 0, dimensions_2 = dimensions; _i < dimensions_2.length; _i++) {
        dimension = dimensions_2[_i];
        var ratioX = object["arrowDimension"][dimension]["ratioX"];
        var ratioY = object["arrowDimension"][dimension]["ratioY"];
        object["arrowDimension"][dimension]["width"] = length / ratioX;
        object["arrowDimension"][dimension]["height"] = length / ratioY;
      }
    };
    Shape2.prototype.updateFontRatio = function(obj, isTextArea) {
      var parent = this.parent;
      var text = this.getMaxText(isTextArea);
      var width = this.upperContext.measureText(text).width + parent.activeObj.textSettings.fontSize * 0.5;
      var height = parent.activeObj.textSettings.fontSize;
      var degree = this.getRotDegOfShape(obj);
      if (isNullOrUndefined(isTextArea)) {
        if (degree === 0 || Math.abs(degree) === 180) {
          obj.textSettings.fontRatio = width / obj.textSettings.fontSize;
        } else {
          obj.textSettings.fontRatio = height / obj.textSettings.fontSize;
        }
      } else if (isTextArea) {
        var transformObj = { bool: false };
        parent.notify("selection", { prop: "getTransformedShape", onPropertyChange: false, value: { obj: transformObj } });
        if (!transformObj["bool"] || degree === 0 || Math.abs(degree) === 180) {
          obj.textSettings.fontRatio = width / parseFloat(parent.textArea.style.fontSize);
        } else {
          obj.textSettings.fontRatio = height / parseFloat(parent.textArea.style.fontSize);
        }
      }
    };
    Shape2.prototype.updateFontSize = function(obj) {
      var degree = this.getRotDegOfShape(obj, true);
      if (degree === 0 || Math.abs(degree) === 180) {
        obj.textSettings.fontSize = obj.activePoint.width / obj.textSettings.fontRatio;
      } else {
        obj.textSettings.fontSize = obj.activePoint.height / obj.textSettings.fontRatio;
      }
    };
    Shape2.prototype.updateObjColl = function(item, objColl) {
      var parent = this.parent;
      var prevCropObj = extend({}, parent.cropObj, {}, true);
      var object = { currObj: {} };
      parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
      var prevObj = object["currObj"];
      prevObj.objColl = objColl;
      prevObj.pointColl = extend([], parent.pointColl, [], true);
      prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      parent.notify("freehand-draw", {
        prop: "getSelPointColl",
        onPropertyChange: false,
        value: { obj: selPointCollObj }
      });
      prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
      var tempBold = parent.activeObj.textSettings.bold;
      var tempItalic = parent.activeObj.textSettings.italic;
      switch (item) {
        case "default":
          parent.activeObj.textSettings.bold = false;
          parent.activeObj.textSettings.italic = false;
          break;
        case "bold":
          parent.activeObj.textSettings.bold = true;
          parent.activeObj.textSettings.italic = false;
          break;
        case "italic":
          parent.activeObj.textSettings.bold = false;
          parent.activeObj.textSettings.italic = true;
          break;
        case "bolditalic":
          parent.activeObj.textSettings.bold = true;
          parent.activeObj.textSettings.italic = true;
          break;
      }
      parent.objColl.push(parent.activeObj);
      parent.notify("undo-redo", {
        prop: "updateUndoRedoColl",
        onPropertyChange: false,
        value: {
          operation: "textAreaCustomization",
          previousObj: prevObj,
          previousObjColl: prevObj.objColl,
          previousPointColl: prevObj.pointColl,
          previousSelPointColl: prevObj.selPointColl,
          previousCropObj: prevCropObj,
          previousText: null,
          currentText: null,
          previousFilter: null,
          isCircleCrop: null
        }
      });
      parent.objColl.pop();
      parent.activeObj.textSettings.bold = tempBold;
      parent.activeObj.textSettings.italic = tempItalic;
    };
    Shape2.prototype.pushActItemIntoObj = function() {
      var parent = this.parent;
      if (parent.textArea.style.display === "none") {
        if (parent.activeObj.activePoint.width !== 0 || parent.activeObj.activePoint.height !== 0) {
          parent.objColl.push(parent.activeObj);
        }
      } else {
        var temp = extend({}, parent.activeObj, {}, true);
        parent.notify("selection", { prop: "setTextBoxStylesToActObj", onPropertyChange: false });
        parent.objColl.push(parent.activeObj);
        parent.activeObj = temp;
      }
    };
    Shape2.prototype.clearActObj = function() {
      var parent = this.parent;
      if (parent.textArea.style.display === "none") {
        this.refreshActiveObj();
        this.applyActObj();
        this.refreshActiveObj();
        parent.currObjType.isCustomCrop = false;
      }
    };
    Shape2.prototype.refreshActiveObj = function() {
      var parent = this.parent;
      parent.activeObj = {};
      parent.activeObj.activePoint = { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 };
      parent.activeObj.triangle = [];
      parent.activeObj.triangleRatio = [];
      parent.activeObj.order = null;
      parent.activeObj.flipObjColl = [];
      parent.activeObj.strokeSettings = this.strokeSettings;
      parent.activeObj.textSettings = this.textSettings;
      parent.activeObj.rotatedAngle = 0;
      parent.activeObj.opacity = 1;
      parent.activeObj.redactType = this.redactType;
      parent.activeObj.redactBlur = parent.tempRedactBlur;
      parent.activeObj.redactPixelate = parent.tempRedactPixel;
    };
    Shape2.prototype.applyActObj = function(isMouseDown) {
      var parent = this.parent;
      var isActObj = false;
      if (parent.activeObj.shape !== undefined && parent.activeObj.shape === "text" && parent.activeObj.keyHistory === "") {
        this.refreshActiveObj();
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      } else {
        var splitWords = undefined;
        var isCropSelection = false;
        if (parent.activeObj.shape !== undefined) {
          splitWords = parent.activeObj.shape.split("-");
        }
        if (splitWords === undefined && parent.currObjType.isCustomCrop) {
          isCropSelection = true;
        } else if (splitWords !== undefined && splitWords[0] === "crop") {
          isCropSelection = true;
        }
        if (parent.activeObj.shape && !isCropSelection && parent.activeObj.shape !== "shape") {
          for (var i = 0; i < parent.objColl.length; i++) {
            if (JSON.stringify(parent.activeObj) === JSON.stringify(parent.objColl[i])) {
              isActObj = true;
              break;
            }
          }
          if (!isActObj) {
            if (isNullOrUndefined(parent.activeObj.currIndex)) {
              parent.activeObj.currIndex = this.getNewShapeId();
            }
            if (isNullOrUndefined(parent.activeObj.order)) {
              parent.activeObj.order = this.getNewOrder();
            }
            this.updImgRatioForActObj();
            var splitWords_1 = parent.activeObj.currIndex.split("_");
            var tempObjColl = parent.objColl.splice(0, parseInt(splitWords_1[1], 10) - 1);
            tempObjColl.push(extend({}, parent.activeObj, {}, true));
            for (var i = 0; i < parent.objColl.length; i++) {
              tempObjColl.push(parent.objColl[i]);
            }
            parent.objColl = tempObjColl;
            tempObjColl = [];
            this.refreshActiveObj();
            this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
            parent.notify("draw", { prop: "redrawImgWithObj", onPropertyChange: false });
            parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
            parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.upperContext } });
            parent.currObjType.shape = "";
            this.refreshActiveObj();
            if (parent.isCircleCrop) {
              parent.notify("crop", {
                prop: "cropCircle",
                onPropertyChange: false,
                value: { context: this.lowerContext, isSave: null, isFlip: null }
              });
            }
            parent.notify("toolbar", { prop: "destroy-qa-toolbar", onPropertyChange: false });
            if (isNullOrUndefined(isMouseDown)) {
              parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
              parent.notify("draw", { prop: "setPrevActObj", onPropertyChange: false, value: { prevActObj: null } });
            }
          }
        }
      }
    };
    Shape2.prototype.getNewShapeId = function() {
      var parent = this.parent;
      var value = parent.objColl.length + 1;
      for (var i = 0; i < parent.objColl.length; i++) {
        if (parent.objColl[i].currIndex === "shape_" + value) {
          value++;
          i = -1;
        }
      }
      return "shape_" + value;
    };
    Shape2.prototype.getNewOrder = function() {
      var parent = this.parent;
      this.updateShapeColl();
      var value = parent.shapeColl.length + 1;
      for (var i = 0; i < parent.shapeColl.length; i++) {
        if (parent.shapeColl[i].order === value) {
          value++;
          i = -1;
        }
      }
      return value;
    };
    Shape2.prototype.getHighestOrder = function() {
      var parent = this.parent;
      this.updateShapeColl();
      var value = 0;
      for (var i = 0; i < parent.shapeColl.length; i++) {
        if (parent.shapeColl[i].order > value) {
          value = parent.shapeColl[i].order;
        }
      }
      return value;
    };
    Shape2.prototype.getLowestOrder = function() {
      var parent = this.parent;
      this.updateShapeColl();
      var value = 1;
      for (var i = 0; i < parent.shapeColl.length; i++) {
        if (parent.shapeColl[i].order < value) {
          value = parent.shapeColl[i].order;
        }
      }
      return value;
    };
    Shape2.prototype.alignTextAreaIntoCanvas = function() {
      var parent = this.parent;
      var letters = parent.textArea.value;
      parent.textArea.value = "";
      for (var i = 0, len = letters.length; i < len; i++) {
        parent.textArea.value += letters[i];
        parent.textArea.style.height = "auto";
        parent.textArea.style.height = parent.textArea.scrollHeight + "px";
        this.setTextBoxWidth();
      }
    };
    Shape2.prototype.transformTextArea = function() {
      var parent = this.parent;
      if (parent.activeObj.shape === "text") {
        parent.textArea.style.transformOrigin = "0 0";
        var rotatedDegree = parent.activeObj.rotatedAngle * (180 / Math.PI);
        var scale = "";
        var degree = this.getRotDegOfShape(parent.activeObj);
        if (parent.activeObj.flipObjColl.length > 0) {
          for (var i = 0; i < parent.activeObj.flipObjColl.length; i++) {
            if (degree !== 0 && degree % 90 === 0 && degree !== 180) {
              scale += parent.activeObj.flipObjColl[i].toLowerCase() === "horizontal" ? "scale(1, -1)" : "scale(-1, 1)";
            } else {
              scale += parent.activeObj.flipObjColl[i].toLowerCase() === "horizontal" ? "scale(-1, 1)" : "scale(1, -1)";
            }
            degree += rotatedDegree;
            if (parent.activeObj.flipObjColl[i].toLowerCase() === "horizontal") {
              parent.textArea.style.transform = "rotate(" + degree + "deg)" + scale;
            } else if (parent.activeObj.flipObjColl[i].toLowerCase() === "vertical") {
              parent.textArea.style.transform = "rotate(" + degree + "deg)" + scale;
            }
          }
        } else {
          degree += rotatedDegree;
          parent.textArea.style.transform = "rotate(" + degree + "deg)";
        }
      }
    };
    Shape2.prototype.getTextAreaWidth = function(item) {
      var parent = this.parent;
      var tempBold = parent.activeObj.textSettings.bold;
      var tempItalic = parent.activeObj.textSettings.italic;
      switch (item) {
        case "default":
          parent.activeObj.textSettings.bold = false;
          parent.activeObj.textSettings.italic = false;
          break;
        case "bold":
          parent.activeObj.textSettings.bold = true;
          parent.activeObj.textSettings.italic = false;
          break;
        case "italic":
          parent.activeObj.textSettings.bold = false;
          parent.activeObj.textSettings.italic = true;
          break;
        case "bolditalic":
          parent.activeObj.textSettings.bold = true;
          parent.activeObj.textSettings.italic = true;
          break;
      }
      var isTextArea = parent.textArea.style.display === "none" ? false : true;
      this.updateFontStyles(isTextArea);
      var width;
      if (!isTextArea) {
        width = this.upperContext.measureText(parent.activeObj.keyHistory).width + parent.activeObj.textSettings.fontSize * 0.5;
      } else {
        width = this.upperContext.measureText(parent.textArea.value).width + parent.activeObj.textSettings.fontSize * 0.5;
      }
      parent.activeObj.textSettings.bold = tempBold;
      parent.activeObj.textSettings.italic = tempItalic;
      return width;
    };
    Shape2.prototype.getRedactObjDetails = function(obj) {
      var parent = this.parent;
      var redactDetails = {};
      redactDetails.id = obj.currIndex;
      redactDetails.type = parent.toPascalCase(obj.redactType);
      redactDetails.startX = obj.activePoint.startX;
      redactDetails.startY = obj.activePoint.startY;
      redactDetails.width = obj.activePoint.width;
      redactDetails.height = obj.activePoint.height;
      switch (obj.redactType) {
        case "blur":
          redactDetails.blurIntensity = obj.redactBlur;
          break;
        case "pixelate":
          redactDetails.pixelSize = obj.redactPixelate;
          break;
      }
      return redactDetails;
    };
    Shape2.prototype.getObjDetails = function(obj) {
      var parent = this.parent;
      var shapeDetails = {};
      shapeDetails.id = obj.currIndex;
      shapeDetails.type = parent.toPascalCase(obj.shape);
      shapeDetails.startX = obj.activePoint.startX;
      shapeDetails.startY = obj.activePoint.startY;
      shapeDetails.index = obj.order;
      var transformObj = { coll: null };
      switch (obj.shape) {
        case "rectangle":
          shapeDetails.width = obj.activePoint.width;
          shapeDetails.height = obj.activePoint.height;
          shapeDetails.strokeColor = obj.strokeSettings.strokeColor;
          shapeDetails.fillColor = obj.strokeSettings.fillColor;
          shapeDetails.strokeWidth = obj.strokeSettings.strokeWidth;
          shapeDetails.degree = obj.rotatedAngle * (180 / Math.PI);
          break;
        case "ellipse":
          shapeDetails.radius = obj.activePoint.width / 2;
          shapeDetails.strokeColor = obj.strokeSettings.strokeColor;
          shapeDetails.fillColor = obj.strokeSettings.fillColor;
          shapeDetails.strokeWidth = obj.strokeSettings.strokeWidth;
          shapeDetails.radiusX = obj.activePoint.width / 2;
          shapeDetails.radiusY = obj.activePoint.height / 2;
          shapeDetails.degree = obj.rotatedAngle * (180 / Math.PI);
          break;
        case "line":
        case "arrow":
          shapeDetails.length = obj.activePoint.width;
          shapeDetails.strokeColor = obj.strokeSettings.strokeColor;
          shapeDetails.strokeWidth = obj.strokeSettings.strokeWidth;
          shapeDetails.endX = obj.activePoint.endX;
          shapeDetails.endY = obj.activePoint.endY;
          if (obj.shape === "arrow") {
            var arrowObj = { type: null };
            parent.notify("selection", { prop: "getArrowType", onPropertyChange: false, value: { type: obj.start, obj: arrowObj } });
            shapeDetails.arrowHead = arrowObj["type"];
            parent.notify("selection", { prop: "getArrowType", onPropertyChange: false, value: { type: obj.end, obj: arrowObj } });
            shapeDetails.arrowTail = arrowObj["type"];
          }
          break;
        case "text":
          shapeDetails.text = obj.keyHistory;
          shapeDetails.fontSize = obj.textSettings.fontSize;
          shapeDetails.fontFamily = obj.textSettings.fontFamily;
          shapeDetails.color = obj.strokeSettings.strokeColor;
          shapeDetails.strokeColor = obj.strokeSettings.outlineColor;
          shapeDetails.fillColor = obj.strokeSettings.fillColor;
          shapeDetails.strokeWidth = obj.strokeSettings.outlineWidth;
          shapeDetails.fontStyle = [];
          if (obj.textSettings.bold) {
            shapeDetails.fontStyle.push("bold");
          }
          if (obj.textSettings.italic) {
            shapeDetails.fontStyle.push("italic");
          }
          shapeDetails.degree = obj.rotatedAngle * (180 / Math.PI);
          parent.notify("selection", { prop: "updateTransColl", onPropertyChange: false, value: { obj: transformObj, object: obj } });
          shapeDetails.transformCollection = transformObj["coll"];
          break;
        case "path":
          shapeDetails.strokeColor = obj.strokeSettings.strokeColor;
          shapeDetails.strokeWidth = obj.strokeSettings.strokeWidth;
          shapeDetails.points = obj.pointColl;
          break;
        case "image":
          shapeDetails.imageData = obj.imageCanvas.toDataURL();
          shapeDetails.degree = obj.rotatedAngle * (180 / Math.PI);
          shapeDetails.width = obj.activePoint.width;
          shapeDetails.height = obj.activePoint.height;
          shapeDetails.opacity = obj.opacity;
          break;
      }
      return shapeDetails;
    };
    Shape2.prototype.getFreehandDrawDetails = function(index) {
      var parent = this.parent;
      var shapeDetails = {};
      shapeDetails.id = parent.pointColl[index].id;
      shapeDetails.type = ShapeType.FreehandDraw;
      shapeDetails.points = extend([], parent.pointColl[index].points);
      shapeDetails.strokeColor = parent.pointColl[index].strokeColor;
      shapeDetails.strokeWidth = parent.pointColl[index].strokeWidth;
      shapeDetails.index = parent.pointColl[index].order;
      return shapeDetails;
    };
    Shape2.prototype.getShapeSetting = function(id, obj) {
      var parent = this.parent;
      var shapeDetails;
      if (!parent.disabled && parent.isImageLoaded) {
        if (parent.textArea.style.display !== "none") {
          parent.okBtn(null, true);
        } else {
          this.applyActObj(true);
        }
        if (id.split("_")[0] === "shape") {
          var obj_4;
          for (var i = 0, len = parent.objColl.length; i < len; i++) {
            if (parent.objColl[i].currIndex === id) {
              obj_4 = extend({}, parent.objColl[i], {}, true);
              break;
            }
          }
          shapeDetails = this.getObjDetails(obj_4);
        } else if (id.split("_")[0] === "pen") {
          shapeDetails = this.getFreehandDrawDetails(parseInt(id.split("_")[1], 10) - 1);
        }
      }
      obj["shapeDetails"] = shapeDetails;
    };
    Shape2.prototype.getShapeSettings = function(obj) {
      var parent = this.parent;
      var shapeDetailsColl = [];
      if (!parent.disabled && parent.isImageLoaded) {
        if (parent.textArea.style.display !== "none") {
          parent.okBtn(null, true);
        } else {
          this.applyActObj(true);
        }
        for (var i = 0, len = parent.objColl.length; i < len; i++) {
          var shapeDetails = this.getObjDetails(parent.objColl[i]);
          shapeDetailsColl.push(shapeDetails);
        }
        for (var i = 0; i < parent.freehandCounter; i++) {
          var shapeDetails = this.getFreehandDrawDetails(i);
          shapeDetailsColl.push(shapeDetails);
        }
      }
      obj["shapeDetailsColl"] = shapeDetailsColl;
    };
    Shape2.prototype.getRedactSettings = function(obj) {
      var parent = this.parent;
      var RedactDetailsColl = [];
      if (!parent.disabled && parent.isImageLoaded) {
        if (parent.textArea.style.display !== "none") {
          parent.okBtn(null, true);
        } else {
          this.applyActObj(true);
        }
        for (var i = 0, len = parent.objColl.length; i < len; i++) {
          var redactDetails = this.getRedactObjDetails(parent.objColl[i]);
          RedactDetailsColl.push(redactDetails);
        }
      }
      obj["shapeDetailsColl"] = RedactDetailsColl;
    };
    Shape2.prototype.isPointsInRange = function(x, y, obj) {
      var inRange = false;
      var parent = this.parent;
      if (!isNullOrUndefined(x) && !isNullOrUndefined(y) && x >= parent.img.destLeft && y >= parent.img.destTop && x <= parent.img.destLeft + parent.img.destWidth && y <= parent.img.destTop + parent.img.destHeight) {
        inRange = true;
      }
      obj["inRange"] = inRange;
    };
    Shape2.prototype.alignRotateFlipColl = function(collection, isRotateFlipCollection, obj) {
      collection = this.popForDefaultTransformedState(collection);
      collection = this.popForDefaultFlipState(collection);
      collection = this.popForDefaultRotateState(collection);
      if (collection.length === 0 && isRotateFlipCollection) {
        this.parent.transform.degree = 0;
        this.parent.transform.currFlipState = "";
      }
      obj["collection"] = collection;
      return collection;
    };
    Shape2.prototype.popForDefaultTransformedState = function(collection) {
      var rotateRight = 0;
      var rotateleft = 0;
      var horizontal = 0;
      var vertical = 0;
      for (var i = 0; i < collection.length; i++) {
        if (collection[i] === 90 || collection[i] === "rotateRight") {
          rotateRight++;
          rotateleft = 0;
          horizontal = 0;
          vertical = 0;
          if (rotateRight === 4) {
            collection.pop();
            collection.pop();
            collection.pop();
            collection.pop();
          }
        } else if (collection[i] === -90 || collection[i] === "rotateLeft") {
          rotateleft++;
          rotateRight = 0;
          horizontal = 0;
          vertical = 0;
          if (rotateleft === 4) {
            collection.pop();
            collection.pop();
            collection.pop();
            collection.pop();
          }
        } else if (collection[i] === "horizontal" || collection[i] === "Horizontal" || collection[i] === "horizontalflip") {
          horizontal++;
          rotateleft = 0;
          rotateRight = 0;
          vertical = 0;
          if (horizontal === 2) {
            collection.pop();
            collection.pop();
          }
        } else if (collection[i] === "vertical" || collection[i] === "Vertical" || collection[i] === "verticalflip") {
          vertical++;
          horizontal = 0;
          rotateleft = 0;
          rotateRight = 0;
          if (vertical === 2) {
            collection.pop();
            collection.pop();
          }
        }
      }
      return collection;
    };
    Shape2.prototype.popForDefaultFlipState = function(collection) {
      for (var i = 0, iLen = collection.length - 3; i < iLen; i++) {
        var isHorizontal = collection[i] === "horizontal" || collection[i] === "Horizontal" || collection[i] === "horizontalFlip";
        var isVertical = collection[i] === "vertical" || collection[i] === "Vertical" || collection[i] === "verticalFlip";
        var isNextHorizontal = collection[i + 1] === "horizontal" || collection[i + 1] === "Horizontal" || collection[i + 1] === "horizontalFlip";
        var isNextVertical = collection[i + 1] === "vertical" || collection[i + 1] === "Vertical" || collection[i + 1] === "verticalFlip";
        var isNextToNextHorizontal = collection[i + 2] === "horizontal" || collection[i + 2] === "Horizontal" || collection[i + 2] === "horizontalFlip";
        var isNextToNextVertical = collection[i + 2] === "vertical" || collection[i + 2] === "Vertical" || collection[i + 2] === "verticalFlip";
        var isNextToNextToNextHorizontal = collection[i + 3] === "horizontal" || collection[i + 3] === "Horizontal" || collection[i + 3] === "horizontalFlip";
        if (isHorizontal && isNextVertical && isNextToNextHorizontal && isNextToNextVertical || isVertical && isNextHorizontal && isNextToNextVertical && isNextToNextToNextHorizontal) {
          collection.splice(i, 4);
          i -= 4;
        }
      }
      return collection;
    };
    Shape2.prototype.popForDefaultRotateState = function(collection) {
      for (var i = 0; i < collection.length - 1; i++) {
        var curr = collection[i];
        var next = collection[i + 1];
        if ((curr === 90 || curr === "rotateRight") && (next === -90 || next === "rotateLeft")) {
          collection.splice(i, 2);
          i -= 2;
        } else if ((curr === -90 || curr === "rotateLeft") && (next === 90 || next === "rotateRight")) {
          collection.splice(i, 2);
          i -= 2;
        }
      }
      return collection;
    };
    Shape2.prototype.selectShape = function(id, obj) {
      var parent = this.parent;
      var isSelected = false;
      if (!parent.disabled && parent.isImageLoaded) {
        this.applyActObj();
        if (id.split("_")[0] === "shape") {
          var obj_5;
          for (var i = 0, len = parent.objColl.length; i < len; i++) {
            if (parent.objColl[i].currIndex === id) {
              obj_5 = extend({}, parent.objColl[i], {}, true);
              break;
            }
          }
          if (isNullOrUndefined(obj_5)) {
            isSelected = false;
          } else {
            isSelected = true;
            parent.activeObj = obj_5;
            var object = { canvasFilter: null };
            parent.notify("toolbar", { prop: "getCanvasFilter", onPropertyChange: false, value: { obj: object } });
            this.lowerContext.filter = object["canvasFilter"];
            parent.notify("selection", {
              prop: "redrawShape",
              onPropertyChange: false,
              value: { obj: parent.activeObj }
            });
            if (parent.activeObj.shape === "text") {
              parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
                type: "text",
                isApplyBtn: null,
                isCropping: null,
                isZooming: null,
                cType: null
              } });
            } else if (parent.activeObj.shape === "pen") {
              parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
                type: "pen",
                isApplyBtn: null,
                isCropping: null,
                isZooming: null,
                cType: null
              } });
            } else if (parent.activeObj.shape === "redact") {
              parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
                type: "redact",
                isApplyBtn: null,
                isCropping: null,
                isZooming: null,
                cType: null
              } });
            } else {
              parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
                type: "shapes",
                isApplyBtn: null,
                isCropping: null,
                isZooming: null,
                cType: null
              } });
            }
            parent.notify("toolbar", { prop: "update-toolbar-items", onPropertyChange: false });
            parent.notify("toolbar", { prop: "renderQAT", onPropertyChange: false, value: { isPenEdit: null } });
          }
        } else if (id.split("_")[0] === "pen") {
          var object = { bool: false };
          parent.notify("selection", { prop: "getFreehandDrawEditing", onPropertyChange: false, value: { obj: object } });
          if (object["bool"]) {
            parent.okBtn(null, true);
          }
          var obj_6 = { isIndex: false };
          parent.notify("freehand-draw", { prop: "isFHDIdx", value: { index: parseInt(id.split("_")[1], 10) - 1, obj: obj_6 } });
          if (obj_6["isIndex"]) {
            isSelected = true;
            parent.notify("freehand-draw", { prop: "selectFhd", value: { id } });
            parent.notify("toolbar", { prop: "renderQAT", onPropertyChange: false, value: { isPenEdit: true } });
            parent.notify("toolbar", { prop: "update-toolbar-items", onPropertyChange: false });
          } else {
            isSelected = false;
          }
        }
      }
      obj["isSelected"] = isSelected;
    };
    Shape2.prototype.deleteShape = function(id) {
      var parent = this.parent;
      if (!parent.disabled && parent.isImageLoaded) {
        if (parent.activeObj.currIndex && parent.activeObj.currIndex === id) {
          parent.notify("selection", { prop: "deleteItem", onPropertyChange: false });
        } else {
          this.applyActObj();
          if (id.split("_")[0] === "shape") {
            for (var i = 0, len = parent.objColl.length; i < len; i++) {
              if (parent.objColl[i].currIndex === id) {
                parent.objColl.splice(i, 1);
                break;
              }
            }
          } else if (id.split("_")[0] === "pen") {
            parent.notify("freehand-draw", { prop: "handle-freehand-draw", value: { id } });
          }
        }
        var object = { canvasFilter: null };
        parent.notify("toolbar", { prop: "getCanvasFilter", onPropertyChange: false, value: { obj: object } });
        this.lowerContext.filter = object["canvasFilter"];
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        parent.notify("draw", { prop: "redrawImgWithObj", onPropertyChange: false });
        parent.notify("toolbar", { prop: "refresh-main-toolbar", onPropertyChange: false });
      }
    };
    Shape2.prototype.getMaxText = function(isTextBox, text, obj) {
      if (isNullOrUndefined(text)) {
        text = isTextBox ? this.parent.textArea.value : this.parent.activeObj.keyHistory;
        if (!text) {
          return text;
        }
      }
      var maxi;
      var rows = text.split("\n");
      var maxStr = rows[0].length;
      var maxText = rows[0];
      for (var i = 1; i < rows.length; i++) {
        maxi = rows[i].length;
        if (maxi > maxStr) {
          maxText = rows[i];
          maxStr = maxi;
        }
      }
      if (obj) {
        obj["maxText"] = maxText;
      }
      return maxText;
    };
    Shape2.prototype.getLinePoints = function(x1, y1, x2, y2) {
      var points = [];
      var i;
      var j;
      if (x1 === x2) {
        if (y1 < y2) {
          i = [x1, y1];
          j = [x2, y2];
        } else {
          j = [x1, y1];
          i = [x2, y2];
        }
        var m = this.getSlope(i, j, true);
        var b = this.getIntercept(i, m);
        for (var y = i[1]; y <= j[1]; y++) {
          var x = m * y + b;
          points.push({ x, y });
        }
      } else {
        if (x1 < x2) {
          i = [x1, y1];
          j = [x2, y2];
        } else {
          j = [x1, y1];
          i = [x2, y2];
        }
        var m = this.getSlope(i, j, false);
        var b = this.getIntercept(i, m);
        for (var x = i[0]; x <= j[0]; x++) {
          var y = m * x + b;
          points.push({ x, y });
        }
      }
      if (Math.floor(x1) === Math.floor(x2) || points.length < 10 && (y2 - y1 > 10 || y1 - y2 > 10)) {
        points = [];
        var lesserY = Math.min(y1, y2);
        for (var i_1 = 0; i_1 < Math.abs(Math.floor(y2) - Math.floor(y1)); i_1++) {
          points.push({ x: x1, y: lesserY + i_1 });
        }
        if (points.length > 1) {
          var prev = undefined;
          if (isNullOrUndefined(points[points.length - 2])) {
            prev = { x: 0, y: 0 };
          } else {
            prev = points[points.length - 2];
          }
          var diffX = points[points.length - 1]["x"] - prev.x;
          var diffY = points[points.length - 1]["y"] - prev.y;
          points.push({ x: points[points.length - 1]["x"] + diffX / 2, y: points[points.length - 1]["y"] + diffY / 2 });
        }
      } else if (Math.floor(y1) === Math.floor(y2) || points.length < 10 && (x2 - x1 > 10 || x1 - x2 > 10)) {
        points = [];
        var lesserX = Math.min(x1, x2);
        for (var i_2 = 0; i_2 < Math.abs(Math.floor(x2) - Math.floor(x1)); i_2++) {
          points.push({ x: lesserX + i_2, y: y1 });
        }
        if (points.length > 1) {
          var prev = undefined;
          if (isNullOrUndefined(points[points.length - 2])) {
            prev = { x: 0, y: 0 };
          } else {
            prev = points[points.length - 2];
          }
          var diffX = points[points.length - 1]["x"] - prev.x;
          var diffY = points[points.length - 1]["y"] - prev.y;
          points.push({ x: points[points.length - 1]["x"] + diffX / 2, y: points[points.length - 1]["y"] + diffY / 2 });
        }
      }
      return points;
    };
    Shape2.prototype.getSlope = function(a, b, isSameAxis) {
      var slope;
      if (isSameAxis) {
        if (a[1] === b[1]) {
          return null;
        }
        slope = (b[0] - a[0]) / (b[1] - a[1]);
      } else {
        if (a[0] === b[0]) {
          return null;
        }
        slope = (b[1] - a[1]) / (b[0] - a[0]);
      }
      return slope;
    };
    Shape2.prototype.getIntercept = function(point, getSlope) {
      if (getSlope === null) {
        return point[0];
      }
      return point[1] - getSlope * point[0];
    };
    Shape2.prototype.setPointCollForShapeRotation = function(obj) {
      var parent = this.parent;
      var _a = obj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY, width = _a.width, height = _a.height;
      var center = { x: startX + width / 2, y: startY + height / 2 };
      var cosAngle = Math.cos(obj.rotatedAngle);
      var sinAngle = Math.sin(obj.rotatedAngle);
      var p1 = {
        x: cosAngle * (startX - center.x) - sinAngle * (startY - center.y) + center.x,
        y: sinAngle * (startX - center.x) + cosAngle * (startY - center.y) + center.y
      };
      var p2 = {
        x: cosAngle * (endX - center.x) - sinAngle * (startY - center.y) + center.x,
        y: sinAngle * (endX - center.x) + cosAngle * (startY - center.y) + center.y
      };
      var p3 = {
        x: cosAngle * (startX - center.x) - sinAngle * (endY - center.y) + center.x,
        y: sinAngle * (startX - center.x) + cosAngle * (endY - center.y) + center.y
      };
      var p4 = {
        x: cosAngle * (endX - center.x) - sinAngle * (endY - center.y) + center.x,
        y: sinAngle * (endX - center.x) + cosAngle * (endY - center.y) + center.y
      };
      obj.horTopLinePointColl = this.getLinePoints(p1.x, p1.y, p2.x, p2.y);
      obj.horTopLinePointColl = this.getLinePoints(p1.x, p1.y, p2.x, p2.y);
      obj.horBottomLinePointColl = this.getLinePoints(p3.x, p3.y, p4.x, p4.y);
      obj.verLeftLinePointColl = this.getLinePoints(p1.x, p1.y, p3.x, p3.y);
      obj.verRightLinePointColl = this.getLinePoints(p2.x, p2.y, p4.x, p4.y);
      obj.verLeftLinePointColl.reverse();
      obj.verRightLinePointColl.reverse();
      for (var i = 0; i < obj.horTopLinePointColl.length; i++) {
        obj.horTopLinePointColl[i].ratioX = (obj.horTopLinePointColl[i].x - this.parent.img.destLeft) / this.parent.img.destWidth;
        obj.horTopLinePointColl[i].ratioY = (obj.horTopLinePointColl[i].y - this.parent.img.destTop) / this.parent.img.destHeight;
      }
      for (var i = 0; i < obj.horBottomLinePointColl.length; i++) {
        obj.horBottomLinePointColl[i].ratioX = (obj.horBottomLinePointColl[i].x - this.parent.img.destLeft) / this.parent.img.destWidth;
        obj.horBottomLinePointColl[i].ratioY = (obj.horBottomLinePointColl[i].y - this.parent.img.destTop) / this.parent.img.destHeight;
      }
      for (var i = 0; i < obj.verLeftLinePointColl.length; i++) {
        obj.verLeftLinePointColl[i].ratioX = (obj.verLeftLinePointColl[i].x - this.parent.img.destLeft) / this.parent.img.destWidth;
        obj.verLeftLinePointColl[i].ratioY = (obj.verLeftLinePointColl[i].y - this.parent.img.destTop) / this.parent.img.destHeight;
      }
      for (var i = 0; i < obj.verRightLinePointColl.length; i++) {
        obj.verRightLinePointColl[i].ratioX = (obj.verRightLinePointColl[i].x - this.parent.img.destLeft) / this.parent.img.destWidth;
        obj.verRightLinePointColl[i].ratioY = (obj.verRightLinePointColl[i].y - this.parent.img.destTop) / this.parent.img.destHeight;
      }
      if (parent.upperCanvas.style.cursor !== "move") {
        var object = { rotationCirclePoint: null };
        parent.notify("selection", { prop: "getTransRotationPoint", value: { obj, object } });
        var rotationCirclePoint = object["rotationCirclePoint"];
        if (rotationCirclePoint) {
          obj.rotationCirclePointColl = {
            x: cosAngle * (rotationCirclePoint.x - center.x) - sinAngle * (rotationCirclePoint.y - center.y) + center.x,
            y: sinAngle * (rotationCirclePoint.x - center.x) + cosAngle * (rotationCirclePoint.y - center.y) + center.y
          };
          obj.rotationCirclePointColl.ratioX = (obj.rotationCirclePointColl.x - parent.img.destLeft) / parent.img.destWidth;
          obj.rotationCirclePointColl.ratioY = (obj.rotationCirclePointColl.y - parent.img.destTop) / parent.img.destHeight;
        }
      }
    };
    Shape2.prototype.getSquarePointForRotatedShape = function(obj, object) {
      var point = { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 };
      var _a = obj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY, width = _a.width, height = _a.height;
      var center = { x: startX + width / 2, y: startY + height / 2 };
      var cosAngle = Math.cos(obj.rotatedAngle);
      var sinAngle = Math.sin(obj.rotatedAngle);
      var p1 = {
        x: cosAngle * (startX - center.x) - sinAngle * (startY - center.y) + center.x,
        y: sinAngle * (startX - center.x) + cosAngle * (startY - center.y) + center.y
      };
      var p2 = {
        x: cosAngle * (endX - center.x) - sinAngle * (startY - center.y) + center.x,
        y: sinAngle * (endX - center.x) + cosAngle * (startY - center.y) + center.y
      };
      var p3 = {
        x: cosAngle * (startX - center.x) - sinAngle * (endY - center.y) + center.x,
        y: sinAngle * (startX - center.x) + cosAngle * (endY - center.y) + center.y
      };
      var p4 = {
        x: cosAngle * (endX - center.x) - sinAngle * (endY - center.y) + center.x,
        y: sinAngle * (endX - center.x) + cosAngle * (endY - center.y) + center.y
      };
      point.startX = p1.x;
      point.startY = p1.y;
      point.endX = p1.x;
      point.endY = p1.y;
      if (point.startX > p2.x) {
        point.startX = p2.x;
      }
      if (point.startX > p3.x) {
        point.startX = p3.x;
      }
      if (point.startX > p4.x) {
        point.startX = p4.x;
      }
      if (point.startY > p2.y) {
        point.startY = p2.y;
      }
      if (point.startY > p3.y) {
        point.startY = p3.y;
      }
      if (point.startY > p4.y) {
        point.startY = p4.y;
      }
      if (point.endX < p2.x) {
        point.endX = p2.x;
      }
      if (point.endX < p3.x) {
        point.endX = p3.x;
      }
      if (point.endX < p4.x) {
        point.endX = p4.x;
      }
      if (point.endY < p2.y) {
        point.endY = p2.y;
      }
      if (point.endY < p3.y) {
        point.endY = p3.y;
      }
      if (point.endY < p4.y) {
        point.endY = p4.y;
      }
      point.width = point.endX - point.startX;
      point.height = point.endY - point.startY;
      if (object) {
        object["activePoint"] = point;
      }
      return point;
    };
    Shape2.prototype.updateZOrder = function(obj, value) {
      var parent = this.parent;
      value = value.toLowerCase();
      var object = obj;
      if (isNullOrUndefined(object.order)) {
        return;
      }
      var index;
      var prevIndex;
      var highestOrder = this.getHighestOrder();
      this.updateShapeColl();
      if (parent.shapeColl.length === 0) {
        return;
      }
      var coll;
      for (var i = 0; i < parent.shapeColl.length; i++) {
        coll = parent.shapeColl[i];
        if (object.id && object.id.indexOf("pen") > -1) {
          if (coll.id && coll.id === object.id) {
            parent.shapeColl.splice(i, 1);
          }
        } else if (coll.shape && coll.shape.indexOf("crop-") > -1) {
          parent.shapeColl.splice(i, 1);
        }
      }
      switch (value) {
        case "sendtoback":
          prevIndex = object.order;
          index = object.order;
          object.order = 1;
          break;
        case "sendbackward":
          object.order -= 1;
          index = object.order;
          break;
        case "bringtofront":
          prevIndex = object.order;
          index = highestOrder;
          object.order = index;
          break;
        case "bringforward":
          object.order += 1;
          index = object.order;
          break;
      }
      this.reArrangeObjColl(index, value, prevIndex);
      if (object.id && object.id.indexOf("pen") > -1) {
        this.reUpdateShapeColl(object);
      }
    };
    Shape2.prototype.reArrangeObjColl = function(index, value, prevIndex) {
      var parent = this.parent;
      var obj;
      switch (value) {
        case "sendtoback":
          for (var i = 0, len = parent.shapeColl.length; i < len; i++) {
            obj = parent.shapeColl[i];
            if (obj.order < prevIndex && obj.order <= index) {
              obj.order += 1;
              this.reUpdateShapeColl(obj);
            }
          }
          break;
        case "sendbackward":
          for (var i = 0, len = parent.shapeColl.length; i < len; i++) {
            obj = parent.shapeColl[i];
            if (obj.order === index) {
              obj.order += 1;
              this.reUpdateShapeColl(obj);
              break;
            }
          }
          break;
        case "bringtofront":
          for (var i = 0, len = parent.shapeColl.length; i < len; i++) {
            obj = parent.shapeColl[i];
            if (obj.order > prevIndex && obj.order <= index) {
              obj.order -= 1;
              this.reUpdateShapeColl(obj);
            }
          }
          break;
        case "bringforward":
          for (var i = 0, len = parent.shapeColl.length; i < len; i++) {
            obj = parent.shapeColl[i];
            if (obj.order === index) {
              obj.order -= 1;
              this.reUpdateShapeColl(obj);
              break;
            }
          }
          break;
      }
    };
    Shape2.prototype.reorderRedact = function(tempObjColl) {
      var nonRedact = tempObjColl.filter(function(item) {
        return item.shape !== "redact";
      });
      var redact = tempObjColl.filter(function(item) {
        return item.shape === "redact";
      });
      return redact.concat(nonRedact);
    };
    Shape2.prototype.updateShapeColl = function() {
      var parent = this.parent;
      var isOrdered = false;
      var tempOrder = 1;
      var tempObjColl = extend([], parent.objColl, [], true);
      tempObjColl = this.reorderRedact(tempObjColl);
      var tempPointColl = extend([], parent.pointColl, [], true);
      if (parent.shapeColl.length > 0 && parent.shapeColl.length === parent.objColl.length + parent.pointColl.length) {
        for (var i = 0; i < parent.shapeColl.length; i++) {
          if (parent.shapeColl[i].order === tempOrder) {
            isOrdered = true;
            tempOrder++;
          } else {
            isOrdered = false;
            break;
          }
        }
        if (isOrdered) {
          for (var i = 0; i < parent.shapeColl.length; i++) {
            if (parent.shapeColl[i].currIndex && parent.shapeColl[i].currIndex.indexOf("shape") > -1) {
              for (var j = 0; j < tempObjColl.length; j++) {
                if (parent.shapeColl[i].currIndex === tempObjColl[j].currIndex) {
                  parent.shapeColl[i] = extend({}, tempObjColl[j], {}, true);
                  tempObjColl.splice(j, 1);
                  break;
                }
              }
            } else if (parent.shapeColl[i].id && parent.shapeColl[i].id.indexOf("pen") > -1) {
              for (var j = 0; j < tempPointColl.length; j++) {
                if (parent.shapeColl[i].id === tempPointColl[j].id) {
                  parent.shapeColl[i] = extend([], tempPointColl[j], [], true);
                  tempPointColl.splice(j, 1);
                  break;
                }
              }
            }
          }
          return;
        }
      }
      tempObjColl = extend([], parent.objColl, [], true);
      tempPointColl = extend([], parent.pointColl, [], true);
      parent.shapeColl = [];
      var order = 1;
      var isBreak;
      var isCrop = false;
      while (tempObjColl.length !== 0 || tempPointColl.length !== 0) {
        isBreak = isCrop = false;
        for (var i = 0; i < tempObjColl.length; i++) {
          if (tempObjColl[i].order === order || !tempObjColl[i].order && tempObjColl[i].shape && tempObjColl[i].shape.indexOf("crop-") > -1) {
            parent.shapeColl.push(extend({}, tempObjColl[i], {}, true));
            if (tempObjColl[i].shape && tempObjColl[i].shape.indexOf("crop-") > -1) {
              isCrop = true;
            }
            tempObjColl.splice(i, 1);
            isBreak = true;
            break;
          }
        }
        if (!isBreak) {
          for (var i = 0; i < tempPointColl.length; i++) {
            if (tempPointColl[i].order === order) {
              parent.shapeColl.push(extend([], tempPointColl[i], [], true));
              tempPointColl.splice(i, 1);
              isBreak = true;
              break;
            }
          }
        }
        if (!isCrop) {
          order++;
        }
      }
    };
    Shape2.prototype.reUpdateShapeColl = function(obj) {
      var parent = this.parent;
      if (obj.id && obj.id.indexOf("pen") > -1) {
        if (parent.freehandCounter > 0) {
          for (var i = 0; i < parent.freehandCounter; i++) {
            if (parent.pointColl[i].id === obj.id) {
              parent.pointColl[i].order = obj.order;
            }
          }
        }
      } else if (obj.currIndex && obj.currIndex.indexOf("shape") > -1) {
        for (var i = 0; i < parent.objColl.length; i++) {
          if (parent.objColl[i].currIndex === obj.currIndex) {
            parent.objColl[i].order = obj.order;
          }
        }
      }
    };
    Shape2.prototype.drawAnnotations = function(ctx, shape, pen, isPreventApply, x, y, panRegion) {
      var parent = this.parent;
      var activeObj = extend({}, parent.activeObj, {}, true);
      var tempObjColl = extend([], parent.objColl, [], true);
      var tempPointColl = extend([], parent.pointColl, [], true);
      var tempSelPointCollObj = { selPointColl: null };
      parent.notify("freehand-draw", {
        prop: "getSelPointColl",
        onPropertyChange: false,
        value: { obj: tempSelPointCollObj }
      });
      var selPointCollObj = { selPointColl: null };
      parent.notify("freehand-draw", {
        prop: "getSelPointColl",
        onPropertyChange: false,
        value: { obj: selPointCollObj }
      });
      this.updateShapeColl();
      var tempShapeColl = extend([], parent.shapeColl, [], true);
      tempShapeColl = this.reorderRedact(tempShapeColl);
      var isPrevented = false;
      if (!this.preventFrameAnnotation) {
        this.preventFrameAnnotation = isPrevented = true;
      }
      for (var i = 0; i < tempShapeColl.length; i++) {
        var isPenId = tempShapeColl[i].id;
        if (tempShapeColl[i].order || !tempShapeColl[i].order && tempShapeColl[i].shape && tempShapeColl[i].shape.indexOf("crop-") > -1 || !tempShapeColl[i].order && tempShapeColl[i].shape === "path" && parent.drawingShape === "path") {
          if (tempShapeColl[i].currIndex && tempShapeColl[i].currIndex.indexOf("shape") > -1) {
            parent.objColl = [];
            parent.objColl.push(extend({}, tempShapeColl[i], {}, true));
            if (shape === "iterate") {
              var temp = this.lowerContext.filter;
              this.lowerContext.filter = "none";
              this.iterateObjColl();
              this.lowerContext.filter = temp;
            } else if (shape === "zoom" || shape === "pan") {
              var tempObjCollIndex = -1;
              for (var i_3 = 0; i_3 < tempObjColl.length; i_3++) {
                if (JSON.stringify(tempObjColl[i_3]) === JSON.stringify(parent.objColl[0])) {
                  tempObjCollIndex = i_3;
                  break;
                }
              }
              if (shape === "zoom") {
                this.zoomObjColl(isPreventApply);
              } else {
                this.panObjColl(x, y, panRegion);
              }
              if (tempObjCollIndex > -1) {
                tempObjColl[tempObjCollIndex] = extend({}, parent.objColl[0], {}, true);
              }
            }
          } else if (tempShapeColl[i].id && tempShapeColl[i].id.indexOf("pen") > -1) {
            parent.pointColl = [];
            parent.freehandCounter = 0;
            parent.notify("freehand-draw", { prop: "setSelPointColl", onPropertyChange: false, value: { obj: { selPointColl: [] } } });
            parent.pointColl.push(extend({}, tempShapeColl[i], {}, true));
            parent.notify("freehand-draw", {
              prop: "pushSelPointColl",
              onPropertyChange: false,
              value: { obj: { selPointColl: selPointCollObj["selPointColl"][i] } }
            });
            parent.freehandCounter = parent.pointColl.length;
            if (pen === "iterate") {
              parent.notify("freehand-draw", {
                prop: "freehandRedraw",
                onPropertyChange: false,
                value: { context: ctx, points: null }
              });
            } else if (pen === "zoom" || pen === "pan") {
              if (pen === "zoom") {
                parent.notify("freehand-draw", {
                  prop: "zoomFHDColl",
                  onPropertyChange: false,
                  value: { isPreventApply }
                });
              } else {
                parent.notify("freehand-draw", {
                  prop: "panFHDColl",
                  onPropertyChange: false,
                  value: { xDiff: x, yDiff: y, panRegion }
                });
              }
              for (var i_4 = 0; i_4 < tempPointColl.length; i_4++) {
                if (tempPointColl[i_4].id === parent.pointColl[0].id) {
                  tempPointColl[i_4] = extend({}, parent.pointColl[0], {}, true);
                  break;
                }
              }
              for (var i_5 = 0, len = tempSelPointCollObj["selPointColl"].length; i_5 < len; i_5++) {
                if (tempSelPointCollObj["selPointColl"][i_5].id === selPointCollObj["selPointColl"][i_5].id) {
                  tempSelPointCollObj["selPointColl"][i_5] = extend({}, selPointCollObj["selPointColl"][i_5], {}, true);
                  break;
                }
              }
            }
          }
        } else if (!tempShapeColl[i].shape && !isPenId || !tempShapeColl[i].currIndex && !isPenId) {
          tempShapeColl.splice(i, 1);
        }
      }
      if (pen && pen === "zoom") {
        parent.pointColl = [];
        parent.freehandCounter = 0;
        parent.notify("freehand-draw", { prop: "zoomFHDColl", onPropertyChange: false, value: { isPreventApply } });
      }
      parent.objColl = tempObjColl;
      parent.pointColl = tempPointColl;
      parent.freehandCounter = parent.pointColl.length;
      parent.notify("freehand-draw", { prop: "setSelPointColl", onPropertyChange: false, value: { obj: { selPointColl: tempSelPointCollObj["selPointColl"] } } });
      if (isPrevented && this.preventFrameAnnotation) {
        parent.notify("draw", { prop: "applyFrame", value: { ctx: this.lowerContext, frame: parent.frameObj.type, preventImg: true } });
        this.preventFrameAnnotation = false;
      }
      parent.activeObj = activeObj;
    };
    return Shape2;
  }()
);
var Transform = (
  /** @class */
  function() {
    function Transform2(parent) {
      this.isReverseFlip = false;
      this.disablePan = false;
      this.isReverseRotate = false;
      this.flipColl = [];
      this.prevZoomValue = 1;
      this.cropDimension = { width: 0, height: 0 };
      this.isPreventSelect = false;
      this.preventDownScale = false;
      this.resizedImgAngle = null;
      this.parent = parent;
      this.addEventListener();
    }
    Transform2.prototype.destroy = function() {
      if (this.parent.isDestroyed) {
        return;
      }
      this.removeEventListener();
    };
    Transform2.prototype.addEventListener = function() {
      this.parent.on("transform", this.transform, this);
      this.parent.on("destroyed", this.destroy, this);
    };
    Transform2.prototype.removeEventListener = function() {
      this.parent.off("transform", this.transform);
      this.parent.off("destroyed", this.destroy);
    };
    Transform2.prototype.transform = function(args) {
      this.initTransformPvtVar();
      switch (args.prop) {
        case "flipImage":
          this.flipImage(args.value["direction"]);
          break;
        case "setDestPointsForFlipState":
          this.setDestPointsForFlipState();
          break;
        case "zoomAction":
          this.zoomAction(args.value["zoomFactor"], args.value["zoomPoint"], args.value["isResize"]);
          break;
        case "disableZoomOutBtn":
          this.disableZoomOutBtn(args.value["isZoomOut"]);
          break;
        case "rotatedFlip":
          this.rotatedFlip();
          break;
        case "drawPannedImage":
          this.drawPannedImage(args.value["xDiff"], args.value["yDiff"]);
          break;
        case "drawPannImage":
          this.drawPannImage(args.value["point"]);
          break;
        case "performTransformation":
          this.performTransformation(args.value["text"]);
          break;
        case "updateTransform":
          this.updateTransform(args.value["text"]);
          break;
        case "rotatePan":
          this.rotatePan(args.value["isCropSelection"], args.value["isDefaultZoom"]);
          break;
        case "resetZoom":
          this.resetZoom();
          break;
        case "pan":
          this.pan(args.value["value"], args.value["x"], args.value["y"]);
          break;
        case "zoom":
          this.zoom(args.value["zoomFactor"], args.value["zoomPoint"]);
          break;
        case "setCurrPanRegion":
          this.setCurrPanRegion(args.value["region"], args.value["type"], args.value["obj"]);
          break;
        case "rotate":
          this.rotate(args.value["degree"], args.value["obj"]);
          break;
        case "flip":
          this.flip(args.value["direction"]);
          break;
        case "update":
          this.update();
          break;
        case "calcMaxDimension":
          this.calcMaxDimension(args.value["width"], args.value["height"], args.value["obj"], args.value["isImgShape"]);
          break;
        case "getPanMove":
          args.value["obj"]["panMove"] = this.panMove;
          break;
        case "setPanMove":
          this.panMove = args.value["point"];
          break;
        case "getTempPanMove":
          args.value["obj"]["tempPanMove"] = this.tempPanMove;
          break;
        case "setTempPanMove":
          this.tempPanMove = args.value["point"];
          break;
        case "setReverseFlip":
          this.isReverseFlip = args.value["isReverseFlip"];
          break;
        case "setDisablePan":
          this.disablePan = args.value["bool"];
          break;
        case "setCurrDestinationPoint":
          this.currDestPoint = args.value["point"];
          this.currDestPoint.startX -= this.parent.cropObj.totalPannedPoint.x;
          this.currDestPoint.startY -= this.parent.cropObj.totalPannedPoint.y;
          break;
        case "setReverseRotate":
          this.isReverseRotate = args.value["bool"];
          break;
        case "getFlipColl":
          args.value["obj"]["flipColl"] = this.flipColl;
          break;
        case "setFlipColl":
          this.flipColl = args.value["flipColl"];
          break;
        case "getPreviousZoomValue":
          args.value["obj"]["previousZoomValue"] = this.prevZoomValue;
          break;
        case "setPreviousZoomValue":
          this.prevZoomValue = args.value["previousZoomValue"];
          break;
        case "getCropDimension":
          args.value["obj"]["cropDimension"] = this.cropDimension;
          break;
        case "setCropDimension":
          this.cropDimension.width = args.value["width"];
          this.cropDimension.height = args.value["height"];
          break;
        case "getPreventSelect":
          args.value["obj"]["bool"] = this.isPreventSelect;
          break;
        case "setPreventSelect":
          this.isPreventSelect = args.value["bool"];
          break;
        case "resizeImage":
          this.resizeImage(args.value["width"], args.value["height"]);
          break;
        case "resizeCrop":
          this.resizeCrop(args.value["width"], args.value["height"]);
          break;
        case "updateResize":
          this.updateResize();
          break;
        case "resize":
          this.resize(args.value["width"], args.value["height"], args.value["isAspectRatio"]);
          break;
        case "straightenImage":
          this.straightenImage(args.value["degree"]);
          break;
        case "reset":
          this.reset();
          break;
        case "cropZoom":
          args.value["obj"]["maxDimension"] = this.cropZoom(args.value["value"], args.value["selectionObj"]);
          break;
        case "setResizedImgAngle":
          this.resizedImgAngle = args.value["angle"];
          break;
      }
    };
    Transform2.prototype.getModuleName = function() {
      return "transform";
    };
    Transform2.prototype.initTransformPvtVar = function() {
      if (this.parent.lowerCanvas) {
        this.lowerContext = this.parent.lowerCanvas.getContext("2d");
      }
      if (this.parent.upperCanvas) {
        this.upperContext = this.parent.upperCanvas.getContext("2d");
      }
    };
    Transform2.prototype.reset = function() {
      this.zoomBtnHold = null;
      this.tempPanMove = null;
      this.panMove = null;
      this.disablePan = false;
      this.currDestPoint = null;
      this.isReverseRotate = false;
      this.flipColl = [];
      this.resizedImgAngle = null;
      this.transCurrObj = null;
      this.prevZoomValue = 1;
      this.isPreventSelect = this.preventDownScale = false;
    };
    Transform2.prototype.rotateImage = function(degree) {
      var parent = this.parent;
      var transitionArgs = {
        cancel: false,
        previousDegree: parent.transform.degree,
        currentDegree: Math.abs(parent.transform.degree + degree) === 360 ? 0 : parent.transform.degree + degree
      };
      if (!this.isPreventSelect) {
        parent.trigger("rotating", transitionArgs);
        parent.editCompleteArgs = transitionArgs;
      }
      this.rotateEvent(transitionArgs, degree);
    };
    Transform2.prototype.rotateEvent = function(transitionArgs, degree) {
      var parent = this.parent;
      if (!transitionArgs.cancel) {
        var prevObj = undefined;
        if (isNullOrUndefined(this.transCurrObj)) {
          var object = { currObj: {} };
          parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
          prevObj = object["currObj"];
          prevObj.objColl = extend([], parent.objColl, null, true);
          prevObj.pointColl = extend({}, parent.pointColl, null, true);
          prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
          var selPointCollObj = { selPointColl: null };
          parent.notify("freehand-draw", { prop: "getSelPointColl", onPropertyChange: false, value: { obj: selPointCollObj } });
          prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
        }
        parent.afterCropActions.push(degree === 90 ? "rotateRight" : "rotateLeft");
        var splitWords = [];
        var activeObjShape = undefined;
        if (parent.activeObj.activePoint && parent.activeObj.shape) {
          if (parent.activeObj.shape !== undefined) {
            splitWords = parent.activeObj.shape.split("-");
          }
          if (parent.currObjType.isCustomCrop || splitWords[0] === "crop") {
            activeObjShape = parent.currObjType.isCustomCrop ? "custom" : splitWords[1];
            parent.notify("shape", { prop: "updImgRatioForActObj", onPropertyChange: false });
            parent.objColl.push(parent.activeObj);
            parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
          }
        }
        parent.notify("shape", {
          prop: "redrawActObj",
          onPropertyChange: false,
          value: { x: null, y: null, isMouseDown: true }
        });
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        this.drawRotatedImage(degree);
        parent.notify("draw", { prop: "setImageEdited", onPropertyChange: false });
        parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
        parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.upperContext } });
        if (parent.isCircleCrop) {
          parent.notify("crop", {
            prop: "cropCircle",
            onPropertyChange: false,
            value: { context: this.lowerContext, isSave: null, isFlip: null }
          });
        }
        if (activeObjShape) {
          this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
          parent.activeObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
          parent.objColl.pop();
          parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate", obj: parent.activeObj } });
        }
        parent.isUndoRedo = false;
        var obj = { collection: parent.rotateFlipColl };
        parent.notify("shape", {
          prop: "alignRotateFlipColl",
          onPropertyChange: false,
          value: { collection: parent.rotateFlipColl, isRotateFlipCollection: true, obj }
        });
        parent.rotateFlipColl = obj["collection"];
        if (parent.cropObj.activeObj.shape && !this.isPreventSelect) {
          parent.notify("draw", { prop: "setIsCropSelect", value: { bool: true } });
          this.isPreventSelect = true;
          parent.notify("draw", {
            prop: "select",
            onPropertyChange: false,
            value: { type: "custom", startX: null, startY: null, width: null, height: null }
          });
          this.isPreventSelect = false;
          parent.setProperties({ zoomSettings: { zoomFactor: 1 } }, true);
          this.prevZoomValue = parent.zoomSettings.zoomFactor;
        }
      } else {
        parent.notify("draw", { prop: "setCurrentObj", onPropertyChange: false, value: { obj: parent.prevEventObjPoint } });
        parent.activeObj = parent.prevEventSelectionPoint;
        parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate", obj: parent.activeObj } });
      }
    };
    Transform2.prototype.drawRotatedImage = function(degree) {
      var parent = this.parent;
      if (degree === 0) {
        parent.transform.degree = 0;
      } else {
        parent.transform.degree += degree;
      }
      if (Math.abs(parent.transform.degree) === 360) {
        parent.transform.degree = 0;
      }
      parent.notify("draw", { prop: "setDestPoints", onPropertyChange: false });
      var tempObjColl = extend([], parent.objColl, [], true);
      var tempActiveObj = extend({}, parent.activeObj, {}, true);
      parent.objColl = [];
      parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      if (!this.isReverseRotate) {
        parent.notify("draw", {
          prop: "updateCurrTransState",
          onPropertyChange: false,
          value: { type: "initial", isPreventDestination: null, isRotatePan: null }
        });
      }
      this.rotateDegree(degree);
      if (!this.isReverseRotate) {
        parent.notify("draw", {
          prop: "updateCurrTransState",
          onPropertyChange: false,
          value: { type: "reverse", isPreventDestination: null, isRotatePan: null }
        });
        parent.rotateFlipColl.push(degree);
      }
      parent.objColl = extend([], tempObjColl, [], true);
      parent.activeObj = extend({}, tempActiveObj, {}, true);
      if (parent.isCircleCrop) {
        parent.notify("crop", {
          prop: "cropCircle",
          onPropertyChange: false,
          value: { context: this.lowerContext, isSave: null, isFlip: null }
        });
      }
      parent.notify("shape", { prop: "redrawObj", onPropertyChange: false, value: { degree } });
      parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      if (degree > 0) {
        parent.notify("freehand-draw", { prop: "rotateFhdColl", onPropertyChange: false });
      } else {
        for (var i = 0; i < 3; i++) {
          parent.notify("freehand-draw", { prop: "rotateFhdColl", onPropertyChange: false });
        }
      }
      parent.notify("freehand-draw", {
        prop: "freehandRedraw",
        onPropertyChange: false,
        value: { context: this.lowerContext, points: null }
      });
      this.updateCurrSelectionPoint(degree);
    };
    Transform2.prototype.rotateDegree = function(degree) {
      var parent = this.parent;
      this.lowerContext.save();
      this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      this.lowerContext.translate(parent.lowerCanvas.width / 2, parent.lowerCanvas.height / 2);
      this.lowerContext.rotate(Math.PI / 180 * degree);
      this.lowerContext.translate(-parent.lowerCanvas.width / 2, -parent.lowerCanvas.height / 2);
      var temp = this.lowerContext.filter;
      parent.notify("draw", { prop: "drawImage", onPropertyChange: false });
      this.lowerContext.filter = temp;
      this.lowerContext.translate(parent.lowerCanvas.width / 2, parent.lowerCanvas.height / 2);
      this.lowerContext.rotate(Math.PI / 180 * -degree);
      this.lowerContext.translate(-parent.lowerCanvas.width / 2, -parent.lowerCanvas.height / 2);
      this.lowerContext.restore();
    };
    Transform2.prototype.updateCurrSelectionPoint = function(degree) {
      var parent = this.parent;
      if (parent.currSelectionPoint && this.currDestPoint) {
        var activeObj = extend({}, parent.activeObj, {}, true);
        var objColl = extend([], parent.objColl, [], true);
        var srcPoints = {
          startX: parent.img.srcLeft,
          startY: parent.img.srcTop,
          width: parent.img.srcWidth,
          height: parent.img.srcHeight
        };
        var destPoints = {
          startX: parent.img.destLeft,
          startY: parent.img.destTop,
          width: parent.img.destWidth,
          height: parent.img.destHeight
        };
        parent.objColl = [];
        parent.objColl.push(extend({}, parent.currSelectionPoint, {}, true));
        parent.img = {
          srcLeft: 0,
          srcTop: 0,
          srcWidth: parent.baseImgCanvas.width,
          srcHeight: parent.baseImgCanvas.height,
          destLeft: this.currDestPoint.startX,
          destTop: this.currDestPoint.startY,
          destWidth: this.currDestPoint.width,
          destHeight: this.currDestPoint.height
        };
        if (typeof degree === "number") {
          parent.notify("draw", { prop: "setDestPoints", onPropertyChange: false });
          parent.notify("draw", {
            prop: "setClientTransDim",
            onPropertyChange: false,
            value: { isPreventDimension: null }
          });
        }
        parent.notify("shape", { prop: "redrawObj", onPropertyChange: false, value: { degree } });
        parent.currSelectionPoint = extend({}, parent.objColl[0], {}, true);
        this.currDestPoint = {
          startX: parent.img.destLeft,
          startY: parent.img.destTop,
          width: parent.img.destWidth,
          height: parent.img.destHeight
        };
        parent.objColl = objColl;
        parent.activeObj = activeObj;
        parent.img = {
          srcLeft: srcPoints.startX,
          srcTop: srcPoints.startY,
          srcWidth: srcPoints.width,
          srcHeight: srcPoints.height,
          destLeft: destPoints.startX,
          destTop: destPoints.startY,
          destWidth: destPoints.width,
          destHeight: destPoints.height
        };
      }
    };
    Transform2.prototype.flipImage = function(direction) {
      var parent = this.parent;
      var transitionArgs = {
        direction,
        cancel: false,
        previousDirection: parent.toPascalCase(parent.transform.currFlipState || direction)
      };
      if (!this.isPreventSelect) {
        parent.trigger("flipping", transitionArgs);
        parent.editCompleteArgs = transitionArgs;
      }
      this.flipEvent(transitionArgs, direction);
    };
    Transform2.prototype.flipEvent = function(transitionArgs, direction) {
      var parent = this.parent;
      if (transitionArgs.cancel) {
        parent.notify("draw", { prop: "setCurrentObj", onPropertyChange: false, value: { obj: parent.prevEventObjPoint } });
        parent.activeObj = parent.prevEventSelectionPoint;
        parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate", obj: parent.activeObj } });
        return;
      }
      var prevObj;
      if (isNullOrUndefined(this.transCurrObj)) {
        var object = { currObj: {} };
        parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
        prevObj = object["currObj"];
        prevObj.objColl = extend([], parent.objColl, null, true);
        prevObj.pointColl = extend({}, parent.pointColl, null, true);
        prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        parent.notify("freehand-draw", {
          prop: "getSelPointColl",
          onPropertyChange: false,
          value: { obj: selPointCollObj }
        });
        prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
      }
      parent.afterCropActions.push(direction.toLowerCase() === "horizontal" ? "horizontalflip" : "verticalflip");
      var splitWords = [];
      var activeObjShape;
      if (parent.activeObj.activePoint) {
        if (parent.activeObj.shape !== undefined) {
          splitWords = parent.activeObj.shape.split("-");
        }
        if (parent.currObjType.isCustomCrop || splitWords[0] === "crop") {
          activeObjShape = parent.currObjType.isCustomCrop ? "custom" : splitWords[1];
          parent.notify("shape", { prop: "updImgRatioForActObj", onPropertyChange: false });
          parent.objColl.push(parent.activeObj);
          parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        }
      }
      parent.notify("shape", {
        prop: "redrawActObj",
        onPropertyChange: false,
        value: { x: null, y: null, isMouseDown: true }
      });
      parent.clearContext(this.lowerContext);
      parent.clearContext(this.upperContext);
      var tempObjColl = extend([], parent.objColl, [], true);
      var tempActiveObj = extend({}, parent.activeObj, {}, true);
      parent.objColl = [];
      parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      if (!this.isReverseFlip) {
        parent.notify("draw", {
          prop: "updateCurrTransState",
          onPropertyChange: false,
          value: { type: "initial", isPreventDestination: null, isRotatePan: null }
        });
      }
      var lowercaseDirection = direction.toLowerCase();
      this.updateFlipState(lowercaseDirection);
      var flipState = parent.transform.currFlipState.toLowerCase();
      parent.transform.currFlipState = lowercaseDirection === "horizontal" && flipState === "horizontal" || lowercaseDirection === "vertical" && flipState === "vertical" ? "" : lowercaseDirection;
      var selObj = { isSelected: null };
      parent.notify("draw", { prop: "getRotatedFlipCropSelection", onPropertyChange: false, value: { bool: selObj } });
      if (selObj["isSelected"]) {
        parent.img.destLeft += parent.panPoint.totalPannedInternalPoint.x;
        parent.img.destTop += parent.panPoint.totalPannedInternalPoint.y;
      }
      var temp = this.lowerContext.filter;
      parent.notify("draw", { prop: "drawImage", onPropertyChange: false });
      this.lowerContext.filter = temp;
      parent.notify("draw", { prop: "setImageEdited", onPropertyChange: false });
      this.updateFlipState(direction.toLowerCase());
      if (!this.isReverseFlip) {
        parent.notify("draw", {
          prop: "updateCurrTransState",
          onPropertyChange: false,
          value: { type: "reverse", isPreventDestination: null, isRotatePan: null }
        });
        this.updateFlipColl(direction.toLocaleLowerCase());
        parent.rotateFlipColl.push(direction.toLowerCase());
      }
      if (parent.rotateFlipColl.length === 1) {
        var panObj = { panRegion: "" };
        parent.notify("crop", {
          prop: "getCurrFlipState",
          onPropertyChange: false,
          value: { panObj }
        });
        if (panObj["panRegion"] === "") {
          parent.notify("draw", {
            prop: "setClientTransDim",
            onPropertyChange: false,
            value: { isPreventDimension: null }
          });
        } else {
          this.setDestPointsForFlipState();
        }
      }
      if (parent.isCircleCrop) {
        parent.notify("crop", {
          prop: "cropCircle",
          onPropertyChange: false,
          value: { context: this.lowerContext, isSave: null, isFlip: null }
        });
      }
      parent.objColl = extend([], tempObjColl, [], true);
      parent.activeObj = extend({}, tempActiveObj, {}, true);
      for (var i = 0, len = parent.objColl.length; i < len; i++) {
        var flipObjColl = parent.objColl[i].flipObjColl;
        if (flipObjColl.length === 0) {
          flipObjColl.push(direction);
        } else if (flipObjColl[flipObjColl.length - 1] === direction) {
          flipObjColl.pop();
        } else {
          flipObjColl.push(direction);
        }
      }
      parent.notify("shape", { prop: "redrawObj", onPropertyChange: false, value: { degree: direction.toLowerCase() } });
      var tempFilter = this.lowerContext.filter;
      this.lowerContext.filter = "brightness(1) contrast(100%) hue-rotate(0deg) saturate(100%) opacity(1) blur(0px) sepia(0%) grayscale(0%) invert(0%)";
      parent.notify("shape", { prop: "iterateObjColl", onPropertyChange: false });
      var dir = direction.toLowerCase();
      if (dir === "horizontal" || dir === "vertical") {
        parent.notify("freehand-draw", {
          prop: "flipFHDColl",
          onPropertyChange: false,
          value: { value: dir }
        });
        parent.notify("freehand-draw", {
          prop: "freehandRedraw",
          onPropertyChange: false,
          value: { context: this.lowerContext, points: null }
        });
      } else {
        parent.notify("freehand-draw", {
          prop: "freehandRedraw",
          onPropertyChange: false,
          value: { context: this.lowerContext, points: null }
        });
      }
      this.lowerContext.filter = tempFilter;
      parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      this.updateCurrSelectionPoint(dir);
      parent.isUndoRedo = false;
      parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
      parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.upperContext } });
      if (parent.isCircleCrop) {
        parent.notify("crop", {
          prop: "cropCircle",
          onPropertyChange: false,
          value: { context: this.lowerContext, isSave: null, isFlip: null }
        });
      }
      if (activeObjShape) {
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        parent.activeObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
        parent.objColl.pop();
        parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate", obj: parent.activeObj } });
      }
      var obj = { collection: parent.rotateFlipColl };
      parent.notify("shape", {
        prop: "alignRotateFlipColl",
        onPropertyChange: false,
        value: { collection: parent.rotateFlipColl, isRotateFlipCollection: true, obj }
      });
      parent.rotateFlipColl = obj["collection"];
      if (parent.cropObj.activeObj.shape && !this.isPreventSelect) {
        parent.notify("draw", { prop: "setIsCropSelect", value: { bool: true } });
        this.isPreventSelect = true;
        parent.notify("draw", {
          prop: "select",
          onPropertyChange: false,
          value: { type: "custom", startX: null, startY: null, width: null, height: null }
        });
        this.isPreventSelect = false;
        parent.setProperties({ zoomSettings: { zoomFactor: 1 } }, true);
        this.prevZoomValue = parent.zoomSettings.zoomFactor;
      }
    };
    Transform2.prototype.updateFlipState = function(direction) {
      var degree = this.parent.transform.degree;
      if (direction === "horizontal") {
        if (degree % 90 === 0 && degree % 180 !== 0) {
          this.verticalFlip();
        } else {
          this.horizontalFlip();
        }
      } else if (direction === "vertical") {
        if (degree % 90 === 0 && degree % 180 !== 0) {
          this.horizontalFlip();
        } else {
          this.verticalFlip();
        }
      }
    };
    Transform2.prototype.horizontalFlip = function() {
      this.lowerContext.translate(this.lowerContext.canvas.width, 0);
      this.lowerContext.scale(-1, 1);
      this.upperContext.translate(this.upperContext.canvas.width, 0);
      this.upperContext.scale(-1, 1);
    };
    Transform2.prototype.verticalFlip = function() {
      this.lowerContext.translate(0, this.lowerContext.canvas.height);
      this.lowerContext.scale(1, -1);
      this.upperContext.translate(0, this.upperContext.canvas.height);
      this.upperContext.scale(1, -1);
    };
    Transform2.prototype.updateFlipColl = function(direction) {
      if (this.isPreventSelect) {
        return;
      }
      if (this.flipColl.length === 0 || this.flipColl[this.flipColl.length - 1] !== direction) {
        this.flipColl.push(direction);
      } else {
        this.flipColl.pop();
      }
      if (this.flipColl.length >= 4) {
        var lastFourItems = this.flipColl.slice(-4);
        if (lastFourItems[0] === "horizontal" && lastFourItems[1] === "vertical" && lastFourItems[2] === "horizontal" && lastFourItems[3] === "vertical" || lastFourItems[0] === "vertical" && lastFourItems[1] === "horizontal" && lastFourItems[2] === "vertical" && lastFourItems[3] === "horizontal") {
          this.flipColl.splice(-4);
        }
      }
    };
    Transform2.prototype.setDestPointsForFlipState = function() {
      var parent = this.parent;
      var panObj = { panRegion: "" };
      var _a = parent.img, destLeft = _a.destLeft, destTop = _a.destTop, destWidth = _a.destWidth, destHeight = _a.destHeight;
      var _b = parent.lowerCanvas, clientWidth = _b.clientWidth, clientHeight = _b.clientHeight;
      parent.notify("crop", {
        prop: "getCurrFlipState",
        onPropertyChange: false,
        value: { panObj }
      });
      if (panObj["panRegion"] !== "") {
        if (panObj["panRegion"] === "horizontal") {
          parent.img.destLeft = clientWidth - (destWidth + destLeft);
        } else if (panObj["panRegion"] === "vertical") {
          parent.img.destTop = clientHeight - (destHeight + destTop);
        } else {
          parent.img.destLeft = clientWidth - (destWidth + destLeft);
          parent.img.destTop = clientHeight - (destHeight + destTop);
        }
      }
    };
    Transform2.prototype.zoomAction = function(zoomFactor, zoomPoint, isResize, isPreventApply) {
      var parent = this.parent;
      if (!parent.disabled && parent.isImageLoaded) {
        if (isNullOrUndefined(isResize) && (parent.zoomSettings.zoomFactor >= parent.zoomSettings.maxZoomFactor && zoomFactor > 0 || parent.zoomSettings.zoomFactor > parent.zoomSettings.minZoomFactor && zoomFactor < 0 && this.disableZoomOutBtn(true) || parent.zoomSettings.zoomFactor <= parent.zoomSettings.minZoomFactor && zoomFactor < 0)) {
          parent.notify("toolbar", { prop: "zoom-up-handler", onPropertyChange: false });
          return;
        }
        parent.notify("draw", { prop: "setImageEdited", onPropertyChange: false });
        var tempZoomFactor = zoomFactor;
        zoomFactor = tempZoomFactor > 0 ? 0.1 : -0.1;
        for (var i = 0; i < Math.round(Math.abs(tempZoomFactor / 0.1)); i++) {
          if (this.prevZoomValue === 1) {
            this.prevZoomValue += zoomFactor > 0 ? zoomFactor * 10 : zoomFactor * 10 / 10;
          } else if (this.prevZoomValue > 1) {
            this.prevZoomValue += zoomFactor * 10;
          } else if (this.prevZoomValue < 1) {
            this.prevZoomValue += zoomFactor * 10 / 10;
            var powerOften = Math.pow(10, 1);
            this.prevZoomValue = Math.round(this.prevZoomValue * powerOften) / powerOften;
          }
        }
        zoomFactor = tempZoomFactor;
        parent.setProperties({ zoomSettings: { zoomFactor: this.prevZoomValue } }, true);
        var splitWords = undefined;
        this.tempActiveObj = null;
        this.isShape = false;
        if (parent.activeObj.shape !== undefined) {
          if (parent.activeObj.shape === "shape") {
            parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
          } else {
            splitWords = parent.activeObj.shape.split("-");
          }
        }
        if (splitWords !== undefined && splitWords[0] === "crop") {
          this.tempActiveObj = extend({}, parent.activeObj, {}, true);
          parent.isCropTab = true;
        } else if (parent.activeObj.shape && splitWords[0] !== "crop" && (parent.activeObj.activePoint.width !== 0 || parent.activeObj.activePoint.height !== 0) || parent.activeObj.shape === "path" && parent.activeObj.pointColl.length > 0) {
          this.isShape = true;
        }
        var obj = { zoomType: null };
        parent.notify("selection", { prop: "getZoomType", onPropertyChange: false, value: { obj } });
        if (isNullOrUndefined(zoomPoint)) {
          if (parent.isCropTab && this.tempActiveObj) {
            zoomPoint = {
              x: parent.activeObj.activePoint.startX + parent.activeObj.activePoint.width / 2,
              y: parent.activeObj.activePoint.startY + parent.activeObj.activePoint.height / 2
            };
          } else {
            zoomPoint = { x: parent.lowerCanvas.clientWidth / 2, y: parent.lowerCanvas.clientHeight / 2 };
          }
          if (obj["zoomType"] === "MouseWheel" || obj["zoomType"] === "Pinch") {
            zoomPoint = { x: parent.zoomSettings.zoomPoint.x, y: parent.zoomSettings.zoomPoint.y };
          }
        }
        var previousZoomFactor = parent.zoomSettings.zoomFactor - zoomFactor * 10;
        var zoomEventArgs = {
          zoomPoint,
          cancel: false,
          previousZoomFactor,
          currentZoomFactor: parent.zoomSettings.zoomFactor,
          zoomTrigger: obj["zoomType"]
        };
        if (!parent.isCropToolbar && parent.isZoomBtnClick) {
          parent.trigger("zooming", zoomEventArgs);
          parent.editCompleteArgs = zoomEventArgs;
        }
        this.zoomEvent(zoomEventArgs, zoomFactor, isPreventApply);
      }
    };
    Transform2.prototype.zoomEvent = function(zoomEventArgs, zoomFact, isPreventApply) {
      var parent = this.parent;
      var shapeId;
      var _a = parent.zoomSettings, zoomFactor = _a.zoomFactor, minZoomFactor = _a.minZoomFactor;
      if (zoomEventArgs.cancel) {
        parent.isZoomBtnClick = false;
        return;
      }
      if (this.parent.activeObj.redactType !== "blur" && this.parent.activeObj.redactType !== "pixelate") {
        parent.notify("toolbar", { prop: "close-contextual-toolbar", onPropertyChange: false });
      }
      if (!parent.isCropTab && parent.activeObj.shape) {
        shapeId = parent.activeObj.currIndex;
      }
      parent.notify("shape", {
        prop: "redrawActObj",
        onPropertyChange: false,
        value: { x: null, y: null, isMouseDown: true }
      });
      parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      this.upperContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      var object = { canvasFilter: parent.canvasFilter };
      this.lowerContext.filter = object["canvasFilter"];
      parent.upperCanvas.style.cursor = parent.cursor = "default";
      var objColl = extend([], parent.objColl, [], true);
      if (!parent.isCropTab) {
        if (parent.transform.degree !== 0) {
          parent.notify("shape", { prop: "redrawActObj", onPropertyChange: false, value: { x: null, y: null, isMouseDown: null } });
          parent.panPoint.currentPannedPoint = { x: 0, y: 0 };
          var temp = parent.allowDownScale;
          parent.allowDownScale = false;
          this.rotatePan(true, true);
          parent.allowDownScale = temp;
        } else if (parent.transform.currFlipState !== "") {
          parent.panPoint.totalPannedPoint = { x: 0, y: 0 };
        }
        if (parent.transform.straighten === 0 && !this.isPreventSelect) {
          parent.notify("freehand-draw", { prop: "updateFHDColl", onPropertyChange: false, value: { isPreventApply } });
        }
      }
      if (parent.transform.degree === 0) {
        this.drawZoomImgToCanvas(zoomFact, this.tempActiveObj);
        var panObj_1 = { panRegion: "" };
        parent.notify("crop", { prop: "getCurrFlipState", onPropertyChange: false, value: { panObj: panObj_1 } });
        if (panObj_1["panRegion"] !== "") {
          parent.notify("crop", { prop: "setTempFlipPanPoint", onPropertyChange: false, value: { point: parent.panPoint.totalPannedPoint, isAdd: true } });
          objColl = extend([], parent.objColl, [], true);
          parent.objColl = [];
          var destLeft = parent.img.destLeft;
          var destTop = parent.img.destTop;
          this.setDestPointsForFlipState();
          this.rotatedFlip();
          parent.img.destLeft = destLeft;
          parent.img.destTop = destTop;
          parent.objColl = objColl;
          parent.notify("shape", {
            prop: "drawAnnotations",
            onPropertyChange: false,
            value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply }
          });
          if (parent.transform.straighten === 0 && !this.isPreventSelect) {
            parent.notify("freehand-draw", { prop: "updateFHDColl", onPropertyChange: false, value: { isPreventApply } });
          }
        }
        if (zoomFactor <= minZoomFactor && !parent.isCropTab) {
          parent.panPoint.totalPannedPoint = { x: 0, y: 0 };
        }
      } else {
        if (parent.transform.straighten === 0 && !this.isPreventSelect) {
          parent.notify("freehand-draw", { prop: "updateFHDColl", onPropertyChange: false, value: { isPreventApply } });
        }
        parent.panPoint.totalPannedClientPoint = { x: 0, y: 0 };
        parent.panPoint.totalPannedInternalPoint = { x: 0, y: 0 };
        this.rotateZoom(zoomFact);
        var panObj_2 = { panRegion: "" };
        parent.notify("crop", { prop: "getCurrFlipState", onPropertyChange: false, value: { panObj: panObj_2 } });
        if (panObj_2["panRegion"] !== "") {
          var temp = this.lowerContext.filter;
          this.lowerContext.filter = "none";
          parent.notify("shape", {
            prop: "drawAnnotations",
            onPropertyChange: false,
            value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply }
          });
          this.lowerContext.filter = temp;
        }
      }
      var powerOften = Math.pow(10, 1);
      if (zoomFactor <= minZoomFactor || Math.round(parent.transform.zoomFactor * powerOften) / powerOften === 2) {
        clearInterval(this.zoomBtnHold);
        this.zoomBtnHold = 0;
      }
      var panObj = { panRegion: "" };
      parent.notify("crop", { prop: "getCurrFlipState", onPropertyChange: false, value: { panObj } });
      if (panObj["panRegion"] === "") {
        var temp = this.lowerContext.filter;
        this.lowerContext.filter = "none";
        parent.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply }
        });
        this.lowerContext.filter = temp;
      }
      if (parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle" || parent.isCircleCrop) {
        parent.notify("crop", {
          prop: "cropCircle",
          onPropertyChange: false,
          value: { context: this.lowerContext, isSave: null, isFlip: null }
        });
      }
      parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
      parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      if (this.tempActiveObj) {
        parent.activeObj = extend({}, this.tempActiveObj, {}, true);
        parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate", obj: parent.activeObj } });
        if (zoomFactor <= minZoomFactor) {
          parent.currSelectionPoint = null;
        }
      }
      parent.isUndoRedo = false;
      var zoomOut;
      zoomOut = (undefined).querySelector("#" + parent.element.id + "_zoomOut");
      if (zoomOut && zoomFactor <= minZoomFactor) {
        zoomOut.classList.add("e-disabled");
        zoomOut.parentElement.classList.add("e-overlay");
      } else if (zoomOut) {
        zoomOut.classList.remove("e-disabled");
        zoomOut.parentElement.classList.remove("e-overlay");
      }
      var drawingShape = parent.drawingShape;
      this.autoEnablePan();
      parent.drawingShape = drawingShape;
      if (this.tempActiveObj) {
        parent.activeObj = extend({}, this.tempActiveObj, {}, true);
      }
      if (parent.activeObj.shape === "crop-custom") {
        parent.currObjType.isCustomCrop = true;
      }
      if (this.isShape) {
        if (shapeId) {
          for (var i = 0, len = parent.objColl.length; i < len; i++) {
            if (parent.objColl[i].currIndex === shapeId) {
              parent.activeObj = extend({}, parent.objColl[i], {}, true);
              parent.objColl.splice(i, 1);
              break;
            }
          }
        } else {
          parent.activeObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
          parent.objColl.pop();
        }
        parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: {
          canvas: "duplicate",
          obj: parent.activeObj,
          isCropRatio: null,
          points: null,
          isPreventDrag: true,
          saveContext: null,
          isPreventSelection: null
        } });
        parent.notify("toolbar", { prop: "update-toolbar-items", onPropertyChange: false });
        parent.notify("toolbar", { prop: "renderQAT", onPropertyChange: false, value: { isPenEdit: null } });
      }
      parent.notify("toolbar", { prop: "enable-disable-btns", onPropertyChange: false });
      parent.notify("selection", { prop: "setZoomType", onPropertyChange: false, value: { zoomType: "Toolbar" } });
      zoomEventArgs = { zoomPoint: zoomEventArgs.zoomPoint, previousZoomFactor: zoomEventArgs.previousZoomFactor, currentZoomFactor: zoomEventArgs.currentZoomFactor, zoomTrigger: zoomEventArgs.zoomTrigger };
      if (!parent.isCropToolbar && parent.isZoomBtnClick) {
        parent.isZoomBtnClick = false;
      }
      if (parent.drawingShape) {
        var activeObj = extend({}, parent.activeObj, {}, true);
        parent.enableShapeDrawing(parent.toPascalCase(parent.drawingShape), true);
        parent.activeObj = activeObj;
        if (activeObj.activePoint.width > 0 || activeObj.activePoint.height > 0 || activeObj.pointColl && activeObj.pointColl.length > 0) {
          if (activeObj.shape === "redact") {
            parent.notify("toolbar", { prop: "renderQAT", onPropertyChange: false, value: { isPenEdit: null } });
          }
          var zOrderElem = parent.element.querySelector("#" + parent.element.id + "_zOrderBtn");
          var dupElem = parent.element.querySelector("#" + parent.element.id + "_duplicate");
          var removeElem = parent.element.querySelector("#" + parent.element.id + "_remove");
          var editTextElem = parent.element.querySelector("#" + parent.element.id + "_editText");
          if (zOrderElem) {
            zOrderElem.classList.remove("e-overlay");
          }
          if (dupElem) {
            dupElem.classList.remove("e-overlay");
          }
          if (removeElem) {
            removeElem.classList.remove("e-overlay");
          }
          if (editTextElem) {
            editTextElem.classList.remove("e-overlay");
          }
        }
      } else if (parent.activeObj.shape && parent.activeObj.shape === "redact") {
        parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
          type: "redact",
          isApplyBtn: false,
          isCropping: false
        } });
        parent.notify("toolbar", { prop: "renderQAT", onPropertyChange: false, value: { isPenEdit: null } });
      }
    };
    Transform2.prototype.disableZoomOutBtn = function(isZoomOut) {
      var parent = this.parent;
      var _a = parent.zoomSettings, zoomFactor = _a.zoomFactor, minZoomFactor = _a.minZoomFactor;
      var isDisabled = false;
      var zoomOut;
      if (!isNullOrUndefined(isZoomOut)) {
        parent.transform.zoomFactor -= 0.1;
      }
      zoomOut = parent.element.querySelector("#" + parent.element.id + "_zoomOut");
      var destPoints = {
        destLeft: parent.img.destLeft,
        destTop: parent.img.destTop,
        destWidth: parent.img.destWidth,
        destHeight: parent.img.destHeight
      };
      if (parent.activeObj.shape) {
        var maxDimension = this.setZoomDimension(-0.1, parent.activeObj);
        if (!isNullOrUndefined(zoomOut)) {
          var actPoint = parent.activeObj.activePoint;
          if (parent.transform.straighten === 0) {
            if (parent.img.destLeft > actPoint.startX || parent.img.destTop > actPoint.startY || parent.img.destLeft + parent.img.destWidth < actPoint.endX || parent.img.destTop + parent.img.destHeight < actPoint.endY || zoomFactor === minZoomFactor) {
              zoomOut.classList.add("e-disabled");
              zoomOut.parentElement.classList.add("e-overlay");
              isDisabled = true;
            } else {
              zoomOut.classList.remove("e-disabled");
              zoomOut.parentElement.classList.remove("e-overlay");
              isDisabled = false;
            }
          } else {
            parent.img.destWidth = maxDimension.width;
            parent.img.destHeight = maxDimension.height;
            var obj = { isIntersect: null };
            parent.notify("draw", { prop: "updateImgCanvasPoints", onPropertyChange: false });
            parent.notify("draw", { prop: "isLinesIntersect", onPropertyChange: false, value: { obj } });
            if (obj["isIntersect"] || zoomFactor === minZoomFactor) {
              zoomOut.classList.add("e-disabled");
              zoomOut.parentElement.classList.add("e-overlay");
              isDisabled = true;
            } else {
              zoomOut.classList.remove("e-disabled");
              zoomOut.parentElement.classList.remove("e-overlay");
              isDisabled = false;
            }
          }
        }
      } else {
        this.setZoomDimension(-0.1, null);
      }
      if (!isNullOrUndefined(isZoomOut)) {
        parent.transform.zoomFactor += 0.1;
      }
      parent.img.destLeft = destPoints["destLeft"];
      parent.img.destTop = destPoints["destTop"];
      parent.img.destWidth = destPoints["destWidth"];
      parent.img.destHeight = destPoints["destHeight"];
      return isDisabled;
    };
    Transform2.prototype.drawZoomImgToCanvas = function(value, selectionObj) {
      var parent = this.parent;
      var powerOften = Math.pow(10, 1);
      var zmFactor = Math.round(parent.transform.zoomFactor * powerOften) / powerOften;
      if (zmFactor === 0.1 && value === -0.1 || zmFactor === 0 && value === -0.025) {
        parent.transform.zoomFactor = 0;
      } else {
        parent.transform.zoomFactor += value;
      }
      parent.transform[parent.isCropTab ? "cropZoomFactor" : "defaultZoomFactor"] = parent.transform.zoomFactor;
      var maxDimension = { width: 0, height: 0 };
      if (parent.isCropTab) {
        maxDimension = this.cropZoom(value, selectionObj);
      } else {
        maxDimension = this.calcMaxDimension(parent.img.srcWidth, parent.img.srcHeight);
        maxDimension.width += maxDimension.width * parent.transform.zoomFactor;
        maxDimension.height += maxDimension.height * parent.transform.zoomFactor;
        parent.img.destLeft = (parent.lowerCanvas.clientWidth - maxDimension.width) / 2;
        parent.img.destTop = (parent.lowerCanvas.clientHeight - maxDimension.height + 1) / 2;
      }
      parent.notify("draw", { prop: "draw-image-to-canvas", value: { dimension: maxDimension } });
      maxDimension.width = this.cropDimension.width;
      maxDimension.height = this.cropDimension.height;
      maxDimension.width += maxDimension.width * parent.transform.zoomFactor;
      maxDimension.height += maxDimension.height * parent.transform.zoomFactor;
      parent.notify("draw", { prop: "setZoomCropWidth", value: { width: maxDimension.width, height: maxDimension.height } });
    };
    Transform2.prototype.rotatedFlip = function() {
      var parent = this.parent;
      this.isReverseFlip = true;
      var tempCurrFlipState = parent.transform.currFlipState;
      var tempFlipColl = this.flipColl;
      var tempObjColl = extend([], parent.objColl, [], true);
      var tempActiveObj = extend({}, parent.activeObj, {}, true);
      this.flipColl = [];
      parent.objColl = [];
      parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      parent.notify("draw", {
        prop: "currTransState",
        onPropertyChange: false,
        value: { type: "initial", isPreventDestination: null, context: null, isPreventCircleCrop: null }
      });
      var temp = this.lowerContext.filter;
      parent.notify("draw", { prop: "drawImage", onPropertyChange: false });
      this.lowerContext.filter = temp;
      parent.notify("draw", {
        prop: "currTransState",
        onPropertyChange: false,
        value: { type: "reverse", isPreventDestination: true, context: null, isPreventCircleCrop: null }
      });
      if (tempCurrFlipState === "" && parent.transform.currFlipState !== "") {
        tempCurrFlipState = parent.transform.currFlipState;
      }
      parent.transform.currFlipState = tempCurrFlipState;
      this.flipColl = tempFlipColl;
      parent.objColl = extend([], tempObjColl, [], true);
      this.lowerContext.filter = "none";
      parent.notify("shape", { prop: "iterateObjColl", onPropertyChange: false });
      this.lowerContext.filter = temp;
      if (tempActiveObj.activePoint.width !== 0) {
        parent.activeObj = extend({}, tempActiveObj, {}, true);
      }
      this.isReverseFlip = false;
    };
    Transform2.prototype.rotateZoom = function(value) {
      var parent = this.parent;
      var powerOften = Math.pow(10, 1);
      var zmFactor = Math.round(parent.transform.zoomFactor * powerOften) / powerOften;
      if (zmFactor === 0.1 && value === -0.1 || zmFactor === 0 && value === -0.025) {
        parent.transform.zoomFactor = 0;
      } else {
        parent.transform.zoomFactor += value;
      }
      if (parent.isCropTab) {
        parent.transform.cropZoomFactor = parent.transform.zoomFactor;
      } else {
        parent.transform.defaultZoomFactor = parent.transform.zoomFactor;
      }
      var tempObjColl = extend([], parent.objColl, [], true);
      var tempActiveObj = extend({}, parent.activeObj, {}, true);
      parent.objColl = [];
      parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      parent.notify("draw", {
        prop: "updateCurrTransState",
        onPropertyChange: false,
        value: { type: "initial", isPreventDestination: null, isRotatePan: null }
      });
      parent.notify("draw", { prop: "setRotateZoom", onPropertyChange: false, value: { isRotateZoom: true } });
      parent.notify("draw", { prop: "setDestPoints", onPropertyChange: false });
      var temp = this.lowerContext.filter;
      parent.notify("draw", { prop: "drawImage", onPropertyChange: false });
      this.lowerContext.filter = temp;
      parent.notify("draw", { prop: "setRotateZoom", onPropertyChange: false, value: { isRotateZoom: false } });
      parent.notify("draw", {
        prop: "updateCurrTransState",
        onPropertyChange: false,
        value: { type: "reverse", isPreventDestination: null, isRotatePan: null }
      });
      parent.objColl = tempObjColl;
      parent.activeObj = tempActiveObj;
      var maxDimension = { width: this.cropDimension.width, height: this.cropDimension.height };
      maxDimension.width += maxDimension.width * parent.transform.zoomFactor;
      maxDimension.height += maxDimension.height * parent.transform.zoomFactor;
      parent.notify("draw", { prop: "setZoomCropWidth", value: { width: maxDimension.width, height: maxDimension.height } });
    };
    Transform2.prototype.autoEnablePan = function() {
      var parent = this.parent;
      if (parent.transform.zoomFactor <= 0) {
        parent.togglePan = false;
        parent.notify("selection", { prop: "setDragCanvas", value: { bool: false } });
        parent.pan(false);
        this.disablePan = false;
      } else {
        parent.pan(!this.disablePan);
      }
    };
    Transform2.prototype.cropZoom = function(value, selectionObj) {
      var parent = this.parent;
      var destLeft = parent.img.destLeft;
      var destTop = parent.img.destTop;
      var maxDimension = { width: 0, height: 0 };
      if (parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0) {
        maxDimension = this.calcMaxDimension(parent.img.srcHeight, parent.img.srcWidth);
      } else {
        maxDimension = this.calcMaxDimension(parent.img.srcWidth, parent.img.srcHeight);
      }
      maxDimension.width += maxDimension.width * parent.transform.zoomFactor;
      maxDimension.height += maxDimension.height * parent.transform.zoomFactor;
      parent.img.destLeft = destLeft - (maxDimension.width - parent.img.destWidth) / 2;
      parent.img.destTop = destTop - (maxDimension.height - parent.img.destHeight) / 2;
      destLeft = parent.img.destLeft;
      destTop = parent.img.destTop;
      if (selectionObj && parent.transform.straighten === 0) {
        if (parent.img.destLeft > selectionObj.activePoint.startX) {
          parent.img.destLeft = selectionObj.activePoint.startX;
          if (parent.transform.degree === 0) {
            parent.panPoint.totalPannedPoint.x -= destLeft - parent.img.destLeft;
          }
        }
        if (parent.img.destTop > selectionObj.activePoint.startY) {
          parent.img.destTop = selectionObj.activePoint.startY;
          if (parent.transform.degree === 0) {
            parent.panPoint.totalPannedPoint.y -= destTop - parent.img.destTop;
          }
        }
        if (parent.img.destLeft + maxDimension.width < selectionObj.activePoint.endX) {
          parent.img.destLeft = selectionObj.activePoint.endX - maxDimension.width;
          if (parent.transform.degree === 0) {
            parent.panPoint.totalPannedPoint.x -= destLeft - parent.img.destLeft;
          }
        }
        if (parent.img.destTop + maxDimension.height < selectionObj.activePoint.endY) {
          parent.img.destTop = selectionObj.activePoint.endY - maxDimension.height;
          if (parent.transform.degree === 0) {
            parent.panPoint.totalPannedPoint.y -= destTop - parent.img.destTop;
          }
        }
      }
      return maxDimension;
    };
    Transform2.prototype.setZoomDimension = function(value, selectionObj) {
      var parent = this.parent;
      var degree = parent.transform.degree;
      var maxDimension = { width: 0, height: 0 };
      if (degree % 90 === 0 && degree % 180 !== 0) {
        maxDimension = this.calcMaxDimension(parent.img.srcHeight, parent.img.srcWidth);
      } else {
        maxDimension = this.calcMaxDimension(parent.img.srcWidth, parent.img.srcHeight);
      }
      maxDimension.width += maxDimension.width * parent.transform.zoomFactor;
      maxDimension.height += maxDimension.height * parent.transform.zoomFactor;
      parent.img.destLeft += (parent.img.destWidth - maxDimension.width) / 2;
      parent.img.destTop += (parent.img.destHeight - maxDimension.height) / 2;
      if (value < 0 && selectionObj) {
        var startX = selectionObj.activePoint.startX;
        var startY = selectionObj.activePoint.startY;
        var width = selectionObj.activePoint.width;
        var height = selectionObj.activePoint.height;
        var maxDestLeft = parent.img.destLeft + maxDimension.width;
        var maxDestTop = parent.img.destTop + maxDimension.height;
        if (parent.img.destLeft > startX) {
          parent.img.destLeft = startX;
        }
        if (parent.img.destTop > startY) {
          parent.img.destTop = startY;
        }
        if (maxDestLeft < startX + width) {
          parent.img.destLeft = startX + width - maxDimension.width;
        }
        if (maxDestTop < startY + height) {
          parent.img.destTop = startY + height - maxDimension.height;
        }
      } else if (value < 0 && isNullOrUndefined(selectionObj)) {
        if (parent.img.destLeft > 0) {
          parent.img.destLeft = 0;
        }
        if (parent.img.destTop > 0) {
          parent.img.destTop = 0;
        }
        if (parent.img.destLeft + maxDimension.width < parent.lowerCanvas.clientWidth) {
          parent.img.destLeft = parent.lowerCanvas.clientWidth - parent.img.destWidth;
        }
        if (parent.img.destTop + maxDimension.height < parent.lowerCanvas.clientHeight) {
          parent.img.destTop = parent.lowerCanvas.clientHeight - parent.img.destHeight;
        }
      }
      return maxDimension;
    };
    Transform2.prototype.drawPannedImage = function(xDiff, yDiff) {
      var parent = this.parent;
      var obj = { panDown: null };
      parent.notify("selection", { prop: "getPanDown", onPropertyChange: false, value: { obj } });
      var panEventArgs = { startPoint: obj["panDown"], endPoint: this.panMove, cancel: false };
      parent.trigger("panning", panEventArgs);
      if (panEventArgs.cancel) {
        return;
      }
      this.panEvent(xDiff, yDiff);
    };
    Transform2.prototype.panEvent = function(xDiff, yDiff, isPanMethod) {
      var parent = this.parent;
      var isObjCreated = false;
      if (parent.activeObj.shape && parent.activeObj.shape === "shape") {
        parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      }
      if (isNullOrUndefined(parent.activeObj.shape)) {
        isObjCreated = true;
        var actPoint = parent.activeObj.activePoint = {
          startX: parent.img.destLeft,
          startY: parent.img.destTop,
          endX: parent.img.destLeft + parent.img.destWidth,
          endY: parent.img.destTop + parent.img.destHeight
        };
        var startX = actPoint.startX;
        var startY = actPoint.startY;
        var endX = actPoint.endX;
        var endY = actPoint.endY;
        if (startX < 0) {
          actPoint.startX = 0;
        }
        if (startY < 0) {
          actPoint.startY = 0;
        }
        if (endX > parent.lowerCanvas.width) {
          actPoint.endX = parent.lowerCanvas.width;
        }
        if (endY > parent.lowerCanvas.height) {
          actPoint.endY = parent.lowerCanvas.height;
        }
        actPoint.width = actPoint.endX - actPoint.startX;
        actPoint.height = actPoint.endY - actPoint.startY;
        parent.activeObj.shape = "crop-custom";
        var obj = { strokeSettings: {} };
        parent.notify("shape", { prop: "getStrokeSettings", onPropertyChange: false, value: { obj } });
        parent.activeObj.strokeSettings = obj["strokeSettings"];
        parent.notify("draw", { prop: "updateActiveObject", onPropertyChange: false, value: {
          actPoint,
          obj: parent.activeObj,
          isMouseMove: null,
          x: null,
          y: null
        } });
        parent.isCropTab = true;
      }
      if (parent.transform.degree === 0) {
        var point = undefined;
        if (isNullOrUndefined(xDiff) && isNullOrUndefined(yDiff) || isPanMethod) {
          if (isPanMethod) {
            point = this.updatePanPoints(xDiff, yDiff);
          } else {
            point = this.updatePanPoints();
          }
        } else {
          point = { x: xDiff, y: yDiff };
        }
        parent.panPoint.totalPannedPoint.x += point.x;
        parent.panPoint.totalPannedPoint.y += point.y;
        var tempSelectionObj = extend({}, parent.activeObj, {}, true);
        var temp = this.lowerContext.filter;
        this.drawPannImage(point, isObjCreated);
        this.lowerContext.filter = temp;
        this.tempPanMove = extend({}, this.panMove, {}, true);
        parent.activeObj = extend({}, tempSelectionObj, {}, true);
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        if (parent.activeObj.shape) {
          parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate", obj: parent.activeObj } });
        }
      } else {
        var tempFlipState = parent.transform.currFlipState;
        parent.isCropTab = true;
        if (isNullOrUndefined(xDiff) && isNullOrUndefined(yDiff) || isPanMethod) {
          if (isPanMethod) {
            parent.panPoint.currentPannedPoint = this.updatePanPoints(xDiff, yDiff);
          } else {
            parent.panPoint.currentPannedPoint = this.updatePanPoints();
          }
        } else {
          parent.panPoint.currentPannedPoint = { x: xDiff, y: yDiff };
        }
        parent.transform.currFlipState = tempFlipState;
        this.rotatePan(null, null, isObjCreated);
        parent.isCropTab = false;
        this.tempPanMove = extend({}, this.panMove, {}, true);
      }
      if (isObjCreated) {
        parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        parent.isCropTab = false;
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      }
    };
    Transform2.prototype.drawPannImage = function(point, isObjCreated) {
      var parent = this.parent;
      var filter = this.lowerContext.filter;
      var destPoints = {
        startX: parent.img.destLeft,
        startY: parent.img.destTop,
        width: parent.img.destWidth,
        height: parent.img.destHeight
      };
      this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      parent.notify("draw", {
        prop: "updateCurrTransState",
        onPropertyChange: false,
        value: { type: "initial", isPreventDestination: null, isRotatePan: null }
      });
      parent.img.destLeft = destPoints.startX;
      parent.img.destTop = destPoints.startY;
      parent.img.destWidth = destPoints.width;
      parent.img.destHeight = destPoints.height;
      this.setDestPointsForFlipState();
      if (isObjCreated) {
        parent.isCropTab = false;
      }
      parent.notify("draw", { prop: "drawImage", onPropertyChange: false });
      if (isObjCreated) {
        parent.isCropTab = true;
      }
      if (parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle" || parent.isCircleCrop) {
        parent.notify("crop", {
          prop: "cropCircle",
          onPropertyChange: false,
          value: { context: this.lowerContext, isSave: null, isFlip: true }
        });
      }
      this.lowerContext.filter = filter;
      parent.notify("draw", {
        prop: "updateCurrTransState",
        onPropertyChange: false,
        value: { type: "reverse", isPreventDestination: null, isRotatePan: null }
      });
      parent.img.destLeft = destPoints.startX;
      parent.img.destTop = destPoints.startY;
      parent.img.destWidth = destPoints.width;
      parent.img.destHeight = destPoints.height;
      var temp = this.lowerContext.filter;
      this.lowerContext.filter = "none";
      if (isObjCreated) {
        parent.isCropTab = false;
      }
      parent.notify("shape", {
        prop: "drawAnnotations",
        onPropertyChange: false,
        value: {
          ctx: this.lowerContext,
          shape: "pan",
          pen: "pan",
          x: point.x,
          y: point.y,
          panRegion: ""
        }
      });
      if (isObjCreated) {
        parent.isCropTab = true;
      }
      this.lowerContext.filter = temp;
      parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
      if (parent.isCircleCrop) {
        parent.notify("crop", {
          prop: "cropCircle",
          onPropertyChange: false,
          value: { context: this.lowerContext, isSave: null, isFlip: true }
        });
      }
    };
    Transform2.prototype.resetZoom = function() {
      var parent = this.parent;
      if (parent.transform.defaultZoomFactor !== 0) {
        var isUndoRedo = parent.isUndoRedo;
        var object = { currObj: {} };
        parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
        this.transCurrObj = object["currObj"];
        this.transCurrObj.objColl = extend([], parent.objColl, null, true);
        this.transCurrObj.pointColl = extend({}, parent.pointColl, null, true);
        this.transCurrObj.afterCropActions = extend([], parent.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        parent.notify("freehand-draw", {
          prop: "getSelPointColl",
          onPropertyChange: false,
          value: { obj: selPointCollObj }
        });
        this.transCurrObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
        parent.isUndoRedo = parent.isCropToolbar = true;
        var zmFactor = parent.transform.defaultZoomFactor;
        if (zmFactor > 0) {
          this.zoomAction(-zmFactor);
        } else {
          this.zoomAction(Math.abs(zmFactor));
        }
        parent.isCropToolbar = false;
        parent.isUndoRedo = isUndoRedo;
      }
    };
    Transform2.prototype.performTransformation = function(text) {
      var parent = this.parent;
      this.resetZoom();
      this.updateTransform(text);
      for (var i = 0, len = parent.objColl.length; i < len; i++) {
        if (parent.objColl[i].flipObjColl.length > 0) {
          var flipObjColl = { collection: parent.objColl[i].flipObjColl };
          parent.notify("shape", {
            prop: "alignRotateFlipColl",
            onPropertyChange: false,
            value: { collection: flipObjColl["collection"], isRotateFlipCollection: null, obj: flipObjColl }
          });
          parent.objColl[i].flipObjColl = flipObjColl["collection"];
          if (parent.objColl[i].flipObjColl.length === 0) {
            parent.objColl[i].shapeFlip = "";
          }
        }
      }
    };
    Transform2.prototype.updateTransform = function(text) {
      switch (text.toLowerCase()) {
        case "rotateleft":
          this.rotateImage(-90);
          break;
        case "rotateright":
          this.rotateImage(90);
          break;
        case "horizontalflip":
          this.flipImage(Direction.Horizontal);
          break;
        case "verticalflip":
          this.flipImage(Direction.Vertical);
          break;
      }
    };
    Transform2.prototype.rotatePan = function(isCropSelection, isDefaultZoom, isObjCreated) {
      var parent = this.parent;
      this.isReverseRotate = true;
      var tempDegree = parent.transform.degree;
      var rotatePanActiveObj;
      var object = { selPointColl: null };
      if (parent.activeObj.activePoint && parent.activeObj.shape) {
        rotatePanActiveObj = extend({}, parent.activeObj, {}, true);
      }
      var tempObjColl = extend([], parent.objColl, [], true);
      var tempPointColl = extend([], parent.pointColl, [], true);
      parent.objColl = [];
      parent.pointColl = [];
      parent.freehandCounter = 0;
      parent.notify("freehand-draw", { prop: "getSelPointColl", onPropertyChange: false, value: { obj: object } });
      var cropSelPointColl = object["selPointColl"];
      parent.notify("freehand-draw", { prop: "setSelPointColl", onPropertyChange: false, value: { obj: { selPointColl: [] } } });
      parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      parent.notify("draw", { prop: "setRotateZoom", onPropertyChange: false, value: { isRotateZoom: true } });
      parent.notify("draw", {
        prop: "updateCurrTransState",
        onPropertyChange: false,
        value: { type: "initial", isPreventDestination: null, isRotatePan: null }
      });
      var initialDestLeft = parent.img.destLeft;
      var initialDestTop = parent.img.destTop;
      var intPan = parent.panPoint.totalPannedInternalPoint;
      if (parent.isCropTab) {
        parent.img.destLeft += intPan.x;
        parent.img.destTop += intPan.y;
      }
      parent.notify("crop", { prop: "updateRotatePan", onPropertyChange: false });
      if (parent.isCropTab) {
        parent.panPoint.totalPannedInternalPoint.x = parent.img.destLeft - initialDestLeft;
        parent.panPoint.totalPannedInternalPoint.y = parent.img.destTop - initialDestTop;
      }
      var temp = this.lowerContext.filter;
      if (isObjCreated) {
        parent.isCropTab = false;
      }
      parent.notify("draw", { prop: "drawImage", onPropertyChange: false });
      if (isObjCreated) {
        parent.isCropTab = true;
      }
      parent.notify("draw", { prop: "setRotateZoom", onPropertyChange: false, value: { isRotateZoom: false } });
      parent.notify("draw", {
        prop: "updateCurrTransState",
        onPropertyChange: false,
        value: { type: "reverse", isPreventDestination: true, isRotatePan: true }
      });
      var destLeft = parent.img.destLeft;
      var destTop = parent.img.destTop;
      parent.img.destLeft += parent.panPoint.totalPannedClientPoint.x;
      parent.img.destTop += parent.panPoint.totalPannedClientPoint.y;
      parent.img.destLeft += parent.panPoint.currentPannedPoint.x;
      parent.img.destTop += parent.panPoint.currentPannedPoint.y;
      parent.panPoint.totalPannedClientPoint.x = parent.img.destLeft - destLeft;
      parent.panPoint.totalPannedClientPoint.y = parent.img.destTop - destTop;
      parent.objColl = tempObjColl;
      parent.pointColl = tempPointColl;
      parent.freehandCounter = parent.pointColl.length;
      parent.notify("freehand-draw", {
        prop: "setSelPointColl",
        onPropertyChange: false,
        value: { obj: { selPointColl: cropSelPointColl } }
      });
      parent.transform.degree = tempDegree;
      this.lowerContext.filter = "none";
      if (isCropSelection) {
        if (isDefaultZoom) {
          parent.panPoint.totalPannedClientPoint.x = -parent.panPoint.totalPannedClientPoint.x;
          parent.panPoint.totalPannedClientPoint.y = -parent.panPoint.totalPannedClientPoint.y;
          parent.panPoint.currentPannedPoint = extend({}, parent.panPoint.totalPannedClientPoint, {}, true);
          parent.panPoint.totalPannedClientPoint = { x: 0, y: 0 };
          parent.img.destLeft += parent.panPoint.currentPannedPoint.x;
          parent.img.destTop += parent.panPoint.currentPannedPoint.y;
        } else {
          parent.panPoint.currentPannedPoint = extend({}, parent.panPoint.totalPannedClientPoint, {}, true);
        }
      }
      if (isObjCreated) {
        parent.isCropTab = false;
      }
      parent.notify("shape", {
        prop: "drawAnnotations",
        onPropertyChange: false,
        value: {
          ctx: this.lowerContext,
          shape: "pan",
          pen: "pan",
          x: parent.panPoint.currentPannedPoint.x,
          y: parent.panPoint.currentPannedPoint.y,
          panRegion: ""
        }
      });
      if (isObjCreated) {
        parent.isCropTab = true;
      }
      this.lowerContext.filter = temp;
      parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      parent.activeObj = extend({}, rotatePanActiveObj, {}, true);
      if (parent.activeObj.activePoint) {
        parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: {
          canvas: "duplicate",
          obj: parent.activeObj,
          isCropRatio: null,
          points: null,
          isPreventDrag: true,
          saveContext: null,
          isPreventSelection: null
        } });
      }
      this.isReverseRotate = false;
    };
    Transform2.prototype.limitPan = function() {
      var parent = this.parent;
      var _a = parent.activeObj.activePoint, startX = _a.startX, startY = _a.startY, endX = _a.endX, endY = _a.endY;
      var img = parent.img;
      if (parent.activeObj.activePoint) {
        if (img.destLeft > startX) {
          parent.img.destLeft = startX;
        }
        if (img.destTop > startY) {
          parent.img.destTop = startY;
        }
        if (img.destLeft + img.destWidth < endX) {
          parent.img.destLeft = endX - img.destWidth;
        }
        if (img.destTop + img.destHeight < endY) {
          parent.img.destTop = endY - img.destHeight;
        }
      }
    };
    Transform2.prototype.pan = function(value, x, y) {
      var parent = this.parent;
      if (!parent.disabled && parent.isImageLoaded) {
        if (value) {
          parent.togglePan = true;
          parent.notify("shape", {
            prop: "redrawActObj",
            onPropertyChange: false,
            value: { x: null, y: null, isMouseDown: null }
          });
          parent.notify("selection", { prop: "setDragCanvas", value: { bool: true } });
          parent.lowerCanvas.style.cursor = parent.upperCanvas.style.cursor = parent.cursor = "grab";
          parent.notify("selection", { prop: "setPanDown", onPropertyChange: false, value: { panDown: null } });
          if (x || y) {
            x = x ? x : 0;
            y = y ? y : 0;
            if (isNullOrUndefined(this.panMove)) {
              this.panMove = { x, y };
            }
            if (isNullOrUndefined(this.tempPanMove)) {
              this.tempPanMove = { x: this.panMove.x, y: this.panMove.y };
            }
            this.panEvent(x, y, true);
            this.tempPanMove = null;
          }
        } else {
          parent.togglePan = parent.currObjType.isCustomCrop = false;
          parent.notify("selection", { prop: "setDragCanvas", value: { bool: false } });
          parent.lowerCanvas.style.cursor = parent.upperCanvas.style.cursor = parent.cursor = "default";
        }
      }
    };
    Transform2.prototype.zoom = function(zoomFactor, zoomPoint) {
      var parent = this.parent;
      if (!parent.disabled && parent.isImageLoaded) {
        var value = this.getCurrentZoomFactor(zoomFactor);
        if (isNullOrUndefined(zoomPoint)) {
          this.zoomAction(value, zoomPoint);
        } else {
          var type = value > 0 ? "zoomIn" : "zoomOut";
          var absValue = Math.abs(value) * 10;
          for (var i = 0; i < absValue; i++) {
            parent.notify("draw", {
              prop: "performPointZoom",
              onPropertyChange: false,
              value: { x: zoomPoint.x, y: zoomPoint.y, type, isResize: null }
            });
          }
        }
        var actionArgs = {
          action: value > 0 ? "zoom-in" : "zoom-out",
          actionEventArgs: parent.editCompleteArgs
        };
        parent.triggerEditCompleteEvent(actionArgs);
      }
    };
    Transform2.prototype.getCurrentZoomFactor = function(zoomFactor) {
      return zoomFactor >= 1 ? this.prevZoomValue < 1 ? zoomFactor - this.prevZoomValue : (zoomFactor - this.prevZoomValue) * 0.1 : zoomFactor - this.prevZoomValue;
    };
    Transform2.prototype.setCurrPanRegion = function(region, type, obj) {
      var panRegion = region;
      if (region === "") {
        panRegion = type === "horizontal" ? "horizontal" : type === "vertical" ? "vertical" : region;
      } else if (region === "horizontal") {
        panRegion = type === "horizontal" ? "horizontalVertical" : type === "vertical" ? "verticalHorizontal" : type === 90 ? "vertical" : type === -90 ? "horizontal" : region;
      } else if (region === "vertical") {
        panRegion = type === "horizontal" ? "horizontalVertical" : type === "vertical" ? "verticalHorizontal" : type === 90 ? "horizontal" : type === -90 ? "vertical" : region;
      } else {
        panRegion = type === "horizontal" ? "vertical" : type === "vertical" ? "horizontal" : region;
      }
      obj["panRegion"] = panRegion;
    };
    Transform2.prototype.rotate = function(degree, obj) {
      var parent = this.parent;
      var isRotate = false;
      if (!parent.disabled && parent.isImageLoaded && degree % 90 === 0) {
        this.rotateImage(degree);
      }
      obj["isRotate"] = isRotate;
    };
    Transform2.prototype.flip = function(direction) {
      var parent = this.parent;
      if (!parent.disabled && parent.isImageLoaded) {
        this.flipImage(direction);
      }
    };
    Transform2.prototype.update = function() {
      var parent = this.parent;
      var toolbarHeight = 0;
      var isActiveObj = false;
      var freehandObj = { bool: false };
      var straightenObj = { bool: parent.isStraightening };
      var cxtTbarHeight = 0;
      var ctToolbar = parent.element.querySelector("#" + parent.element.id + "_contextualToolbar");
      var ctWrapper = parent.element.querySelector(".e-contextual-toolbar-wrapper");
      var hdWrapper = parent.element.querySelector("#" + parent.element.id + "_headWrapper");
      if (parent.isImageLoaded) {
        var isCropSelection = false;
        var splitWords = undefined;
        if (Browser.isDevice) {
          if (parent.activeObj.shape) {
            splitWords = parent.activeObj.shape.split("-");
          }
          if (parent.currObjType.isCustomCrop) {
            isCropSelection = true;
          } else if (splitWords && splitWords[0] === "crop") {
            isCropSelection = true;
          }
        }
        var frameObj = { bool: null };
        parent.notify("toolbar", { prop: "getFrameToolbar", onPropertyChange: false, value: { obj: frameObj } });
        if (!straightenObj["bool"] && (ctToolbar && !ctToolbar.parentElement.classList.contains("e-hide") || hdWrapper && !hdWrapper.parentElement.classList.contains("e-hide"))) {
          ctWrapper.classList.add("e-hide");
          if (!isCropSelection) {
            parent.okBtn(null, true);
          }
          parent.notify("toolbar", { prop: "refresh-main-toolbar", onPropertyChange: false });
          parent.notify("toolbar", { prop: "destroy-qa-toolbar", onPropertyChange: false });
        }
        parent.notify("selection", { prop: "getFreehandDrawEditing", onPropertyChange: false, value: { obj: freehandObj } });
        if (freehandObj["bool"]) {
          parent.notify("toolbar", { prop: "destroy-qa-toolbar", onPropertyChange: false });
        }
        var actPoint = extend({}, parent.activeObj.activePoint, {}, true);
        if (parent.activeObj.shape && (actPoint.width !== 0 || actPoint.height !== 0)) {
          isActiveObj = true;
          if (parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block") {
            parent.notify("shape", {
              prop: "redrawActObj",
              onPropertyChange: false,
              value: { x: null, y: null, isMouseDown: null }
            });
            parent.notify("toolbar", { prop: "destroy-qa-toolbar", onPropertyChange: false });
          } else {
            parent.notify("shape", { prop: "updImgRatioForActObj", onPropertyChange: false });
            parent.objColl.push(parent.activeObj);
          }
          parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        }
      }
      parent.updateDropInfoContent(parent.element.querySelector(".e-ie-drop-info"));
      var tempFilter = this.lowerContext.filter;
      var canvasWrapper = parent.element.querySelector("#" + parent.element.id + "_canvasWrapper");
      if (canvasWrapper) {
        canvasWrapper.style.width = parent.element.offsetWidth - 2 + "px";
      }
      parent.lowerCanvas.width = parent.upperCanvas.width = parent.maskCanvas.width = parent.element.offsetWidth - 2;
      if (parent.toolbarTemplate) {
        toolbarHeight = parent.element.querySelector("#" + parent.element.id + "_toolbarArea").clientHeight;
      } else if (parent.element.querySelector("#" + parent.element.id + "_toolbar")) {
        toolbarHeight = parent.element.querySelector("#" + parent.element.id + "_toolbar").clientHeight;
        if (toolbarHeight === 0 && parent.toolbar && parent.toolbar.length > 0 && parent.toolbar.indexOf("Open") === -1) {
          var obj = { toolbarHeight: 0 };
          parent.notify("toolbar", { prop: "getToolbarHeight", value: { obj } });
          toolbarHeight = obj["toolbarHeight"];
        }
      }
      var ctxTbarArea = parent.element.querySelector("#" + parent.element.id + "_contextualToolbarArea");
      if (Browser.isDevice && straightenObj["bool"] && ctxTbarArea) {
        cxtTbarHeight = ctxTbarArea.clientHeight;
      }
      parent.notify("toolbar", { prop: "setToolbarHeight", value: { height: toolbarHeight } });
      if (Browser.isDevice) {
        if (canvasWrapper) {
          canvasWrapper.style.height = parent.element.offsetHeight - (2 * toolbarHeight + cxtTbarHeight) - 4 + "px";
        }
      } else {
        if (canvasWrapper) {
          canvasWrapper.style.height = parent.element.offsetHeight - toolbarHeight - 2 + "px";
        }
      }
      parent.lowerCanvas.height = parent.upperCanvas.height = parseFloat(canvasWrapper.style.height);
      this.lowerContext.filter = "brightness(1) contrast(100%) hue-rotate(0deg) saturate(100%) opacity(1) blur(0px) sepia(0%) grayscale(0%) invert(0%)";
      parent.notify("filter", { prop: "setAdjustmentValue", onPropertyChange: false, value: { adjustmentValue: this.lowerContext.filter } });
      parent.canvasFilter = this.lowerContext.filter;
      parent.initialAdjustmentValue = this.lowerContext.filter;
      parent.clearContext(this.lowerContext);
      parent.clearContext(this.upperContext);
      if (parent.isImageLoaded) {
        parent.notify("shape", { prop: "applyActObj", onPropertyChange: false, value: { isMouseDown: null } });
        parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        this.lowerContext.filter = tempFilter;
        parent.initialAdjustmentValue = tempFilter;
        parent.canvasFilter = this.lowerContext.filter;
        if (parent.isImageLoaded) {
          showSpinner(parent.element);
          parent.element.style.opacity = "0.5";
        }
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        if (canvasWrapper) {
          canvasWrapper.style.width = parent.element.offsetWidth - 2 + "px";
          canvasWrapper.style.height = parent.element.offsetHeight + "px";
          var obj_1 = { toolbarHeight: 0 };
          parent.notify("toolbar", { prop: "getToolbarHeight", value: { obj: obj_1 } });
          if (Browser.isDevice) {
            canvasWrapper.style.height = parseFloat(canvasWrapper.style.height) - 2 * obj_1["toolbarHeight"] - cxtTbarHeight - 4 + "px";
          } else {
            canvasWrapper.style.height = parseFloat(canvasWrapper.style.height) - obj_1["toolbarHeight"] - 2 + "px";
          }
        }
        parent.lowerCanvas.width = parent.upperCanvas.width = parent.maskCanvas.width = parseFloat(canvasWrapper.style.width);
        parent.lowerCanvas.height = parent.upperCanvas.height = parent.maskCanvas.height = parseFloat(canvasWrapper.style.height);
        this.lowerContext.filter = tempFilter;
        var obj = { width: 0, height: 0 };
        this.calcMaxDimension(parent.img.srcWidth, parent.img.srcHeight, obj);
        var maxDimension = obj;
        if (straightenObj["bool"] && parent.transform.cropZoomFactor !== 0) {
          maxDimension.width += maxDimension.width * parent.transform.cropZoomFactor;
          maxDimension.height += maxDimension.height * parent.transform.cropZoomFactor;
        } else if (parent.transform.defaultZoomFactor > 0) {
          maxDimension.width += maxDimension.width * parent.transform.defaultZoomFactor;
          maxDimension.height += maxDimension.height * parent.transform.defaultZoomFactor;
        }
        parent.img.destLeft = (parent.lowerCanvas.clientWidth - maxDimension.width) / 2;
        parent.img.destTop = (parent.lowerCanvas.clientHeight - maxDimension.height + 1) / 2;
        if (parent.transform.degree === 0 && parent.transform.currFlipState === "") {
          if (parent.transform.defaultZoomFactor > 0) {
            parent.img.destLeft += parent.panPoint.totalPannedPoint.x;
            parent.img.destTop += parent.panPoint.totalPannedPoint.y;
          }
          parent.notify("draw", { prop: "draw-image-to-canvas", value: { dimension: maxDimension } });
        } else {
          parent.notify("draw", { prop: "draw-image-to-canvas", value: { dimension: maxDimension } });
          parent.notify("draw", {
            prop: "updateCurrTransState",
            onPropertyChange: false,
            value: { type: "initial", isPreventDestination: null, isRotatePan: null }
          });
          var temp = this.lowerContext.filter;
          parent.notify("draw", { prop: "drawImage", onPropertyChange: false });
          this.lowerContext.filter = temp;
          parent.notify("draw", {
            prop: "updateCurrTransState",
            onPropertyChange: false,
            value: { type: "reverse", isPreventDestination: null, isRotatePan: null }
          });
        }
        parent.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
        });
        parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
        parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.upperContext } });
        if (parent.isCircleCrop) {
          parent.notify("crop", {
            prop: "cropCircle",
            onPropertyChange: false,
            value: { context: this.lowerContext, isSave: null, isFlip: null }
          });
        }
        hideSpinner(parent.element);
        parent.element.style.opacity = "1";
        var obj1 = { defToolbarItems: null };
        parent.notify("toolbar", { prop: "getDefToolbarItems", value: { obj: obj1 } });
        if (obj1["defToolbarItems"] && obj1["defToolbarItems"].length > 0 && (undefined).getElementById(parent.element.id + "_toolbar")) {
          var toolbar_1 = getComponent(parent.element.id + "_toolbar", "toolbar");
          if (toolbar_1) {
            toolbar_1.refreshOverflow();
          }
          if (ctWrapper && !straightenObj["bool"]) {
            ctWrapper.classList.add("e-hide");
          }
        }
        parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        if (isActiveObj) {
          var activeObj = extend({}, parent.objColl[parent.objColl.length - 1], null, true);
          parent.objColl.pop();
          if (activeObj.activePoint.width !== 0 && activeObj.activePoint.height !== 0) {
            this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
            parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null } });
            parent.objColl.push(activeObj);
            parent.notify("shape", {
              prop: "drawAnnotations",
              onPropertyChange: false,
              value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
            });
            activeObj = extend({}, parent.objColl[parent.objColl.length - 1], null, true);
            parent.objColl.pop();
            this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
            parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null } });
            parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate", obj: activeObj } });
            if (straightenObj["bool"]) {
              parent.notify("draw", { prop: "setStraightenActObj", value: { activeObj } });
            }
            if (parent.activeObj.shape === "rectangle" || parent.activeObj.shape === "ellipse" || parent.activeObj.shape === "text" || parent.activeObj.shape === "line" || parent.activeObj.shape === "arrow" || parent.activeObj.shape === "path" || parent.activeObj.shape === "image") {
              parent.notify("toolbar", { prop: "renderQAT", onPropertyChange: false, value: { isPenEdit: null } });
            }
          }
        }
        if (freehandObj["bool"]) {
          parent.notify("toolbar", { prop: "renderQAT", onPropertyChange: false, value: { isPenEdit: true } });
        }
        if (parent.isResize) {
          parent.aspectWidth = Math.ceil(parent.img.destWidth);
          parent.aspectHeight = Math.ceil(parent.img.destHeight);
          parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
            type: "resize",
            isApplyBtn: false,
            isCropping: false
          } });
          parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
            type: "resize",
            isApplyBtn: false,
            isCropping: false
          } });
        }
        if ((parent.transform.degree !== 0 || parent.transform.currFlipState !== "") && parent.transform.defaultZoomFactor > 0) {
          var totalPannedPoint = extend({}, parent.panPoint.totalPannedPoint, null, true);
          var totalPannedInternalPoint = extend({}, parent.panPoint.totalPannedInternalPoint, null, true);
          var totalPannedClientPoint = extend({}, parent.panPoint.totalPannedClientPoint, null, true);
          this.zoomAction(0.1);
          this.zoomAction(-0.1);
          if (parent.transform.degree === 0) {
            parent.img.destLeft += totalPannedPoint.x;
            parent.img.destTop += totalPannedPoint.y;
            parent.panPoint.totalPannedPoint = totalPannedPoint;
            parent.notify("draw", { prop: "updateFlipPan", value: { tempSelectionObj: null } });
          } else {
            parent.panPoint.totalPannedInternalPoint = totalPannedInternalPoint;
            parent.panPoint.totalPannedClientPoint = totalPannedClientPoint;
            parent.panPoint.currentPannedPoint = { x: 0, y: 0 };
            parent.isCropTab = true;
            this.rotatePan();
            parent.isCropTab = false;
          }
        } else if (parent.transform.degree !== 0 && parent.transform.cropZoomFactor > 0) {
          parent.transform.zoomFactor = 0;
          parent.transform.cropZoomFactor = null;
          parent.notify("toolbar", { prop: "enable-disable-btns", onPropertyChange: false });
        }
      }
    };
    Transform2.prototype.calcMaxDimension = function(width, height, obj, isImgShape) {
      var object = { toolbarHeight: 0 };
      var parent = this.parent;
      parent.notify("toolbar", { prop: "getToolbarHeight", value: { obj: object } });
      var canvasMaxWidth = isImgShape ? parent.element.clientWidth / 3 : parent.element.clientWidth;
      var canvasMaxHeight = isImgShape ? (parent.element.clientHeight - object["toolbarHeight"]) / 3 : parent.element.clientHeight - object["toolbarHeight"];
      canvasMaxHeight = Browser.isDevice ? canvasMaxHeight - object["toolbarHeight"] : canvasMaxHeight;
      if (Browser.isDevice && parent.isStraightening) {
        var cxtTbar = parent.element.querySelector("#" + parent.element.id + "_contextualToolbarArea");
        canvasMaxHeight -= cxtTbar ? cxtTbar.clientHeight : 0;
      }
      if (!isImgShape && parent.element.clientHeight === 0) {
        canvasMaxHeight = 0;
      }
      if (isNullOrUndefined(isImgShape)) {
        if (canvasMaxWidth > 30) {
          canvasMaxWidth -= 30;
        }
        if (canvasMaxHeight > 30) {
          canvasMaxHeight -= 30;
        }
      }
      var widthScale = canvasMaxWidth / width;
      var heightScale = canvasMaxHeight / height;
      var cssMaxWidth = Math.min(width, canvasMaxWidth);
      var cssMaxHeight = Math.min(height, canvasMaxHeight);
      if (widthScale < 1 && widthScale < heightScale) {
        cssMaxWidth = width * widthScale;
        cssMaxHeight = height * widthScale;
      } else if (heightScale < 1 && heightScale < widthScale) {
        cssMaxWidth = width * heightScale;
        cssMaxHeight = height * heightScale;
      }
      if (isNullOrUndefined(isImgShape)) {
        var cropObj = { bool: null };
        parent.notify("crop", {
          prop: "getPreventScaling",
          onPropertyChange: false,
          value: { obj: cropObj }
        });
        if (cropObj["bool"] && parent.cropObj.activeObj.activePoint && parent.cropObj.activeObj.activePoint.width !== 0 && parent.cropObj.activeObj.activePoint.height !== 0) {
          cssMaxWidth = parent.cropObj.activeObj.activePoint.width;
          cssMaxHeight = parent.cropObj.activeObj.activePoint.height;
        }
      }
      if (obj) {
        obj["width"] = cssMaxWidth;
        obj["height"] = cssMaxHeight;
      }
      return { width: cssMaxWidth, height: cssMaxHeight };
    };
    Transform2.prototype.updatePanPoints = function(x, y) {
      var parent = this.parent;
      var tempActObj = extend({}, parent.activeObj, {}, true);
      var tempDestLeft = parent.img.destLeft;
      var tempDestTop = parent.img.destTop;
      if (isNullOrUndefined(this.tempPanMove)) {
        this.tempPanMove = { x: this.panMove.x, y: this.panMove.y };
      }
      var xDiff = this.panMove.x - this.tempPanMove.x;
      var yDiff = this.panMove.y - this.tempPanMove.y;
      if (x || y) {
        xDiff = x;
        yDiff = y;
      }
      parent.img.destLeft += xDiff;
      parent.img.destTop += yDiff;
      this.limitPan();
      var obj = { bool: null };
      var object = { isIntersect: null };
      parent.notify("draw", { prop: "updateImgCanvasPoints", onPropertyChange: false });
      parent.notify("draw", { prop: "isLinesIntersect", onPropertyChange: false, value: { obj: object } });
      parent.notify("draw", { prop: "isSelOutsideImg", onPropertyChange: false, value: { obj } });
      var count = 0;
      while (parent.transform.straighten !== 0 && (object["isIntersect"] || obj["bool"])) {
        count++;
        parent.img.destLeft = tempDestLeft;
        parent.img.destTop = tempDestTop;
        if (xDiff !== 0 && xDiff > 0) {
          xDiff -= 1;
        } else if (xDiff !== 0 && xDiff < 0) {
          xDiff += 1;
        }
        if (yDiff !== 0 && yDiff > 0) {
          yDiff -= 1;
        } else if (yDiff !== 0 && yDiff < 0) {
          yDiff += 1;
        }
        if (xDiff === 0 && yDiff === 0 || count === 200) {
          break;
        }
        parent.img.destLeft += xDiff;
        parent.img.destTop += yDiff;
        this.limitPan();
        parent.notify("draw", { prop: "updateImgCanvasPoints", onPropertyChange: false });
        parent.notify("draw", { prop: "isLinesIntersect", onPropertyChange: false, value: { obj: object } });
        parent.notify("draw", { prop: "isSelOutsideImg", onPropertyChange: false, value: { obj } });
      }
      parent.activeObj = tempActObj;
      return { x: parent.img.destLeft - tempDestLeft, y: parent.img.destTop - tempDestTop };
    };
    Transform2.prototype.resizeImage = function(width, height) {
      var parent = this.parent;
      var temp = true;
      var temp1 = true;
      parent.allowDownScale = false;
      parent.img.srcLeft = 0;
      parent.img.srcTop = 0;
      parent.isAspectRatio = true;
      var minimum = [];
      parent.img.srcWidth = parent.baseImgCanvas.width;
      parent.img.srcHeight = parent.baseImgCanvas.height;
      if (parent.resizeSrc && parent.resizeSrc.width !== 0 && parent.resizeSrc.height !== 0) {
        parent.img.srcLeft = parent.resizeSrc.startX;
        parent.img.srcTop = parent.resizeSrc.startY;
        parent.img.srcWidth = parent.resizeSrc.width;
        parent.img.srcHeight = parent.resizeSrc.height;
      }
      while ((width < parent.img.destWidth || height < parent.img.destHeight) && temp1) {
        this.zoomAction(-0.1, null, true, true);
        if (width > parent.img.destWidth || height > parent.img.destHeight) {
          while (width > parent.img.destWidth || height > parent.img.destHeight) {
            this.zoomAction(0.0125, null, true, true);
            temp1 = false;
            minimum.push(parent.img.destWidth);
          }
        }
      }
      while ((width > parent.img.destWidth || height > parent.img.destHeight) && temp1 && temp) {
        this.zoomAction(0.1, null, true, true);
        if (width < parent.img.destWidth || height < parent.img.destHeight) {
          while (width < parent.img.destWidth) {
            this.zoomAction(-0.0125, null, true, true);
            temp = false;
            minimum.push(parent.img.destWidth);
          }
        }
      }
      var nearestNumber = minimum[0];
      var smallestDifference = Math.abs(parent.img.destWidth - nearestNumber);
      for (var _i = 0, minimum_1 = minimum; _i < minimum_1.length; _i++) {
        var num = minimum_1[_i];
        var difference = Math.abs(width - num);
        if (difference < smallestDifference) {
          nearestNumber = num;
          smallestDifference = difference;
        }
      }
      if (nearestNumber < width && temp) {
        this.zoomAction(-0.0125, null, true, true);
        temp = false;
      }
      if (nearestNumber > width && !temp) {
        this.zoomAction(0.0125, null, true, true);
        temp = false;
      }
      this.zoomAction(0.0125, null, true);
      parent.allowDownScale = true;
      this.zoomAction(-0.0125, null, true);
      var prevCropObj = extend({}, parent.cropObj, {}, true);
      var prevObj = extend({}, this.prevResizeCurrObj, {}, true);
      parent.notify("undo-redo", { prop: "updateUndoRedoColl", onPropertyChange: false, value: {
        operation: "resize",
        previousObj: prevObj,
        previousObjColl: prevObj.objColl,
        previousPointColl: prevObj.pointColl,
        previousSelPointColl: prevObj.selPointColl,
        previousCropObj: prevCropObj,
        previousText: null,
        currentText: null,
        previousFilter: null,
        isCircleCrop: parent.isCircleCrop
      } });
      parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
    };
    Transform2.prototype.resizeCrop = function(width, height) {
      var parent = this.parent;
      var temp = true;
      var obj1 = { prevObj: parent.prevObj };
      parent.cropObj = extend({}, parent.prevCropObj, {}, true);
      parent.allowDownScale = false;
      parent.notify("toolbar", { prop: "getPrevObj", onPropertyChange: false, value: { obj: obj1 } });
      var activeObj = extend({}, obj1["prevObj"]["activeObj"], {}, true);
      obj1["prevObj"]["activeObj"] = extend({}, parent.activeObj, {}, true);
      parent.notify("draw", { prop: "setCurrentObj", onPropertyChange: false, value: { obj: obj1["prevObj"] } });
      parent.objColl = extend([], obj1["prevObj"]["objColl"], [], true);
      parent.pointColl = extend([], obj1["prevObj"]["pointColl"], [], true);
      parent.transform.straighten = 0;
      parent.notify("shape", {
        prop: "drawAnnotations",
        onPropertyChange: false,
        value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
      });
      if (parent.transform.straighten === 0 && !this.isPreventSelect) {
        parent.notify("freehand-draw", { prop: "updateFHDColl", onPropertyChange: false });
      }
      var tempwidth = width;
      var tempheight = height;
      var tempZoom = false;
      if (height >= width && height <= Math.ceil(parent.img.destHeight)) {
        while (height <= Math.ceil(parent.img.destHeight) && temp) {
          this.zoomAction(-0.1, null, true, true);
          if (width > parent.img.destWidth || height > parent.img.destHeight) {
            while (width > parent.img.destWidth || height > parent.img.destHeight) {
              this.zoomAction(0.0125, null, true, true);
              temp = false;
            }
          }
        }
      } else if (height <= width && width < parent.img.destWidth) {
        while (width < parent.img.destWidth && temp) {
          this.zoomAction(-0.1, null, true, true);
          if (width > parent.img.destWidth || height > parent.img.destHeight) {
            while (width > parent.img.destWidth || height > parent.img.destHeight) {
              this.zoomAction(0.0125, null, true, true);
              temp = false;
            }
          }
        }
      } else if (height >= width && height >= parent.img.destHeight) {
        while (height >= parent.img.destHeight && temp) {
          this.zoomAction(0.1, null, true, true);
        }
      } else if (width >= height && width >= parent.img.destWidth) {
        while (width >= parent.img.destWidth && temp) {
          this.zoomAction(0.1, null, true, true);
        }
        if (width < parent.img.destWidth && height < parent.img.destHeight) {
          while (width < parent.img.destWidth && height < parent.img.destHeight) {
            this.zoomAction(-0.0125, null, true, true);
            temp = false;
          }
          this.zoomAction(0.0125, null, true, true);
        }
      } else if (height > parent.img.destHeight && width > parent.img.destWidth) {
        while (height > parent.img.destHeight && width > parent.img.destWidth && temp) {
          this.zoomAction(0.1, null, true, true);
        }
        if (width < parent.img.destWidth && height < parent.img.destHeight) {
          while (width < parent.img.destWidth && height < parent.img.destHeight) {
            this.zoomAction(-0.0125, null, true, true);
            temp = false;
          }
          this.zoomAction(0.0125, null, true, true);
        }
      }
      this.resizeImg(activeObj, width, height);
      width = tempwidth;
      height = tempheight;
      if (height !== parent.img.destHeight || width !== parent.img.destWidth) {
        while (height > parent.img.destHeight || width > parent.img.destWidth) {
          this.zoomAction(0.0125, null, true, true);
          tempZoom = true;
        }
        if (tempZoom) {
          this.zoomAction(-0.0125, null, true, true);
          tempZoom = false;
        }
      }
      if (height !== parent.img.destHeight || width !== parent.img.destWidth) {
        while (height < parent.img.destHeight || width < parent.img.destWidth) {
          this.zoomAction(-0.0125, null, true, true);
          tempZoom = true;
        }
        if (tempZoom) {
          this.zoomAction(-0.0125, null, true, true);
          tempZoom = false;
        }
      }
      obj1["prevObj"]["activeObj"] = extend({}, activeObj, {}, true);
      this.zoomAction(0.0125, null, true);
      parent.allowDownScale = this.preventDownScale ? false : true;
      parent.isCropTab = false;
      this.zoomAction(-0.0125, null, true);
      parent.aspectWidth = width;
      parent.aspectHeight = height;
    };
    Transform2.prototype.resizeImg = function(activeObj, width, height) {
      var parent = this.parent;
      var widthRatio = width / parent.img.destWidth;
      var heightRatio = height / parent.img.destHeight;
      if (activeObj.shape) {
        parent.currSelectionPoint = activeObj;
        parent.notify("crop", { prop: "setInitCrop", onPropertyChange: false, value: { bool: true } });
      } else if (parent.img.srcWidth === parent.baseImgCanvas.width && parent.img.srcHeight === parent.baseImgCanvas.height) {
        parent.currSelectionPoint = null;
        parent.notify("draw", {
          prop: "select",
          onPropertyChange: false,
          value: { type: "custom", startX: null, startY: null, width: null, height: null }
        });
      }
      if (isNullOrUndefined(parent.currSelectionPoint)) {
        parent.notify("draw", {
          prop: "select",
          onPropertyChange: false,
          value: {
            type: "custom",
            startX: parent.img.destLeft,
            startY: parent.img.destTop,
            width: parent.img.destWidth,
            height: parent.img.destHeight
          }
        });
      } else {
        parent.notify("draw", {
          prop: "select",
          onPropertyChange: false,
          value: { type: "custom", startX: null, startY: null, width: null, height: null }
        });
      }
      width = parent.activeObj.activePoint.width * widthRatio;
      height = parent.activeObj.activePoint.height * heightRatio;
      var sx = parent.activeObj.activePoint.startX + parent.activeObj.activePoint.width / 2 - width / 2;
      var sy = parent.activeObj.activePoint.startY + parent.activeObj.activePoint.height / 2 - height / 2;
      var count = 0;
      while (Browser.isDevice && count < 500 && (sx < 0 || sy < 0 || sx + width > parent.img.destWidth || sy + height > parent.img.destHeight)) {
        count++;
        width -= 1;
        height -= 1;
        sx = parent.activeObj.activePoint.startX + parent.activeObj.activePoint.width / 2 - width / 2;
        sy = parent.activeObj.activePoint.startY + parent.activeObj.activePoint.height / 2 - height / 2;
      }
      parent.transform.defaultZoomFactor = 0;
      parent.notify("draw", { prop: "setResizeSelect", value: { bool: true } });
      parent.notify("draw", { prop: "setIsCropSelect", value: { bool: true } });
      parent.notify("draw", {
        prop: "select",
        onPropertyChange: false,
        value: { type: "custom", startX: sx, startY: sy, width, height }
      });
      parent.notify("draw", { prop: "setResizeSelect", value: { bool: false } });
      if (parent.transform.straighten !== 0) {
        var obj = { isIntersect: null, arr: null };
        parent.notify("draw", { prop: "updateImgCanvasPoints", onPropertyChange: false });
        parent.notify("draw", { prop: "isLinesIntersect", onPropertyChange: false, value: { obj } });
        while (obj["arr"][0] || obj["arr"][1] || obj["arr"][2] || obj["arr"][3]) {
          this.zoomAction(0.0125, null, true);
          parent.notify("draw", { prop: "updateImgCanvasPoints", onPropertyChange: false });
          parent.notify("draw", { prop: "isLinesIntersect", onPropertyChange: false, value: { obj } });
        }
      }
      parent.isCropToolbar = true;
      parent.crop();
      parent.isCropToolbar = false;
    };
    Transform2.prototype.updateResize = function() {
      var parent = this.parent;
      parent.prevCropObj = extend({}, parent.cropObj, {}, true);
      var currObject = { currObj: {} };
      parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object: currObject } });
      parent.prevObj = currObject["currObj"];
      if (parent.currSelectionPoint && parent.prevCropObj.activeObj.shape) {
        parent.prevObj.activeObj = extend({}, parent.prevCropObj.activeObj, {}, true);
      }
      parent.prevObj.objColl = extend([], parent.objColl, [], true);
      parent.prevObj.pointColl = extend([], parent.pointColl, [], true);
      parent.prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      parent.notify("freehand-draw", {
        prop: "getSelPointColl",
        onPropertyChange: false,
        value: { obj: selPointCollObj }
      });
      parent.prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
      parent.resizeSrc = {
        startX: parent.img.srcLeft,
        startY: parent.img.srcTop,
        width: parent.img.srcWidth,
        height: parent.img.srcHeight
      };
    };
    Transform2.prototype.resize = function(width, height, isAspectRatio) {
      var parent = this.parent;
      var aspectHeight;
      parent.isResize = true;
      if (isNullOrUndefined(parent.prevCropObj) && isNullOrUndefined(parent.prevObj)) {
        parent.notify("transform", { prop: "updateResize", value: { bool: false } });
      }
      var aspectIcon = parent.element.querySelector("#" + parent.element.id + "_aspectratio");
      var nonAspectIcon = parent.element.querySelector("#" + parent.element.id + "_nonaspectratio");
      if (aspectIcon && nonAspectIcon) {
        parent.notify("toolbar", { prop: "initResizeToolbar" });
        if (Browser.isDevice) {
          parent.notify("toolbar", { prop: "init-main-toolbar", value: { isApplyBtn: false, isDevice: true, isOkBtn: true, isResize: true } });
        }
      }
      var aspectRatioHeight = parent.element.querySelector("#" + parent.element.id + "_resizeHeight");
      if (aspectRatioHeight) {
        aspectHeight = aspectRatioHeight.value === "" ? aspectRatioHeight.placeholder : aspectRatioHeight.value;
      } else {
        aspectHeight = height + "px";
      }
      var resizeEventArgs = {
        cancel: false,
        previousWidth: Math.ceil(parent.img.destWidth),
        previousHeight: Math.ceil(parent.img.destHeight),
        width: Math.ceil(width),
        height: height && height !== 0 ? Math.ceil(height) : isAspectRatio ? Math.ceil(parseFloat(aspectHeight)) : Math.ceil(parent.img.destHeight),
        isAspectRatio: isAspectRatio ? isAspectRatio : false
      };
      parent.trigger("resizing", resizeEventArgs);
      parent.editCompleteArgs = resizeEventArgs;
      if (!resizeEventArgs.cancel) {
        this.resizeEventHandler(resizeEventArgs);
      } else if (parent.aspectHeight && parent.aspectWidth) {
        parent.aspectHeight = resizeEventArgs.previousHeight;
        parent.aspectWidth = resizeEventArgs.previousWidth;
      }
    };
    Transform2.prototype.resizeEventHandler = function(args) {
      var parent = this.parent;
      var isRotate;
      var aspectRatioWidth = parent.element.querySelector("#" + parent.element.id + "_resizeWidth");
      var aspectRatioHeight = parent.element.querySelector("#" + parent.element.id + "_resizeHeight");
      if (args.isAspectRatio) {
        if (this.resizedImgAngle == null || this.resizedImgAngle !== parent.transform.degree) {
          this.resizedImgAngle = parent.transform.degree;
          isRotate = true;
        }
        if (isRotate) {
          parent.notify("transform", { prop: "resizeImage", value: { width: args.width, height: 0 } });
          var originalWidth2 = parent.img.destWidth;
          var originalHeight2 = parent.img.destHeight;
          var aspectRatioWidthValue = undefined;
          if (aspectRatioHeight) {
            aspectRatioWidthValue = parseFloat(aspectRatioWidth.value === "" ? aspectRatioWidth.placeholder : aspectRatioWidth.value);
            var value = aspectRatioWidthValue / (originalWidth2 / originalHeight2);
            var height = value % 1 >= 0.5 || value % 1 <= -0.5 ? Math.round(value) : value < 0 ? Math.ceil(value) : Math.floor(value);
            getComponent(aspectRatioHeight, "numerictextbox").value = height;
            aspectRatioHeight.value = height.toString() + " px";
            parent.aspectHeight = height;
            if (aspectRatioWidth && aspectRatioWidth.value === "") {
              var aspectRatioHeightValue = parseFloat(aspectRatioHeight.value === "" ? aspectRatioHeight.placeholder : aspectRatioHeight.value);
              value = aspectRatioHeightValue / (originalHeight2 / originalWidth2);
              var width = value % 1 >= 0.5 || value % 1 <= -0.5 ? Math.round(value) : value < 0 ? Math.ceil(value) : Math.floor(value);
              getComponent(aspectRatioWidth, "numerictextbox").value = width;
              aspectRatioWidth.value = width.toString() + " px";
              parent.aspectWidth = width;
            }
          }
        } else {
          parent.notify("transform", { prop: "resizeImage", value: { width: args.width, height: null } });
        }
      } else {
        if (this.resizedImgAngle !== null && this.resizedImgAngle !== parent.transform.degree) {
          this.resizedImgAngle = parent.transform.degree;
          isRotate = true;
        }
        if (isRotate) {
          parent.notify("transform", { prop: "setPreventDownScale", value: { bool: true } });
          parent.notify("transform", { prop: "resizeCrop", value: { width: args.width, height: args.height } });
          parent.notify("undo-redo", { prop: "setPreventUR", value: { bool: true } });
          parent.okBtn(null, true);
          parent.notify("undo-redo", { prop: "setPreventUR", value: { bool: false } });
          parent.resizeSrc = {
            startX: parent.img.srcLeft,
            startY: parent.img.srcTop,
            width: parent.img.srcWidth,
            height: parent.img.srcHeight
          };
          parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
            type: "resize",
            isApplyBtn: null,
            isCropping: null,
            isZooming: null,
            cType: null
          } });
          parent.notify("transform", { prop: "setPreventDownScale", value: { bool: false } });
          parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
            type: "resize",
            isApplyBtn: null,
            isCropping: null,
            isZooming: null,
            cType: null
          } });
        } else {
          parent.notify("transform", { prop: "resizeCrop", value: { width: args.width, height: args.height } });
        }
      }
      this.resizedImgAngle = parent.transform.degree;
    };
    Transform2.prototype.straightenImage = function(degree) {
      var parent = this.parent;
      var isSelection = parent.activeObj.shape && parent.activeObj.shape.indexOf("crop-") > -1;
      if (parent.toolbar && parent.toolbar.length === 0) {
        parent.notify("draw", {
          prop: "select",
          onPropertyChange: false,
          value: { type: "custom", startX: null, startY: null, width: null, height: null }
        });
      }
      parent.notify("toolbar", { prop: "performCropTransformClick", value: { shape: null } });
      parent.setStraighten(degree);
      if (!isSelection) {
        parent.okBtn();
      }
    };
    return Transform2;
  }()
);
var UndoRedo = (
  /** @class */
  function() {
    function UndoRedo2(parent) {
      this.undoRedoStep = 0;
      this.undoRedoColl = [];
      this.appliedUndoRedoColl = [];
      this.tempUndoRedoColl = [];
      this.tempUndoRedoStep = 0;
      this.isPreventing = false;
      this.parent = parent;
      this.addEventListener();
    }
    UndoRedo2.prototype.destroy = function() {
      if (this.parent.isDestroyed) {
        return;
      }
      this.removeEventListener();
    };
    UndoRedo2.prototype.addEventListener = function() {
      this.parent.on("undo-redo", this.undoRedo, this);
      this.parent.on("destroyed", this.destroy, this);
    };
    UndoRedo2.prototype.removeEventListener = function() {
      this.parent.off("undo-redo", this.undoRedo);
      this.parent.off("destroyed", this.destroy);
    };
    UndoRedo2.prototype.initializeUrPvtProp = function() {
      if (this.parent.lowerCanvas) {
        this.lowerContext = this.parent.lowerCanvas.getContext("2d");
      }
      if (this.parent.upperCanvas) {
        this.upperContext = this.parent.upperCanvas.getContext("2d");
      }
    };
    UndoRedo2.prototype.undoRedo = function(args) {
      this.initializeUrPvtProp();
      switch (args.prop) {
        case "updateUndoRedoColl":
          this.updateUrc(args.value["operation"], args.value["previousObj"], args.value["previousObjColl"], args.value["previousPointColl"], args.value["previousSelPointColl"], args.value["previousCropObj"], args.value["previousText"], args.value["currentText"], args.value["previousFilter"], args.value["isCircleCrop"]);
          break;
        case "refreshUrc":
          this.refreshUrc(args.value["bool"]);
          break;
        case "updateCurrUrc":
          this.updateCurrUrc(args.value["type"], args.value["isCancel"]);
          break;
        case "call-undo":
          this.callUndo();
          break;
        case "call-redo":
          this.callRedo();
          break;
        case "undo":
          this.undo();
          break;
        case "redo":
          this.redo();
          break;
        case "updateUrObj":
          this.updateUrObj(args.value["objColl"], args.value["operation"]);
          break;
        case "updateUndoRedo":
          this.updateUndoRedo(args.value ? args.value["operation"] : null);
          break;
        case "getAppliedUndoRedoColl":
          args.value["obj"]["appliedUndoRedoColl"] = this.appliedUndoRedoColl;
          break;
        case "getUndoRedoStep":
          args.value["obj"]["undoRedoStep"] = this.undoRedoStep;
          break;
        case "setUndoRedoStep":
          this.undoRedoStep = args.value["step"];
          break;
        case "undoDefault":
          this.undoDefault(args.value["obj"]);
          break;
        case "setPreventUR":
          this.isPreventing = args.value["bool"];
          break;
        case "updateUndoRedoStack":
          if (args.value && args.value["isPenDraw"]) {
            this.updateUndoRedoStack(args.value["isPenDraw"]);
          } else {
            this.updateUndoRedoStack();
          }
          break;
        case "reset":
          this.reset();
          break;
      }
    };
    UndoRedo2.prototype.getModuleName = function() {
      return "undo-redo";
    };
    UndoRedo2.prototype.reset = function() {
      this.tempCurrSelPoint = null;
      this.undoRedoStep = 0;
      this.undoRedoColl = [];
      this.appliedUndoRedoColl = [];
      this.tempActObj = null;
      this.tempUndoRedoColl = [];
      this.tempUndoRedoStep = 0;
      this.isPreventing = false;
    };
    UndoRedo2.prototype.refreshUrc = function(refreshToolbar) {
      var parent = this.parent;
      if (parent.isImageUpdated) {
        return;
      }
      refreshToolbar = refreshToolbar ? refreshToolbar : false;
      if (refreshToolbar) {
        parent.notify("toolbar", { prop: "setEnableDisableUndoRedo", value: { isPrevent: true } });
        this.tempUndoRedoColl = extend([], this.appliedUndoRedoColl, [], true);
        this.tempUndoRedoStep = this.undoRedoStep;
      }
      parent.notify("toolbar", { prop: "setEnableDisableUndoRedo", value: { isPrevent: false } });
      this.undoRedoColl = this.undoRedoColl.slice(0, this.undoRedoStep);
      this.appliedUndoRedoColl = this.appliedUndoRedoColl.slice(0, this.undoRedoStep);
      parent.isUndoRedo = parent.currObjType.isUndoAction = false;
      parent.notify("toolbar", { prop: "enable-disable-btns" });
    };
    UndoRedo2.prototype.updateCurrUrc = function(type, isCancel) {
      var parent = this.parent;
      if (parent.isResize || this.isPreventing || parent.noPushUndo) {
        return;
      }
      parent.notify("toolbar", { prop: "setEnableDisableUndoRedo", value: { isPrevent: false } });
      if (type === "ok") {
        parent.notify("draw", { prop: "setShapeTextInsert", onPropertyChange: false, value: { bool: false } });
        var collection = this.tempUndoRedoColl.length > 0 ? extend([], this.tempUndoRedoColl, [], true) : extend([], this.undoRedoColl, [], true);
        var prevObj = this.undoRedoColl[this.undoRedoColl.length - 1];
        var appliedURColl = this.appliedUndoRedoColl[this.appliedUndoRedoColl.length - 1];
        var prevTransform = prevObj ? extend({}, prevObj.previousObj, {}, true) : null;
        if (isNullOrUndefined(appliedURColl)) {
          if (this.undoRedoColl[0]) {
            prevObj.previousCropObj = collection[0].previousCropObj;
            prevObj.previousObj = collection[0].previousObj;
            prevObj.previousObjColl = collection[0].previousObjColl;
            prevObj.previousPointColl = collection[0].previousPointColl;
            prevObj.previousText = collection[0].previousText;
          }
        } else if (prevObj.operation !== "imageHFlip" && prevObj.operation !== "imageVFlip") {
          prevObj.previousCropObj = appliedURColl.currentCropObj;
          prevObj.previousObj = appliedURColl.currentObj;
          prevObj.previousObjColl = appliedURColl.currentObjColl;
          prevObj.previousPointColl = appliedURColl.currentPointColl;
          prevObj.previousText = appliedURColl.currentText;
          if (prevObj.operation === "frame" && prevObj.previousObj && prevTransform) {
            prevObj.previousObj.defaultZoom = prevTransform.defaultZoom;
            prevObj.previousObj.zoomFactor = prevTransform.zoomFactor;
            prevObj.previousObj.cropZoom = prevTransform.cropZoom;
          }
        }
        if (prevObj) {
          if (prevObj.operation !== "imageHFlip" && prevObj.operation !== "imageVFlip") {
            var obj = this.getZeroZoomObjPointValue(prevObj.currentObjColl, prevObj.currentPointColl);
            prevObj.currentObjColl = obj["obj"];
            prevObj.currentPointColl = obj["point"];
            var adjObj = { adjustmentLevel: null };
            parent.notify("filter", { prop: "getAdjustmentLevel", onPropertyChange: false, value: { obj: adjObj } });
            prevObj.currentObj.adjustmentLevel = extend({}, adjObj["adjustmentLevel"], {}, true);
            parent.notify("filter", { prop: "setTempAdjVal" });
            prevObj.currentObj.currentFilter = parent.currentFilter;
          }
          this.appliedUndoRedoColl.push(prevObj);
          if (!isCancel) {
            this.triggerActionCompletedEvent(prevObj.operation);
          }
        }
        this.tempUndoRedoColl = [];
        this.tempUndoRedoStep = 0;
      } else if (this.tempUndoRedoColl.length > 0) {
        this.appliedUndoRedoColl = extend([], this.tempUndoRedoColl, [], true);
        this.undoRedoStep = this.tempUndoRedoStep;
        this.tempUndoRedoColl = [];
        this.tempUndoRedoStep = 0;
      }
      var lastObj = this.appliedUndoRedoColl[this.appliedUndoRedoColl.length - 1];
      var lastPrevObj = this.appliedUndoRedoColl[this.appliedUndoRedoColl.length - 2];
      if (this.appliedUndoRedoColl.length > 16) {
        this.appliedUndoRedoColl.splice(0, 1);
      } else if (!isCancel && lastObj && lastPrevObj) {
        if ((lastObj.operation === "shapeTransform" && lastPrevObj.operation === "shapeTransform" || lastObj.operation === "shapeInsert" && lastPrevObj.operation === "shapeInsert") && JSON.stringify(lastObj.currentObjColl) === JSON.stringify(lastPrevObj.currentObjColl) || lastObj.operation === "freehand-draw" && lastPrevObj.operation === "freehand-draw" && JSON.stringify(lastObj.currentPointColl) === JSON.stringify(lastPrevObj.currentPointColl) || lastObj.operation === "freehanddrawCustomized" && lastPrevObj.operation === "freehanddrawCustomized" && JSON.stringify(lastObj.currentPointColl) === JSON.stringify(lastPrevObj.currentPointColl)) {
          this.appliedUndoRedoColl.splice(this.appliedUndoRedoColl.length - 1, 1);
        } else if (this.undoRedoStep !== this.appliedUndoRedoColl.length - 1) {
          lastObj = this.appliedUndoRedoColl[this.appliedUndoRedoColl.length - 1];
          lastPrevObj = this.appliedUndoRedoColl[this.undoRedoStep];
          if (lastObj && lastPrevObj && lastObj.operation === "shapeTransform" && lastPrevObj.operation === "shapeTransform" && JSON.stringify(lastObj.currentObjColl) === JSON.stringify(lastPrevObj.previousObjColl)) {
            this.appliedUndoRedoColl.splice(this.appliedUndoRedoColl.length - 1, 1);
            this.undoRedoColl = [];
            this.undoRedoColl = extend([], this.appliedUndoRedoColl, [], true);
            return;
          }
        }
      }
      this.undoRedoColl = [];
      this.undoRedoColl = extend([], this.appliedUndoRedoColl, [], true);
      if (type === "ok") {
        this.undoRedoStep = this.undoRedoColl.length;
        parent.notify("toolbar", { prop: "enable-disable-btns" });
      }
      if (parent.transform.zoomFactor > 0) {
        parent.togglePan = true;
        parent.notify("selection", { prop: "setDragCanvas", value: { bool: true } });
      }
    };
    UndoRedo2.prototype.triggerActionCompletedEvent = function(action) {
      var parent = this.parent;
      var actionMap = {
        "brightness": "fine-tune",
        "contrast": "fine-tune",
        "hue": "fine-tune",
        "saturation": "fine-tune",
        "opacity": "fine-tune",
        "blur": "fine-tune",
        "exposure": "fine-tune",
        "default": "filter",
        "chrome": "filter",
        "cold": "filter",
        "warm": "filter",
        "grayscale": "filter",
        "sepia": "filter",
        "invert": "filter",
        "deleteObj": "shape-delete",
        "deleteFreehandDrawing": "freehand-draw-delete",
        "shapeInsert": "shape-insert",
        "shapeTransform": "shape-customize",
        "freehanddrawCustomized": "freehand-draw-customize"
      };
      var actionResult = actionMap[action] || action;
      var actionArgs = { action: actionResult, actionEventArgs: parent.editCompleteArgs };
      parent.triggerEditCompleteEvent(actionArgs);
    };
    UndoRedo2.prototype.getUndoRedoAction = function(action) {
      var actionMap = {
        "brightness": "fine-tune",
        "contrast": "fine-tune",
        "hue": "fine-tune",
        "saturation": "fine-tune",
        "opacity": "fine-tune",
        "blur": "fine-tune",
        "exposure": "fine-tune",
        "default": "filter",
        "chrome": "filter",
        "cold": "filter",
        "warm": "filter",
        "grayscale": "filter",
        "sepia": "filter",
        "invert": "filter",
        "deleteObj": "shape-delete",
        "deleteFreehandDrawing": "freehand-drawing-delete",
        "shapeInsert": "shape-insert",
        "shapeTransform": "shape-customize",
        "imageRotate": "shape-customize",
        "freehanddraw": "freehand-draw",
        "freehanddrawCustomized": "freehand-draw-customize",
        "textAreaCustomization": "text-area-customization",
        "imageHFlip": "shape-customize",
        "imageVFlip": "shape-customize",
        "bgColor": "background-color",
        "updateImage": "image-update"
      };
      return actionMap[action] || action;
    };
    UndoRedo2.prototype.cancelCropSelection = function() {
      var parent = this.parent;
      var isCropSelection = false;
      var splitWords;
      if (parent.activeObj.shape) {
        splitWords = parent.activeObj.shape.split("-");
      }
      if (parent.currObjType.isCustomCrop || splitWords && splitWords[0] === "crop") {
        isCropSelection = true;
      }
      if (isCropSelection) {
        parent.notify("draw", { prop: "performCancel", value: { isContextualToolbar: null } });
      }
      if (this.tempUndoRedoColl.length !== 0 || this.tempUndoRedoStep !== 0) {
        this.appliedUndoRedoColl = extend([], this.tempUndoRedoColl, [], true);
        this.undoRedoColl = extend([], this.tempUndoRedoColl, [], true);
        this.undoRedoStep = this.tempUndoRedoStep;
        this.tempUndoRedoColl = [];
        this.tempUndoRedoStep = 0;
        parent.notify("toolbar", { prop: "setEnableDisableUndoRedo", value: { isPrevent: false } });
      }
    };
    UndoRedo2.prototype.refreshToolbarActions = function() {
      var parent = this.parent;
      if (parent.activeObj.shape) {
        parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
          type: "shapes",
          isApplyBtn: null,
          isCropping: null,
          isZooming: null,
          cType: null
        } });
        parent.notify("toolbar", { prop: "update-toolbar-items", onPropertyChange: false });
      } else {
        parent.notify("toolbar", { prop: "refresh-main-toolbar", onPropertyChange: false });
      }
    };
    UndoRedo2.prototype.applyCurrentChanges = function() {
      var parent = this.parent;
      parent.currObjType.isFiltered = false;
      if (parent.transform.zoomFactor === 0) {
        parent.togglePan = false;
        parent.notify("selection", { prop: "setDragCanvas", value: { bool: false } });
      }
      if (parent.element.querySelector(".e-contextual-toolbar-wrapper")) {
        parent.element.querySelector(".e-contextual-toolbar-wrapper").classList.add("e-hide");
      }
      if (parent.togglePen) {
        parent.togglePen = false;
        parent.upperCanvas.style.cursor = parent.cursor = "default";
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      }
      if (this.appliedUndoRedoColl.length > 0) {
        this.undoRedoColl = extend([], this.appliedUndoRedoColl, [], true);
      }
    };
    UndoRedo2.prototype.callUndo = function() {
      this.applyCurrentChanges();
      this.undo();
    };
    UndoRedo2.prototype.callRedo = function() {
      this.applyCurrentChanges();
      this.redo();
    };
    UndoRedo2.prototype.undo = function() {
      var parent = this.parent;
      this.cancelCropSelection();
      parent.notify("draw", { prop: "resetFrameZoom", onPropertyChange: false, value: { isOk: false } });
      if (!parent.disabled && parent.isImageLoaded) {
        if (this.undoRedoStep > 0) {
          this.refreshToolbarActions();
          if (parent.activeObj.activePoint && parent.activeObj.activePoint.width !== 0) {
            this.tempActObj = parent.activeObj;
          }
          parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
          this.undoRedoStep--;
          parent.notify("toolbar", { prop: "enable-disable-btns" });
          if (parent.element.querySelector(".e-contextual-toolbar-wrapper")) {
            parent.element.querySelector(".e-contextual-toolbar-wrapper").classList.add("e-hide");
          }
          parent.isUndoRedo = true;
          var obj = this.undoRedoColl[this.undoRedoStep];
          if (this.undoRedoColl.length === this.undoRedoStep) {
            parent.currObjType.isUndoAction = false;
          } else {
            parent.currObjType.isUndoAction = true;
          }
          if (obj.operation !== "textAreaCustomization" && (parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block")) {
            parent.textArea.style.display = "none";
          }
          parent.notify("draw", { prop: "setCancelAction", onPropertyChange: false, value: { bool: true } });
          var activeObj = undefined;
          parent.cropObj = extend({}, obj.previousCropObj, {}, true);
          parent.afterCropActions = obj.previousObj.afterCropActions;
          this.lowerContext.filter = obj.previousObj.filter;
          parent.notify("filter", { prop: "setAdjustmentLevel", onPropertyChange: false, value: { adjustmentLevel: obj.previousObj.adjustmentLevel } });
          parent.notify("filter", { prop: "setTempAdjVal" });
          parent.currentFilter = obj.previousObj.currentFilter;
          parent.notify("filter", { prop: "setTempFilVal" });
          parent.canvasFilter = this.lowerContext.filter;
          parent.initialAdjustmentValue = this.lowerContext.filter;
          parent.notify("filter", { prop: "setBevelFilter", onPropertyChange: false, value: { bevelFilter: this.lowerContext.filter } });
          var editCompleteArgs = { action: this.getUndoRedoAction(obj.operation) };
          switch (obj.operation) {
            case "shapeTransform":
            case "brightness":
            case "contrast":
            case "hue":
            case "saturation":
            case "opacity":
            case "blur":
            case "exposure":
            case "default":
            case "chrome":
            case "cold":
            case "warm":
            case "grayscale":
            case "blackandwhite":
            case "sepia":
            case "invert":
            case "sharpen":
            case "imageRotate":
            case "shapeInsert":
              this.shapeTransform(obj.previousObjColl, obj.previousPointColl);
              break;
            case "freehanddraw":
            case "freehand-draw":
              this.updateFreehandDraw(obj.previousPointColl, obj.previousSelPointColl);
              parent.notify("freehand-draw", {
                prop: "setCurrentFreehandDrawIndex",
                value: { value: parent.pointColl.length }
              });
              break;
            case "freehanddrawCustomized":
              this.updateFreehandDrawCustomized(obj.previousObjColl, obj.previousPointColl);
              break;
            case "deleteFreehandDrawing":
            case "deleteObj":
              this.updateDelete(obj.operation, obj.previousObjColl, obj.previousPointColl, obj.previousSelPointColl);
              break;
            case "textAreaCustomization":
              this.shapeTransform(obj.previousObjColl, obj.previousPointColl);
              this.updateTextAreaCustomization(activeObj, obj.previousObjColl);
              break;
            case "text":
              this.updateText(obj.previousObjColl, true);
              break;
            case "frame":
              parent.transform.zoomFactor = parent.transform.defaultZoomFactor = obj.previousObj.defaultZoom;
              parent.setProperties({ zoomSettings: { zoomFactor: obj.previousObj.zoomFactor } }, true);
              parent.notify("transform", {
                prop: "setPreviousZoomValue",
                onPropertyChange: false,
                value: { previousZoomValue: parent.zoomSettings.zoomFactor }
              });
              extend(parent.frameObj, obj.previousObj.frameObj);
              parent.notify("draw", { prop: "render-image", value: { isMouseWheel: true, isPreventClearRect: null, isFrame: true } });
              break;
            case "imageHFlip":
              this.imageFlip("horizontal", obj.previousObjColl);
              break;
            case "imageVFlip":
              this.imageFlip("vertical", obj.previousObjColl);
              break;
            case "bgColor":
              parent.notify("draw", { prop: "imageBackgroundColor", onPropertyChange: false, value: { color: obj.previousObj.bgColor } });
              parent.notify("draw", { prop: "render-image", value: { isMouseWheel: false } });
              break;
            case "updateImage":
              parent.isImageUpdated = true;
              parent.baseImg.src = obj.previousObj.imageSource;
              setTimeout(function() {
                if (parent.cropObj.straighten !== 0) {
                  parent.notify("toolbar", { prop: "performCropTransformClick", value: { shape: "crop-custom" } });
                  parent.noPushUndo = true;
                  parent.crop();
                  parent.noPushUndo = false;
                } else {
                  parent.notify("draw", { prop: "render-image", value: { isMouseWheel: false } });
                }
                parent.isImageUpdated = false;
              });
              break;
            default:
              this.undoDefault(obj, true);
              parent.notify("filter", { prop: "set-adjustment", value: { operation: obj.operation } });
              parent.notify("filter", { prop: "update-filter", value: { operation: obj.operation, filter: obj.filter } });
              break;
          }
          if (obj.operation === "crop") {
            if (obj.previousObj.currSelectionPoint) {
              parent.currSelectionPoint = extend({}, obj.previousObj.currSelectionPoint, {}, true);
              if (parent.currSelectionPoint && isNullOrUndefined(parent.currSelectionPoint.shape)) {
                parent.currSelectionPoint = null;
              }
            }
            parent.updateCropTransformItems();
            parent.notify("draw", {
              prop: "select",
              onPropertyChange: false,
              value: { type: "custom", startX: null, startY: null, width: null, height: null }
            });
            if (parent.isCircleCrop) {
              parent.isCircleCrop = false;
              this.tempCurrSelPoint = extend({}, parent.currSelectionPoint, {}, true);
              parent.currSelectionPoint = null;
            }
            var tempCircleCrop = parent.cancelCropSelection.isCircleCrop;
            parent.cancelCropSelection.isCircleCrop = false;
            parent.notify("draw", { prop: "performCancel", value: { isContextualToolbar: null, isUndoRedo: true } });
            parent.cancelCropSelection.isCircleCrop = tempCircleCrop;
            parent.currObjType.isActiveObj = false;
            if (parent.transform.straighten !== 0) {
              parent.notify("draw", { prop: "setStraightenActObj", value: { activeObj: null } });
            }
          } else if (obj.operation === "resize" && parent.cropObj && parent.cropObj.activeObj) {
            parent.currSelectionPoint = extend({}, parent.cropObj.activeObj, {}, true);
          }
          if (this.undoRedoColl[this.undoRedoStep - 1] && this.undoRedoColl[this.undoRedoStep - 1].isCircleCrop) {
            parent.isCircleCrop = true;
            parent.notify("crop", {
              prop: "cropCircle",
              onPropertyChange: false,
              value: { context: this.lowerContext, isSave: null, isFlip: null }
            });
          }
          this.endUndoRedo(obj.operation, true);
          var action = { action: "undo", actionEventArgs: editCompleteArgs };
          parent.triggerEditCompleteEvent(action);
        }
      }
    };
    UndoRedo2.prototype.redo = function() {
      var parent = this.parent;
      this.cancelCropSelection();
      parent.notify("draw", { prop: "resetFrameZoom", onPropertyChange: false, value: { isOk: false } });
      if (!parent.disabled && parent.isImageLoaded) {
        if (this.undoRedoStep < this.appliedUndoRedoColl.length) {
          this.refreshToolbarActions();
          this.undoRedoStep++;
          parent.notify("toolbar", { prop: "enable-disable-btns" });
          parent.isUndoRedo = true;
          var obj = this.undoRedoColl[this.undoRedoStep - 1];
          if (this.undoRedoColl.length === this.undoRedoStep) {
            parent.currObjType.isUndoAction = false;
          } else {
            parent.currObjType.isUndoAction = true;
          }
          if (obj.operation !== "textAreaCustomization" && (parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block")) {
            parent.textArea.style.display = "none";
          }
          parent.notify("draw", { prop: "setCancelAction", onPropertyChange: false, value: { bool: true } });
          parent.cropObj = extend({}, obj.currentCropObj, {}, true);
          parent.afterCropActions = obj.currentObj.afterCropActions;
          this.lowerContext.filter = obj.currentObj.filter;
          if (parent.element.querySelector(".e-contextual-toolbar-wrapper")) {
            parent.element.querySelector(".e-contextual-toolbar-wrapper").classList.add("e-hide");
          }
          parent.notify("filter", { prop: "setAdjustmentLevel", onPropertyChange: false, value: { adjustmentLevel: obj.currentObj.adjustmentLevel } });
          parent.notify("filter", { prop: "setTempAdjVal" });
          parent.currentFilter = obj.currentObj.currentFilter;
          parent.notify("filter", { prop: "setTempFilVal" });
          parent.canvasFilter = this.lowerContext.filter;
          parent.initialAdjustmentValue = this.lowerContext.filter;
          parent.notify("filter", { prop: "setBevelFilter", onPropertyChange: false, value: { bevelFilter: this.lowerContext.filter } });
          var activeObj = undefined;
          var editCompleteArgs = { action: this.getUndoRedoAction(obj.operation) };
          switch (obj.operation) {
            case "shapeTransform":
            case "brightness":
            case "contrast":
            case "hue":
            case "saturation":
            case "opacity":
            case "blur":
            case "exposure":
            case "default":
            case "chrome":
            case "cold":
            case "warm":
            case "grayscale":
            case "blackandwhite":
            case "sepia":
            case "invert":
            case "sharpen":
            case "imageRotate":
            case "shapeInsert":
              this.shapeTransform(obj.currentObjColl, obj.currentPointColl);
              break;
            case "freehanddraw":
            case "freehand-draw":
              this.updateFreehandDraw(obj.currentPointColl, obj.currentSelPointColl);
              parent.notify("freehand-draw", {
                prop: "setCurrentFreehandDrawIndex",
                value: { value: parent.pointColl.length }
              });
              break;
            case "freehanddrawCustomized":
              this.updateFreehandDrawCustomized(obj.currentObjColl, obj.currentPointColl);
              break;
            case "deleteFreehandDrawing":
            case "deleteObj":
              this.updateDelete(obj.operation, obj.currentObjColl, obj.currentPointColl, obj.currentSelPointColl);
              break;
            case "textAreaCustomization":
              this.shapeTransform(obj.currentObjColl, obj.currentPointColl);
              this.updateTextAreaCustomization(activeObj, obj.currentObjColl);
              break;
            case "text":
              this.updateText(obj.currentObjColl, false);
              break;
            case "frame":
              extend(parent.frameObj, obj.currentObj.frameObj);
              parent.notify("draw", { prop: "render-image", value: { isMouseWheel: true, isPreventClearRect: null, isFrame: true } });
              break;
            case "imageHFlip":
              this.imageFlip("horizontal", obj.currentObjColl);
              break;
            case "imageVFlip":
              this.imageFlip("vertical", obj.currentObjColl);
              break;
            case "bgColor":
              parent.notify("draw", { prop: "imageBackgroundColor", onPropertyChange: false, value: { color: obj.currentObj.bgColor } });
              parent.notify("draw", { prop: "render-image", value: { isMouseWheel: false } });
              break;
            case "updateImage":
              parent.isImageUpdated = true;
              parent.baseImg.src = obj.currentObj.imageSource;
              setTimeout(function() {
                if (parent.cropObj.straighten !== 0) {
                  parent.notify("toolbar", { prop: "performCropTransformClick", value: { shape: "crop-custom" } });
                  parent.noPushUndo = true;
                  parent.crop();
                  parent.noPushUndo = false;
                } else {
                  parent.notify("draw", { prop: "render-image", value: { isMouseWheel: false } });
                }
                parent.isImageUpdated = false;
              });
              break;
            default:
              parent.objColl = [];
              parent.pointColl = [];
              parent.freehandCounter = 0;
              parent.notify("freehand-draw", {
                prop: "setSelPointColl",
                onPropertyChange: false,
                value: { obj: { selPointColl: [] } }
              });
              parent.notify("draw", { prop: "setCurrentObj", onPropertyChange: false, value: { obj: obj.currentObj, isUndoRedo: true } });
              parent.img.destLeft = obj.currentObj.destPoints.startX;
              parent.img.destTop = obj.currentObj.destPoints.startY;
              activeObj = extend({}, parent.activeObj, {}, true);
              parent.objColl = extend([], obj.currentObjColl, [], true);
              parent.pointColl = extend([], obj.currentPointColl, [], true);
              parent.freehandCounter = parent.pointColl.length;
              parent.notify("freehand-draw", {
                prop: "setSelPointColl",
                onPropertyChange: false,
                value: { obj: { selPointColl: extend([], obj.currentSelPointColl, [], true) } }
              });
              parent.transform.straighten = 0;
              this.lowerContext.filter = "none";
              parent.notify("shape", {
                prop: "drawAnnotations",
                onPropertyChange: false,
                value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
              });
              this.lowerContext.filter = obj.currentObj.filter;
              parent.prevStraightenedDegree = parent.transform.straighten;
              parent.activeObj = activeObj;
              this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
              if (parent.activeObj.activePoint.width !== 0 && parent.activeObj.activePoint.height !== 0) {
                parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate" } });
              }
              parent.notify("filter", { prop: "set-adjustment", value: { operation: obj.operation } });
              parent.notify("filter", { prop: "update-filter", value: { operation: obj.operation } });
              break;
          }
          if (obj.operation === "crop" && obj.isCircleCrop) {
            parent.isCircleCrop = true;
            parent.currSelectionPoint = extend({}, this.tempCurrSelPoint, {}, true);
            this.tempCurrSelPoint = null;
          }
          if (obj.operation === "crop" && !obj.isCircleCrop) {
            parent.isCircleCrop = false;
          }
          if (obj.operation === "crop" && obj.currentObj.currSelectionPoint) {
            parent.currSelectionPoint = extend({}, obj.currentObj.currSelectionPoint, {}, true);
            parent.notify("draw", { prop: "setStraightenActObj", value: { activeObj: parent.currSelectionPoint } });
          }
          if (parent.currSelectionPoint && isNullOrUndefined(parent.currSelectionPoint.shape)) {
            parent.currSelectionPoint = null;
          }
          if (obj.operation === "resize" && parent.cropObj && parent.cropObj.activeObj) {
            parent.currSelectionPoint = extend({}, parent.cropObj.activeObj, {}, true);
          }
          this.endUndoRedo(obj.operation, false);
          var action = { action: "redo", actionEventArgs: editCompleteArgs };
          parent.triggerEditCompleteEvent(action);
        }
      }
    };
    UndoRedo2.prototype.imageFlip = function(type, objColl) {
      var parent = this.parent;
      this.shapeTransform(objColl, null);
      parent.activeObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
      var _a = parent.activeObj, shape = _a.shape, isHorImageFlip = _a.isHorImageFlip, isVerImageFlip = _a.isVerImageFlip;
      parent.objColl.pop();
      if (shape && shape === "image") {
        if (type === "horizontal") {
          if (isNullOrUndefined(isHorImageFlip) && isVerImageFlip) {
            parent.activeObj.isHorImageFlip = true;
            parent.activeObj.isVerImageFlip = null;
            parent.horizontalFlip(this.upperContext, true);
          } else {
            if (isNullOrUndefined(isHorImageFlip) || !isHorImageFlip) {
              parent.activeObj.isHorImageFlip = true;
            } else {
              parent.activeObj.isHorImageFlip = null;
            }
            parent.horizontalFlip(this.upperContext, true);
          }
        } else if (type === "vertical") {
          if (isNullOrUndefined(isVerImageFlip) && isHorImageFlip) {
            parent.activeObj.isVerImageFlip = true;
            parent.activeObj.isHorImageFlip = null;
            parent.verticalFlip(this.upperContext, true);
          } else {
            if (isNullOrUndefined(isVerImageFlip) || !isVerImageFlip) {
              parent.activeObj.isVerImageFlip = true;
            } else {
              parent.activeObj.isVerImageFlip = null;
            }
            parent.verticalFlip(this.upperContext, true);
          }
        }
        parent.notify("shape", { prop: "applyActObj", onPropertyChange: false, value: { isMouseDown: true } });
      } else {
        parent.notify("draw", { prop: "render-image", value: { isMouseWheel: true } });
      }
    };
    UndoRedo2.prototype.shapeTransform = function(objColl, pointColl) {
      var parent = this.parent;
      parent.objColl = extend([], objColl, [], true);
      if (pointColl) {
        parent.pointColl = extend([], pointColl, [], true);
        parent.freehandCounter = parent.pointColl.length;
      }
      parent.notify("shape", {
        prop: "drawAnnotations",
        onPropertyChange: false,
        value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
      });
      this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      parent.isUndoRedo = true;
      parent.notify("draw", { prop: "redrawImgWithObj", onPropertyChange: false });
      parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
    };
    UndoRedo2.prototype.updateFreehandDraw = function(pointColl, selPointColl) {
      var parent = this.parent;
      parent.pointColl = pointColl;
      parent.notify("freehand-draw", {
        prop: "setSelPointColl",
        onPropertyChange: false,
        value: { obj: { selPointColl } }
      });
      parent.freehandCounter = parent.pointColl.length;
      parent.notify("shape", {
        prop: "drawAnnotations",
        onPropertyChange: false,
        value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
      });
      this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      parent.isUndoRedo = true;
      parent.notify("draw", { prop: "redrawImgWithObj", onPropertyChange: false });
    };
    UndoRedo2.prototype.updateFreehandDrawCustomized = function(objColl, pointColl) {
      var parent = this.parent;
      parent.objColl = extend([], objColl, [], true);
      parent.pointColl = pointColl;
      parent.notify("shape", {
        prop: "drawAnnotations",
        onPropertyChange: false,
        value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
      });
      this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      parent.isUndoRedo = true;
      parent.notify("draw", { prop: "redrawImgWithObj", onPropertyChange: false });
    };
    UndoRedo2.prototype.updateDelete = function(operation, objColl, pointColl, selPointColl) {
      var parent = this.parent;
      if (operation === "deleteFreehandDrawing") {
        parent.pointColl = pointColl;
        parent.freehandCounter = parent.pointColl.length;
        parent.notify("freehand-draw", {
          prop: "setSelPointColl",
          onPropertyChange: false,
          value: { obj: { selPointColl } }
        });
        parent.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
        });
      } else if (operation === "deleteObj") {
        parent.objColl = objColl;
        parent.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
        });
      }
      this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      parent.isUndoRedo = true;
      parent.notify("draw", { prop: "redrawImgWithObj", onPropertyChange: false });
    };
    UndoRedo2.prototype.updateTextAreaCustomization = function(activeObj, objColl) {
      var parent = this.parent;
      parent.objColl = extend([], objColl, [], true);
      parent.notify("shape", {
        prop: "drawAnnotations",
        onPropertyChange: false,
        value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
      });
      this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      parent.isUndoRedo = true;
      parent.notify("draw", { prop: "redrawImgWithObj", onPropertyChange: false });
      for (var i = 0, len = objColl.length; i < len; i++) {
        if (this.tempActObj) {
          if (this.tempActObj.currIndex === objColl[i].currIndex) {
            activeObj = extend({}, objColl[i], {}, true);
            parent.objColl.splice(i, 1);
            break;
          }
        } else {
          activeObj = extend({}, objColl[objColl.length - 1], {}, true);
          parent.objColl.splice(i, 1);
          break;
        }
      }
      if (activeObj) {
        this.updateTextBox(activeObj);
      }
      if (parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block") {
        parent.notify("shape", {
          prop: "redrawActObj",
          onPropertyChange: false,
          value: { x: null, y: null, isMouseDown: null }
        });
      }
    };
    UndoRedo2.prototype.updateText = function(objColl, allowActiveObj) {
      var parent = this.parent;
      if (this.tempActObj) {
        parent.activeObj = extend({}, this.tempActObj, {}, true);
      }
      if (objColl.length === 0 && parent.objColl.length === 1) {
        this.tempActObj = extend({}, parent.objColl[0], {}, true);
      } else {
        for (var i = 0, iLen = parent.objColl.length; i < iLen; i++) {
          if (parent.objColl[i] && isNullOrUndefined(objColl[i])) {
            this.tempActObj = extend({}, parent.objColl[i], {}, true);
            break;
          }
          if (objColl[i].currIndex !== parent.objColl[i].currIndex) {
            this.tempActObj = extend({}, parent.objColl[i], {}, true);
            break;
          }
        }
      }
      if (allowActiveObj) {
        parent.activeObj = extend({}, this.tempActObj, {}, true);
      }
      parent.objColl = extend([], objColl, [], true);
      parent.notify("shape", {
        prop: "drawAnnotations",
        onPropertyChange: false,
        value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: true }
      });
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      parent.isUndoRedo = true;
      parent.notify("draw", { prop: "redrawImgWithObj", onPropertyChange: false });
      parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
    };
    UndoRedo2.prototype.updateTextBox = function(obj) {
      var parent = this.parent;
      this.upperContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
      parent.notify("draw", { prop: "redrawImgWithObj", onPropertyChange: false });
      parent.notify("toolbar", { prop: "destroy-qa-toolbar", onPropertyChange: false });
      var textArea = parent.textArea;
      textArea.style.display = "block";
      textArea.style.fontFamily = obj.textSettings.fontFamily;
      textArea.style.fontSize = obj.textSettings.fontSize + "px";
      textArea.style.color = obj.strokeSettings.strokeColor;
      textArea.style.fontWeight = obj.textSettings.bold ? "bold" : "normal";
      textArea.style.fontStyle = obj.textSettings.italic ? "italic" : "normal";
      textArea.style.border = "2px solid " + parent.themeColl[parent.theme]["primaryColor"];
      textArea.value = obj.keyHistory;
      parent.activeObj = extend({}, obj, {}, true);
      parent.notify("shape", {
        prop: "updateFontStyles",
        onPropertyChange: false,
        value: { isTextBox: null }
      });
      parent.textArea.style.width = parent.activeObj.activePoint.width + "px";
    };
    UndoRedo2.prototype.undoDefault = function(obj, isUndoRedo) {
      this.lowerContext.filter = obj.previousObj.filter;
      var parent = this.parent;
      parent.objColl = [];
      parent.pointColl = [];
      parent.freehandCounter = 0;
      parent.notify("freehand-draw", {
        prop: "setSelPointColl",
        onPropertyChange: false,
        value: { obj: { selPointColl: [] } }
      });
      var isCircleCrop = !isUndoRedo ? obj.isCircleCrop : false;
      parent.notify("draw", { prop: "setCurrentObj", onPropertyChange: false, value: { obj: obj.previousObj, isUndoRedo, isCircleCrop } });
      parent.prevStraightenedDegree = parent.transform.straighten;
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      parent.img.destLeft = obj.previousObj.destPoints.startX;
      parent.img.destTop = obj.previousObj.destPoints.startY;
      var activeObj = extend({}, parent.activeObj, {}, true);
      parent.objColl = extend([], obj.previousObjColl, [], true);
      parent.pointColl = extend([], obj.previousPointColl, [], true);
      parent.freehandCounter = parent.pointColl.length;
      parent.notify("freehand-draw", {
        prop: "setSelPointColl",
        onPropertyChange: false,
        value: { obj: { selPointColl: extend([], obj.previousSelPointColl, [], true) } }
      });
      parent.transform.straighten = 0;
      this.lowerContext.filter = "none";
      parent.notify("shape", {
        prop: "drawAnnotations",
        onPropertyChange: false,
        value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
      });
      this.lowerContext.filter = obj.previousObj.filter;
      parent.activeObj = activeObj;
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      if (parent.activeObj.activePoint.width !== 0 && parent.activeObj.activePoint.height !== 0) {
        parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate" } });
      }
    };
    UndoRedo2.prototype.endUndoRedo = function(operation, isUndo) {
      var parent = this.parent;
      var frameObj = { type: "none", color: "#fff", size: 20, inset: 20, offset: 20, radius: 0, amount: 1, border: "solid", gradientColor: "" };
      if ((parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle" || parent.isCircleCrop) && JSON.stringify(parent.frameObj) !== JSON.stringify(frameObj)) {
        parent.notify("draw", { prop: "render-image", value: { isMouseWheel: true } });
      }
      parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
      if (parent.isCircleCrop && (isUndo && operation !== "crop" || !isUndo)) {
        parent.notify("crop", {
          prop: "cropCircle",
          onPropertyChange: false,
          value: { context: this.lowerContext, isSave: null, isFlip: null }
        });
      }
      if (parent.transform.zoomFactor > 0) {
        parent.notify("selection", { prop: "setDragCanvas", value: { bool: true } });
      }
      parent.notify("draw", { prop: "setCancelAction", onPropertyChange: false, value: { bool: false } });
      if (parent.activeObj.shape && parent.activeObj.shape.split("-")[0] === "crop") {
        parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
          type: "main",
          isApplyBtn: true,
          isCropping: true,
          isZooming: null,
          cType: null
        } });
      } else {
        parent.notify("toolbar", { prop: "refresh-main-toolbar", onPropertyChange: false });
      }
      parent.notify("toolbar", { prop: "enable-disable-btns" });
      if ((undefined).getElementById(parent.element.id + "_quickAccessToolbarArea")) {
        (undefined).getElementById(parent.element.id + "_quickAccessToolbarArea").style.display = "none";
      }
      parent.notify("toolbar", { prop: "enable-disable-btns" });
      if (parent.transform.degree !== 0) {
        parent.notify("transform", {
          prop: "drawPannedImage",
          onPropertyChange: false,
          value: { xDiff: 0, yDiff: 0 }
        });
      }
      parent.notify("filter", { prop: "setAdjustmentValue", onPropertyChange: false, value: { adjustmentValue: this.lowerContext.filter } });
      parent.currObjType.isCustomCrop = false;
    };
    UndoRedo2.prototype.updateUrc = function(operation, previousObj, previousObjColl, previousPointColl, previousSelPointColl, previousCropObj, previousText, currentText, previousFilter, isCircleCrop) {
      var parent = this.parent;
      if (parent.isResize || this.isPreventing) {
        return;
      }
      var obj = { isInitialLoaded: false };
      if (parent.currObjType.isUndoAction) {
        this.refreshUrc(true);
      }
      parent.notify("draw", { prop: "isInitialLoaded", onPropertyChange: false, value: { object: obj } });
      if (!obj["isInitialLoaded"] && parent.allowUndoRedo) {
        var object = { currObj: {} };
        parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
        var currentObj = object["currObj"];
        currentObj.objColl = extend([], parent.objColl, [], true);
        currentObj.pointColl = extend([], parent.pointColl, [], true);
        currentObj.afterCropActions = extend([], parent.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        parent.notify("freehand-draw", {
          prop: "getSelPointColl",
          onPropertyChange: false,
          value: { obj: selPointCollObj }
        });
        currentObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
        if (operation === "crop") {
          currentObj.currSelectionPoint = extend({}, parent.currSelectionPoint, {}, true);
        } else if (operation === "frame") {
          previousObj.destPoints = {
            startX: parent.frameDestPoints.destLeft,
            startY: parent.frameDestPoints.destTop,
            width: parent.frameDestPoints.destWidth,
            height: parent.frameDestPoints.destHeight
          };
          currentObj.destPoints = {
            startX: parent.frameDestPoints.destLeft,
            startY: parent.frameDestPoints.destTop,
            width: parent.frameDestPoints.destWidth,
            height: parent.frameDestPoints.destHeight
          };
          if (!isNullOrUndefined(parent.tempFrameZoomLevel)) {
            previousObj.defaultZoom = currentObj.defaultZoom = parent.tempFrameZoomLevel;
          }
        } else if ((operation === "imageHFlip" || operation === "imageVFlip") && this.appliedUndoRedoColl.length > 0) {
          var index = previousObjColl[previousObjColl.length - 1].currIndex;
          previousObjColl = this.appliedUndoRedoColl[this.appliedUndoRedoColl.length - 1].currentObjColl;
          if (index) {
            for (var i = 0, len = previousObjColl.length; i < len; i++) {
              if (previousObjColl[i].currIndex === index) {
                var actObj = extend({}, previousObjColl[i], {}, true);
                previousObjColl.splice(i, 1);
                previousObjColl.push(actObj);
                break;
              }
            }
          }
        }
        this.undoRedoColl.push({
          operation,
          previousObj,
          currentObj,
          previousObjColl,
          currentObjColl: currentObj.objColl,
          previousPointColl,
          currentPointColl: currentObj.pointColl,
          previousSelPointColl,
          currentSelPointColl: currentObj.selPointColl,
          previousCropObj,
          currentCropObj: extend({}, parent.cropObj, {}, true),
          previousText,
          currentText,
          filter: previousFilter,
          isCircleCrop
        });
        parent.notify("toolbar", { prop: "enable-disable-btns", onPropertyChange: false });
      }
    };
    UndoRedo2.prototype.updateUrObj = function(objColl, operation) {
      var parent = this.parent;
      if (parent.allowUndoRedo) {
        if (parent.currObjType.isUndoAction && !parent.isShapeDrawing) {
          this.refreshUrc(true);
        }
        if (isNullOrUndefined(parent.activeObj.imageRatio)) {
          parent.notify("shape", { prop: "updImgRatioForActObj", onPropertyChange: false });
        }
        parent.objColl.push(parent.activeObj);
        var cropObj = extend({}, parent.cropObj, {}, true);
        var object = { currObj: {} };
        parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
        var obj = object["currObj"];
        obj.objColl = extend([], parent.objColl, [], true);
        obj.pointColl = extend([], parent.pointColl, [], true);
        obj.afterCropActions = extend([], parent.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        parent.notify("freehand-draw", {
          prop: "getSelPointColl",
          onPropertyChange: false,
          value: { obj: selPointCollObj }
        });
        obj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
        var oper = operation ? operation : "shapeTransform";
        this.undoRedoColl.push({
          operation: oper,
          previousObj: obj,
          currentObj: obj,
          previousObjColl: objColl,
          currentObjColl: obj.objColl,
          previousPointColl: obj.pointColl,
          currentPointColl: obj.pointColl,
          previousSelPointColl: obj.selPointColl,
          currentSelPointColl: obj.selPointColl,
          previousCropObj: cropObj,
          currentCropObj: cropObj
        });
        parent.notify("selection", {
          prop: "redrawShape",
          onPropertyChange: false,
          value: { obj: parent.objColl[parent.objColl.length - 1] }
        });
      }
    };
    UndoRedo2.prototype.updateUndoRedo = function(operation) {
      var parent = this.parent;
      var prevCropObj = extend({}, parent.cropObj, {}, true);
      var object = { currObj: {} };
      parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
      var prevObj = object["currObj"];
      prevObj.objColl = extend([], parent.objColl, [], true);
      prevObj.pointColl = extend([], parent.pointColl, [], true);
      prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      parent.notify("freehand-draw", {
        prop: "getSelPointColl",
        onPropertyChange: false,
        value: { obj: selPointCollObj }
      });
      prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
      if (isNullOrUndefined(parent.activeObj.imageRatio)) {
        parent.notify("shape", { prop: "updImgRatioForActObj", onPropertyChange: false });
      }
      parent.objColl.push(parent.activeObj);
      var oper = operation ? operation : "shapeTransform";
      this.updateUrc(oper, prevObj, prevObj.objColl, prevObj.pointColl, prevObj.selPointColl, prevCropObj);
      parent.objColl.pop();
      parent.notify("shape", { prop: "applyActObj", onPropertyChange: false, value: { isMouseDown: null } });
      parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
        type: "shapes",
        isApplyBtn: null,
        isCropping: null,
        isZooming: null,
        cType: null
      } });
      parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
        type: "main",
        isApplyBtn: null,
        isCropping: null,
        isZooming: null,
        cType: null
      } });
    };
    UndoRedo2.prototype.getZeroZoomObjPointValue = function(obj, point) {
      var parent = this.parent;
      this.updateObjColl();
      var object = { currObj: {} };
      parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
      var currentObj = object["currObj"];
      currentObj.objColl = extend([], parent.objColl, [], true);
      currentObj.pointColl = extend([], parent.pointColl, [], true);
      currentObj.afterCropActions = extend([], parent.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      parent.notify("freehand-draw", {
        prop: "getSelPointColl",
        onPropertyChange: false,
        value: { obj: selPointCollObj }
      });
      currentObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
      var cropDimensionObj = { cropDimension: null };
      parent.notify("transform", { prop: "getCropDimension", onPropertyChange: false, value: { obj: cropDimensionObj } });
      var getZeroZoomObjColl = extend([], parent.objColl, [], true);
      var getZeroZoomPointColl = extend([], parent.pointColl, [], true);
      var arrowObj = { arrowDimension: null };
      this.parent.notify("draw", { prop: "getArrowDimension", onPropertyChange: false, value: { obj: arrowObj } });
      var tempArrowObj = extend({}, arrowObj["arrowDimension"], {}, true);
      if (parent.transform.zoomFactor > 0 && (obj.length > 0 || point.length > 0)) {
        if (obj.length > 0) {
          for (var i = 0; i < obj.length; i++) {
            if (obj[i].currIndex) {
              continue;
            } else {
              obj[i].currIndex = "shape_" + (i + 1);
            }
          }
        }
        parent.objColl = obj;
        parent.pointColl = point;
        var isUndoRedo = parent.isUndoRedo;
        var isCropTab = parent.isCropTab;
        if (parent.transform.zoomFactor !== 0) {
          parent.isUndoRedo = true;
          parent.notify("shape", {
            prop: "drawAnnotations",
            onPropertyChange: false,
            value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: true }
          });
          parent.notify("freehand-draw", { prop: "updateFHDColl", onPropertyChange: false });
          parent.isCropTab = true;
          var zoomSettings = extend({}, parent.zoomSettings, null, true);
          if (parent.transform.zoomFactor > 0) {
            parent.notify("transform", {
              prop: "zoomAction",
              onPropertyChange: false,
              value: { zoomFactor: -parent.transform.zoomFactor, zoomPoint: null, isResize: null }
            });
          } else {
            parent.notify("transform", {
              prop: "zoomAction",
              onPropertyChange: false,
              value: { zoomFactor: Math.abs(parent.transform.zoomFactor), zoomPoint: null, isResize: null }
            });
          }
          parent.zoomSettings = zoomSettings;
          parent.isCropTab = isCropTab;
          parent.isUndoRedo = isUndoRedo;
          getZeroZoomObjColl = extend([], parent.objColl, [], true);
          getZeroZoomPointColl = extend([], parent.pointColl, [], true);
          parent.objColl = [];
          parent.pointColl = [];
          parent.freehandCounter = 0;
          parent.notify("freehand-draw", {
            prop: "setSelPointColl",
            onPropertyChange: false,
            value: { obj: { selPointColl: [] } }
          });
          parent.notify("transform", {
            prop: "setCropDimension",
            onPropertyChange: false,
            value: { width: cropDimensionObj["cropDimension"]["width"], height: cropDimensionObj["cropDimension"]["height"] }
          });
          var maxDimension = { width: cropDimensionObj["cropDimension"]["width"], height: cropDimensionObj["cropDimension"]["height"] };
          maxDimension.width += maxDimension.width * currentObj.defaultZoom;
          maxDimension.height += maxDimension.height * currentObj.defaultZoom;
          parent.notify("draw", { prop: "setZoomCropWidth", value: { width: maxDimension.width, height: maxDimension.height } });
          parent.notify("draw", { prop: "setCurrentObj", onPropertyChange: false, value: { obj: currentObj } });
          parent.img.destLeft = currentObj.destPoints.startX;
          parent.img.destTop = currentObj.destPoints.startY;
          parent.panPoint.totalPannedPoint = currentObj.totalPannedPoint;
          parent.panPoint.totalPannedClientPoint = currentObj.totalPannedClientPoint;
          parent.panPoint.totalPannedInternalPoint = currentObj.totalPannedInternalPoint;
          parent.objColl = extend([], currentObj.objColl, [], true);
          parent.pointColl = extend([], currentObj.pointColl, [], true);
          parent.freehandCounter = parent.pointColl.length;
          parent.notify("draw", { prop: "setArrowDimension", onPropertyChange: false, value: { arrowDimension: tempArrowObj } });
          parent.notify("freehand-draw", {
            prop: "setSelPointColl",
            onPropertyChange: false,
            value: { obj: { selPointColl: extend([], currentObj.selPointColl, [], true) } }
          });
          this.lowerContext.filter = "none";
          parent.transform.straighten = 0;
          this.applyImgTranform();
          parent.notify("shape", {
            prop: "drawAnnotations",
            onPropertyChange: false,
            value: { ctx: this.lowerContext, shape: "iterate", pen: "iterate", isPreventApply: null }
          });
          parent.notify("freehand-draw", { prop: "updateFHDCurPts", onPropertyChange: false });
          this.lowerContext.filter = currentObj.filter;
          if (parent.transform.degree !== 0) {
            parent.notify("transform", {
              prop: "drawPannedImage",
              onPropertyChange: false,
              value: { xDiff: 0, yDiff: 0 }
            });
          }
          parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
          if (parent.isCircleCrop || parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle") {
            parent.notify("crop", {
              prop: "cropCircle",
              onPropertyChange: false,
              value: { context: this.lowerContext, isSave: null, isFlip: null }
            });
          }
        }
      }
      return { obj: getZeroZoomObjColl, point: getZeroZoomPointColl };
    };
    UndoRedo2.prototype.updateObjColl = function() {
      var parent = this.parent;
      for (var i = 0; i < parent.objColl.length; i++) {
        var obj = parent.objColl[i];
        var isUpdated = false;
        if (obj.shape === "line" || obj.shape === "arrow") {
          if (obj.activePoint.width < 0) {
            obj.activePoint.width = Math.abs(obj.activePoint.width);
            isUpdated = true;
          }
          if (obj.activePoint.height < 0) {
            obj.activePoint.height = Math.abs(obj.activePoint.height);
            isUpdated = true;
          }
          if (isUpdated) {
            var activeObj = extend({}, parent.activeObj, {}, true);
            parent.activeObj = obj;
            parent.notify("shape", { prop: "updImgRatioForActObj", onPropertyChange: false });
            obj = parent.activeObj;
            parent.activeObj = activeObj;
          }
        }
      }
    };
    UndoRedo2.prototype.applyImgTranform = function() {
      var parent = this.parent;
      var obj = extend({}, parent.activeObj, {}, true);
      for (var i = 0, len = parent.objColl.length; i < len; i++) {
        if (parent.objColl[i].shape === "image") {
          parent.activeObj = extend({}, parent.objColl[i], {}, true);
          var ctx = parent.objColl[i].imageCanvas.getContext("2d");
          parent.notify("selection", { prop: "applyTransformToImg", onPropertyChange: false, value: { ctx } });
          this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
          parent.notify("selection", { prop: "setImageClarity", onPropertyChange: false, value: { bool: true } });
        }
      }
      parent.activeObj = obj;
    };
    UndoRedo2.prototype.updateUndoRedoStack = function(isPenDraw) {
      var parent = this.parent;
      if (parent.activeObj.currIndex && parent.activeObj.activePoint.width !== 0 || parent.activeObj.activePoint.height !== 0 || parent.activeObj.pointColl && parent.activeObj.pointColl.length > 0 || isPenDraw) {
        var isTextArea = parent.textArea.style.display === "none" ? false : true;
        var temp = parent.noPushUndo;
        parent.noPushUndo = false;
        parent.isUndoRedoStack = true;
        if (isPenDraw) {
          var tempTogglePen = parent.togglePen;
          var obj = { freehandDrawSelectedId: null };
          parent.notify("freehand-draw", { prop: "getFreehandDrawSelectedId", onPropertyChange: false, value: { obj } });
          parent.okBtn();
          parent.noPushUndo = temp;
          if (obj["freehandDrawSelectedId"]) {
            parent.noRedact = true;
            parent.selectShape(obj["freehandDrawSelectedId"]);
          } else {
            parent.freeHandDraw(true);
          }
          parent.togglePen = tempTogglePen;
        } else if (parent.activeObj.currIndex) {
          var shapeId = parent.activeObj.currIndex;
          parent.okBtn();
          parent.noPushUndo = temp;
          parent.noRedact = true;
          parent.selectShape(shapeId);
          if (parent.drawingShape) {
            parent.notify("selection", { prop: "setCurrentDrawingShape", onPropertyChange: false, value: { value: parent.drawingShape.toLowerCase() } });
          }
          if (isTextArea) {
            parent.enableTextEditing();
          }
        }
        parent.isUndoRedoStack = false;
      }
    };
    return UndoRedo2;
  }()
);
var CLASSNAMES = {
  RTL: "e-rtl",
  DISABLE: "e-disabled",
  INPUT: "e-input",
  TEXTAREA: "e-multi-line-input",
  INPUTGROUP: "e-input-group",
  FLOATINPUT: "e-float-input",
  FLOATLINE: "e-float-line",
  FLOATTEXT: "e-float-text",
  FLOATTEXTCONTENT: "e-float-text-content",
  CLEARICON: "e-clear-icon",
  CLEARICONHIDE: "e-clear-icon-hide",
  LABELTOP: "e-label-top",
  LABELBOTTOM: "e-label-bottom",
  NOFLOATLABEL: "e-no-float-label",
  INPUTCUSTOMTAG: "e-input-custom-tag",
  FLOATCUSTOMTAG: "e-float-custom-tag"
};
var containerAttributes = ["title", "style", "class"];
var TEXTBOX_FOCUS = "e-input-focus";
var Input;
(function(Input2) {
  var isBindClearAction = true;
  function createInput(args, internalCreateElement) {
    args.element.__eventHandlers = {};
    var makeElement = !isNullOrUndefined(internalCreateElement) ? internalCreateElement : createElement;
    var inputObject = { container: null, buttons: [], clearButton: null };
    args.floatLabelType;
    isBindClearAction = args.bindClearAction;
    if (isNullOrUndefined(args.floatLabelType) || args.floatLabelType === "Never") {
      inputObject.container = createInputContainer(args, CLASSNAMES.INPUTGROUP, CLASSNAMES.INPUTCUSTOMTAG, "span", makeElement);
      args.element.parentNode.insertBefore(inputObject.container, args.element);
      addClass([args.element], CLASSNAMES.INPUT);
      inputObject.container.appendChild(args.element);
    } else {
      createFloatingInput(args, inputObject, makeElement);
    }
    bindInitialEvent(args);
    if (!isNullOrUndefined(args.properties) && !isNullOrUndefined(args.properties.showClearButton) && args.properties.showClearButton) {
      setClearButton(args.properties.showClearButton, args.element, inputObject, true, makeElement);
      inputObject.clearButton.setAttribute("role", "button");
      if (inputObject.container.classList.contains(CLASSNAMES.FLOATINPUT)) {
        addClass([inputObject.container], CLASSNAMES.INPUTGROUP);
      }
    }
    if (!isNullOrUndefined(args.buttons)) {
      for (var i = 0; i < args.buttons.length; i++) {
        inputObject.buttons.push(appendSpan(args.buttons[i], inputObject.container, makeElement));
      }
    }
    if (!isNullOrUndefined(args.element) && args.element.tagName === "TEXTAREA") {
      addClass([inputObject.container], CLASSNAMES.TEXTAREA);
    }
    validateInputType(inputObject.container, args.element);
    inputObject = setPropertyValue(args, inputObject);
    createSpanElement(inputObject.container, makeElement);
    return inputObject;
  }
  Input2.createInput = createInput;
  function bindFocusEventHandler(args) {
    var parent = getParentNode(args.element);
    if (parent.classList.contains("e-input-group") || parent.classList.contains("e-outline") || parent.classList.contains("e-filled")) {
      parent.classList.add("e-input-focus");
    }
    if (args.floatLabelType !== "Never") {
      setTimeout(function() {
        Input2.calculateWidth(args.element, parent);
      }, 80);
    }
  }
  function bindBlurEventHandler(args) {
    var parent = getParentNode(args.element);
    if (parent.classList.contains("e-input-group") || parent.classList.contains("e-outline") || parent.classList.contains("e-filled")) {
      parent.classList.remove("e-input-focus");
    }
    if (args.floatLabelType !== "Never") {
      setTimeout(function() {
        Input2.calculateWidth(args.element, parent);
      }, 80);
    }
  }
  function bindInputEventHandler(args) {
    checkInputValue(args.floatLabelType, args.element);
  }
  function bindInitialEvent(args) {
    checkInputValue(args.floatLabelType, args.element);
    var focusHandler2 = function() {
      return bindFocusEventHandler(args);
    };
    var blurHandler2 = function() {
      return bindBlurEventHandler(args);
    };
    var inputHandler2 = function() {
      return bindInputEventHandler(args);
    };
    args.element.addEventListener("focus", focusHandler2);
    args.element.addEventListener("blur", blurHandler2);
    args.element.addEventListener("input", inputHandler2);
    args.element.__eventHandlers["inputFocusHandler"] = { focusHandler: focusHandler2 };
    args.element.__eventHandlers["inputBlurHandler"] = { blurHandler: blurHandler2 };
    args.element.__eventHandlers["inputHandler"] = { inputHandler: inputHandler2 };
  }
  Input2.bindInitialEvent = bindInitialEvent;
  function unbindInitialEvent(args) {
    if (!isNullOrUndefined(args.element)) {
      if (!isNullOrUndefined(args.element.__eventHandlers)) {
        if (!isNullOrUndefined(args.element.__eventHandlers["inputFocusHandler"]) && !isNullOrUndefined(args.element.__eventHandlers["inputBlurHandler"]) && !isNullOrUndefined(args.element.__eventHandlers["inputHandler"])) {
          var focusHandler_1 = args.element.__eventHandlers["inputFocusHandler"].focusHandler;
          var blurHandler_1 = args.element.__eventHandlers["inputBlurHandler"].blurHandler;
          var inputHandler_1 = args.element.__eventHandlers["inputHandler"].inputHandler;
          args.element.removeEventListener("focus", focusHandler_1);
          args.element.removeEventListener("blur", blurHandler_1);
          args.element.removeEventListener("input", inputHandler_1);
          delete args.element.__eventHandlers["inputFocusHandler"];
          delete args.element.__eventHandlers["inputBlurHandler"];
          delete args.element.__eventHandlers["inputHandler"];
        }
      }
    }
  }
  function checkInputValue(floatLabelType, inputElement) {
    var inputValue = inputElement.value;
    var inputParent = inputElement.parentElement;
    var grandParent = inputParent && inputParent.parentElement;
    if (inputValue !== "" && !isNullOrUndefined(inputValue)) {
      if (inputParent && inputParent.classList.contains("e-input-group")) {
        inputParent.classList.add("e-valid-input");
      } else if (grandParent && grandParent.classList.contains("e-input-group")) {
        grandParent.classList.add("e-valid-input");
      }
    } else if (floatLabelType !== "Always") {
      if (inputParent && inputParent.classList.contains("e-input-group")) {
        inputParent.classList.remove("e-valid-input");
      } else if (grandParent && grandParent.classList.contains("e-input-group")) {
        grandParent.classList.remove("e-valid-input");
      }
    }
  }
  function _focusFn() {
    var label = getParentNode(this).getElementsByClassName("e-float-text")[0];
    if (!isNullOrUndefined(label)) {
      addClass([label], CLASSNAMES.LABELTOP);
      if (label.classList.contains(CLASSNAMES.LABELBOTTOM)) {
        removeClass([label], CLASSNAMES.LABELBOTTOM);
      }
    }
  }
  function _blurFn() {
    var parent = getParentNode(this);
    if (parent.getElementsByTagName("textarea")[0] ? parent.getElementsByTagName("textarea")[0].value === "" : parent.getElementsByTagName("input")[0].value === "") {
      var label = parent.getElementsByClassName("e-float-text")[0];
      if (!isNullOrUndefined(label)) {
        if (label.classList.contains(CLASSNAMES.LABELTOP)) {
          removeClass([label], CLASSNAMES.LABELTOP);
        }
        addClass([label], CLASSNAMES.LABELBOTTOM);
      }
    }
  }
  function wireFloatingEvents(element2) {
    element2.addEventListener("focus", _focusFn);
    element2.addEventListener("blur", _blurFn);
  }
  Input2.wireFloatingEvents = wireFloatingEvents;
  function unwireFloatingEvents(element2) {
    if (!isNullOrUndefined(element2)) {
      element2.removeEventListener("focus", _focusFn);
      element2.removeEventListener("blur", _blurFn);
    }
  }
  function inputEventHandler(args) {
    validateLabel(args.element, args.floatLabelType);
  }
  function blurEventHandler(args) {
    validateLabel(args.element, args.floatLabelType);
  }
  function createFloatingInput(args, inputObject, internalCreateElement) {
    var makeElement = !isNullOrUndefined(internalCreateElement) ? internalCreateElement : createElement;
    if (args.floatLabelType === "Auto") {
      wireFloatingEvents(args.element);
    }
    if (isNullOrUndefined(inputObject.container)) {
      inputObject.container = createInputContainer(args, CLASSNAMES.FLOATINPUT, CLASSNAMES.FLOATCUSTOMTAG, "div", makeElement);
      inputObject.container.classList.add(CLASSNAMES.INPUTGROUP);
      if (args.element.parentNode) {
        args.element.parentNode.insertBefore(inputObject.container, args.element);
      }
    } else {
      if (!isNullOrUndefined(args.customTag)) {
        inputObject.container.classList.add(CLASSNAMES.FLOATCUSTOMTAG);
      }
      inputObject.container.classList.add(CLASSNAMES.FLOATINPUT);
    }
    var floatLinelement = makeElement("span", { className: CLASSNAMES.FLOATLINE });
    var floatLabelElement = makeElement("label", { className: CLASSNAMES.FLOATTEXT });
    if (!isNullOrUndefined(args.element.id) && args.element.id !== "") {
      floatLabelElement.id = "label_" + args.element.id.replace(/ /g, "_");
      attributes(args.element, { "aria-labelledby": floatLabelElement.id });
    }
    if (!isNullOrUndefined(args.element.placeholder) && args.element.placeholder !== "") {
      floatLabelElement.innerText = encodePlaceHolder(args.element.placeholder);
      args.element.removeAttribute("placeholder");
    }
    if (!isNullOrUndefined(args.properties) && !isNullOrUndefined(args.properties.placeholder) && args.properties.placeholder !== "") {
      floatLabelElement.innerText = encodePlaceHolder(args.properties.placeholder);
    }
    if (!floatLabelElement.innerText) {
      inputObject.container.classList.add(CLASSNAMES.NOFLOATLABEL);
    }
    if (inputObject.container.classList.contains("e-float-icon-left")) {
      var inputWrap = inputObject.container.querySelector(".e-input-in-wrap");
      inputWrap.appendChild(args.element);
      inputWrap.appendChild(floatLinelement);
      inputWrap.appendChild(floatLabelElement);
    } else {
      inputObject.container.appendChild(args.element);
      inputObject.container.appendChild(floatLinelement);
      inputObject.container.appendChild(floatLabelElement);
    }
    updateLabelState(args.element.value, floatLabelElement);
    if (args.floatLabelType === "Always") {
      if (floatLabelElement.classList.contains(CLASSNAMES.LABELBOTTOM)) {
        removeClass([floatLabelElement], CLASSNAMES.LABELBOTTOM);
      }
      addClass([floatLabelElement], CLASSNAMES.LABELTOP);
    }
    if (args.floatLabelType === "Auto") {
      var inputFloatHandler = function() {
        return inputEventHandler(args);
      };
      var blurFloatHandler = function() {
        return blurEventHandler(args);
      };
      args.element.addEventListener("input", inputFloatHandler);
      args.element.addEventListener("blur", blurFloatHandler);
      args.element.__eventHandlers["floatInputHandler"] = { inputFloatHandler };
      args.element.__eventHandlers["floatBlurHandler"] = { blurFloatHandler };
    } else {
      unWireFloatLabelEvents(args);
    }
    if (!isNullOrUndefined(args.element.getAttribute("id"))) {
      floatLabelElement.setAttribute("for", args.element.getAttribute("id"));
    }
  }
  function unWireFloatLabelEvents(args) {
    if (!isNullOrUndefined(args.element) && !isNullOrUndefined(args.element.__eventHandlers) && !isNullOrUndefined(args.element.__eventHandlers["floatInputHandler"]) && !isNullOrUndefined(args.element.__eventHandlers["floatBlurHandler"])) {
      var inputFloatHandler = args.element.__eventHandlers["floatInputHandler"].inputFloatHandler;
      var blurFloatHandler = args.element.__eventHandlers["floatBlurHandler"].blurFloatHandler;
      args.element.removeEventListener("input", inputFloatHandler);
      args.element.removeEventListener("blur", blurFloatHandler);
      delete args.element.__eventHandlers["floatInputHandler"];
      delete args.element.__eventHandlers["floatBlurHandler"];
    }
  }
  function checkFloatLabelType(type, container) {
    if (type === "Always" && container.classList.contains("e-outline")) {
      container.classList.add("e-valid-input");
    }
  }
  function setPropertyValue(args, inputObject) {
    if (!isNullOrUndefined(args.properties)) {
      for (var _i = 0, _a = Object.keys(args.properties); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "cssClass":
            setCssClass(args.properties.cssClass, [inputObject.container]);
            checkFloatLabelType(args.floatLabelType, inputObject.container);
            break;
          case "enabled":
            setEnabled(args.properties.enabled, args.element, args.floatLabelType, inputObject.container);
            break;
          case "enableRtl":
            setEnableRtl(args.properties.enableRtl, [inputObject.container]);
            break;
          case "placeholder":
            setPlaceholder(args.properties.placeholder, args.element);
            break;
          case "readonly":
            setReadonly(args.properties.readonly, args.element);
            break;
        }
      }
    }
    return inputObject;
  }
  function updateIconState(value, button, readonly) {
    if (!isNullOrUndefined(button)) {
      if (value && !readonly) {
        removeClass([button], CLASSNAMES.CLEARICONHIDE);
      } else {
        addClass([button], CLASSNAMES.CLEARICONHIDE);
      }
    }
  }
  function updateLabelState(value, label, element2) {
    if (element2 === undefined) {
      element2 = null;
    }
    if (value) {
      addClass([label], CLASSNAMES.LABELTOP);
      if (label.classList.contains(CLASSNAMES.LABELBOTTOM)) {
        removeClass([label], CLASSNAMES.LABELBOTTOM);
      }
    } else {
      var isNotFocused = element2 != null ? element2 !== (undefined).activeElement : true;
      if (isNotFocused) {
        if (label.classList.contains(CLASSNAMES.LABELTOP)) {
          removeClass([label], CLASSNAMES.LABELTOP);
        }
        addClass([label], CLASSNAMES.LABELBOTTOM);
      }
    }
  }
  function getParentNode(element2) {
    var parentNode = isNullOrUndefined(element2.parentNode) ? element2 : element2.parentNode;
    if (parentNode && parentNode.classList.contains("e-input-in-wrap")) {
      parentNode = parentNode.parentNode;
    }
    return parentNode;
  }
  function createClearButton(element2, inputObject, initial, internalCreateElement) {
    var makeElement = !isNullOrUndefined(internalCreateElement) ? internalCreateElement : createElement;
    var button = makeElement("span", { className: CLASSNAMES.CLEARICON });
    var container = inputObject.container;
    if (!isNullOrUndefined(initial)) {
      container.appendChild(button);
    } else {
      var baseElement = inputObject.container.classList.contains(CLASSNAMES.FLOATINPUT) ? inputObject.container.querySelector("." + CLASSNAMES.FLOATTEXT) : element2;
      baseElement.insertAdjacentElement("afterend", button);
    }
    addClass([button], CLASSNAMES.CLEARICONHIDE);
    wireClearBtnEvents(element2, button);
    button.setAttribute("aria-label", "close");
    return button;
  }
  function clickHandler(event, element2, button) {
    if (!(element2.classList.contains(CLASSNAMES.DISABLE) || element2.readOnly)) {
      event.preventDefault();
      if (element2 !== (undefined).activeElement) {
        element2.focus();
      }
      element2.value = "";
      addClass([button], CLASSNAMES.CLEARICONHIDE);
    }
  }
  function inputHandler(element2, button) {
    updateIconState(element2.value, button);
  }
  function focusHandler(element2, button) {
    updateIconState(element2.value, button, element2.readOnly);
  }
  function blurHandler(element2, button) {
    setTimeout(function() {
      if (!isNullOrUndefined(button)) {
        addClass([button], CLASSNAMES.CLEARICONHIDE);
        button = !isNullOrUndefined(element2) && element2.classList.contains("e-combobox") ? null : button;
      }
    }, 200);
  }
  function wireClearBtnEvents(element2, button, container) {
    if (isBindClearAction === undefined || isBindClearAction) {
      var clickHandlerEvent = function(e) {
        return clickHandler(e, element2, button);
      };
      button.addEventListener("click", clickHandlerEvent);
      element2.__eventHandlers["clearClickHandler"] = { clickHandlerEvent };
    }
    var inputHandlerEvent = function() {
      return inputHandler(element2, button);
    };
    var focusHandlerEvent = function() {
      return focusHandler(element2, button);
    };
    var blurHandlerEvent = function() {
      return blurHandler(element2, button);
    };
    element2.addEventListener("input", inputHandlerEvent);
    element2.addEventListener("focus", focusHandlerEvent);
    element2.addEventListener("blur", blurHandlerEvent);
    element2.__eventHandlers["clearInputHandler"] = { inputHandlerEvent };
    element2.__eventHandlers["clearFocusHandler"] = { focusHandlerEvent };
    element2.__eventHandlers["clearBlurHandler"] = { blurHandlerEvent };
  }
  Input2.wireClearBtnEvents = wireClearBtnEvents;
  function unWireClearBtnEvents(element2, button) {
    if (!isNullOrUndefined(element2) && !isNullOrUndefined(element2.__eventHandlers)) {
      if (!isNullOrUndefined(element2.__eventHandlers["clearClickHandler"])) {
        var clickHandlerEvent = element2.__eventHandlers["clearClickHandler"].clickHandlerEvent;
        if (isBindClearAction === undefined || isBindClearAction) {
          if (!isNullOrUndefined(button)) {
            button.removeEventListener("click", clickHandlerEvent);
          }
        }
        delete element2.__eventHandlers["clearClickHandler"];
      }
      if (!isNullOrUndefined(element2.__eventHandlers["clearInputHandler"]) && !isNullOrUndefined(element2.__eventHandlers["clearFocusHandler"]) && !isNullOrUndefined(element2.__eventHandlers["clearBlurHandler"])) {
        var inputHandlerEvent = element2.__eventHandlers["clearInputHandler"].inputHandlerEvent;
        var focusHandlerEvent = element2.__eventHandlers["clearFocusHandler"].focusHandlerEvent;
        var blurHandlerEvent = element2.__eventHandlers["clearBlurHandler"].blurHandlerEvent;
        element2.removeEventListener("input", inputHandlerEvent);
        element2.removeEventListener("focus", focusHandlerEvent);
        element2.removeEventListener("blur", blurHandlerEvent);
        delete element2.__eventHandlers["clearInputHandler"];
        delete element2.__eventHandlers["clearFocusHandler"];
        delete element2.__eventHandlers["clearBlurHandler"];
      }
    }
  }
  function destroy2(args, button) {
    if (button === undefined) {
      button = null;
    }
    unbindInitialEvent(args);
    if (args.floatLabelType === "Auto") {
      unWireFloatLabelEvents(args);
    }
    if (args.properties.showClearButton) {
      unWireClearBtnEvents(args.element, button);
    }
    if (!isNullOrUndefined(args.buttons)) {
      _internalRipple(false, null, args.buttons);
    }
    unwireFloatingEvents(args.element);
    if (!isNullOrUndefined(args.element)) {
      delete args.element.__eventHandlers;
      if (args.element.classList.contains(CLASSNAMES.INPUT)) {
        args.element.classList.remove(CLASSNAMES.INPUT);
      }
    }
  }
  Input2.destroy = destroy2;
  function validateLabel(element2, floatLabelType) {
    var parent = getParentNode(element2);
    if (parent.classList.contains(CLASSNAMES.FLOATINPUT) && floatLabelType === "Auto") {
      var label = getParentNode(element2).getElementsByClassName("e-float-text")[0];
      updateLabelState(element2.value, label, element2);
    }
  }
  function createInputContainer(args, className, tagClass, tag, internalCreateElement) {
    var makeElement = !isNullOrUndefined(internalCreateElement) ? internalCreateElement : createElement;
    var container;
    if (!isNullOrUndefined(args.customTag)) {
      container = makeElement(args.customTag, { className });
      container.classList.add(tagClass);
    } else {
      container = makeElement(tag, { className });
    }
    container.classList.add("e-control-wrapper");
    return container;
  }
  function encodePlaceHolder(placeholder) {
    var result = "";
    if (!isNullOrUndefined(placeholder) && placeholder !== "") {
      var spanEle = (undefined).createElement("span");
      spanEle.innerHTML = '<input  placeholder="' + placeholder + '"/>';
      var hiddenInput = spanEle.children[0];
      result = hiddenInput.placeholder;
    }
    return result;
  }
  function setValue2(value, element2, floatLabelType, clearButton) {
    element2.value = value;
    if (floatLabelType !== "Never") {
      calculateWidth(element2, element2.parentElement);
    }
    if (!isNullOrUndefined(floatLabelType) && floatLabelType === "Auto") {
      validateLabel(element2, floatLabelType);
    }
    if (!isNullOrUndefined(clearButton) && clearButton) {
      var parentElement = getParentNode(element2);
      if (!isNullOrUndefined(parentElement)) {
        var button = parentElement.getElementsByClassName(CLASSNAMES.CLEARICON)[0];
        if (!isNullOrUndefined(button)) {
          if (element2.value && !isNullOrUndefined(parentElement) && parentElement.classList.contains("e-input-focus")) {
            removeClass([button], CLASSNAMES.CLEARICONHIDE);
          } else {
            addClass([button], CLASSNAMES.CLEARICONHIDE);
          }
        }
      }
    }
    checkInputValue(floatLabelType, element2);
  }
  Input2.setValue = setValue2;
  function setCssClass(cssClass, elements, oldClass) {
    if (!isNullOrUndefined(oldClass) && oldClass !== "") {
      removeClass(elements, oldClass.split(" "));
    }
    if (!isNullOrUndefined(cssClass) && cssClass !== "") {
      addClass(elements, cssClass.split(" "));
    }
  }
  Input2.setCssClass = setCssClass;
  function calculateWidth(element2, container, moduleName) {
    if (moduleName !== "multiselect" && !_isElementVisible(element2)) {
      return;
    }
    var elementWidth = moduleName === "multiselect" ? element2 : element2.clientWidth - parseInt(getComputedStyle(element2, null).getPropertyValue("padding-left"), 10);
    if (!isNullOrUndefined(container) && !isNullOrUndefined(container.getElementsByClassName("e-float-text-content")[0])) {
      if (container.getElementsByClassName("e-float-text-content")[0].classList.contains("e-float-text-overflow")) {
        container.getElementsByClassName("e-float-text-content")[0].classList.remove("e-float-text-overflow");
      }
      if (elementWidth < container.getElementsByClassName("e-float-text-content")[0].clientWidth || elementWidth === container.getElementsByClassName("e-float-text-content")[0].clientWidth) {
        container.getElementsByClassName("e-float-text-content")[0].classList.add("e-float-text-overflow");
      }
    }
  }
  Input2.calculateWidth = calculateWidth;
  function setWidth2(width, container) {
    if (typeof width === "number") {
      container.style.width = formatUnit(width);
    } else if (typeof width === "string") {
      container.style.width = width.match(/px|%|em/) ? width : formatUnit(width);
    }
    calculateWidth(container.firstChild, container);
  }
  Input2.setWidth = setWidth2;
  function setPlaceholder(placeholder, element2) {
    placeholder = encodePlaceHolder(placeholder);
    var parentElement = getParentNode(element2);
    if (parentElement.classList.contains(CLASSNAMES.FLOATINPUT)) {
      if (!isNullOrUndefined(placeholder) && placeholder !== "") {
        var floatTextContent = parentElement.getElementsByClassName("e-float-text-content")[0];
        if (floatTextContent && floatTextContent.children[0]) {
          floatTextContent.children[0].textContent = placeholder;
        } else {
          parentElement.getElementsByClassName(CLASSNAMES.FLOATTEXT)[0].textContent = placeholder;
        }
        parentElement.classList.remove(CLASSNAMES.NOFLOATLABEL);
        element2.removeAttribute("placeholder");
      } else {
        parentElement.classList.add(CLASSNAMES.NOFLOATLABEL);
        var floatTextContent = parentElement.getElementsByClassName("e-float-text-content")[0];
        if (floatTextContent) {
          floatTextContent.children[0].textContent = "";
        } else {
          parentElement.getElementsByClassName(CLASSNAMES.FLOATTEXT)[0].textContent = "";
        }
      }
    } else {
      if (!isNullOrUndefined(placeholder) && placeholder !== "") {
        attributes(element2, { "placeholder": placeholder });
      } else {
        element2.removeAttribute("placeholder");
      }
    }
  }
  Input2.setPlaceholder = setPlaceholder;
  function setReadonly(isReadonly, element2, floatLabelType) {
    if (isReadonly) {
      attributes(element2, { readonly: "" });
    } else {
      element2.removeAttribute("readonly");
    }
    if (!isNullOrUndefined(floatLabelType)) {
      validateLabel(element2, floatLabelType);
    }
  }
  Input2.setReadonly = setReadonly;
  function setEnableRtl(isRtl, elements) {
    if (isRtl) {
      addClass(elements, CLASSNAMES.RTL);
    } else {
      removeClass(elements, CLASSNAMES.RTL);
    }
  }
  Input2.setEnableRtl = setEnableRtl;
  function setEnabled(isEnable, element2, floatLabelType, inputContainer) {
    var disabledAttrs = { "disabled": "", "aria-disabled": "true" };
    var considerWrapper = isNullOrUndefined(inputContainer) ? false : true;
    if (isEnable) {
      element2.classList.remove(CLASSNAMES.DISABLE);
      removeAttributes(disabledAttrs, element2);
      if (considerWrapper) {
        removeClass([inputContainer], CLASSNAMES.DISABLE);
      }
    } else {
      element2.classList.add(CLASSNAMES.DISABLE);
      addAttributes(disabledAttrs, element2);
      if (considerWrapper) {
        addClass([inputContainer], CLASSNAMES.DISABLE);
      }
    }
    if (!isNullOrUndefined(floatLabelType)) {
      validateLabel(element2, floatLabelType);
    }
  }
  Input2.setEnabled = setEnabled;
  function setClearButton(isClear, element2, inputObject, initial, internalCreateElement) {
    var makeElement = !isNullOrUndefined(internalCreateElement) ? internalCreateElement : createElement;
    if (isClear) {
      inputObject.clearButton = createClearButton(element2, inputObject, initial, makeElement);
    } else {
      remove(inputObject.clearButton);
      inputObject.clearButton = null;
    }
  }
  Input2.setClearButton = setClearButton;
  function removeAttributes(attrs, element2) {
    for (var _i = 0, _a = Object.keys(attrs); _i < _a.length; _i++) {
      var key = _a[_i];
      var parentElement = getParentNode(element2);
      if (key === "disabled") {
        element2.classList.remove(CLASSNAMES.DISABLE);
      }
      if (key === "disabled" && parentElement.classList.contains(CLASSNAMES.INPUTGROUP)) {
        parentElement.classList.remove(CLASSNAMES.DISABLE);
      }
      if (key === "placeholder" && parentElement.classList.contains(CLASSNAMES.FLOATINPUT)) {
        parentElement.getElementsByClassName(CLASSNAMES.FLOATTEXT)[0].textContent = "";
      } else {
        element2.removeAttribute(key);
      }
    }
  }
  Input2.removeAttributes = removeAttributes;
  function addAttributes(attrs, element2) {
    for (var _i = 0, _a = Object.keys(attrs); _i < _a.length; _i++) {
      var key = _a[_i];
      var parentElement = getParentNode(element2);
      if (key === "disabled") {
        element2.classList.add(CLASSNAMES.DISABLE);
      }
      if (key === "disabled" && parentElement.classList.contains(CLASSNAMES.INPUTGROUP)) {
        parentElement.classList.add(CLASSNAMES.DISABLE);
      }
      if (key === "placeholder" && parentElement.classList.contains(CLASSNAMES.FLOATINPUT)) {
        parentElement.getElementsByClassName(CLASSNAMES.FLOATTEXT)[0].textContent = attrs["" + key];
      } else {
        element2.setAttribute(key, attrs["" + key]);
      }
    }
  }
  Input2.addAttributes = addAttributes;
  function removeFloating(input) {
    var container = input.container;
    if (!isNullOrUndefined(container) && container.classList.contains(CLASSNAMES.FLOATINPUT)) {
      var inputEle = container.querySelector("textarea") ? container.querySelector("textarea") : container.querySelector("input");
      var placeholder = container.querySelector("." + CLASSNAMES.FLOATTEXT).textContent;
      var clearButton = container.querySelector(".e-clear-icon") !== null;
      detach(container.querySelector("." + CLASSNAMES.FLOATLINE));
      detach(container.querySelector("." + CLASSNAMES.FLOATTEXT));
      classList(container, [CLASSNAMES.INPUTGROUP], [CLASSNAMES.FLOATINPUT]);
      unwireFloatingEvents(inputEle);
      attributes(inputEle, { "placeholder": placeholder });
      inputEle.classList.add(CLASSNAMES.INPUT);
      if (!clearButton && inputEle.tagName === "INPUT") {
        inputEle.removeAttribute("required");
      }
    }
  }
  Input2.removeFloating = removeFloating;
  function addFloating(input, type, placeholder, internalCreateElement) {
    var makeElement = !isNullOrUndefined(internalCreateElement) ? internalCreateElement : createElement;
    var container = closest(input, "." + CLASSNAMES.INPUTGROUP);
    var customTag = container.tagName;
    customTag = customTag !== "DIV" && customTag !== "SPAN" ? customTag : null;
    var args = {
      element: input,
      floatLabelType: type,
      customTag,
      properties: { placeholder }
    };
    if (type !== "Never") {
      var iconEle = container.querySelector(".e-clear-icon");
      var inputObj = { container };
      input.classList.remove(CLASSNAMES.INPUT);
      createFloatingInput(args, inputObj, makeElement);
      createSpanElement(inputObj.container, makeElement);
      calculateWidth(args.element, inputObj.container);
      var isPrependIcon = container.classList.contains("e-float-icon-left");
      if (isNullOrUndefined(iconEle)) {
        if (isPrependIcon) {
          var inputWrap = container.querySelector(".e-input-in-wrap");
          iconEle = inputWrap.querySelector(".e-input-group-icon");
        } else {
          iconEle = container.querySelector(".e-input-group-icon");
        }
      }
      if (isNullOrUndefined(iconEle)) {
        if (isPrependIcon) {
          iconEle = container.querySelector(".e-input-group-icon");
        }
      } else {
        var floatLine = container.querySelector("." + CLASSNAMES.FLOATLINE);
        var floatText = container.querySelector("." + CLASSNAMES.FLOATTEXT);
        var wrapper = isPrependIcon ? container.querySelector(".e-input-in-wrap") : container;
        wrapper.insertBefore(input, iconEle);
        wrapper.insertBefore(floatLine, iconEle);
        wrapper.insertBefore(floatText, iconEle);
      }
    } else {
      unWireFloatLabelEvents(args);
    }
    checkFloatLabelType(type, input.parentElement);
  }
  Input2.addFloating = addFloating;
  function createSpanElement(inputObject, makeElement) {
    if (inputObject.classList.contains("e-outline") && inputObject.getElementsByClassName("e-float-text")[0]) {
      var labelSpanElement = makeElement("span", { className: CLASSNAMES.FLOATTEXTCONTENT });
      labelSpanElement.innerHTML = inputObject.getElementsByClassName("e-float-text")[0].innerHTML;
      inputObject.getElementsByClassName("e-float-text")[0].innerHTML = "";
      inputObject.getElementsByClassName("e-float-text")[0].appendChild(labelSpanElement);
    }
  }
  Input2.createSpanElement = createSpanElement;
  function setRipple(isRipple, inputObj) {
    for (var i = 0; i < inputObj.length; i++) {
      _internalRipple(isRipple, inputObj[parseInt(i.toString(), 10)].container);
    }
  }
  Input2.setRipple = setRipple;
  function _internalRipple(isRipple, container, button) {
    var argsButton = [];
    argsButton.push(button);
    var buttons = isNullOrUndefined(button) ? container.querySelectorAll(".e-input-group-icon") : argsButton;
    if (isRipple && buttons.length > 0) {
      for (var index = 0; index < buttons.length; index++) {
        buttons[parseInt(index.toString(), 10)].addEventListener("mousedown", _onMouseDownRipple, false);
        buttons[parseInt(index.toString(), 10)].addEventListener("mouseup", _onMouseUpRipple, false);
      }
    } else if (buttons.length > 0) {
      for (var index = 0; index < buttons.length; index++) {
        buttons[parseInt(index.toString(), 10)].removeEventListener("mousedown", _onMouseDownRipple, this);
        buttons[parseInt(index.toString(), 10)].removeEventListener("mouseup", _onMouseUpRipple, this);
      }
    }
  }
  function _onMouseRipple(container, button) {
    if (!container.classList.contains("e-disabled") && !container.querySelector("input").readOnly) {
      button.classList.add("e-input-btn-ripple");
    }
  }
  function _isElementVisible(element2) {
    if (!element2) {
      return false;
    }
    var currentElement = element2;
    while (currentElement && currentElement !== (undefined).body) {
      var style = (undefined).getComputedStyle(currentElement);
      if (style.display === "none") {
        return false;
      }
      currentElement = currentElement.parentElement;
    }
    return true;
  }
  function _onMouseDownRipple() {
    var ele = this;
    var parentEle = this.parentElement;
    while (!parentEle.classList.contains("e-input-group")) {
      parentEle = parentEle.parentElement;
    }
    _onMouseRipple(parentEle, ele);
  }
  function _onMouseUpRipple() {
    var ele = this;
    setTimeout(function() {
      ele.classList.remove("e-input-btn-ripple");
    }, 500);
  }
  function createIconEle(iconClass, makeElement) {
    var button = makeElement("span", { className: iconClass });
    button.classList.add("e-input-group-icon");
    return button;
  }
  function addIcon(position, icons, container, input, internalCreate) {
    var result = typeof icons === "string" ? icons.split(",") : icons;
    if (position.toLowerCase() === "append") {
      for (var _i = 0, result_1 = result; _i < result_1.length; _i++) {
        var icon = result_1[_i];
        appendSpan(icon, container, internalCreate);
      }
    } else {
      for (var _a = 0, result_2 = result; _a < result_2.length; _a++) {
        var icon = result_2[_a];
        prependSpan(icon, container, input, internalCreate);
      }
    }
    if (container.getElementsByClassName("e-input-group-icon")[0] && container.getElementsByClassName("e-float-text-overflow")[0]) {
      container.getElementsByClassName("e-float-text-overflow")[0].classList.add("e-icon");
    }
  }
  Input2.addIcon = addIcon;
  function prependSpan(iconClass, container, inputElement, internalCreateElement) {
    var makeElement = !isNullOrUndefined(internalCreateElement) ? internalCreateElement : createElement;
    var button = createIconEle(iconClass, makeElement);
    container.classList.add("e-float-icon-left");
    var innerWrapper = container.querySelector(".e-input-in-wrap");
    if (isNullOrUndefined(innerWrapper)) {
      innerWrapper = makeElement("span", { className: "e-input-in-wrap" });
      inputElement.parentNode.insertBefore(innerWrapper, inputElement);
      var result = container.querySelectorAll(inputElement.tagName + " ~ *");
      innerWrapper.appendChild(inputElement);
      for (var i = 0; i < result.length; i++) {
        var element2 = result[parseInt(i.toString(), 10)];
        var parentElement = innerWrapper.parentElement;
        if (!element2.classList.contains("e-float-line") || !(parentElement && parentElement.classList.contains("e-filled")) && parentElement) {
          innerWrapper.appendChild(element2);
        }
      }
    }
    innerWrapper.parentNode.insertBefore(button, innerWrapper);
    _internalRipple(true, container, button);
    return button;
  }
  Input2.prependSpan = prependSpan;
  function appendSpan(iconClass, container, internalCreateElement) {
    var makeElement = !isNullOrUndefined(internalCreateElement) ? internalCreateElement : createElement;
    var button = createIconEle(iconClass, makeElement);
    var wrap = container.classList.contains("e-float-icon-left") ? container.querySelector(".e-input-in-wrap") : container;
    wrap.appendChild(button);
    _internalRipple(true, container, button);
    return button;
  }
  Input2.appendSpan = appendSpan;
  function validateInputType(containerElement2, input) {
    if (input.type === "hidden") {
      containerElement2.classList.add("e-hidden");
    } else if (containerElement2.classList.contains("e-hidden")) {
      containerElement2.classList.remove("e-hidden");
    }
  }
  Input2.validateInputType = validateInputType;
  function updateHTMLAttributesToElement(htmlAttributes, element2) {
    if (!isNullOrUndefined(htmlAttributes)) {
      for (var _i = 0, _a = Object.keys(htmlAttributes); _i < _a.length; _i++) {
        var key = _a[_i];
        if (containerAttributes.indexOf(key) < 0) {
          element2.setAttribute(key, htmlAttributes["" + key]);
        }
      }
    }
  }
  Input2.updateHTMLAttributesToElement = updateHTMLAttributesToElement;
  function updateCssClass(newClass, oldClass, container) {
    setCssClass(getInputValidClassList(newClass), [container], getInputValidClassList(oldClass));
  }
  Input2.updateCssClass = updateCssClass;
  function getInputValidClassList(inputClassName) {
    var result = inputClassName;
    if (!isNullOrUndefined(inputClassName) && inputClassName !== "") {
      result = inputClassName.replace(/\s+/g, " ").trim();
    }
    return result;
  }
  Input2.getInputValidClassList = getInputValidClassList;
  function updateHTMLAttributesToWrapper(htmlAttributes, container) {
    if (!isNullOrUndefined(htmlAttributes)) {
      for (var _i = 0, _a = Object.keys(htmlAttributes); _i < _a.length; _i++) {
        var key = _a[_i];
        if (containerAttributes.indexOf(key) > -1) {
          if (key === "class") {
            var updatedClassValues = this.getInputValidClassList(htmlAttributes["" + key]);
            if (updatedClassValues !== "") {
              addClass([container], updatedClassValues.split(" "));
            }
          } else if (key === "style") {
            var setStyle = container.getAttribute(key);
            setStyle = !isNullOrUndefined(setStyle) ? setStyle + htmlAttributes["" + key] : htmlAttributes["" + key];
            container.setAttribute(key, setStyle);
          } else {
            container.setAttribute(key, htmlAttributes["" + key]);
          }
        }
      }
    }
  }
  Input2.updateHTMLAttributesToWrapper = updateHTMLAttributesToWrapper;
  function isBlank(inputString) {
    return !inputString || /^\s*$/.test(inputString);
  }
  Input2.isBlank = isBlank;
})(Input || (Input = {}));
var __extends$b = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate$b = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ROOT = "e-control-wrapper e-numeric";
var SPINICON = "e-input-group-icon";
var SPINUP = "e-spin-up";
var SPINDOWN = "e-spin-down";
var ERROR = "e-error";
var INCREMENT = "increment";
var DECREMENT = "decrement";
var INTREGEXP = new RegExp("^(-)?(\\d*)$");
var DECIMALSEPARATOR = ".";
var COMPONENT = "e-numerictextbox";
var CONTROL = "e-control";
var NUMERIC_FOCUS = "e-input-focus";
var HIDDENELEMENT = "e-numeric-hidden";
var wrapperAttributes = ["title", "style", "class"];
var selectionTimeOut = 0;
var NumericTextBox = (
  /** @class */
  function(_super) {
    __extends$b(NumericTextBox2, _super);
    function NumericTextBox2(options, element2) {
      var _this = _super.call(this, options, element2) || this;
      _this.preventChange = false;
      _this.isDynamicChange = false;
      _this.numericOptions = options;
      return _this;
    }
    NumericTextBox2.prototype.preRender = function() {
      this.isPrevFocused = false;
      this.decimalSeparator = ".";
      this.intRegExp = new RegExp("/^(-)?(d*)$/");
      this.isCalled = false;
      var ejInstance = getValue("ej2_instances", this.element);
      this.cloneElement = this.element.cloneNode(true);
      removeClass([this.cloneElement], [CONTROL, COMPONENT, "e-lib"]);
      this.angularTagName = null;
      this.formEle = closest(this.element, "form");
      if (this.element.tagName === "EJS-NUMERICTEXTBOX") {
        this.angularTagName = this.element.tagName;
        var input = this.createElement("input");
        var index = 0;
        for (index; index < this.element.attributes.length; index++) {
          var attributeName = this.element.attributes[index].nodeName;
          if (attributeName !== "id" && attributeName !== "class") {
            input.setAttribute(this.element.attributes[index].nodeName, this.element.attributes[index].nodeValue);
            input.innerHTML = this.element.innerHTML;
          } else if (attributeName === "class") {
            input.setAttribute(attributeName, this.element.className.split(" ").filter(function(item) {
              return item.indexOf("ng-") !== 0;
            }).join(" "));
          }
        }
        if (this.element.hasAttribute("name")) {
          this.element.removeAttribute("name");
        }
        this.element.classList.remove("e-control", "e-numerictextbox");
        this.element.appendChild(input);
        this.element = input;
        setValue("ej2_instances", ejInstance, this.element);
      }
      attributes(this.element, { "role": "spinbutton", "tabindex": "0", "autocomplete": "off" });
      var localeText = {
        incrementTitle: "Increment value",
        decrementTitle: "Decrement value",
        placeholder: this.placeholder
      };
      this.l10n = new L10n("numerictextbox", localeText, this.locale);
      if (this.l10n.getConstant("placeholder") !== "") {
        this.setProperties({ placeholder: this.placeholder || this.l10n.getConstant("placeholder") }, true);
      }
      if (!this.element.hasAttribute("id")) {
        this.element.setAttribute("id", getUniqueID("numerictextbox"));
      }
      this.isValidState = true;
      this.inputStyle = null;
      this.inputName = null;
      this.cultureInfo = {};
      this.initCultureInfo();
      this.initCultureFunc();
      this.prevValue = this.value;
      this.updateHTMLAttrToElement();
      this.checkAttributes(false);
      if (this.formEle) {
        this.inputEleValue = this.value;
      }
      this.validateMinMax();
      this.validateStep();
      if (this.placeholder === null) {
        this.updatePlaceholder();
      }
    };
    NumericTextBox2.prototype.render = function() {
      if (this.element.tagName.toLowerCase() === "input") {
        this.createWrapper();
        if (this.showSpinButton) {
          this.spinBtnCreation();
        }
        this.setElementWidth(this.width);
        if (!this.container.classList.contains("e-input-group")) {
          this.container.classList.add("e-input-group");
        }
        this.changeValue(this.value === null || isNaN(this.value) ? null : this.strictMode ? this.trimValue(this.value) : this.value);
        this.wireEvents();
        if (this.value !== null && !isNaN(this.value)) {
          if (this.decimals) {
            this.setProperties({ value: this.roundNumber(this.value, this.decimals) }, true);
          }
        }
        if (this.element.getAttribute("value") || this.value) {
          this.element.setAttribute("value", this.element.value);
          this.hiddenInput.setAttribute("value", this.hiddenInput.value);
        }
        this.elementPrevValue = this.element.value;
        if (this.element.hasAttribute("data-val")) {
          this.element.setAttribute("data-val", "false");
        }
        if (!this.element.hasAttribute("aria-labelledby") && !this.element.hasAttribute("placeholder") && !this.element.hasAttribute("aria-label")) {
          this.element.setAttribute("aria-label", "numerictextbox");
        }
        if (!isNullOrUndefined(closest(this.element, "fieldset")) && closest(this.element, "fieldset").disabled) {
          this.enabled = false;
        }
        this.renderComplete();
      }
    };
    NumericTextBox2.prototype.checkAttributes = function(isDynamic) {
      var attributes2 = isDynamic ? isNullOrUndefined(this.htmlAttributes) ? [] : Object.keys(this.htmlAttributes) : ["value", "min", "max", "step", "disabled", "readonly", "style", "name", "placeholder"];
      for (var _i = 0, attributes_1 = attributes2; _i < attributes_1.length; _i++) {
        var prop = attributes_1[_i];
        if (!isNullOrUndefined(this.element.getAttribute(prop))) {
          switch (prop) {
            case "disabled":
              if (isNullOrUndefined(this.numericOptions) || this.numericOptions["enabled"] === undefined || isDynamic) {
                var enabled = this.element.getAttribute(prop) === "disabled" || this.element.getAttribute(prop) === "" || this.element.getAttribute(prop) === "true" ? false : true;
                this.setProperties({ enabled }, !isDynamic);
              }
              break;
            case "readonly":
              if (isNullOrUndefined(this.numericOptions) || this.numericOptions["readonly"] === undefined || isDynamic) {
                var readonly = this.element.getAttribute(prop) === "readonly" || this.element.getAttribute(prop) === "" || this.element.getAttribute(prop) === "true" ? true : false;
                this.setProperties({ readonly }, !isDynamic);
              }
              break;
            case "placeholder":
              if (isNullOrUndefined(this.numericOptions) || this.numericOptions["placeholder"] === undefined || isDynamic) {
                this.setProperties({ placeholder: this.element.placeholder }, !isDynamic);
              }
              break;
            case "value":
              if (isNullOrUndefined(this.numericOptions) || this.numericOptions["value"] === undefined || isDynamic) {
                var setNumber = this.instance.getNumberParser({ format: "n" })(this.element.getAttribute(prop));
                this.setProperties(setValue(prop, setNumber, {}), !isDynamic);
              }
              break;
            case "min":
              if (isNullOrUndefined(this.numericOptions) || this.numericOptions["min"] === undefined || isDynamic) {
                var minValue = this.instance.getNumberParser({ format: "n" })(this.element.getAttribute(prop));
                if (minValue !== null && !isNaN(minValue)) {
                  this.setProperties(setValue(prop, minValue, {}), !isDynamic);
                }
              }
              break;
            case "max":
              if (isNullOrUndefined(this.numericOptions) || this.numericOptions["max"] === undefined || isDynamic) {
                var maxValue = this.instance.getNumberParser({ format: "n" })(this.element.getAttribute(prop));
                if (maxValue !== null && !isNaN(maxValue)) {
                  this.setProperties(setValue(prop, maxValue, {}), !isDynamic);
                }
              }
              break;
            case "step":
              if (isNullOrUndefined(this.numericOptions) || this.numericOptions["step"] === undefined || isDynamic) {
                var stepValue = this.instance.getNumberParser({ format: "n" })(this.element.getAttribute(prop));
                if (stepValue !== null && !isNaN(stepValue)) {
                  this.setProperties(setValue(prop, stepValue, {}), !isDynamic);
                }
              }
              break;
            case "style":
              this.inputStyle = this.element.getAttribute(prop);
              break;
            case "name":
              this.inputName = this.element.getAttribute(prop);
              break;
            default:
              {
                var value = this.instance.getNumberParser({ format: "n" })(this.element.getAttribute(prop));
                if (value !== null && !isNaN(value) || prop === "value") {
                  this.setProperties(setValue(prop, value, {}), true);
                }
              }
              break;
          }
        }
      }
    };
    NumericTextBox2.prototype.updatePlaceholder = function() {
      this.setProperties({ placeholder: this.l10n.getConstant("placeholder") }, true);
    };
    NumericTextBox2.prototype.initCultureFunc = function() {
      this.instance = new Internationalization(this.locale);
    };
    NumericTextBox2.prototype.initCultureInfo = function() {
      this.cultureInfo.format = this.format;
      if (getValue("currency", this) !== null) {
        setValue("currency", this.currency, this.cultureInfo);
        this.setProperties({ currencyCode: this.currency }, true);
      }
    };
    NumericTextBox2.prototype.createWrapper = function() {
      var updatedCssClassValue = this.cssClass;
      if (!isNullOrUndefined(this.cssClass) && this.cssClass !== "") {
        updatedCssClassValue = this.getNumericValidClassList(this.cssClass);
      }
      var inputObj = Input.createInput({
        element: this.element,
        floatLabelType: this.floatLabelType,
        properties: {
          readonly: this.readonly,
          placeholder: this.placeholder,
          cssClass: updatedCssClassValue,
          enableRtl: this.enableRtl,
          showClearButton: this.showClearButton,
          enabled: this.enabled
        }
      }, this.createElement);
      this.inputWrapper = inputObj;
      this.container = inputObj.container;
      this.container.setAttribute("class", ROOT + " " + this.container.getAttribute("class"));
      this.updateHTMLAttrToWrapper();
      if (this.readonly) {
        attributes(this.element, { "aria-readonly": "true" });
      }
      this.hiddenInput = this.createElement("input", { attrs: {
        type: "text",
        "validateHidden": "true",
        "aria-label": "hidden",
        "class": HIDDENELEMENT
      } });
      this.inputName = this.inputName !== null ? this.inputName : this.element.id;
      this.element.removeAttribute("name");
      if (this.isAngular && this.angularTagName === "EJS-NUMERICTEXTBOX" && this.cloneElement.id.length > 0) {
        attributes(this.hiddenInput, { "name": this.cloneElement.id });
      } else {
        attributes(this.hiddenInput, { "name": this.inputName });
      }
      this.container.insertBefore(this.hiddenInput, this.container.childNodes[1]);
      this.updateDataAttribute(false);
      if (this.inputStyle !== null) {
        attributes(this.container, { "style": this.inputStyle });
      }
    };
    NumericTextBox2.prototype.updateDataAttribute = function(isDynamic) {
      var attr = {};
      if (!isDynamic) {
        for (var a = 0; a < this.element.attributes.length; a++) {
          attr[this.element.attributes[a].name] = this.element.getAttribute(this.element.attributes[a].name);
        }
      } else {
        attr = this.htmlAttributes;
      }
      for (var _i = 0, _a = Object.keys(attr); _i < _a.length; _i++) {
        var key = _a[_i];
        if (key.indexOf("data") === 0) {
          this.hiddenInput.setAttribute(key, attr["" + key]);
        }
      }
    };
    NumericTextBox2.prototype.updateHTMLAttrToElement = function() {
      if (!isNullOrUndefined(this.htmlAttributes)) {
        for (var _i = 0, _a = Object.keys(this.htmlAttributes); _i < _a.length; _i++) {
          var pro = _a[_i];
          if (wrapperAttributes.indexOf(pro) < 0) {
            this.element.setAttribute(pro, this.htmlAttributes["" + pro]);
          }
        }
      }
    };
    NumericTextBox2.prototype.updateCssClass = function(newClass, oldClass) {
      Input.setCssClass(this.getNumericValidClassList(newClass), [this.container], this.getNumericValidClassList(oldClass));
    };
    NumericTextBox2.prototype.getNumericValidClassList = function(numericClassName) {
      var result = numericClassName;
      if (!isNullOrUndefined(numericClassName) && numericClassName !== "") {
        result = numericClassName.replace(/\s+/g, " ").trim();
      }
      return result;
    };
    NumericTextBox2.prototype.updateHTMLAttrToWrapper = function() {
      if (!isNullOrUndefined(this.htmlAttributes)) {
        for (var _i = 0, _a = Object.keys(this.htmlAttributes); _i < _a.length; _i++) {
          var pro = _a[_i];
          if (wrapperAttributes.indexOf(pro) > -1) {
            if (pro === "class") {
              var updatedClassValue = this.getNumericValidClassList(this.htmlAttributes["" + pro]);
              if (updatedClassValue !== "") {
                addClass([this.container], updatedClassValue.split(" "));
              }
            } else if (pro === "style") {
              var numericStyle = this.container.getAttribute(pro);
              numericStyle = !isNullOrUndefined(numericStyle) ? numericStyle + this.htmlAttributes["" + pro] : this.htmlAttributes["" + pro];
              this.container.setAttribute(pro, numericStyle);
            } else {
              this.container.setAttribute(pro, this.htmlAttributes["" + pro]);
            }
          }
        }
      }
    };
    NumericTextBox2.prototype.setElementWidth = function(width) {
      if (!isNullOrUndefined(width)) {
        if (typeof width === "number") {
          this.container.style.width = formatUnit(width);
        } else if (typeof width === "string") {
          this.container.style.width = width.match(/px|%|em/) ? width : formatUnit(width);
        }
      }
    };
    NumericTextBox2.prototype.spinBtnCreation = function() {
      this.spinDown = Input.appendSpan(SPINICON + " " + SPINDOWN, this.container, this.createElement);
      attributes(this.spinDown, {
        "title": this.l10n.getConstant("decrementTitle")
      });
      this.spinUp = Input.appendSpan(SPINICON + " " + SPINUP, this.container, this.createElement);
      attributes(this.spinUp, {
        "title": this.l10n.getConstant("incrementTitle")
      });
      this.wireSpinBtnEvents();
    };
    NumericTextBox2.prototype.validateMinMax = function() {
      if (!(typeof this.min === "number" && !isNaN(this.min))) {
        this.setProperties({ min: -Number.MAX_VALUE }, true);
      }
      if (!(typeof this.max === "number" && !isNaN(this.max))) {
        this.setProperties({ max: Number.MAX_VALUE }, true);
      }
      if (this.decimals !== null) {
        if (this.min !== -Number.MAX_VALUE) {
          this.setProperties({ min: this.instance.getNumberParser({ format: "n" })(this.formattedValue(this.decimals, this.min)) }, true);
        }
        if (this.max !== Number.MAX_VALUE) {
          this.setProperties({ max: this.instance.getNumberParser({ format: "n" })(this.formattedValue(this.decimals, this.max)) }, true);
        }
      }
      this.setProperties({ min: this.min > this.max ? this.max : this.min }, true);
      if (this.min !== -Number.MAX_VALUE) {
        attributes(this.element, { "aria-valuemin": this.min.toString() });
      }
      if (this.max !== Number.MAX_VALUE) {
        attributes(this.element, { "aria-valuemax": this.max.toString() });
      }
    };
    NumericTextBox2.prototype.formattedValue = function(decimals, value) {
      return this.instance.getNumberFormat({
        maximumFractionDigits: decimals,
        minimumFractionDigits: decimals,
        useGrouping: false
      })(value);
    };
    NumericTextBox2.prototype.validateStep = function() {
      if (this.decimals !== null) {
        this.setProperties({ step: this.instance.getNumberParser({ format: "n" })(this.formattedValue(this.decimals, this.step)) }, true);
      }
    };
    NumericTextBox2.prototype.action = function(operation, event) {
      this.isInteract = true;
      var value = this.isFocused ? this.instance.getNumberParser({ format: "n" })(this.element.value) : this.value;
      this.changeValue(this.performAction(value, this.step, operation));
      this.raiseChangeEvent(event);
    };
    NumericTextBox2.prototype.checkErrorClass = function() {
      if (this.isValidState) {
        removeClass([this.container], ERROR);
      } else {
        addClass([this.container], ERROR);
      }
      attributes(this.element, { "aria-invalid": this.isValidState ? "false" : "true" });
    };
    NumericTextBox2.prototype.bindClearEvent = function() {
      if (this.showClearButton) {
        EventHandler.add(this.inputWrapper.clearButton, "mousedown touchstart", this.resetHandler, this);
      }
    };
    NumericTextBox2.prototype.resetHandler = function(e) {
      e.preventDefault();
      if (!this.inputWrapper.clearButton.classList.contains("e-clear-icon-hide") || this.inputWrapper.container.classList.contains("e-static-clear")) {
        this.clear(e);
      }
      this.isInteract = true;
      this.raiseChangeEvent(e);
    };
    NumericTextBox2.prototype.clear = function(event) {
      this.setProperties({ value: null }, true);
      this.setElementValue("");
      this.hiddenInput.value = "";
      var formElement = closest(this.element, "form");
      if (formElement) {
        var element2 = this.element.nextElementSibling;
        var keyupEvent = (undefined).createEvent("KeyboardEvent");
        keyupEvent.initEvent("keyup", false, true);
        element2.dispatchEvent(keyupEvent);
      }
    };
    NumericTextBox2.prototype.resetFormHandler = function() {
      if (this.element.tagName === "EJS-NUMERICTEXTBOX") {
        this.updateValue(null);
      } else {
        this.updateValue(this.inputEleValue);
      }
    };
    NumericTextBox2.prototype.setSpinButton = function() {
      if (!isNullOrUndefined(this.spinDown)) {
        attributes(this.spinDown, {
          "title": this.l10n.getConstant("decrementTitle"),
          "aria-label": this.l10n.getConstant("decrementTitle")
        });
      }
      if (!isNullOrUndefined(this.spinUp)) {
        attributes(this.spinUp, {
          "title": this.l10n.getConstant("incrementTitle"),
          "aria-label": this.l10n.getConstant("incrementTitle")
        });
      }
    };
    NumericTextBox2.prototype.wireEvents = function() {
      EventHandler.add(this.element, "focus", this.focusHandler, this);
      EventHandler.add(this.element, "blur", this.focusOutHandler, this);
      EventHandler.add(this.element, "keydown", this.keyDownHandler, this);
      EventHandler.add(this.element, "keyup", this.keyUpHandler, this);
      EventHandler.add(this.element, "input", this.inputHandler, this);
      EventHandler.add(this.element, "keypress", this.keyPressHandler, this);
      EventHandler.add(this.element, "change", this.changeHandler, this);
      EventHandler.add(this.element, "paste", this.pasteHandler, this);
      if (this.enabled) {
        this.bindClearEvent();
        if (this.formEle) {
          EventHandler.add(this.formEle, "reset", this.resetFormHandler, this);
        }
      }
    };
    NumericTextBox2.prototype.wireSpinBtnEvents = function() {
      EventHandler.add(this.spinUp, Browser.touchStartEvent, this.mouseDownOnSpinner, this);
      EventHandler.add(this.spinDown, Browser.touchStartEvent, this.mouseDownOnSpinner, this);
      EventHandler.add(this.spinUp, Browser.touchEndEvent, this.mouseUpOnSpinner, this);
      EventHandler.add(this.spinDown, Browser.touchEndEvent, this.mouseUpOnSpinner, this);
      EventHandler.add(this.spinUp, Browser.touchMoveEvent, this.touchMoveOnSpinner, this);
      EventHandler.add(this.spinDown, Browser.touchMoveEvent, this.touchMoveOnSpinner, this);
    };
    NumericTextBox2.prototype.unwireEvents = function() {
      EventHandler.remove(this.element, "focus", this.focusHandler);
      EventHandler.remove(this.element, "blur", this.focusOutHandler);
      EventHandler.remove(this.element, "keyup", this.keyUpHandler);
      EventHandler.remove(this.element, "input", this.inputHandler);
      EventHandler.remove(this.element, "keydown", this.keyDownHandler);
      EventHandler.remove(this.element, "keypress", this.keyPressHandler);
      EventHandler.remove(this.element, "change", this.changeHandler);
      EventHandler.remove(this.element, "paste", this.pasteHandler);
      if (this.formEle) {
        EventHandler.remove(this.formEle, "reset", this.resetFormHandler);
      }
    };
    NumericTextBox2.prototype.unwireSpinBtnEvents = function() {
      EventHandler.remove(this.spinUp, Browser.touchStartEvent, this.mouseDownOnSpinner);
      EventHandler.remove(this.spinDown, Browser.touchStartEvent, this.mouseDownOnSpinner);
      EventHandler.remove(this.spinUp, Browser.touchEndEvent, this.mouseUpOnSpinner);
      EventHandler.remove(this.spinDown, Browser.touchEndEvent, this.mouseUpOnSpinner);
      EventHandler.remove(this.spinUp, Browser.touchMoveEvent, this.touchMoveOnSpinner);
      EventHandler.remove(this.spinDown, Browser.touchMoveEvent, this.touchMoveOnSpinner);
    };
    NumericTextBox2.prototype.changeHandler = function(event) {
      event.stopPropagation();
      if (!this.element.value.length) {
        this.setProperties({ value: null }, true);
      }
      var parsedInput = this.instance.getNumberParser({ format: "n" })(this.element.value);
      this.updateValue(parsedInput, event);
    };
    NumericTextBox2.prototype.raiseChangeEvent = function(event) {
      this.inputValue = isNullOrUndefined(this.inputValue) || isNaN(this.inputValue) ? null : this.inputValue;
      if (this.prevValue !== this.value || this.prevValue !== this.inputValue) {
        var eventArgs = {};
        this.changeEventArgs = {
          value: this.value,
          previousValue: this.prevValue,
          isInteracted: this.isInteract,
          isInteraction: this.isInteract,
          event
        };
        if (event) {
          this.changeEventArgs.event = event;
        }
        if (this.changeEventArgs.event === undefined) {
          this.changeEventArgs.isInteracted = false;
          this.changeEventArgs.isInteraction = false;
        }
        merge(eventArgs, this.changeEventArgs);
        this.prevValue = this.value;
        this.isInteract = false;
        this.elementPrevValue = this.element.value;
        this.preventChange = false;
        this.trigger("change", eventArgs);
      }
    };
    NumericTextBox2.prototype.pasteHandler = function() {
      var _this = this;
      if (!this.enabled || this.readonly) {
        return;
      }
      var beforeUpdate = this.element.value;
      setTimeout(function() {
        if (!_this.numericRegex().test(_this.element.value)) {
          _this.setElementValue(beforeUpdate);
        }
      });
    };
    NumericTextBox2.prototype.preventHandler = function() {
      var _this = this;
      var iOS = !!(undefined).platform && /iPad|iPhone|iPod/.test((undefined).platform);
      setTimeout(function() {
        if (_this.element.selectionStart > 0) {
          var currentPos = _this.element.selectionStart;
          var prevPos = _this.element.selectionStart - 1;
          var start = 0;
          var valArray = _this.element.value.split("");
          var numericObject = getNumericObject(_this.locale);
          var decimalSeparator = getValue("decimal", numericObject);
          var ignoreKeyCode = decimalSeparator.charCodeAt(0);
          if (_this.element.value[prevPos] === " " && _this.element.selectionStart > 0 && !iOS) {
            if (isNullOrUndefined(_this.prevVal)) {
              _this.element.value = _this.element.value.trim();
            } else if (prevPos !== 0) {
              _this.element.value = _this.prevVal;
            } else if (prevPos === 0) {
              _this.element.value = _this.element.value.trim();
            }
            _this.element.setSelectionRange(prevPos, prevPos);
          } else if (isNaN(parseFloat(_this.element.value[_this.element.selectionStart - 1])) && _this.element.value[_this.element.selectionStart - 1].charCodeAt(0) !== 45) {
            if (valArray.indexOf(_this.element.value[_this.element.selectionStart - 1]) !== valArray.lastIndexOf(_this.element.value[_this.element.selectionStart - 1]) && _this.element.value[_this.element.selectionStart - 1].charCodeAt(0) === ignoreKeyCode || _this.element.value[_this.element.selectionStart - 1].charCodeAt(0) !== ignoreKeyCode) {
              _this.element.value = _this.element.value.substring(0, prevPos) + _this.element.value.substring(currentPos, _this.element.value.length);
              _this.element.setSelectionRange(prevPos, prevPos);
              if (isNaN(parseFloat(_this.element.value[_this.element.selectionStart - 1])) && _this.element.selectionStart > 0 && _this.element.value.length) {
                _this.preventHandler();
              }
            }
          } else if (isNaN(parseFloat(_this.element.value[_this.element.selectionStart - 2])) && _this.element.selectionStart > 1 && _this.element.value[_this.element.selectionStart - 2].charCodeAt(0) !== 45) {
            if (valArray.indexOf(_this.element.value[_this.element.selectionStart - 2]) !== valArray.lastIndexOf(_this.element.value[_this.element.selectionStart - 2]) && _this.element.value[_this.element.selectionStart - 2].charCodeAt(0) === ignoreKeyCode || _this.element.value[_this.element.selectionStart - 2].charCodeAt(0) !== ignoreKeyCode) {
              _this.element.setSelectionRange(prevPos, prevPos);
              _this.nextEle = _this.element.value[_this.element.selectionStart];
              _this.cursorPosChanged = true;
              _this.preventHandler();
            }
          }
          if (_this.cursorPosChanged === true && _this.element.value[_this.element.selectionStart] === _this.nextEle && isNaN(parseFloat(_this.element.value[_this.element.selectionStart - 1]))) {
            _this.element.setSelectionRange(_this.element.selectionStart + 1, _this.element.selectionStart + 1);
            _this.cursorPosChanged = false;
            _this.nextEle = null;
          }
          if (_this.element.value.trim() === "") {
            _this.element.setSelectionRange(start, start);
          }
          if (_this.element.selectionStart > 0) {
            if (_this.element.value[_this.element.selectionStart - 1].charCodeAt(0) === 45 && _this.element.selectionStart > 1) {
              if (!isNullOrUndefined(_this.prevVal)) {
                _this.element.value = _this.prevVal;
              }
              _this.element.setSelectionRange(_this.element.selectionStart, _this.element.selectionStart);
            }
            if (_this.element.value[_this.element.selectionStart - 1] === decimalSeparator && _this.decimals === 0 && _this.validateDecimalOnType) {
              _this.element.value = _this.element.value.substring(0, prevPos) + _this.element.value.substring(currentPos, _this.element.value.length);
            }
          }
          _this.prevVal = _this.element.value;
        }
      });
    };
    NumericTextBox2.prototype.keyUpHandler = function() {
      if (!this.enabled || this.readonly) {
        return;
      }
      var iOS = !!(undefined).platform && /iPad|iPhone|iPod/.test((undefined).platform);
      if (!iOS && Browser.isDevice) {
        this.preventHandler();
      }
      var parseValue = this.instance.getNumberParser({ format: "n" })(this.element.value);
      parseValue = parseValue === null || isNaN(parseValue) ? null : parseValue;
      this.hiddenInput.value = parseValue || parseValue === 0 ? parseValue.toString() : null;
      var formElement = closest(this.element, "form");
      if (formElement) {
        var element2 = this.element.nextElementSibling;
        var keyupEvent = (undefined).createEvent("KeyboardEvent");
        keyupEvent.initEvent("keyup", false, true);
        element2.dispatchEvent(keyupEvent);
      }
    };
    NumericTextBox2.prototype.inputHandler = function(event) {
      var numerictextboxObj = this;
      if (!this.enabled || this.readonly) {
        return;
      }
      var iOS = !!(undefined).platform && /iPad|iPhone|iPod/.test((undefined).platform);
      var fireFox = (undefined).userAgent.toLowerCase().indexOf("firefox") > -1;
      if ((fireFox || iOS) && Browser.isDevice) {
        this.preventHandler();
      }
      if (this.isAngular && this.element.value !== getValue("decimal", getNumericObject(this.locale)) && this.element.value !== getValue("minusSign", getNumericObject(this.locale))) {
        var parsedValue = this.instance.getNumberParser({ format: "n" })(this.element.value);
        parsedValue = isNaN(parsedValue) ? null : parsedValue;
        numerictextboxObj.localChange({ value: parsedValue });
        this.preventChange = true;
      }
      if (this.isVue) {
        var current = this.instance.getNumberParser({ format: "n" })(this.element.value);
        var previous = this.instance.getNumberParser({ format: "n" })(this.elementPrevValue);
        var nonZeroRegex = new RegExp("[^0-9]+$");
        if (nonZeroRegex.test(this.element.value) || (this.elementPrevValue.indexOf(".") !== -1 || this.elementPrevValue.indexOf("-") !== -1) && this.element.value[this.element.value.length - 1] === "0") {
          current = this.value;
        }
        var eventArgs = {
          event,
          value: current === null || isNaN(current) ? null : current,
          previousValue: previous === null || isNaN(previous) ? null : previous
        };
        this.preventChange = true;
        this.elementPrevValue = this.element.value;
        this.trigger("input", eventArgs);
      }
    };
    NumericTextBox2.prototype.keyDownHandler = function(event) {
      if (!this.readonly) {
        switch (event.keyCode) {
          case 38:
            event.preventDefault();
            this.action(INCREMENT, event);
            break;
          case 40:
            event.preventDefault();
            this.action(DECREMENT, event);
            break;
        }
      }
    };
    NumericTextBox2.prototype.performAction = function(value, step, operation) {
      if (value === null || isNaN(value)) {
        value = 0;
      }
      var updatedValue = operation === INCREMENT ? value + step : value - step;
      updatedValue = this.correctRounding(value, step, updatedValue);
      return this.strictMode ? this.trimValue(updatedValue) : updatedValue;
    };
    NumericTextBox2.prototype.correctRounding = function(value, step, result) {
      var floatExp = new RegExp("[,.](.*)");
      var floatValue = floatExp.test(value.toString());
      var floatStep = floatExp.test(step.toString());
      if (floatValue || floatStep) {
        var valueCount = floatValue ? floatExp.exec(value.toString())[0].length : 0;
        var stepCount = floatStep ? floatExp.exec(step.toString())[0].length : 0;
        var max = Math.max(valueCount, stepCount);
        return value = this.roundValue(result, max);
      }
      return result;
    };
    NumericTextBox2.prototype.roundValue = function(result, precision) {
      precision = precision || 0;
      var divide = Math.pow(10, precision);
      return result *= divide, result = Math.round(result) / divide;
    };
    NumericTextBox2.prototype.updateValue = function(value, event) {
      if (event) {
        this.isInteract = true;
      }
      if (value !== null && !isNaN(value)) {
        if (this.decimals) {
          value = this.roundNumber(value, this.decimals);
        }
      }
      this.inputValue = value;
      if (!(this.isVue && this.element && this.element.hasAttribute("modelvalue") && this.isDynamicChange)) {
        this.changeValue(value === null || isNaN(value) ? null : this.strictMode ? this.trimValue(value) : value);
      }
      if (!this.isDynamicChange) {
        this.raiseChangeEvent(event);
      }
    };
    NumericTextBox2.prototype.updateCurrency = function(prop, propVal) {
      setValue(prop, propVal, this.cultureInfo);
      this.updateValue(this.value);
    };
    NumericTextBox2.prototype.changeValue = function(value) {
      if (!(value || value === 0)) {
        value = null;
        this.setProperties({ value }, true);
      } else {
        var numberOfDecimals = this.getNumberOfDecimals(value);
        this.setProperties({ value: this.roundNumber(value, numberOfDecimals) }, true);
      }
      this.modifyText();
      if (!this.strictMode) {
        this.validateState();
      }
    };
    NumericTextBox2.prototype.modifyText = function() {
      if (this.value || this.value === 0) {
        var value = this.formatNumber();
        var elementValue = this.isFocused ? value : this.instance.getNumberFormat(this.cultureInfo)(this.value);
        this.setElementValue(elementValue);
        attributes(this.element, { "aria-valuenow": value });
        if (!isNullOrUndefined(this.hiddenInput)) {
          this.hiddenInput.value = this.value.toString();
          if (this.value !== null && this.serverDecimalSeparator) {
            this.hiddenInput.value = this.hiddenInput.value.replace(".", this.serverDecimalSeparator);
          }
        }
      } else {
        this.setElementValue("");
        this.element.removeAttribute("aria-valuenow");
        this.hiddenInput.value = null;
      }
    };
    NumericTextBox2.prototype.setElementValue = function(val, element2) {
      Input.setValue(val, element2 ? element2 : this.element, this.floatLabelType, this.showClearButton);
    };
    NumericTextBox2.prototype.validateState = function() {
      this.isValidState = true;
      if (this.value || this.value === 0) {
        this.isValidState = !(this.value > this.max || this.value < this.min);
      }
      this.checkErrorClass();
    };
    NumericTextBox2.prototype.getNumberOfDecimals = function(value) {
      var numberOfDecimals;
      var EXPREGEXP = new RegExp("[eE][-+]?([0-9]+)");
      var valueString = value.toString();
      if (EXPREGEXP.test(valueString)) {
        var result = EXPREGEXP.exec(valueString);
        if (!isNullOrUndefined(result)) {
          valueString = value.toFixed(Math.min(parseInt(result[1], 10), 20));
        }
      }
      var decimalPart = valueString.split(".")[1];
      numberOfDecimals = !decimalPart || !decimalPart.length ? 0 : decimalPart.length;
      if (this.decimals !== null) {
        numberOfDecimals = numberOfDecimals < this.decimals ? numberOfDecimals : this.decimals;
      }
      return numberOfDecimals;
    };
    NumericTextBox2.prototype.formatNumber = function() {
      var numberOfDecimals = this.getNumberOfDecimals(this.value);
      return this.instance.getNumberFormat({
        maximumFractionDigits: numberOfDecimals,
        minimumFractionDigits: numberOfDecimals,
        useGrouping: false
      })(this.value);
    };
    NumericTextBox2.prototype.trimValue = function(value) {
      if (value > this.max) {
        return this.max;
      }
      if (value < this.min) {
        return this.min;
      }
      return value;
    };
    NumericTextBox2.prototype.roundNumber = function(value, precision) {
      var result = value;
      var decimals = precision || 0;
      var result1 = result.toString().split("e");
      result = Math.round(Number(result1[0] + "e" + (result1[1] ? Number(result1[1]) + decimals : decimals)));
      var result2 = result.toString().split("e");
      result = Number(result2[0] + "e" + (result2[1] ? Number(result2[1]) - decimals : -decimals));
      return Number(result.toFixed(decimals));
    };
    NumericTextBox2.prototype.cancelEvent = function(event) {
      event.preventDefault();
      return false;
    };
    NumericTextBox2.prototype.keyPressHandler = function(event) {
      if (!this.enabled || this.readonly) {
        return true;
      }
      if (!Browser.isDevice && Browser.info.version === "11.0" && event.keyCode === 13) {
        var parsedInput = this.instance.getNumberParser({ format: "n" })(this.element.value);
        this.updateValue(parsedInput, event);
        return true;
      }
      if (event.which === 0 || event.metaKey || event.ctrlKey || event.keyCode === 8 || event.keyCode === 13) {
        return true;
      }
      var currentChar = String.fromCharCode(event.which);
      var decimalSeparator = getValue("decimal", getNumericObject(this.locale));
      var isAlterNumPadDecimalChar = event.code === "NumpadDecimal" && currentChar !== decimalSeparator;
      if (isAlterNumPadDecimalChar) {
        currentChar = decimalSeparator;
      }
      var text = this.element.value;
      text = text.substring(0, this.element.selectionStart) + currentChar + text.substring(this.element.selectionEnd);
      if (!this.numericRegex().test(text)) {
        event.preventDefault();
        event.stopPropagation();
        return false;
      } else {
        if (isAlterNumPadDecimalChar) {
          var start = this.element.selectionStart + 1;
          this.element.value = text;
          this.element.setSelectionRange(start, start);
          event.preventDefault();
          event.stopPropagation();
        }
        return true;
      }
    };
    NumericTextBox2.prototype.numericRegex = function() {
      var numericObject = getNumericObject(this.locale);
      var decimalSeparator = getValue("decimal", numericObject);
      var fractionRule = "*";
      if (decimalSeparator === DECIMALSEPARATOR) {
        decimalSeparator = "\\" + decimalSeparator;
      }
      if (this.decimals === 0 && this.validateDecimalOnType) {
        return INTREGEXP;
      }
      if (this.decimals && this.validateDecimalOnType) {
        fractionRule = "{0," + this.decimals + "}";
      }
      return new RegExp("^\\s*(-)?(((\\d+(" + decimalSeparator + "\\d" + fractionRule + ")?)|(" + decimalSeparator + "\\d" + fractionRule + ")))?$");
    };
    NumericTextBox2.prototype.mouseWheel = function(event) {
      event.preventDefault();
      var delta;
      var rawEvent = event;
      if (rawEvent.wheelDelta) {
        delta = rawEvent.wheelDelta / 120;
      } else if (rawEvent.detail) {
        delta = -rawEvent.detail / 3;
      }
      if (delta > 0) {
        this.action(INCREMENT, event);
      } else if (delta < 0) {
        this.action(DECREMENT, event);
      }
      this.cancelEvent(event);
    };
    NumericTextBox2.prototype.focusHandler = function(event) {
      var _this = this;
      clearTimeout(selectionTimeOut);
      this.focusEventArgs = { event, value: this.value, container: this.container };
      this.trigger("focus", this.focusEventArgs);
      if (!this.enabled || this.readonly) {
        return;
      }
      this.isFocused = true;
      this.prevValue = this.value;
      if (this.value || this.value === 0) {
        var formatValue_1 = this.formatNumber();
        this.setElementValue(formatValue_1);
        if (!this.isPrevFocused) {
          if (!Browser.isDevice && Browser.info.version === "11.0") {
            this.element.setSelectionRange(0, formatValue_1.length);
          } else {
            var delay = Browser.isDevice && Browser.isIos ? 600 : 0;
            selectionTimeOut = setTimeout(function() {
              _this.element.setSelectionRange(0, formatValue_1.length);
            }, delay);
          }
        }
      }
      if (!Browser.isDevice) {
        EventHandler.add(this.element, "mousewheel DOMMouseScroll", this.mouseWheel, this);
      }
    };
    NumericTextBox2.prototype.focusOutHandler = function(event) {
      var _this = this;
      this.blurEventArgs = { event, value: this.value, container: this.container };
      this.trigger("blur", this.blurEventArgs);
      if (!this.enabled || this.readonly) {
        return;
      }
      if (this.isPrevFocused) {
        event.preventDefault();
        if (Browser.isDevice) {
          var value_1 = this.element.value;
          this.element.focus();
          this.isPrevFocused = false;
          var ele_1 = this.element;
          setTimeout(function() {
            _this.setElementValue(value_1, ele_1);
          }, 200);
        }
      } else {
        this.isFocused = false;
        if (!this.element.value.length) {
          this.setProperties({ value: null }, true);
        }
        var parsedInput = this.instance.getNumberParser({ format: "n" })(this.element.value);
        this.updateValue(parsedInput);
        if (!Browser.isDevice) {
          EventHandler.remove(this.element, "mousewheel DOMMouseScroll", this.mouseWheel);
        }
      }
      var formElement = closest(this.element, "form");
      if (formElement) {
        var element2 = this.element.nextElementSibling;
        var focusEvent = (undefined).createEvent("FocusEvent");
        focusEvent.initEvent("focusout", false, true);
        element2.dispatchEvent(focusEvent);
      }
    };
    NumericTextBox2.prototype.mouseDownOnSpinner = function(event) {
      var _this = this;
      if (this.isFocused) {
        this.isPrevFocused = true;
        event.preventDefault();
      }
      if (!this.getElementData(event)) {
        return;
      }
      this.getElementData(event);
      var target = event.currentTarget;
      var action = target.classList.contains(SPINUP) ? INCREMENT : DECREMENT;
      EventHandler.add(target, "mouseleave", this.mouseUpClick, this);
      this.timeOut = setInterval(function() {
        _this.isCalled = true;
        _this.action(action, event);
      }, 150);
      EventHandler.add(undefined, "mouseup", this.mouseUpClick, this);
    };
    NumericTextBox2.prototype.touchMoveOnSpinner = function(event) {
      var target;
      if (event.type === "touchmove") {
        var touchEvent = event.touches;
        target = touchEvent.length && (undefined).elementFromPoint(touchEvent[0].pageX, touchEvent[0].pageY);
      } else {
        target = (undefined).elementFromPoint(event.clientX, event.clientY);
      }
      if (!target.classList.contains(SPINICON)) {
        clearInterval(this.timeOut);
      }
    };
    NumericTextBox2.prototype.mouseUpOnSpinner = function(event) {
      this.prevValue = this.value;
      if (this.isPrevFocused) {
        this.element.focus();
        if (!Browser.isDevice) {
          this.isPrevFocused = false;
        }
      }
      if (!Browser.isDevice) {
        event.preventDefault();
      }
      if (!this.getElementData(event)) {
        return;
      }
      var target = event.currentTarget;
      var action = target.classList.contains(SPINUP) ? INCREMENT : DECREMENT;
      EventHandler.remove(target, "mouseleave", this.mouseUpClick);
      if (!this.isCalled) {
        this.action(action, event);
      }
      this.isCalled = false;
      EventHandler.remove(undefined, "mouseup", this.mouseUpClick);
      var formElement = closest(this.element, "form");
      if (formElement) {
        var element2 = this.element.nextElementSibling;
        var keyupEvent = (undefined).createEvent("KeyboardEvent");
        keyupEvent.initEvent("keyup", false, true);
        element2.dispatchEvent(keyupEvent);
      }
    };
    NumericTextBox2.prototype.getElementData = function(event) {
      if (event.which && event.which === 3 || event.button && event.button === 2 || !this.enabled || this.readonly) {
        return false;
      }
      clearInterval(this.timeOut);
      return true;
    };
    NumericTextBox2.prototype.floatLabelTypeUpdate = function() {
      Input.removeFloating(this.inputWrapper);
      var hiddenInput = this.hiddenInput;
      this.hiddenInput.remove();
      Input.addFloating(this.element, this.floatLabelType, this.placeholder, this.createElement);
      this.container.insertBefore(hiddenInput, this.container.childNodes[1]);
    };
    NumericTextBox2.prototype.mouseUpClick = function(event) {
      event.stopPropagation();
      clearInterval(this.timeOut);
      this.isCalled = false;
      if (this.spinUp) {
        EventHandler.remove(this.spinUp, "mouseleave", this.mouseUpClick);
      }
      if (this.spinDown) {
        EventHandler.remove(this.spinDown, "mouseleave", this.mouseUpClick);
      }
    };
    NumericTextBox2.prototype.increment = function(step) {
      if (step === undefined) {
        step = this.step;
      }
      this.isInteract = false;
      this.changeValue(this.performAction(this.value, step, INCREMENT));
      this.raiseChangeEvent();
    };
    NumericTextBox2.prototype.decrement = function(step) {
      if (step === undefined) {
        step = this.step;
      }
      this.isInteract = false;
      this.changeValue(this.performAction(this.value, step, DECREMENT));
      this.raiseChangeEvent();
    };
    NumericTextBox2.prototype.destroy = function() {
      this.unwireEvents();
      if (this.showClearButton) {
        this.clearButton = (undefined).getElementsByClassName("e-clear-icon")[0];
      }
      detach(this.hiddenInput);
      if (this.showSpinButton) {
        this.unwireSpinBtnEvents();
        detach(this.spinUp);
        detach(this.spinDown);
      }
      var attrArray = [
        "aria-labelledby",
        "role",
        "autocomplete",
        "aria-readonly",
        "aria-disabled",
        "autocapitalize",
        "spellcheck",
        "aria-autocomplete",
        "tabindex",
        "aria-valuemin",
        "aria-valuemax",
        "aria-valuenow",
        "aria-invalid"
      ];
      for (var i = 0; i < attrArray.length; i++) {
        this.element.removeAttribute(attrArray[i]);
      }
      this.element.classList.remove("e-input");
      this.container.insertAdjacentElement("afterend", this.element);
      detach(this.container);
      this.spinUp = null;
      this.spinDown = null;
      this.container = null;
      this.hiddenInput = null;
      this.changeEventArgs = null;
      this.blurEventArgs = null;
      this.focusEventArgs = null;
      this.inputWrapper = null;
      Input.destroy({
        element: this.element,
        floatLabelType: this.floatLabelType,
        properties: this.properties
      }, this.clearButton);
      _super.prototype.destroy.call(this);
    };
    NumericTextBox2.prototype.getText = function() {
      return this.element.value;
    };
    NumericTextBox2.prototype.focusIn = function() {
      if ((undefined).activeElement !== this.element && this.enabled) {
        this.element.focus();
        addClass([this.container], [NUMERIC_FOCUS]);
      }
    };
    NumericTextBox2.prototype.focusOut = function() {
      if ((undefined).activeElement === this.element && this.enabled) {
        this.element.blur();
        removeClass([this.container], [NUMERIC_FOCUS]);
      }
    };
    NumericTextBox2.prototype.getPersistData = function() {
      var keyEntity = ["value"];
      return this.addOnPersist(keyEntity);
    };
    NumericTextBox2.prototype.onPropertyChanged = function(newProp, oldProp) {
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "width":
            this.setElementWidth(newProp.width);
            Input.calculateWidth(this.element, this.container);
            break;
          case "cssClass":
            this.updateCssClass(newProp.cssClass, oldProp.cssClass);
            break;
          case "enabled":
            Input.setEnabled(newProp.enabled, this.element);
            this.bindClearEvent();
            break;
          case "enableRtl":
            Input.setEnableRtl(newProp.enableRtl, [this.container]);
            break;
          case "readonly":
            Input.setReadonly(newProp.readonly, this.element);
            if (this.readonly) {
              attributes(this.element, { "aria-readonly": "true" });
            } else {
              this.element.removeAttribute("aria-readonly");
            }
            break;
          case "htmlAttributes":
            this.updateHTMLAttrToElement();
            this.updateHTMLAttrToWrapper();
            this.updateDataAttribute(true);
            this.checkAttributes(true);
            Input.validateInputType(this.container, this.element);
            break;
          case "placeholder":
            Input.setPlaceholder(newProp.placeholder, this.element);
            Input.calculateWidth(this.element, this.container);
            break;
          case "step":
            this.step = newProp.step;
            this.validateStep();
            break;
          case "showSpinButton":
            this.updateSpinButton(newProp);
            break;
          case "showClearButton":
            this.updateClearButton(newProp);
            break;
          case "floatLabelType":
            this.floatLabelType = newProp.floatLabelType;
            this.floatLabelTypeUpdate();
            break;
          case "value":
            this.isDynamicChange = (this.isAngular || this.isVue) && this.preventChange;
            this.updateValue(newProp.value);
            if (this.isDynamicChange) {
              this.preventChange = false;
              this.isDynamicChange = false;
            }
            break;
          case "min":
          case "max":
            setValue(prop, getValue(prop, newProp), this);
            this.validateMinMax();
            this.updateValue(this.value);
            break;
          case "strictMode":
            this.strictMode = newProp.strictMode;
            this.updateValue(this.value);
            this.validateState();
            break;
          case "locale":
            this.initCultureFunc();
            this.l10n.setLocale(this.locale);
            this.setSpinButton();
            this.updatePlaceholder();
            Input.setPlaceholder(this.placeholder, this.element);
            this.updateValue(this.value);
            break;
          case "currency":
            {
              var propVal = getValue(prop, newProp);
              this.setProperties({ currencyCode: propVal }, true);
              this.updateCurrency(prop, propVal);
            }
            break;
          case "currencyCode":
            {
              var propValue = getValue(prop, newProp);
              this.setProperties({ currency: propValue }, true);
              this.updateCurrency("currency", propValue);
            }
            break;
          case "format":
            setValue(prop, getValue(prop, newProp), this);
            this.initCultureInfo();
            this.updateValue(this.value);
            break;
          case "decimals":
            this.decimals = newProp.decimals;
            this.updateValue(this.value);
        }
      }
    };
    NumericTextBox2.prototype.updateClearButton = function(newProp) {
      Input.setClearButton(newProp.showClearButton, this.element, this.inputWrapper, undefined, this.createElement);
      this.bindClearEvent();
    };
    NumericTextBox2.prototype.updateSpinButton = function(newProp) {
      if (newProp.showSpinButton) {
        this.spinBtnCreation();
      } else {
        detach(this.spinUp);
        detach(this.spinDown);
      }
    };
    NumericTextBox2.prototype.getModuleName = function() {
      return "numerictextbox";
    };
    __decorate$b([
      Property("")
    ], NumericTextBox2.prototype, "cssClass", undefined);
    __decorate$b([
      Property(null)
    ], NumericTextBox2.prototype, "value", undefined);
    __decorate$b([
      Property(-Number.MAX_VALUE)
    ], NumericTextBox2.prototype, "min", undefined);
    __decorate$b([
      Property(Number.MAX_VALUE)
    ], NumericTextBox2.prototype, "max", undefined);
    __decorate$b([
      Property(1)
    ], NumericTextBox2.prototype, "step", undefined);
    __decorate$b([
      Property(null)
    ], NumericTextBox2.prototype, "width", undefined);
    __decorate$b([
      Property(null)
    ], NumericTextBox2.prototype, "placeholder", undefined);
    __decorate$b([
      Property({})
    ], NumericTextBox2.prototype, "htmlAttributes", undefined);
    __decorate$b([
      Property(true)
    ], NumericTextBox2.prototype, "showSpinButton", undefined);
    __decorate$b([
      Property(false)
    ], NumericTextBox2.prototype, "readonly", undefined);
    __decorate$b([
      Property(true)
    ], NumericTextBox2.prototype, "enabled", undefined);
    __decorate$b([
      Property(false)
    ], NumericTextBox2.prototype, "showClearButton", undefined);
    __decorate$b([
      Property(false)
    ], NumericTextBox2.prototype, "enablePersistence", undefined);
    __decorate$b([
      Property("n2")
    ], NumericTextBox2.prototype, "format", undefined);
    __decorate$b([
      Property(null)
    ], NumericTextBox2.prototype, "decimals", undefined);
    __decorate$b([
      Property(null)
    ], NumericTextBox2.prototype, "currency", undefined);
    __decorate$b([
      Property(null)
    ], NumericTextBox2.prototype, "currencyCode", undefined);
    __decorate$b([
      Property(true)
    ], NumericTextBox2.prototype, "strictMode", undefined);
    __decorate$b([
      Property(false)
    ], NumericTextBox2.prototype, "validateDecimalOnType", undefined);
    __decorate$b([
      Property("Never")
    ], NumericTextBox2.prototype, "floatLabelType", undefined);
    __decorate$b([
      Event()
    ], NumericTextBox2.prototype, "created", undefined);
    __decorate$b([
      Event()
    ], NumericTextBox2.prototype, "destroyed", undefined);
    __decorate$b([
      Event()
    ], NumericTextBox2.prototype, "change", undefined);
    __decorate$b([
      Event()
    ], NumericTextBox2.prototype, "focus", undefined);
    __decorate$b([
      Event()
    ], NumericTextBox2.prototype, "blur", undefined);
    NumericTextBox2 = __decorate$b([
      NotifyPropertyChanges
    ], NumericTextBox2);
    return NumericTextBox2;
  }(Component)
);
var __extends$a = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate$a = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var TicksData = (
  /** @class */
  function(_super) {
    __extends$a(TicksData2, _super);
    function TicksData2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$a([
      Property("None")
    ], TicksData2.prototype, "placement", undefined);
    __decorate$a([
      Property(10)
    ], TicksData2.prototype, "largeStep", undefined);
    __decorate$a([
      Property(1)
    ], TicksData2.prototype, "smallStep", undefined);
    __decorate$a([
      Property(false)
    ], TicksData2.prototype, "showSmallTicks", undefined);
    __decorate$a([
      Property(null)
    ], TicksData2.prototype, "format", undefined);
    return TicksData2;
  }(ChildProperty)
);
var ColorRangeData = (
  /** @class */
  function(_super) {
    __extends$a(ColorRangeData2, _super);
    function ColorRangeData2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$a([
      Property(null)
    ], ColorRangeData2.prototype, "color", undefined);
    __decorate$a([
      Property(null)
    ], ColorRangeData2.prototype, "start", undefined);
    __decorate$a([
      Property(null)
    ], ColorRangeData2.prototype, "end", undefined);
    return ColorRangeData2;
  }(ChildProperty)
);
var LimitData = (
  /** @class */
  function(_super) {
    __extends$a(LimitData2, _super);
    function LimitData2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$a([
      Property(false)
    ], LimitData2.prototype, "enabled", undefined);
    __decorate$a([
      Property(null)
    ], LimitData2.prototype, "minStart", undefined);
    __decorate$a([
      Property(null)
    ], LimitData2.prototype, "minEnd", undefined);
    __decorate$a([
      Property(null)
    ], LimitData2.prototype, "maxStart", undefined);
    __decorate$a([
      Property(null)
    ], LimitData2.prototype, "maxEnd", undefined);
    __decorate$a([
      Property(false)
    ], LimitData2.prototype, "startHandleFixed", undefined);
    __decorate$a([
      Property(false)
    ], LimitData2.prototype, "endHandleFixed", undefined);
    return LimitData2;
  }(ChildProperty)
);
var TooltipData = (
  /** @class */
  function(_super) {
    __extends$a(TooltipData2, _super);
    function TooltipData2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$a([
      Property("")
    ], TooltipData2.prototype, "cssClass", undefined);
    __decorate$a([
      Property("Before")
    ], TooltipData2.prototype, "placement", undefined);
    __decorate$a([
      Property("Focus")
    ], TooltipData2.prototype, "showOn", undefined);
    __decorate$a([
      Property(false)
    ], TooltipData2.prototype, "isVisible", undefined);
    __decorate$a([
      Property(null)
    ], TooltipData2.prototype, "format", undefined);
    return TooltipData2;
  }(ChildProperty)
);
var bootstrapTooltipOffset = 6;
var bootstrap4TooltipOffset = 3;
var tolerance = 1e-10;
var classNames$1 = {
  root: "e-slider",
  rtl: "e-rtl",
  sliderHiddenInput: "e-slider-input",
  controlWrapper: "e-control-wrapper",
  sliderHandle: "e-handle",
  rangeBar: "e-range",
  sliderButton: "e-slider-button",
  firstButton: "e-first-button",
  secondButton: "e-second-button",
  scale: "e-scale",
  tick: "e-tick",
  large: "e-large",
  tickValue: "e-tick-value",
  sliderTooltip: "e-slider-tooltip",
  sliderHover: "e-slider-hover",
  sliderFirstHandle: "e-handle-first",
  sliderSecondHandle: "e-handle-second",
  sliderDisabled: "e-disabled",
  sliderContainer: "e-slider-container",
  horizontalTooltipBefore: "e-slider-horizontal-before",
  horizontalTooltipAfter: "e-slider-horizontal-after",
  verticalTooltipBefore: "e-slider-vertical-before",
  verticalTooltipAfter: "e-slider-vertical-after",
  materialTooltip: "e-material-tooltip",
  materialTooltipOpen: "e-material-tooltip-open",
  materialTooltipActive: "e-tooltip-active",
  materialSlider: "e-material-slider",
  sliderTrack: "e-slider-track",
  sliderHorizantalColor: "e-slider-horizantal-color",
  sliderVerticalColor: "e-slider-vertical-color",
  sliderHandleFocused: "e-handle-focused",
  verticalSlider: "e-vertical",
  horizontalSlider: "e-horizontal",
  sliderHandleStart: "e-handle-start",
  sliderTooltipStart: "e-material-tooltip-start",
  sliderTabHandle: "e-tab-handle",
  sliderButtonIcon: "e-button-icon",
  sliderSmallSize: "e-small-size",
  sliderTickPosition: "e-tick-pos",
  sliderFirstTick: "e-first-tick",
  sliderLastTick: "e-last-tick",
  sliderButtonClass: "e-slider-btn",
  sliderTooltipWrapper: "e-tooltip-wrap",
  sliderTabTrack: "e-tab-track",
  sliderTabRange: "e-tab-range",
  sliderActiveHandle: "e-handle-active",
  sliderMaterialHandle: "e-material-handle",
  sliderMaterialRange: "e-material-range",
  sliderMaterialDefault: "e-material-default",
  materialTooltipShow: "e-material-tooltip-show",
  materialTooltipHide: "e-material-tooltip-hide",
  readonly: "e-read-only",
  limits: "e-limits",
  limitBarDefault: "e-limit-bar",
  limitBarFirst: "e-limit-first",
  limitBarSecond: "e-limit-second",
  dragHorizontal: "e-drag-horizontal",
  dragVertical: "e-drag-vertical"
};
var Slider = (
  /** @class */
  function(_super) {
    __extends$a(Slider2, _super);
    function Slider2(options, element2) {
      var _this = _super.call(this, options, element2) || this;
      _this.horDir = "left";
      _this.verDir = "bottom";
      _this.transition = {
        handle: "left .4s cubic-bezier(.25, .8, .25, 1), right .4s cubic-bezier(.25, .8, .25, 1), top .4s cubic-bezier(.25, .8, .25, 1) , bottom .4s cubic-bezier(.25, .8, .25, 1)",
        rangeBar: "all .4s cubic-bezier(.25, .8, .25, 1)"
      };
      _this.transitionOnMaterialTooltip = {
        handle: "left 1ms ease-out, right 1ms ease-out, bottom 1ms ease-out, top 1ms ease-out",
        rangeBar: "left 1ms ease-out, right 1ms ease-out, bottom 1ms ease-out, width 1ms ease-out, height 1ms ease-out"
      };
      _this.scaleTransform = "transform .4s cubic-bezier(.25, .8, .25, 1)";
      _this.customAriaText = null;
      _this.drag = true;
      _this.isDragComplete = false;
      _this.initialTooltip = true;
      return _this;
    }
    Slider2.prototype.preRender = function() {
      var localeText = { incrementTitle: "Increase", decrementTitle: "Decrease" };
      this.l10n = new L10n("slider", localeText, this.locale);
      this.isElementFocused = false;
      this.tickElementCollection = [];
      this.tooltipFormatInfo = {};
      this.ticksFormatInfo = {};
      this.initCultureInfo();
      this.initCultureFunc();
      this.formChecker();
    };
    Slider2.prototype.formChecker = function() {
      var formElement = closest(this.element, "form");
      if (formElement) {
        this.isForm = true;
        if (!isNullOrUndefined(this.formResetValue)) {
          this.setProperties({ "value": this.formResetValue }, true);
        }
        this.formResetValue = this.value;
        if (this.type === "Range" && (isNullOrUndefined(this.formResetValue) || typeof this.formResetValue !== "object")) {
          this.formResetValue = [parseFloat(formatUnit(this.min)), parseFloat(formatUnit(this.max))];
        } else if (isNullOrUndefined(this.formResetValue)) {
          this.formResetValue = parseFloat(formatUnit(this.min));
        }
        this.formElement = formElement;
      } else {
        this.isForm = false;
      }
    };
    Slider2.prototype.initCultureFunc = function() {
      this.internationalization = new Internationalization(this.locale);
    };
    Slider2.prototype.initCultureInfo = function() {
      this.tooltipFormatInfo.format = !isNullOrUndefined(this.tooltip.format) ? this.tooltip.format : null;
      this.ticksFormatInfo.format = !isNullOrUndefined(this.ticks.format) ? this.ticks.format : null;
    };
    Slider2.prototype.formatString = function(value, formatInfo) {
      var formatValue = null;
      var formatString = null;
      if (value || value === 0) {
        formatValue = this.formatNumber(value);
        var numberOfDecimals = this.numberOfDecimals(value);
        formatString = this.internationalization.getNumberFormat(formatInfo)(this.makeRoundNumber(value, numberOfDecimals));
      }
      return { elementVal: formatValue, formatString };
    };
    Slider2.prototype.formatNumber = function(value) {
      var numberOfDecimals = this.numberOfDecimals(value);
      return this.internationalization.getNumberFormat({
        maximumFractionDigits: numberOfDecimals,
        minimumFractionDigits: numberOfDecimals,
        useGrouping: false
      })(value);
    };
    Slider2.prototype.numberOfDecimals = function(value) {
      var decimalPart = value.toString().split(".")[1];
      var numberOfDecimals = !decimalPart || !decimalPart.length ? 0 : decimalPart.length;
      return numberOfDecimals;
    };
    Slider2.prototype.makeRoundNumber = function(value, precision) {
      var decimals = precision || 0;
      return Number(value.toFixed(decimals));
    };
    Slider2.prototype.render = function() {
      var _this = this;
      this.initialize();
      this.initRender();
      this.wireEvents();
      this.setZindex();
      this.renderComplete();
      if (this.element.tagName === "EJS-SLIDER") {
        if (this.getTheme(this.sliderContainer) === "none") {
          setTimeout(function() {
            _this.refresh();
          }, 0);
        }
      }
    };
    Slider2.prototype.initialize = function() {
      addClass([this.element], classNames$1.root);
      this.setCSSClass();
    };
    Slider2.prototype.setElementWidth = function(width) {
      if (!isNullOrUndefined(width) && !isNullOrUndefined(this.sliderContainer)) {
        if (typeof width === "number") {
          this.sliderContainer.style.width = formatUnit(width);
        } else if (typeof width === "string") {
          this.sliderContainer.style.width = width.match(/px|%|em/) ? width : formatUnit(width);
        }
      }
    };
    Slider2.prototype.setCSSClass = function(oldCSSClass) {
      if (oldCSSClass) {
        removeClass([this.element], oldCSSClass.split(" "));
      }
      if (this.cssClass) {
        addClass([this.element], this.cssClass.split(" "));
      }
    };
    Slider2.prototype.setEnabled = function() {
      if (!this.enabled) {
        addClass([this.sliderContainer], [classNames$1.sliderDisabled]);
        if (this.tooltip.isVisible && this.tooltipElement && this.tooltip.showOn === "Always") {
          this.tooltipElement.classList.add(classNames$1.sliderDisabled);
        }
        this.unwireEvents();
      } else {
        removeClass([this.sliderContainer], [classNames$1.sliderDisabled]);
        if (this.tooltip.isVisible && this.tooltipElement && this.tooltip.showOn === "Always") {
          this.tooltipElement.classList.remove(classNames$1.sliderDisabled);
        }
        this.wireEvents();
      }
    };
    Slider2.prototype.getTheme = function(container) {
      var theme = (undefined).getComputedStyle(container, ":after").getPropertyValue("content");
      return theme.replace(/['"]+/g, "");
    };
    Slider2.prototype.initRender = function() {
      this.sliderContainer = this.createElement("div", { className: classNames$1.sliderContainer + " " + classNames$1.controlWrapper });
      this.element.parentNode.insertBefore(this.sliderContainer, this.element);
      this.sliderContainer.appendChild(this.element);
      this.sliderTrack = this.createElement("div", { className: classNames$1.sliderTrack });
      this.element.appendChild(this.sliderTrack);
      this.setElementWidth(this.width);
      this.element.tabIndex = -1;
      this.getThemeInitialization();
      this.setHandler();
      this.createRangeBar();
      if (this.limits.enabled) {
        this.createLimitBar();
      }
      this.setOrientClass();
      this.hiddenInput = this.createElement("input", {
        attrs: {
          type: "hidden",
          value: isNullOrUndefined(this.value) ? isNullOrUndefined(this.min) ? "0" : this.min.toString() : this.value.toString(),
          name: this.element.getAttribute("name") || this.element.getAttribute("id") || "_" + (Math.random() * 1e3).toFixed(0) + "slider",
          class: classNames$1.sliderHiddenInput
        }
      });
      this.hiddenInput.tabIndex = -1;
      this.sliderContainer.appendChild(this.hiddenInput);
      if (this.showButtons) {
        this.setButtons();
      }
      this.setEnableRTL();
      if (this.type === "Range") {
        this.rangeValueUpdate();
      } else {
        this.value = isNullOrUndefined(this.value) ? isNullOrUndefined(this.min) ? 0 : parseFloat(formatUnit(this.min.toString())) : this.value;
      }
      this.previousVal = this.type !== "Range" ? this.checkHandleValue(parseFloat(formatUnit(this.value.toString()))) : [
        this.checkHandleValue(parseFloat(formatUnit(this.value[0].toString()))),
        this.checkHandleValue(parseFloat(formatUnit(this.value[1].toString())))
      ];
      this.previousChanged = this.previousVal;
      if (!isNullOrUndefined(this.element.hasAttribute("name"))) {
        this.element.removeAttribute("name");
      }
      this.setValue();
      if (this.limits.enabled) {
        this.setLimitBar();
      }
      if (this.ticks.placement !== "None") {
        this.renderScale();
      }
      if (this.tooltip.isVisible) {
        this.renderTooltip();
      }
      if (!this.enabled) {
        addClass([this.sliderContainer], [classNames$1.sliderDisabled]);
      } else {
        removeClass([this.sliderContainer], [classNames$1.sliderDisabled]);
      }
      if (this.readonly) {
        addClass([this.sliderContainer], [classNames$1.readonly]);
      } else {
        removeClass([this.sliderContainer], [classNames$1.readonly]);
      }
    };
    Slider2.prototype.getThemeInitialization = function() {
      this.isMaterial = this.getTheme(this.sliderContainer) === "material" || this.getTheme(this.sliderContainer) === "material-dark";
      this.isMaterial3 = this.getTheme(this.sliderContainer) === "Material3" || this.getTheme(this.sliderContainer) === "Material3-dark";
      this.isBootstrap = this.getTheme(this.sliderContainer) === "bootstrap" || this.getTheme(this.sliderContainer) === "bootstrap-dark";
      this.isBootstrap4 = this.getTheme(this.sliderContainer) === "bootstrap4";
      this.isTailwind = this.getTheme(this.sliderContainer) === "tailwind" || this.getTheme(this.sliderContainer) === "tailwind-dark";
      this.isTailwind3 = this.getTheme(this.sliderContainer) === "tailwind3" || this.getTheme(this.sliderContainer) === "tailwind3-dark";
      this.isBootstrap5 = this.getTheme(this.sliderContainer) === "bootstrap5";
      this.isFluent = this.getTheme(this.sliderContainer) === "FluentUI";
      this.isFluent2 = this.getTheme(this.sliderContainer) === "fluent2";
      this.isBootstrap5Dot3 = this.getTheme(this.sliderContainer) === "bootstrap5.3";
      this.isMaterialTooltip = (this.isMaterial || this.isMaterial3) && this.type !== "Range" && this.tooltip.isVisible;
    };
    Slider2.prototype.createRangeBar = function() {
      if (this.type !== "Default") {
        this.rangeBar = this.createElement("div", { attrs: { class: classNames$1.rangeBar } });
        this.element.appendChild(this.rangeBar);
        if (this.drag && this.type === "Range") {
          if (this.orientation === "Horizontal") {
            this.rangeBar.classList.add(classNames$1.dragHorizontal);
          } else {
            this.rangeBar.classList.add(classNames$1.dragVertical);
          }
        }
      }
    };
    Slider2.prototype.createLimitBar = function() {
      var firstElementClassName = this.type !== "Range" ? classNames$1.limitBarDefault : classNames$1.limitBarFirst;
      firstElementClassName += " " + classNames$1.limits;
      this.limitBarFirst = this.createElement("div", {
        attrs: { class: firstElementClassName }
      });
      this.element.appendChild(this.limitBarFirst);
      if (this.type === "Range") {
        this.limitBarSecond = this.createElement("div", {
          attrs: {
            class: classNames$1.limitBarSecond + " " + classNames$1.limits
          }
        });
        this.element.appendChild(this.limitBarSecond);
      }
    };
    Slider2.prototype.setOrientClass = function() {
      if (this.orientation !== "Vertical") {
        this.sliderContainer.classList.remove(classNames$1.verticalSlider);
        this.sliderContainer.classList.add(classNames$1.horizontalSlider);
        this.firstHandle.setAttribute("aria-orientation", "horizontal");
        if (this.type === "Range") {
          this.secondHandle.setAttribute("aria-orientation", "horizontal");
        }
      } else {
        this.sliderContainer.classList.remove(classNames$1.horizontalSlider);
        this.sliderContainer.classList.add(classNames$1.verticalSlider);
        this.firstHandle.setAttribute("aria-orientation", "vertical");
        if (this.type === "Range") {
          this.secondHandle.setAttribute("aria-orientation", "vertical");
        }
      }
    };
    Slider2.prototype.setAriaAttributes = function(element2) {
      var _this = this;
      var min = this.min;
      var max = this.max;
      if (!isNullOrUndefined(this.customValues) && this.customValues.length > 0) {
        min = this.customValues[0];
        max = this.customValues[this.customValues.length - 1];
      }
      if (this.type !== "Range") {
        attributes(element2, {
          "aria-valuemin": isNullOrUndefined(min) ? "0" : min.toString(),
          "aria-valuemax": isNullOrUndefined(max) ? "100" : max.toString()
        });
      } else {
        var range = !isNullOrUndefined(this.customValues) && this.customValues.length > 0 ? [
          [min.toString(), this.customValues[this.value[1]].toString()],
          [this.customValues[this.value[0]].toString(), max.toString()]
        ] : [[min.toString(), this.value[1].toString()], [this.value[0].toString(), max.toString()]];
        range.forEach(function(range2, index) {
          var element22 = index === 0 ? _this.firstHandle : _this.secondHandle;
          if (element22) {
            attributes(element22, {
              "aria-valuemin": range2[0],
              "aria-valuemax": range2[1]
            });
          }
        });
      }
    };
    Slider2.prototype.createSecondHandle = function() {
      this.secondHandle = this.createElement("div", {
        attrs: {
          class: classNames$1.sliderHandle,
          "role": "slider",
          tabIndex: "0",
          "aria-label": "slider"
        }
      });
      this.secondHandle.classList.add(classNames$1.sliderSecondHandle);
      this.element.appendChild(this.secondHandle);
    };
    Slider2.prototype.createFirstHandle = function() {
      this.firstHandle = this.createElement("div", {
        attrs: {
          class: classNames$1.sliderHandle,
          "role": "slider",
          tabIndex: "0",
          "aria-label": "slider"
        }
      });
      this.firstHandle.classList.add(classNames$1.sliderFirstHandle);
      this.element.appendChild(this.firstHandle);
      if (this.isMaterialTooltip) {
        this.materialHandle = this.createElement("div", {
          attrs: {
            class: classNames$1.sliderHandle + " " + classNames$1.sliderMaterialHandle
          }
        });
        this.element.appendChild(this.materialHandle);
      }
    };
    Slider2.prototype.wireFirstHandleEvt = function(destroy2) {
      if (!destroy2) {
        EventHandler.add(this.firstHandle, "mousedown touchstart", this.handleFocus, this);
        EventHandler.add(this.firstHandle, "transitionend", this.transitionEnd, this);
        EventHandler.add(this.firstHandle, "mouseenter touchenter", this.handleOver, this);
        EventHandler.add(this.firstHandle, "mouseleave touchend", this.handleLeave, this);
      } else {
        EventHandler.remove(this.firstHandle, "mousedown touchstart", this.handleFocus);
        EventHandler.remove(this.firstHandle, "transitionend", this.transitionEnd);
        EventHandler.remove(this.firstHandle, "mouseenter touchenter", this.handleOver);
        EventHandler.remove(this.firstHandle, "mouseleave touchend", this.handleLeave);
      }
    };
    Slider2.prototype.wireSecondHandleEvt = function(destroy2) {
      if (!destroy2) {
        EventHandler.add(this.secondHandle, "mousedown touchstart", this.handleFocus, this);
        EventHandler.add(this.secondHandle, "transitionend", this.transitionEnd, this);
        EventHandler.add(this.secondHandle, "mouseenter touchenter", this.handleOver, this);
        EventHandler.add(this.secondHandle, "mouseleave touchend", this.handleLeave, this);
      } else {
        EventHandler.remove(this.secondHandle, "mousedown touchstart", this.handleFocus);
        EventHandler.remove(this.secondHandle, "transitionend", this.transitionEnd);
        EventHandler.remove(this.secondHandle, "mouseenter touchenter", this.handleOver);
        EventHandler.remove(this.secondHandle, "mouseleave touchend", this.handleLeave);
      }
    };
    Slider2.prototype.handleStart = function() {
      if (this.type !== "Range") {
        this.firstHandle.classList[this.handlePos1 === 0 ? "add" : "remove"](classNames$1.sliderHandleStart);
        if (this.isMaterialTooltip) {
          this.materialHandle.classList[this.handlePos1 === 0 ? "add" : "remove"](classNames$1.sliderHandleStart);
          if (this.tooltipElement) {
            this.tooltipElement.classList[this.handlePos1 === 0 ? "add" : "remove"](classNames$1.sliderTooltipStart);
          }
        }
      }
    };
    Slider2.prototype.transitionEnd = function(e) {
      if (e.propertyName !== "transform") {
        this.handleStart();
        if (!this.enableAnimation) {
          this.getHandle().style.transition = "none";
        }
        if (this.type !== "Default") {
          this.rangeBar.style.transition = "none";
        }
        if ((this.isMaterial || this.isMaterial3) && this.tooltip.isVisible && this.type === "Default") {
          this.tooltipElement.style.transition = this.transition.handle;
        }
        this.tooltipToggle(this.getHandle());
        this.closeTooltip();
      }
    };
    Slider2.prototype.handleFocusOut = function() {
      if (this.firstHandle.classList.contains(classNames$1.sliderHandleFocused)) {
        this.firstHandle.classList.remove(classNames$1.sliderHandleFocused);
      }
      if (this.type === "Range") {
        if (this.secondHandle.classList.contains(classNames$1.sliderHandleFocused)) {
          this.secondHandle.classList.remove(classNames$1.sliderHandleFocused);
        }
      }
    };
    Slider2.prototype.handleFocus = function(e) {
      this.focusSliderElement();
      this.sliderBarClick(e);
      if (e.currentTarget === this.firstHandle) {
        this.firstHandle.classList.add(classNames$1.sliderHandleFocused);
        this.firstHandle.classList.add(classNames$1.sliderTabHandle);
      } else {
        this.secondHandle.classList.add(classNames$1.sliderHandleFocused);
        this.secondHandle.classList.add(classNames$1.sliderTabHandle);
      }
      EventHandler.add(undefined, "mousemove touchmove", this.sliderBarMove, this);
      EventHandler.add(undefined, "mouseup touchend", this.sliderBarUp, this);
    };
    Slider2.prototype.handleOver = function(e) {
      if (this.tooltip.isVisible && this.tooltip.showOn === "Hover") {
        this.tooltipToggle(e.currentTarget);
      }
      if (this.type === "Default") {
        this.tooltipToggle(this.getHandle());
      }
    };
    Slider2.prototype.handleLeave = function(e) {
      if (this.tooltip.isVisible && this.tooltip.showOn === "Hover" && !e.currentTarget.classList.contains(classNames$1.sliderHandleFocused) && !e.currentTarget.classList.contains(classNames$1.sliderTabHandle)) {
        this.closeTooltip();
      }
    };
    Slider2.prototype.setHandler = function() {
      this.createFirstHandle();
      if (this.type === "Range") {
        this.createSecondHandle();
      }
    };
    Slider2.prototype.setEnableRTL = function() {
      if (this.enableRtl && this.orientation !== "Vertical") {
        addClass([this.sliderContainer], classNames$1.rtl);
      } else {
        removeClass([this.sliderContainer], classNames$1.rtl);
      }
      var preDir = this.orientation !== "Vertical" ? this.horDir : this.verDir;
      if (this.enableRtl) {
        this.horDir = "right";
        this.verDir = "bottom";
      } else {
        this.horDir = "left";
        this.verDir = "bottom";
      }
      var currDir = this.orientation !== "Vertical" ? this.horDir : this.verDir;
      if (preDir !== currDir) {
        if (this.orientation === "Horizontal") {
          setStyleAttribute(this.firstHandle, { "right": "", "left": "auto" });
          if (this.type === "Range") {
            setStyleAttribute(this.secondHandle, { "top": "", "left": "auto" });
          }
        }
      }
      this.setBarColor();
    };
    Slider2.prototype.tooltipValue = function() {
      var _this = this;
      var text;
      var args = {
        value: this.value,
        text: ""
      };
      if (this.initialTooltip) {
        this.initialTooltip = false;
        this.setTooltipContent();
        args.text = text = typeof this.tooltipObj.content === "function" ? this.tooltipObj.content() : this.tooltipObj.content;
        this.trigger("tooltipChange", args, function(observedArgs) {
          _this.addTooltipClass(observedArgs.text);
          if (text !== observedArgs.text) {
            _this.customAriaText = observedArgs.text;
            if (_this.enableHtmlSanitizer) {
              observedArgs.text = SanitizeHtmlHelper.sanitize(observedArgs.text.toString());
            } else {
              observedArgs.text = observedArgs.text.toString();
            }
            var contentTemp = function() {
              return observedArgs.text;
            };
            _this.tooltipObj.content = initializeCSPTemplate(contentTemp);
            _this.setAriaAttrValue(_this.firstHandle);
            if (_this.type === "Range") {
              _this.setAriaAttrValue(_this.secondHandle);
            }
          }
        });
        if (this.isMaterialTooltip) {
          this.setPreviousVal("change", this.value);
        }
      }
    };
    Slider2.prototype.setTooltipContent = function() {
      var content = this.formatContent(this.tooltipFormatInfo, false);
      var contentTemp = function() {
        return content;
      };
      this.tooltipObj.content = initializeCSPTemplate(contentTemp);
    };
    Slider2.prototype.formatContent = function(formatInfo, ariaContent) {
      var content = "";
      var handle1 = this.handleVal1;
      var handle2 = this.handleVal2;
      if (!isNullOrUndefined(this.customValues) && this.customValues.length > 0) {
        handle1 = this.customValues[this.handleVal1];
        handle2 = this.customValues[this.handleVal2];
      }
      if (!ariaContent) {
        if (this.type === "Range") {
          if (this.enableRtl && this.orientation !== "Vertical") {
            content = !isNullOrUndefined(formatInfo.format) ? this.formatString(handle2, formatInfo).formatString + " - " + this.formatString(handle1, formatInfo).formatString : handle2.toString() + " - " + handle1.toString();
          } else {
            content = !isNullOrUndefined(formatInfo.format) ? this.formatString(handle1, formatInfo).formatString + " - " + this.formatString(handle2, formatInfo).formatString : handle1.toString() + " - " + handle2.toString();
          }
        } else {
          if (!isNullOrUndefined(handle1)) {
            content = !isNullOrUndefined(formatInfo.format) ? this.formatString(handle1, formatInfo).formatString : handle1.toString();
          }
        }
        return content;
      } else {
        if (this.type === "Range") {
          if (this.enableRtl && this.orientation !== "Vertical") {
            content = !isNullOrUndefined(this.tooltip) && !isNullOrUndefined(this.tooltip.format) ? this.formatString(handle2, formatInfo).elementVal + " - " + this.formatString(handle1, formatInfo).elementVal : handle2.toString() + " - " + handle1.toString();
          } else {
            content = !isNullOrUndefined(this.tooltip) && !isNullOrUndefined(this.tooltip.format) ? this.formatString(handle1, formatInfo).elementVal + " - " + this.formatString(handle2, formatInfo).elementVal : handle1.toString() + " - " + handle2.toString();
          }
        } else {
          if (!isNullOrUndefined(handle1)) {
            content = !isNullOrUndefined(this.tooltip) && !isNullOrUndefined(this.tooltip.format) ? this.formatString(handle1, formatInfo).elementVal : handle1.toString();
          }
        }
        return content;
      }
    };
    Slider2.prototype.addTooltipClass = function(content) {
      if (this.isMaterialTooltip) {
        var count = content.toString().length;
        if (!this.tooltipElement) {
          var cssClass = count > 4 ? classNames$1.sliderMaterialRange : classNames$1.sliderMaterialDefault;
          this.tooltipObj.cssClass = classNames$1.sliderTooltip + " " + cssClass;
        } else {
          var cssClass = count > 4 ? { oldCss: classNames$1.sliderMaterialDefault, newCss: classNames$1.sliderMaterialRange } : { oldCss: classNames$1.sliderMaterialRange, newCss: classNames$1.sliderMaterialDefault };
          this.tooltipElement.classList.remove(cssClass.oldCss);
          if (!this.tooltipElement.classList.contains(cssClass.newCss)) {
            this.tooltipElement.classList.add(cssClass.newCss);
            this.tooltipElement.style.transform = count > 4 ? "scale(1)" : this.getTooltipTransformProperties(this.previousTooltipClass).rotate;
          }
        }
      }
    };
    Slider2.prototype.tooltipPlacement = function() {
      return this.orientation === "Horizontal" ? this.tooltip.placement === "Before" ? "TopCenter" : "BottomCenter" : this.tooltip.placement === "Before" ? "LeftCenter" : "RightCenter";
    };
    Slider2.prototype.tooltipBeforeOpen = function(args) {
      this.tooltipElement = args.element;
      if (this.tooltip.cssClass) {
        addClass([this.tooltipElement], this.tooltip.cssClass.split(" ").filter(function(css) {
          return css;
        }));
      }
      args.target.removeAttribute("aria-describedby");
      if (this.isMaterialTooltip) {
        this.tooltipElement.firstElementChild.classList.add(classNames$1.materialTooltipHide);
        this.handleStart();
        this.setTooltipTransform();
      }
    };
    Slider2.prototype.tooltipCollision = function(position) {
      if (this.isBootstrap || this.isBootstrap4 || (this.isMaterial || this.isMaterial3) && !this.isMaterialTooltip) {
        var tooltipOffsetValue = this.isBootstrap4 ? bootstrap4TooltipOffset : bootstrapTooltipOffset;
        switch (position) {
          case "TopCenter":
            this.tooltipObj.setProperties({ "offsetY": -tooltipOffsetValue }, false);
            break;
          case "BottomCenter":
            this.tooltipObj.setProperties({ "offsetY": tooltipOffsetValue }, false);
            break;
          case "LeftCenter":
            this.tooltipObj.setProperties({ "offsetX": -tooltipOffsetValue }, false);
            break;
          case "RightCenter":
            this.tooltipObj.setProperties({ "offsetX": tooltipOffsetValue }, false);
            break;
        }
      }
    };
    Slider2.prototype.materialTooltipEventCallBack = function(event) {
      this.sliderBarClick(event);
      EventHandler.add(undefined, "mousemove touchmove", this.sliderBarMove, this);
      EventHandler.add(undefined, "mouseup touchend", this.sliderBarUp, this);
    };
    Slider2.prototype.wireMaterialTooltipEvent = function(destroy2) {
      if (this.isMaterialTooltip) {
        if (!destroy2) {
          EventHandler.add(this.tooltipElement, "mousedown touchstart", this.materialTooltipEventCallBack, this);
        } else {
          EventHandler.remove(this.tooltipElement, "mousedown touchstart", this.materialTooltipEventCallBack);
        }
      }
    };
    Slider2.prototype.tooltipPositionCalculation = function(position) {
      var cssClass;
      switch (position) {
        case "TopCenter":
          cssClass = classNames$1.horizontalTooltipBefore;
          break;
        case "BottomCenter":
          cssClass = classNames$1.horizontalTooltipAfter;
          break;
        case "LeftCenter":
          cssClass = classNames$1.verticalTooltipBefore;
          break;
        case "RightCenter":
          cssClass = classNames$1.verticalTooltipAfter;
          break;
      }
      return cssClass;
    };
    Slider2.prototype.getTooltipTransformProperties = function(className) {
      var transformProperties;
      if (this.tooltipElement) {
        var position = this.orientation === "Horizontal" ? this.tooltipElement.clientHeight + 14 - this.tooltipElement.clientHeight / 2 : this.tooltipElement.clientWidth + 14 - this.tooltipElement.clientWidth / 2;
        transformProperties = this.orientation === "Horizontal" ? className === classNames$1.horizontalTooltipBefore ? { rotate: "rotate(45deg)", translate: "translateY(" + position + "px)" } : { rotate: "rotate(225deg)", translate: "translateY(" + -position + "px)" } : className === classNames$1.verticalTooltipBefore ? { rotate: "rotate(-45deg)", translate: "translateX(" + position + "px)" } : { rotate: "rotate(-225deg)", translate: "translateX(" + -position + "px)" };
      }
      return transformProperties;
    };
    Slider2.prototype.openMaterialTooltip = function() {
      var _this = this;
      if (this.isMaterialTooltip) {
        this.refreshTooltip(this.firstHandle);
        var tooltipContentElement = this.tooltipElement.firstElementChild;
        tooltipContentElement.classList.remove(classNames$1.materialTooltipHide);
        tooltipContentElement.classList.add(classNames$1.materialTooltipShow);
        this.firstHandle.style.cursor = "default";
        this.tooltipElement.style.transition = this.scaleTransform;
        this.tooltipElement.classList.add(classNames$1.materialTooltipOpen);
        this.materialHandle.style.transform = "scale(0)";
        if (tooltipContentElement.innerText.length > 4) {
          this.tooltipElement.style.transform = "scale(1)";
        } else {
          this.tooltipElement.style.transform = this.getTooltipTransformProperties(this.previousTooltipClass).rotate;
        }
        if (this.type === "Default") {
          setTimeout(function() {
            if (_this.tooltipElement) {
              _this.tooltipElement.style.transition = _this.transition.handle;
            }
          }, 2500);
        } else {
          setTimeout(function() {
            if (_this.tooltipElement) {
              _this.tooltipElement.style.transition = "none";
            }
          }, 2500);
        }
      }
    };
    Slider2.prototype.closeMaterialTooltip = function() {
      var _this = this;
      if (this.isMaterialTooltip) {
        var tooltipContentElement = this.tooltipElement.firstElementChild;
        this.tooltipElement.style.transition = this.scaleTransform;
        tooltipContentElement.classList.remove(classNames$1.materialTooltipShow);
        tooltipContentElement.classList.add(classNames$1.materialTooltipHide);
        this.firstHandle.style.cursor = "-webkit-grab";
        this.firstHandle.style.cursor = "grab";
        if (this.materialHandle) {
          this.materialHandle.style.transform = "scale(1)";
        }
        this.tooltipElement.classList.remove(classNames$1.materialTooltipOpen);
        this.setTooltipTransform();
        this.tooltipTarget = undefined;
        setTimeout(function() {
          if (_this.tooltipElement) {
            _this.tooltipElement.style.transition = "none";
          }
        }, 2500);
      }
    };
    Slider2.prototype.checkTooltipPosition = function(args) {
      var tooltipClass = this.tooltipPositionCalculation(args.collidedPosition);
      if (this.tooltipCollidedPosition === undefined || this.tooltipCollidedPosition !== args.collidedPosition || !args.element.classList.contains(tooltipClass)) {
        if (this.isMaterialTooltip) {
          if (tooltipClass !== undefined) {
            args.element.classList.remove(this.previousTooltipClass);
            args.element.classList.add(tooltipClass);
            this.previousTooltipClass = tooltipClass;
          }
          if (args.element.style.transform && args.element.classList.contains(classNames$1.materialTooltipOpen) && args.element.firstElementChild.innerText.length <= 4) {
            args.element.style.transform = this.getTooltipTransformProperties(this.previousTooltipClass).rotate;
          }
        }
        this.tooltipCollidedPosition = args.collidedPosition;
      }
      if (this.isMaterialTooltip && this.tooltipElement && this.tooltipElement.style.transform.indexOf("translate") !== -1) {
        this.setTooltipTransform();
      }
    };
    Slider2.prototype.setTooltipTransform = function() {
      var transformProperties = this.getTooltipTransformProperties(this.previousTooltipClass);
      if (isNullOrUndefined(this.tooltipElement)) {
        return;
      }
      if (this.tooltipElement.firstElementChild.innerText.length > 4) {
        this.tooltipElement.style.transform = transformProperties.translate + " scale(0.01)";
      } else {
        this.tooltipElement.style.transform = transformProperties.translate + " " + transformProperties.rotate + " scale(0.01)";
      }
    };
    Slider2.prototype.renderTooltip = function() {
      this.tooltipObj = new Tooltip({
        showTipPointer: this.isBootstrap || this.isMaterial || this.isMaterial3 || this.isBootstrap4 || this.isTailwind || this.isTailwind3 || this.isBootstrap5 || this.isFluent || this.isFluent2 || this.isBootstrap5Dot3,
        cssClass: classNames$1.sliderTooltip,
        height: this.isMaterial || this.isMaterial3 ? 30 : "auto",
        animation: { open: { effect: "None" }, close: { effect: "FadeOut", duration: 500 } },
        opensOn: "Custom",
        beforeOpen: this.tooltipBeforeOpen.bind(this),
        beforeCollision: this.checkTooltipPosition.bind(this),
        beforeClose: this.tooltipBeforeClose.bind(this),
        enableHtmlSanitizer: this.enableHtmlSanitizer
      });
      this.tooltipObj.appendTo(this.firstHandle);
      this.initializeTooltipProps();
    };
    Slider2.prototype.initializeTooltipProps = function() {
      var tooltipShowOn = this.tooltip.showOn === "Auto" ? "Hover" : this.tooltip.showOn;
      this.setProperties({ tooltip: { showOn: tooltipShowOn } }, true);
      this.tooltipObj.position = this.tooltipPlacement();
      this.tooltipCollision(this.tooltipObj.position);
      [this.firstHandle, this.rangeBar, this.secondHandle].forEach(function(handle) {
        if (!isNullOrUndefined(handle)) {
          handle.style.transition = "none";
        }
      });
      if (this.isMaterialTooltip) {
        this.sliderContainer.classList.add(classNames$1.materialSlider);
        this.tooltipValue();
        this.tooltipObj.animation.close.effect = "None";
        this.tooltipObj.open(this.firstHandle);
      }
    };
    Slider2.prototype.tooltipBeforeClose = function() {
      this.tooltipElement = undefined;
      this.tooltipCollidedPosition = undefined;
    };
    Slider2.prototype.setButtons = function() {
      this.firstBtn = this.createElement("div", { className: classNames$1.sliderButton + " " + classNames$1.firstButton });
      this.firstBtn.appendChild(this.createElement("span", { className: classNames$1.sliderButtonIcon }));
      if (this.isTailwind || this.isTailwind3) {
        this.firstBtn.querySelector("span").classList.add("e-icons");
      }
      this.firstBtn.tabIndex = -1;
      this.secondBtn = this.createElement("div", { className: classNames$1.sliderButton + " " + classNames$1.secondButton });
      this.secondBtn.appendChild(this.createElement("span", { className: classNames$1.sliderButtonIcon }));
      if (this.isTailwind || this.isTailwind3) {
        this.secondBtn.querySelector("span").classList.add("e-icons");
      }
      this.secondBtn.tabIndex = -1;
      this.sliderContainer.classList.add(classNames$1.sliderButtonClass);
      this.sliderContainer.appendChild(this.firstBtn);
      this.sliderContainer.appendChild(this.secondBtn);
      this.sliderContainer.appendChild(this.element);
      this.buttonTitle();
    };
    Slider2.prototype.buttonTitle = function() {
      var enabledRTL = this.enableRtl && this.orientation !== "Vertical";
      this.l10n.setLocale(this.locale);
      var decrementTitle = this.l10n.getConstant("decrementTitle");
      var incrementTitle = this.l10n.getConstant("incrementTitle");
      attributes(enabledRTL ? this.secondBtn : this.firstBtn, { "aria-label": decrementTitle, title: decrementTitle });
      attributes(enabledRTL ? this.firstBtn : this.secondBtn, { "aria-label": incrementTitle, title: incrementTitle });
    };
    Slider2.prototype.buttonFocusOut = function() {
      if (this.isMaterial || this.isMaterial3) {
        this.getHandle().classList.remove("e-large-thumb-size");
      }
    };
    Slider2.prototype.repeatButton = function(args) {
      var hVal = this.handleValueUpdate();
      var enabledRTL = this.enableRtl && this.orientation !== "Vertical";
      var value;
      if (args.target.parentElement.classList.contains(classNames$1.firstButton) || args.target.classList.contains(classNames$1.firstButton)) {
        if (enabledRTL) {
          value = this.add(hVal, parseFloat(this.step.toString()), true);
        } else {
          value = this.add(hVal, parseFloat(this.step.toString()), false);
        }
      } else if (args.target.parentElement.classList.contains(classNames$1.secondButton) || args.target.classList.contains(classNames$1.secondButton)) {
        if (enabledRTL) {
          value = this.add(hVal, parseFloat(this.step.toString()), false);
        } else {
          value = this.add(hVal, parseFloat(this.step.toString()), true);
        }
      }
      if (this.limits.enabled) {
        value = this.getLimitCorrectedValues(value);
      }
      if (value >= this.min && value <= this.max) {
        this.changeHandleValue(value);
        this.tooltipToggle(this.getHandle());
      }
    };
    Slider2.prototype.repeatHandlerMouse = function(args) {
      args.preventDefault();
      if (args.type === "mousedown" || args.type === "touchstart") {
        this.buttonClick(args);
        this.repeatInterval = setInterval(this.repeatButton.bind(this), 180, args);
      }
    };
    Slider2.prototype.materialChange = function() {
      if (!this.getHandle().classList.contains("e-large-thumb-size")) {
        this.getHandle().classList.add("e-large-thumb-size");
      }
    };
    Slider2.prototype.focusHandle = function() {
      if (!this.getHandle().classList.contains(classNames$1.sliderTabHandle)) {
        this.getHandle().classList.add(classNames$1.sliderTabHandle);
      }
    };
    Slider2.prototype.repeatHandlerUp = function(e) {
      this.changeEvent("changed", e);
      this.closeTooltip();
      clearInterval(this.repeatInterval);
      this.getHandle().focus();
    };
    Slider2.prototype.customTickCounter = function(bigNum) {
      var tickCount = 4;
      if (!isNullOrUndefined(this.customValues) && this.customValues.length > 0) {
        if (bigNum > 4) {
          tickCount = 3;
        }
        if (bigNum > 7) {
          tickCount = 2;
        }
        if (bigNum > 14) {
          tickCount = 1;
        }
        if (bigNum > 28) {
          tickCount = 0;
        }
      }
      return tickCount;
    };
    Slider2.prototype.renderScale = function() {
      var orien = this.orientation === "Vertical" ? "v" : "h";
      this.ul = this.createElement("ul", {
        className: classNames$1.scale + " e-" + orien + "-scale " + classNames$1.tick + "-" + this.ticks.placement.toLowerCase(),
        attrs: { role: "presentation", "aria-hidden": "true" }
      });
      this.ul.style.zIndex = "-1";
      if (Browser.isAndroid && orien === "h") {
        this.ul.classList.add(classNames$1.sliderTickPosition);
      }
      var smallStep = this.ticks.smallStep;
      if (!this.ticks.showSmallTicks) {
        if (this.ticks.largeStep > 0) {
          smallStep = this.ticks.largeStep;
        } else {
          smallStep = parseFloat(formatUnit(this.max)) - parseFloat(formatUnit(this.min));
        }
      } else if (smallStep <= 0) {
        smallStep = parseFloat(formatUnit(this.step));
      }
      var min = parseFloat(formatUnit(this.min));
      var max = parseFloat(formatUnit(this.max));
      var steps = parseFloat(formatUnit(smallStep));
      var bigNum = !isNullOrUndefined(this.customValues) && this.customValues.length > 0 && this.customValues.length - 1;
      var customStep = this.customTickCounter(bigNum);
      var count = !isNullOrUndefined(this.customValues) && this.customValues.length > 0 ? bigNum * customStep + bigNum : Math.abs((max - min) / steps);
      this.element.appendChild(this.ul);
      var li;
      var start = parseFloat(this.min.toString());
      if (orien === "v") {
        start = parseFloat(this.max.toString());
      }
      var left = 0;
      var islargeTick;
      var tickWidth = 100 / count;
      if (tickWidth === Infinity) {
        tickWidth = 5;
      }
      for (var i = 0, y = !isNullOrUndefined(this.customValues) && this.customValues.length > 0 ? this.customValues.length - 1 : 0, k = 0; i <= count; i++) {
        li = this.createElement("li", {
          attrs: {
            class: classNames$1.tick,
            role: "presentation",
            "aria-hidden": "true"
          }
        });
        if (!isNullOrUndefined(this.customValues) && this.customValues.length > 0) {
          islargeTick = i % (customStep + 1) === 0;
          if (islargeTick) {
            if (orien === "h") {
              start = this.customValues[k];
              k++;
            } else {
              start = this.customValues[y];
              y--;
            }
            li.setAttribute("title", start.toString());
          }
        } else {
          li.setAttribute("title", start.toString());
          if (this.numberOfDecimals(this.max) === 0 && this.numberOfDecimals(this.min) === 0 && this.numberOfDecimals(this.step) === 0) {
            if (orien === "h") {
              var reminder = (start - parseFloat(this.min.toString())) % this.ticks.largeStep;
              islargeTick = Math.abs(reminder) < tolerance || Math.abs(this.ticks.largeStep - reminder) < tolerance;
            } else {
              var reminder = Math.abs(start - parseFloat(this.max.toString())) % this.ticks.largeStep;
              islargeTick = Math.abs(reminder) < tolerance || Math.abs(this.ticks.largeStep - reminder) < tolerance;
            }
          } else {
            var largestep = this.ticks.largeStep;
            var startValue = start;
            if (orien === "h") {
              var reminder = (startValue - min) % largestep;
              islargeTick = Math.abs(reminder) < tolerance || Math.abs(largestep - reminder) < tolerance;
            } else {
              var reminder = Math.abs(startValue - parseFloat(max.toString())) % largestep;
              islargeTick = Math.abs(reminder) < tolerance || Math.abs(largestep - reminder) < tolerance;
            }
          }
        }
        if (islargeTick) {
          li.classList.add(classNames$1.large);
        }
        if (orien === "h") {
          li.style.width = tickWidth + "%";
        } else {
          li.style.height = tickWidth + "%";
        }
        var repeat = islargeTick ? this.ticks.placement === "Both" ? 2 : 1 : 0;
        if (islargeTick) {
          for (var j = 0; j < repeat; j++) {
            this.createTick(li, start);
          }
        } else if (isNullOrUndefined(this.customValues)) {
          this.formatTicksValue(li, start);
        }
        this.ul.appendChild(li);
        this.tickElementCollection.push(li);
        var decimalPoints = undefined;
        if (isNullOrUndefined(this.customValues)) {
          if (this.numberOfDecimals(smallStep) > this.numberOfDecimals(start)) {
            decimalPoints = this.numberOfDecimals(smallStep);
          } else {
            decimalPoints = this.numberOfDecimals(start);
          }
          if (orien === "h") {
            start = this.makeRoundNumber(start + smallStep, decimalPoints);
          } else {
            if (this.min > this.max) {
              start = this.makeRoundNumber(start + smallStep, decimalPoints);
            } else {
              start = this.makeRoundNumber(start - smallStep, decimalPoints);
            }
          }
          left = this.makeRoundNumber(left + smallStep, decimalPoints);
        }
      }
      this.ticksAlignment(orien, tickWidth);
    };
    Slider2.prototype.ticksAlignment = function(orien, tickWidth, triggerEvent) {
      if (triggerEvent === undefined) {
        triggerEvent = true;
      }
      this.firstChild = this.ul.firstElementChild;
      this.lastChild = this.ul.lastElementChild;
      this.firstChild.classList.add(classNames$1.sliderFirstTick);
      this.lastChild.classList.add(classNames$1.sliderLastTick);
      this.sliderContainer.classList.add(classNames$1.scale + "-" + this.ticks.placement.toLowerCase());
      if (orien === "h") {
        this.firstChild.style.width = tickWidth / 2 + "%";
        this.lastChild.style.width = tickWidth / 2 + "%";
      } else {
        this.firstChild.style.height = tickWidth / 2 + "%";
        this.lastChild.style.height = tickWidth / 2 + "%";
      }
      var eventArgs = { ticksWrapper: this.ul, tickElements: this.tickElementCollection };
      if (triggerEvent) {
        this.trigger("renderedTicks", eventArgs);
      }
      this.scaleAlignment();
    };
    Slider2.prototype.createTick = function(li, start) {
      var span = this.createElement("span", {
        className: classNames$1.tickValue + " " + classNames$1.tick + "-" + this.ticks.placement.toLowerCase(),
        attrs: { role: "presentation", "aria-hidden": "true" }
      });
      li.appendChild(span);
      if (isNullOrUndefined(this.customValues)) {
        this.formatTicksValue(li, start, span);
      } else {
        if (this.enableHtmlSanitizer) {
          span.innerHTML = SanitizeHtmlHelper.sanitize(start.toString());
        } else {
          span.innerHTML = start.toString();
        }
      }
    };
    Slider2.prototype.formatTicksValue = function(li, start, spanElement) {
      var _this = this;
      var tickText = this.formatNumber(start);
      var text = !isNullOrUndefined(this.ticks) && !isNullOrUndefined(this.ticks.format) ? this.formatString(start, this.ticksFormatInfo).formatString : tickText;
      var eventArgs = { value: start, text, tickElement: li };
      this.trigger("renderingTicks", eventArgs, function(observedArgs) {
        li.setAttribute("title", observedArgs.text.toString());
        if (spanElement) {
          if (_this.enableHtmlSanitizer) {
            spanElement.innerHTML = SanitizeHtmlHelper.sanitize(observedArgs.text.toString());
          } else {
            spanElement.innerHTML = observedArgs.text.toString();
          }
        }
      });
    };
    Slider2.prototype.scaleAlignment = function() {
      this.tickValuePosition();
      if (this.orientation === "Vertical") {
        if (this.element.getBoundingClientRect().width <= 15) {
          this.sliderContainer.classList.add(classNames$1.sliderSmallSize);
        } else {
          this.sliderContainer.classList.remove(classNames$1.sliderSmallSize);
        }
      } else {
        if (this.element.getBoundingClientRect().height <= 15) {
          this.sliderContainer.classList.add(classNames$1.sliderSmallSize);
        } else {
          this.sliderContainer.classList.remove(classNames$1.sliderSmallSize);
        }
      }
    };
    Slider2.prototype.tickValuePosition = function() {
      this.firstChild = this.element.querySelector("ul").children[0];
      var first = this.firstChild.getBoundingClientRect();
      var firstChild;
      var otherChild;
      var smallStep = this.ticks.smallStep;
      var count = Math.abs(parseFloat(formatUnit(this.max)) - parseFloat(formatUnit(this.min))) / smallStep;
      if (this.firstChild.children.length > 0) {
        firstChild = this.firstChild.children[0].getBoundingClientRect();
      }
      var tickElements = [this.sliderContainer.querySelectorAll("." + classNames$1.tick + "." + classNames$1.large + " ." + classNames$1.tickValue)];
      var other;
      if (this.ticks.placement === "Both") {
        other = [].slice.call(tickElements[0], 2);
      } else {
        other = [].slice.call(tickElements[0], 1);
      }
      var tickWidth = this.orientation === "Vertical" ? first.height * 2 : first.width * 2;
      for (var i = 0; i < this.firstChild.children.length; i++) {
        if (this.orientation === "Vertical") {
          this.firstChild.children[i].style.top = -(firstChild.height / 2) + "px";
        } else {
          if (!this.enableRtl) {
            this.firstChild.children[i].style.left = -(firstChild.width / 2) + "px";
          } else {
            this.firstChild.children[i].style.left = (tickWidth - this.firstChild.children[i].getBoundingClientRect().width) / 2 + "px";
          }
        }
      }
      for (var i = 0; i < other.length; i++) {
        otherChild = other[i].getBoundingClientRect();
        if (this.orientation === "Vertical") {
          setStyleAttribute(other[i], { top: (tickWidth - otherChild.height) / 2 + "px" });
        } else {
          setStyleAttribute(other[i], { left: (tickWidth - otherChild.width) / 2 + "px" });
        }
      }
      if (this.enableRtl && this.lastChild.children.length && count !== 0) {
        this.lastChild.children[0].style.left = -(this.lastChild.getBoundingClientRect().width / 2) + "px";
        if (this.ticks.placement === "Both") {
          this.lastChild.children[1].style.left = -(this.lastChild.getBoundingClientRect().width / 2) + "px";
        }
      }
      if (count === 0) {
        if (this.orientation === "Horizontal") {
          if (!this.enableRtl) {
            this.firstChild.classList.remove(classNames$1.sliderLastTick);
            this.firstChild.style.left = this.firstHandle.style.left;
          } else {
            this.firstChild.classList.remove(classNames$1.sliderLastTick);
            this.firstChild.style.right = this.firstHandle.style.right;
            this.firstChild.children[0].style.left = this.firstChild.getBoundingClientRect().width / 2 + 2 + "px";
            if (this.ticks.placement === "Both") {
              this.firstChild.children[1].style.left = this.firstChild.getBoundingClientRect().width / 2 + 2 + "px";
            }
          }
        }
        if (this.orientation === "Vertical") {
          this.firstChild.classList.remove(classNames$1.sliderLastTick);
        }
      }
    };
    Slider2.prototype.setAriaAttrValue = function(element2) {
      var ariaValueText;
      var isTickFormatted = !isNullOrUndefined(this.ticks) && !isNullOrUndefined(this.ticks.format) ? true : false;
      var text = !isTickFormatted ? this.formatContent(this.ticksFormatInfo, false) : this.formatContent(this.tooltipFormatInfo, false);
      var valuenow = isTickFormatted ? this.formatContent(this.ticksFormatInfo, true) : this.formatContent(this.tooltipFormatInfo, true);
      text = !this.customAriaText ? text : this.customAriaText;
      if (text.split(" - ").length === 2) {
        ariaValueText = text.split(" - ");
      } else {
        ariaValueText = [text, text];
      }
      this.setAriaAttributes(element2);
      if (this.type !== "Range") {
        attributes(element2, { "aria-valuenow": valuenow, "aria-valuetext": text });
      } else {
        if (!this.enableRtl) {
          if (element2 === this.firstHandle) {
            attributes(element2, { "aria-valuenow": valuenow.split(" - ")[0], "aria-valuetext": ariaValueText[0] });
          } else {
            attributes(element2, { "aria-valuenow": valuenow.split(" - ")[1], "aria-valuetext": ariaValueText[1] });
          }
        } else {
          if (element2 === this.firstHandle) {
            attributes(element2, { "aria-valuenow": valuenow.split(" - ")[1], "aria-valuetext": ariaValueText[1] });
          } else {
            attributes(element2, { "aria-valuenow": valuenow.split(" - ")[0], "aria-valuetext": ariaValueText[0] });
          }
        }
      }
    };
    Slider2.prototype.handleValueUpdate = function() {
      var hVal;
      if (this.type === "Range") {
        if (this.activeHandle === 1) {
          hVal = this.handleVal1;
        } else {
          hVal = this.handleVal2;
        }
      } else {
        hVal = this.handleVal1;
      }
      return hVal;
    };
    Slider2.prototype.getLimitCorrectedValues = function(value) {
      if (this.type === "MinRange" || this.type === "Default") {
        value = this.getLimitValueAndPosition(value, this.limits.minStart, this.limits.minEnd)[0];
      } else {
        if (this.activeHandle === 1) {
          value = this.getLimitValueAndPosition(value, this.limits.minStart, this.limits.minEnd)[0];
        } else {
          value = this.getLimitValueAndPosition(value, this.limits.maxStart, this.limits.maxEnd)[0];
        }
      }
      return value;
    };
    Slider2.prototype.focusSliderElement = function() {
      if (!this.isElementFocused) {
        this.element.focus();
        this.isElementFocused = true;
      }
    };
    Slider2.prototype.buttonClick = function(args) {
      this.focusSliderElement();
      var value;
      var enabledRTL = this.enableRtl && this.orientation !== "Vertical";
      var hVal = this.handleValueUpdate();
      if (args.keyCode === 40 || args.keyCode === 37 || args.currentTarget.classList.contains(classNames$1.firstButton)) {
        if (enabledRTL) {
          value = this.add(hVal, parseFloat(this.step.toString()), true);
        } else {
          value = this.add(hVal, parseFloat(this.step.toString()), false);
        }
      } else if (args.keyCode === 38 || args.keyCode === 39 || args.currentTarget.classList.contains(classNames$1.secondButton)) {
        if (enabledRTL) {
          value = this.add(hVal, parseFloat(this.step.toString()), false);
        } else {
          value = this.add(hVal, parseFloat(this.step.toString()), true);
        }
      } else if (args.keyCode === 33 || args.currentTarget.classList.contains(classNames$1.firstButton)) {
        if (enabledRTL) {
          value = this.add(hVal, parseFloat(this.ticks.largeStep.toString()), false);
        } else {
          value = this.add(hVal, parseFloat(this.ticks.largeStep.toString()), true);
        }
      } else if (args.keyCode === 34 || args.currentTarget.classList.contains(classNames$1.secondButton)) {
        if (enabledRTL) {
          value = this.add(hVal, parseFloat(this.ticks.largeStep.toString()), true);
        } else {
          value = this.add(hVal, parseFloat(this.ticks.largeStep.toString()), false);
        }
      } else if (args.keyCode === 36) {
        value = parseFloat(this.min < this.max ? this.min.toString() : this.max.toString());
      } else if (args.keyCode === 35) {
        value = parseFloat(this.min < this.max ? this.max.toString() : this.min.toString());
      }
      if (this.limits.enabled) {
        value = this.getLimitCorrectedValues(value);
      }
      this.changeHandleValue(value);
      if ((this.isMaterial || this.isMaterial3) && !this.tooltip.isVisible && !this.getHandle().classList.contains(classNames$1.sliderTabHandle)) {
        this.materialChange();
      }
      this.tooltipToggle(this.getHandle());
      this.getHandle().focus();
      this.focusHandle();
      if (args.currentTarget.classList.contains(classNames$1.firstButton)) {
        EventHandler.add(this.firstBtn, "mouseup touchend", this.buttonUp, this);
      }
      if (args.currentTarget.classList.contains(classNames$1.secondButton)) {
        EventHandler.add(this.secondBtn, "mouseup touchend", this.buttonUp, this);
      }
    };
    Slider2.prototype.tooltipToggle = function(target) {
      if (this.isMaterialTooltip) {
        if (!this.tooltipElement.classList.contains(classNames$1.materialTooltipOpen)) {
          this.openMaterialTooltip();
        } else {
          this.refreshTooltip(this.firstHandle);
        }
      } else {
        if (!this.tooltipElement) {
          this.openTooltip(target);
        } else {
          this.refreshTooltip(target);
        }
      }
    };
    Slider2.prototype.buttonUp = function(args) {
      if (args.currentTarget.classList.contains(classNames$1.firstButton)) {
        EventHandler.remove(this.firstBtn, "mouseup touchend", this.buttonUp);
      }
      if (args.currentTarget.classList.contains(classNames$1.secondButton)) {
        EventHandler.remove(this.secondBtn, "mouseup touchend", this.buttonUp);
      }
    };
    Slider2.prototype.setRangeBar = function() {
      if (this.orientation === "Horizontal" && !isNullOrUndefined(this.rangeBar)) {
        if (this.type === "MinRange") {
          if (this.enableRtl) {
            this.rangeBar.style.right = "0px";
          } else {
            this.rangeBar.style.left = "0px";
          }
          setStyleAttribute(this.rangeBar, { "width": isNullOrUndefined(this.handlePos1) ? 0 : this.handlePos1 + "px" });
        } else {
          if (this.enableRtl) {
            this.rangeBar.style.right = this.handlePos1 + "px";
          } else {
            this.rangeBar.style.left = this.handlePos1 + "px";
          }
          setStyleAttribute(this.rangeBar, { "width": this.handlePos2 - this.handlePos1 + "px" });
        }
      } else if (!isNullOrUndefined(this.rangeBar)) {
        if (this.type === "MinRange") {
          this.rangeBar.style.bottom = this.min > this.max ? this.handlePos1 + "px" : "0px";
          setStyleAttribute(this.rangeBar, { "height": isNullOrUndefined(this.handlePos1) ? 0 : this.min > this.max ? this.element.clientHeight - this.handlePos1 + "px" : this.handlePos1 + "px" });
        } else {
          this.rangeBar.style.bottom = this.min > this.max ? this.handlePos2 + "px" : this.handlePos1 + "px";
          setStyleAttribute(this.rangeBar, { "height": this.min > this.max ? this.handlePos1 - this.handlePos2 + "px" : this.handlePos2 - this.handlePos1 + "px" });
        }
      }
    };
    Slider2.prototype.checkValidValueAndPos = function(value) {
      value = this.checkHandleValue(value);
      value = this.checkHandlePosition(value);
      return value;
    };
    Slider2.prototype.setLimitBarPositions = function(fromMinPostion, fromMaxpostion, toMinPostion, toMaxpostion) {
      if (this.orientation === "Horizontal") {
        if (!this.enableRtl) {
          this.limitBarFirst.style.left = fromMinPostion + "px";
          this.limitBarFirst.style.width = fromMaxpostion - fromMinPostion + "px";
        } else {
          this.limitBarFirst.style.right = fromMinPostion + "px";
          this.limitBarFirst.style.width = fromMaxpostion - fromMinPostion + "px";
        }
      } else {
        this.limitBarFirst.style.bottom = (this.min < this.max ? fromMinPostion : fromMaxpostion) + "px";
        this.limitBarFirst.style.height = (this.min < this.max ? fromMaxpostion - fromMinPostion : fromMinPostion - fromMaxpostion) + "px";
      }
      if (this.type === "Range") {
        if (this.orientation === "Horizontal") {
          if (!this.enableRtl) {
            this.limitBarSecond.style.left = toMinPostion + "px";
            this.limitBarSecond.style.width = toMaxpostion - toMinPostion + "px";
          } else {
            this.limitBarSecond.style.right = toMinPostion + "px";
            this.limitBarSecond.style.width = toMaxpostion - toMinPostion + "px";
          }
        } else {
          this.limitBarSecond.style.bottom = (this.min < this.max ? toMinPostion : toMaxpostion) + "px";
          this.limitBarSecond.style.height = (this.min < this.max ? toMaxpostion - toMinPostion : toMinPostion - toMaxpostion) + "px";
        }
      }
    };
    Slider2.prototype.setLimitBar = function() {
      if (this.type === "Default" || this.type === "MinRange") {
        var fromPosition = this.getLimitValueAndPosition(this.limits.minStart, this.limits.minStart, this.limits.minEnd, true)[0];
        fromPosition = this.checkValidValueAndPos(fromPosition);
        var toPosition = this.getLimitValueAndPosition(this.limits.minEnd, this.limits.minStart, this.limits.minEnd, true)[0];
        toPosition = this.checkValidValueAndPos(toPosition);
        this.setLimitBarPositions(fromPosition, toPosition);
      } else if (this.type === "Range") {
        var fromMinPostion = this.getLimitValueAndPosition(this.limits.minStart, this.limits.minStart, this.limits.minEnd, true)[0];
        fromMinPostion = this.checkValidValueAndPos(fromMinPostion);
        var fromMaxpostion = this.getLimitValueAndPosition(this.limits.minEnd, this.limits.minStart, this.limits.minEnd, true)[0];
        fromMaxpostion = this.checkValidValueAndPos(fromMaxpostion);
        var toMinPostion = this.getLimitValueAndPosition(this.limits.maxStart, this.limits.maxStart, this.limits.maxEnd, true)[0];
        toMinPostion = this.checkValidValueAndPos(toMinPostion);
        var toMaxpostion = this.getLimitValueAndPosition(this.limits.maxEnd, this.limits.maxStart, this.limits.maxEnd, true)[0];
        toMaxpostion = this.checkValidValueAndPos(toMaxpostion);
        this.setLimitBarPositions(fromMinPostion, fromMaxpostion, toMinPostion, toMaxpostion);
      }
    };
    Slider2.prototype.getLimitValueAndPosition = function(currentValue, minValue, maxValue, limitBar) {
      if (isNullOrUndefined(minValue)) {
        minValue = this.min < this.max ? this.min : this.max;
        if (isNullOrUndefined(currentValue) && limitBar) {
          currentValue = minValue;
        }
      }
      if (isNullOrUndefined(maxValue)) {
        maxValue = this.min < this.max ? this.max : this.min;
        if (isNullOrUndefined(currentValue) && limitBar) {
          currentValue = maxValue;
        }
      }
      if (currentValue < minValue) {
        currentValue = minValue;
      }
      if (currentValue > maxValue) {
        currentValue = maxValue;
      }
      return [currentValue, this.checkHandlePosition(currentValue)];
    };
    Slider2.prototype.setValue = function() {
      if (!isNullOrUndefined(this.customValues) && this.customValues.length > 0) {
        this.min = 0;
        this.max = this.customValues.length - 1;
        this.setBarColor();
      }
      this.setAriaAttributes(this.firstHandle);
      this.handleVal1 = isNullOrUndefined(this.value) ? this.checkHandleValue(parseFloat(this.min.toString())) : this.checkHandleValue(parseFloat(this.value.toString()));
      this.handlePos1 = this.checkHandlePosition(this.handleVal1);
      this.preHandlePos1 = this.handlePos1;
      if (isNullOrUndefined(this.activeHandle)) {
        this.activeHandle = this.type === "Range" ? 2 : 1;
      }
      if (this.type === "Default" || this.type === "MinRange") {
        if (this.limits.enabled) {
          var values = this.getLimitValueAndPosition(this.handleVal1, this.limits.minStart, this.limits.minEnd);
          this.handleVal1 = values[0];
          this.handlePos1 = values[1];
          this.preHandlePos1 = this.handlePos1;
        }
        this.setHandlePosition(null);
        this.handleStart();
        this.value = this.handleVal1;
        this.setAriaAttrValue(this.firstHandle);
        this.changeEvent("changed", null);
      } else {
        this.validateRangeValue();
      }
      if (this.type !== "Default") {
        this.setRangeBar();
      }
      if (this.limits.enabled) {
        this.setLimitBar();
      }
    };
    Slider2.prototype.rangeValueUpdate = function() {
      if (this.value === null || typeof this.value !== "object") {
        this.value = [parseFloat(formatUnit(this.min)), parseFloat(formatUnit(this.max))];
      }
    };
    Slider2.prototype.validateRangeValue = function() {
      this.rangeValueUpdate();
      this.setRangeValue();
    };
    Slider2.prototype.modifyZindex = function() {
      if (this.type === "Range" && !isNullOrUndefined(this.firstHandle) && !isNullOrUndefined(this.secondHandle)) {
        if (this.activeHandle === 1) {
          this.firstHandle.style.zIndex = this.zIndex + 4 + "";
          this.secondHandle.style.zIndex = this.zIndex + 3 + "";
        } else {
          this.firstHandle.style.zIndex = this.zIndex + 3 + "";
          this.secondHandle.style.zIndex = this.zIndex + 4 + "";
        }
      } else if (this.isMaterialTooltip && this.tooltipElement) {
        this.tooltipElement.style.zIndex = getZindexPartial(this.element) + "";
      }
    };
    Slider2.prototype.setHandlePosition = function(event) {
      var _this = this;
      var handle;
      var pos = this.activeHandle === 1 ? this.handlePos1 : this.handlePos2;
      if (this.isMaterialTooltip) {
        handle = [this.firstHandle, this.materialHandle];
      } else {
        handle = [this.getHandle()];
      }
      this.handleStart();
      handle.forEach(function(handle2) {
        if (isNullOrUndefined(handle2)) {
          return;
        }
        if (_this.orientation === "Horizontal") {
          if (_this.enableRtl) {
            handle2.style.right = pos + "px";
          } else {
            handle2.style.left = pos + "px";
          }
        } else {
          handle2.style.bottom = pos + "px";
        }
      });
      this.changeEvent("change", event);
    };
    Slider2.prototype.getHandle = function() {
      return this.activeHandle === 1 ? this.firstHandle : this.secondHandle;
    };
    Slider2.prototype.setRangeValue = function() {
      this.updateRangeValue();
      this.activeHandle = 1;
      this.setHandlePosition(null);
      this.activeHandle = 2;
      this.setHandlePosition(null);
      this.activeHandle = 1;
    };
    Slider2.prototype.changeEvent = function(eventName, e) {
      var previous = eventName === "change" ? this.previousVal : this.previousChanged;
      if (this.type !== "Range") {
        this.setProperties({ "value": this.handleVal1 }, true);
        if (previous !== this.value && (!this.isMaterialTooltip || !this.initialTooltip)) {
          this.trigger(eventName, this.changeEventArgs(eventName, e));
          this.initialTooltip = true;
          this.setPreviousVal(eventName, this.value);
        }
        this.setAriaAttrValue(this.firstHandle);
      } else {
        var value = this.value = [this.handleVal1, this.handleVal2];
        this.setProperties({ "value": value }, true);
        if (previous.length === this.value.length && this.value[0] !== previous[0] || this.value[1] !== previous[1]) {
          this.initialTooltip = false;
          this.trigger(eventName, this.changeEventArgs(eventName, e));
          this.initialTooltip = true;
          this.setPreviousVal(eventName, this.value);
        }
        this.setAriaAttrValue(this.getHandle());
      }
      this.hiddenInput.value = this.value.toString();
    };
    Slider2.prototype.changeEventArgs = function(eventName, e) {
      var eventArgs;
      if (this.tooltip.isVisible && this.tooltipObj && this.initialTooltip) {
        this.tooltipValue();
        eventArgs = {
          value: this.value,
          previousValue: eventName === "change" ? this.previousVal : this.previousChanged,
          action: eventName,
          text: typeof this.tooltipObj.content === "function" ? this.tooltipObj.content() : this.tooltipObj.content,
          isInteracted: isNullOrUndefined(e) ? false : true
        };
      } else {
        eventArgs = {
          value: this.value,
          previousValue: eventName === "change" ? this.previousVal : this.previousChanged,
          action: eventName,
          text: isNullOrUndefined(this.ticksFormatInfo.format) ? this.value.toString() : this.type !== "Range" ? this.formatString(this.value, this.ticksFormatInfo).formatString : this.formatString(this.value[0], this.ticksFormatInfo).formatString + " - " + this.formatString(this.value[1], this.ticksFormatInfo).formatString,
          isInteracted: isNullOrUndefined(e) ? false : true
        };
      }
      return eventArgs;
    };
    Slider2.prototype.setPreviousVal = function(eventName, value) {
      if (eventName === "change") {
        this.previousVal = value;
      } else {
        this.previousChanged = value;
      }
    };
    Slider2.prototype.updateRangeValue = function() {
      var values = this.value.toString().split(",").map(Number);
      if (this.enableRtl && this.orientation !== "Vertical" || this.rtl) {
        this.value = [values[1], values[0]];
      } else {
        this.value = [values[0], values[1]];
      }
      if (this.enableRtl && this.orientation !== "Vertical") {
        this.handleVal1 = this.checkHandleValue(this.value[1]);
        this.handleVal2 = this.checkHandleValue(this.value[0]);
      } else {
        this.handleVal1 = this.checkHandleValue(this.value[0]);
        this.handleVal2 = this.checkHandleValue(this.value[1]);
      }
      this.handlePos1 = this.checkHandlePosition(this.handleVal1);
      this.handlePos2 = this.checkHandlePosition(this.handleVal2);
      if (this.min < this.max && this.handlePos1 > this.handlePos2) {
        this.handlePos1 = this.handlePos2;
        this.handleVal1 = this.handleVal2;
      }
      if (this.min > this.max && this.handlePos1 < this.handlePos2) {
        this.handlePos2 = this.handlePos1;
        this.handleVal2 = this.handleVal1;
      }
      this.preHandlePos1 = this.handlePos1;
      this.preHandlePos2 = this.handlePos2;
      if (this.limits.enabled) {
        this.activeHandle = 1;
        var values_1 = this.getLimitValueAndPosition(this.handleVal1, this.limits.minStart, this.limits.minEnd);
        this.handleVal1 = values_1[0];
        this.handlePos1 = values_1[1];
        this.preHandlePos1 = this.handlePos1;
        this.activeHandle = 2;
        values_1 = this.getLimitValueAndPosition(this.handleVal2, this.limits.maxStart, this.limits.maxEnd);
        this.handleVal2 = values_1[0];
        this.handlePos2 = values_1[1];
        this.preHandlePos2 = this.handlePos2;
      }
    };
    Slider2.prototype.checkHandlePosition = function(value) {
      var pos;
      value = 100 * (value - parseFloat(formatUnit(this.min))) / (parseFloat(formatUnit(this.max)) - parseFloat(formatUnit(this.min)));
      if (this.orientation === "Horizontal") {
        pos = this.element.getBoundingClientRect().width * (value / 100);
      } else {
        pos = this.element.getBoundingClientRect().height * (value / 100);
      }
      if (parseFloat(formatUnit(this.max)) === parseFloat(formatUnit(this.min))) {
        if (this.orientation === "Horizontal") {
          pos = this.element.getBoundingClientRect().width;
        } else {
          pos = this.element.getBoundingClientRect().height;
        }
      }
      return pos;
    };
    Slider2.prototype.checkHandleValue = function(value) {
      if (this.min === this.max) {
        return parseFloat(formatUnit(this.max));
      }
      var handle = this.tempStartEnd();
      if (value < handle.start) {
        value = handle.start;
      } else if (value > handle.end) {
        value = handle.end;
      }
      return value;
    };
    Slider2.prototype.reposition = function() {
      var _this = this;
      if (!isNullOrUndefined(this.firstHandle)) {
        this.firstHandle.style.transition = "none";
      }
      if (this.type !== "Default" && !isNullOrUndefined(this.rangeBar)) {
        this.rangeBar.style.transition = "none";
      }
      if (this.type === "Range" && !isNullOrUndefined(this.secondHandle)) {
        this.secondHandle.style.transition = "none";
      }
      this.handlePos1 = this.checkHandlePosition(this.handleVal1);
      if (this.handleVal2) {
        this.handlePos2 = this.checkHandlePosition(this.handleVal2);
      }
      if (this.orientation === "Horizontal") {
        if (this.enableRtl) {
          this.firstHandle.style.right = this.handlePos1 + "px";
        } else {
          this.firstHandle.style.left = this.handlePos1 + "px";
        }
        if (this.isMaterialTooltip && !isNullOrUndefined(this.materialHandle)) {
          if (this.enableRtl) {
            this.materialHandle.style.right = this.handlePos1 + "px";
          } else {
            this.materialHandle.style.left = this.handlePos1 + "px";
          }
        }
        if (this.type === "MinRange" && !isNullOrUndefined(this.rangeBar)) {
          if (this.enableRtl) {
            this.rangeBar.style.right = "0px";
          } else {
            this.rangeBar.style.left = "0px";
          }
          setStyleAttribute(this.rangeBar, { "width": isNullOrUndefined(this.handlePos1) ? 0 : this.handlePos1 + "px" });
        } else if (this.type === "Range" && !isNullOrUndefined(this.secondHandle) && !isNullOrUndefined(this.rangeBar)) {
          if (this.enableRtl) {
            this.secondHandle.style.right = this.handlePos2 + "px";
            this.rangeBar.style.right = this.handlePos1 + "px";
          } else {
            this.secondHandle.style.left = this.handlePos2 + "px";
            this.rangeBar.style.left = this.handlePos1 + "px";
          }
          setStyleAttribute(this.rangeBar, { "width": this.handlePos2 - this.handlePos1 + "px" });
        }
      } else {
        this.firstHandle.style.bottom = this.handlePos1 + "px";
        if (this.isMaterialTooltip) {
          this.materialHandle.style.bottom = this.handlePos1 + "px";
        }
        if (this.type === "MinRange") {
          this.rangeBar.style.bottom = this.min > this.max ? this.handlePos1 + "px" : "0px";
          setStyleAttribute(this.rangeBar, { "height": isNullOrUndefined(this.handlePos1) ? 0 : this.min > this.max ? this.element.clientHeight - this.handlePos1 + "px" : this.handlePos1 + "px" });
        } else if (this.type === "Range") {
          this.secondHandle.style.bottom = this.handlePos2 + "px";
          this.rangeBar.style.bottom = this.min > this.max ? this.handlePos2 + "px" : this.handlePos1 + "px";
          setStyleAttribute(this.rangeBar, { "height": this.min > this.max ? this.handlePos1 - this.handlePos2 + "px" : this.handlePos2 - this.handlePos1 + "px" });
        }
      }
      if (this.limits.enabled) {
        this.setLimitBar();
      }
      if (this.ticks.placement !== "None" && this.ul) {
        this.removeElement(this.ul);
        this.ul = undefined;
        this.renderScale();
      }
      this.handleStart();
      if (!this.tooltip.isVisible) {
        setTimeout(function() {
          if (!isNullOrUndefined(_this.firstHandle)) {
            _this.firstHandle.style.transition = _this.scaleTransform;
          }
          if (_this.type === "Range" && !isNullOrUndefined(_this.secondHandle)) {
            _this.secondHandle.style.transition = _this.scaleTransform;
          }
        });
      }
      this.refreshTooltip(this.tooltipTarget);
      this.setBarColor();
    };
    Slider2.prototype.changeHandleValue = function(value) {
      var position = null;
      if (this.activeHandle === 1) {
        if (!(this.limits.enabled && this.limits.startHandleFixed)) {
          this.handleVal1 = this.checkHandleValue(value);
          this.handlePos1 = this.checkHandlePosition(this.handleVal1);
          if (this.type === "Range" && (this.handlePos1 > this.handlePos2 && this.min < this.max || this.handlePos1 < this.handlePos2 && this.min > this.max)) {
            this.handlePos1 = this.handlePos2;
            this.handleVal1 = this.handleVal2;
          }
          if (this.handlePos1 !== this.preHandlePos1) {
            position = this.preHandlePos1 = this.handlePos1;
          }
        }
        this.modifyZindex();
      } else {
        if (!(this.limits.enabled && this.limits.endHandleFixed)) {
          this.handleVal2 = this.checkHandleValue(value);
          this.handlePos2 = this.checkHandlePosition(this.handleVal2);
          if (this.type === "Range" && (this.handlePos2 < this.handlePos1 && this.min < this.max || this.handlePos2 > this.handlePos1 && this.min > this.max)) {
            this.handlePos2 = this.handlePos1;
            this.handleVal2 = this.handleVal1;
          }
          if (this.handlePos2 !== this.preHandlePos2) {
            position = this.preHandlePos2 = this.handlePos2;
          }
        }
        this.modifyZindex();
      }
      if (position !== null) {
        if (this.type !== "Default") {
          this.setRangeBar();
        }
        this.setHandlePosition(null);
      }
    };
    Slider2.prototype.tempStartEnd = function() {
      if (this.min > this.max) {
        return {
          start: this.max,
          end: this.min
        };
      } else {
        return {
          start: this.min,
          end: this.max
        };
      }
    };
    Slider2.prototype.xyToPosition = function(position) {
      var pos;
      if (this.min === this.max) {
        return 100;
      }
      if (this.orientation === "Horizontal") {
        var left = position.x - this.element.getBoundingClientRect().left;
        var num = this.element.offsetWidth / 100;
        this.val = left / num;
      } else {
        var top_1 = position.y - this.element.getBoundingClientRect().top;
        var num = this.element.offsetHeight / 100;
        this.val = 100 - top_1 / num;
      }
      var val = this.stepValueCalculation(this.val);
      if (val < 0) {
        val = 0;
      } else if (val > 100) {
        val = 100;
      }
      if (this.enableRtl && this.orientation !== "Vertical") {
        val = 100 - val;
      }
      if (this.orientation === "Horizontal") {
        pos = this.element.getBoundingClientRect().width * (val / 100);
      } else {
        pos = this.element.getBoundingClientRect().height * (val / 100);
      }
      return pos;
    };
    Slider2.prototype.stepValueCalculation = function(value) {
      if (this.step === 0) {
        this.step = 1;
      }
      var percentStep = parseFloat(formatUnit(this.step)) / ((parseFloat(formatUnit(this.max)) - parseFloat(formatUnit(this.min))) / 100);
      var remain = value % Math.abs(percentStep);
      if (remain !== 0) {
        if (percentStep / 2 > remain) {
          value -= remain;
        } else {
          value += Math.abs(percentStep) - remain;
        }
      }
      return value;
    };
    Slider2.prototype.add = function(a, b, addition) {
      var x = Math.pow(10, 3);
      var val;
      if (addition) {
        val = (Math.round(a * x) + Math.round(b * x)) / x;
      } else {
        val = (Math.round(a * x) - Math.round(b * x)) / x;
      }
      return val;
    };
    Slider2.prototype.positionToValue = function(pos) {
      var val;
      var diff = parseFloat(formatUnit(this.max)) - parseFloat(formatUnit(this.min));
      if (this.orientation === "Horizontal") {
        val = pos / this.element.getBoundingClientRect().width * diff;
      } else {
        val = pos / this.element.getBoundingClientRect().height * diff;
      }
      var total = this.add(val, parseFloat(this.min.toString()), true);
      return total;
    };
    Slider2.prototype.sliderBarClick = function(evt) {
      evt.preventDefault();
      var pos;
      if (evt.type === "mousedown" || evt.type === "mouseup" || evt.type === "click") {
        pos = { x: evt.clientX, y: evt.clientY };
      } else if (evt.type === "touchend" || evt.type === "touchstart") {
        pos = { x: evt.changedTouches[0].clientX, y: evt.changedTouches[0].clientY };
      }
      var handlepos = this.xyToPosition(pos);
      var handleVal = this.positionToValue(handlepos);
      if (this.type === "Range" && (this.min < this.max && this.handlePos2 - handlepos < handlepos - this.handlePos1 || this.min > this.max && this.handlePos1 - handlepos > handlepos - this.handlePos2)) {
        this.activeHandle = 2;
        if (!(this.limits.enabled && this.limits.endHandleFixed)) {
          if (this.limits.enabled) {
            var value = this.getLimitValueAndPosition(handleVal, this.limits.maxStart, this.limits.maxEnd);
            handleVal = value[0];
            handlepos = value[1];
          }
          this.secondHandle.classList.add(classNames$1.sliderActiveHandle);
          this.handlePos2 = this.preHandlePos2 = handlepos;
          this.handleVal2 = handleVal;
        }
        this.modifyZindex();
        this.secondHandle.focus();
      } else {
        this.activeHandle = 1;
        if (!(this.limits.enabled && this.limits.startHandleFixed)) {
          if (this.limits.enabled) {
            var value = this.getLimitValueAndPosition(handleVal, this.limits.minStart, this.limits.minEnd);
            handleVal = value[0];
            handlepos = value[1];
          }
          this.firstHandle.classList.add(classNames$1.sliderActiveHandle);
          this.handlePos1 = this.preHandlePos1 = handlepos;
          this.handleVal1 = handleVal;
        }
        this.modifyZindex();
        this.firstHandle.focus();
      }
      if (this.isMaterialTooltip) {
        this.tooltipElement.classList.add(classNames$1.materialTooltipActive);
      }
      var focusedElement = this.element.querySelector("." + classNames$1.sliderTabHandle);
      if (focusedElement && this.getHandle() !== focusedElement) {
        focusedElement.classList.remove(classNames$1.sliderTabHandle);
      }
      var handle = this.activeHandle === 1 ? this.firstHandle : this.secondHandle;
      if ((evt.type === "click" || evt.type === "mousedown") && evt.target === handle) {
        var eventX = evt.clientX, eventY = evt.clientY;
        (undefined).elementFromPoint(eventX, eventY);
      }
      if (!this.checkRepeatedValue(handleVal)) {
        return;
      }
      var transition = (this.isMaterial || this.isMaterial3) && this.tooltip.isVisible ? this.transitionOnMaterialTooltip : this.transition;
      this.getHandle().style.transition = transition.handle;
      if (this.type !== "Default") {
        this.rangeBar.style.transition = transition.rangeBar;
      }
      this.setHandlePosition(evt);
      if (this.isMaterialTooltip) {
        this.initialTooltip = false;
      }
      if (evt.target !== handle) {
        this.changeEvent("changed", evt);
      }
      if (this.type !== "Default") {
        this.setRangeBar();
      }
    };
    Slider2.prototype.handleValueAdjust = function(handleValue, assignValue, handleNumber) {
      if (handleNumber === 1) {
        this.handleVal1 = assignValue;
        this.handleVal2 = this.handleVal1 + this.minDiff;
      } else if (handleNumber === 2) {
        this.handleVal2 = assignValue;
        this.handleVal1 = this.handleVal2 - this.minDiff;
      }
      this.handlePos1 = this.checkHandlePosition(this.handleVal1);
      this.handlePos2 = this.checkHandlePosition(this.handleVal2);
    };
    Slider2.prototype.dragRangeBarMove = function(event) {
      var _a, _b;
      if (event.type !== "touchmove") {
        event.preventDefault();
      }
      this.rangeBarDragged = true;
      var pos;
      this.rangeBar.style.transition = "none";
      this.firstHandle.style.transition = "none";
      this.secondHandle.style.transition = "none";
      var xPostion;
      var yPostion;
      if (event.type === "mousemove") {
        _a = [event.clientX, event.clientY], xPostion = _a[0], yPostion = _a[1];
      } else {
        _b = [event.changedTouches[0].clientX, event.changedTouches[0].clientY], xPostion = _b[0], yPostion = _b[1];
      }
      if (!(this.limits.enabled && this.limits.startHandleFixed) && !(this.limits.enabled && this.limits.endHandleFixed)) {
        if (!this.enableRtl) {
          pos = { x: xPostion - this.firstPartRemain, y: yPostion + this.secondPartRemain };
        } else {
          pos = { x: xPostion + this.secondPartRemain, y: yPostion + this.secondPartRemain };
        }
        if (this.min > this.max) {
          this.handlePos2 = this.xyToPosition(pos);
          this.handleVal2 = this.positionToValue(this.handlePos2);
        } else {
          this.handlePos1 = this.xyToPosition(pos);
          this.handleVal1 = this.positionToValue(this.handlePos1);
        }
        if (!this.enableRtl) {
          pos = { x: xPostion + this.secondPartRemain, y: yPostion - this.firstPartRemain };
        } else {
          pos = { x: xPostion - this.firstPartRemain, y: yPostion - this.firstPartRemain };
        }
        if (this.min > this.max) {
          this.handlePos1 = this.xyToPosition(pos);
          this.handleVal1 = this.positionToValue(this.handlePos1);
        } else {
          this.handlePos2 = this.xyToPosition(pos);
          this.handleVal2 = this.positionToValue(this.handlePos2);
        }
        if (this.limits.enabled) {
          var value = this.getLimitValueAndPosition(this.handleVal1, this.limits.minStart, this.limits.minEnd);
          this.handleVal1 = value[0];
          this.handlePos1 = value[1];
          if (this.handleVal1 === this.limits.minEnd) {
            this.handleValueAdjust(this.handleVal1, this.limits.minEnd, 1);
          }
          if (this.handleVal1 === this.limits.minStart) {
            this.handleValueAdjust(this.handleVal1, this.limits.minStart, 1);
          }
          value = this.getLimitValueAndPosition(this.handleVal2, this.limits.maxStart, this.limits.maxEnd);
          this.handleVal2 = value[0];
          this.handlePos2 = value[1];
          if (this.handleVal2 === this.limits.maxStart) {
            this.handleValueAdjust(this.handleVal2, this.limits.maxStart, 2);
          }
          if (this.handleVal2 === this.limits.maxEnd) {
            this.handleValueAdjust(this.handleVal2, this.limits.maxEnd, 2);
          }
        }
        if (this.handleVal2 === (this.min > this.max ? this.min : this.max)) {
          this.handleValueAdjust(this.handleVal2, this.min > this.max ? this.min : this.max, 2);
        }
        if (this.handleVal1 === (this.min > this.max ? this.max : this.min)) {
          this.handleValueAdjust(this.handleVal1, this.min > this.max ? this.max : this.min, 1);
        }
      }
      this.activeHandle = 1;
      this.setHandlePosition(event);
      this.activeHandle = 2;
      this.setHandlePosition(event);
      this.tooltipToggle(this.rangeBar);
      this.setRangeBar();
    };
    Slider2.prototype.sliderBarUp = function(event) {
      this.changeEvent("changed", event);
      this.handleFocusOut();
      this.firstHandle.classList.remove(classNames$1.sliderActiveHandle);
      if (this.type === "Range") {
        this.initialTooltip = false;
        this.secondHandle.classList.remove(classNames$1.sliderActiveHandle);
      }
      this.closeTooltip();
      if (this.isMaterial || this.isMaterial3) {
        this.getHandle().classList.remove("e-large-thumb-size");
        if (this.isMaterialTooltip) {
          this.tooltipElement.classList.remove(classNames$1.materialTooltipActive);
        }
      }
      EventHandler.remove(undefined, "mousemove touchmove", this.sliderBarMove);
      EventHandler.remove(undefined, "mouseup touchend", this.sliderBarUp);
    };
    Slider2.prototype.sliderBarMove = function(evt) {
      if (evt.type !== "touchmove") {
        evt.preventDefault();
      }
      var pos;
      if (evt.type === "mousemove") {
        pos = { x: evt.clientX, y: evt.clientY };
      } else {
        pos = { x: evt.changedTouches[0].clientX, y: evt.changedTouches[0].clientY };
      }
      var handlepos = this.xyToPosition(pos);
      var handleVal = this.positionToValue(handlepos);
      handlepos = Math.round(handlepos);
      if (this.type !== "Range" && this.activeHandle === 1) {
        if (!(this.limits.enabled && this.limits.startHandleFixed)) {
          if (this.limits.enabled) {
            var valueAndPostion = this.getLimitValueAndPosition(handleVal, this.limits.minStart, this.limits.minEnd);
            handlepos = valueAndPostion[1];
            handleVal = valueAndPostion[0];
          }
          this.handlePos1 = handlepos;
          this.handleVal1 = handleVal;
        }
        this.firstHandle.classList.add(classNames$1.sliderActiveHandle);
      }
      if (this.type === "Range") {
        if (this.activeHandle === 1) {
          this.firstHandle.classList.add(classNames$1.sliderActiveHandle);
          if (!(this.limits.enabled && this.limits.startHandleFixed)) {
            if (this.min < this.max && handlepos > this.handlePos2 || this.min > this.max && handlepos < this.handlePos2) {
              handlepos = this.handlePos2;
              handleVal = this.handleVal2;
            }
            if (handlepos !== this.preHandlePos1) {
              if (this.limits.enabled) {
                var value = this.getLimitValueAndPosition(handleVal, this.limits.minStart, this.limits.minEnd);
                handleVal = value[0];
                handlepos = value[1];
              }
              this.handlePos1 = this.preHandlePos1 = handlepos;
              this.handleVal1 = handleVal;
              this.activeHandle = 1;
            }
          }
        } else if (this.activeHandle === 2) {
          this.secondHandle.classList.add(classNames$1.sliderActiveHandle);
          if (!(this.limits.enabled && this.limits.endHandleFixed)) {
            if (this.min < this.max && handlepos < this.handlePos1 || this.min > this.max && handlepos > this.handlePos1) {
              handlepos = this.handlePos1;
              handleVal = this.handleVal1;
            }
            if (handlepos !== this.preHandlePos2) {
              if (this.limits.enabled) {
                var value = this.getLimitValueAndPosition(handleVal, this.limits.maxStart, this.limits.maxEnd);
                handleVal = value[0];
                handlepos = value[1];
              }
              this.handlePos2 = this.preHandlePos2 = handlepos;
              this.handleVal2 = handleVal;
              this.activeHandle = 2;
            }
          }
        }
      }
      if (!this.checkRepeatedValue(handleVal)) {
        return;
      }
      this.getHandle().style.transition = this.scaleTransform;
      if (this.type !== "Default") {
        this.rangeBar.style.transition = "none";
      }
      this.setHandlePosition(evt);
      if ((this.isMaterial || this.isMaterial3) && !this.tooltip.isVisible && !this.getHandle().classList.contains(classNames$1.sliderTabHandle)) {
        this.materialChange();
      }
      this.tooltipToggle(this.getHandle());
      if (this.type !== "Default") {
        this.setRangeBar();
      }
    };
    Slider2.prototype.dragRangeBarUp = function(event) {
      if (!this.rangeBarDragged) {
        this.focusSliderElement();
        this.sliderBarClick(event);
      } else {
        this.isDragComplete = true;
      }
      this.changeEvent("changed", event);
      this.closeTooltip();
      EventHandler.remove(undefined, "mousemove touchmove", this.dragRangeBarMove);
      EventHandler.remove(undefined, "mouseup touchend", this.dragRangeBarUp);
      this.rangeBarDragged = false;
    };
    Slider2.prototype.checkRepeatedValue = function(currentValue) {
      if (this.type === "Range") {
        var previousVal = this.enableRtl && this.orientation !== "Vertical" ? this.activeHandle === 1 ? this.previousVal[1] : this.previousVal[0] : this.activeHandle === 1 ? this.previousVal[0] : this.previousVal[1];
        if (currentValue === previousVal) {
          return 0;
        }
      } else {
        if (currentValue === this.previousVal) {
          return 0;
        }
      }
      return 1;
    };
    Slider2.prototype.refreshTooltip = function(target) {
      if (this.tooltip.isVisible && this.tooltipObj) {
        this.tooltipValue();
        if (target) {
          this.tooltipObj.refresh(target);
          this.tooltipTarget = target;
        }
      }
    };
    Slider2.prototype.openTooltip = function(target) {
      if (this.tooltip.isVisible && this.tooltipObj && !this.isMaterialTooltip) {
        this.tooltipValue();
        this.tooltipObj.open(target);
        this.tooltipTarget = target;
      }
    };
    Slider2.prototype.closeTooltip = function() {
      if (this.tooltip.isVisible && this.tooltipObj && this.tooltip.showOn !== "Always" && !this.isMaterialTooltip) {
        this.tooltipValue();
        this.tooltipObj.close();
        this.tooltipTarget = undefined;
      }
    };
    Slider2.prototype.keyDown = function(event) {
      switch (event.keyCode) {
        case 37:
        case 38:
        case 39:
        case 40:
        case 33:
        case 34:
        case 36:
        case 35:
          event.preventDefault();
          this.buttonClick(event);
          break;
      }
    };
    Slider2.prototype.wireButtonEvt = function(destroy2) {
      if (!destroy2) {
        EventHandler.add(this.firstBtn, "mouseleave touchleave", this.buttonFocusOut, this);
        EventHandler.add(this.secondBtn, "mouseleave touchleave", this.buttonFocusOut, this);
        EventHandler.add(this.firstBtn, "mousedown touchstart", this.repeatHandlerMouse, this);
        EventHandler.add(this.firstBtn, "mouseup mouseleave touchup touchend", this.repeatHandlerUp, this);
        EventHandler.add(this.secondBtn, "mousedown touchstart", this.repeatHandlerMouse, this);
        EventHandler.add(this.secondBtn, "mouseup mouseleave touchup touchend", this.repeatHandlerUp, this);
        EventHandler.add(this.firstBtn, "focusout", this.sliderFocusOut, this);
        EventHandler.add(this.secondBtn, "focusout", this.sliderFocusOut, this);
      } else {
        EventHandler.remove(this.firstBtn, "mouseleave touchleave", this.buttonFocusOut);
        EventHandler.remove(this.secondBtn, "mouseleave touchleave", this.buttonFocusOut);
        EventHandler.remove(this.firstBtn, "mousedown touchstart", this.repeatHandlerMouse);
        EventHandler.remove(this.firstBtn, "mouseup mouseleave touchup touchend", this.repeatHandlerUp);
        EventHandler.remove(this.secondBtn, "mousedown touchstart", this.repeatHandlerMouse);
        EventHandler.remove(this.secondBtn, "mouseup mouseleave touchup touchend", this.repeatHandlerUp);
        EventHandler.remove(this.firstBtn, "focusout", this.sliderFocusOut);
        EventHandler.remove(this.secondBtn, "focusout", this.sliderFocusOut);
      }
    };
    Slider2.prototype.rangeBarMousedown = function(event) {
      var _a, _b;
      event.preventDefault();
      this.focusSliderElement();
      if (this.type === "Range" && this.drag && event.target === this.rangeBar) {
        var xPostion = undefined;
        var yPostion = undefined;
        if (event.type === "mousedown") {
          _a = [event.clientX, event.clientY], xPostion = _a[0], yPostion = _a[1];
        } else if (event.type === "touchstart") {
          _b = [event.changedTouches[0].clientX, event.changedTouches[0].clientY], xPostion = _b[0], yPostion = _b[1];
        }
        if (this.orientation === "Horizontal") {
          this.firstPartRemain = xPostion - this.rangeBar.getBoundingClientRect().left;
          this.secondPartRemain = this.rangeBar.getBoundingClientRect().right - xPostion;
        } else {
          this.firstPartRemain = yPostion - this.rangeBar.getBoundingClientRect().top;
          this.secondPartRemain = this.rangeBar.getBoundingClientRect().bottom - yPostion;
        }
        this.minDiff = this.handleVal2 - this.handleVal1;
        this.tooltipToggle(this.rangeBar);
        var focusedElement = this.element.querySelector("." + classNames$1.sliderTabHandle);
        if (focusedElement) {
          focusedElement.classList.remove(classNames$1.sliderTabHandle);
        }
        EventHandler.add(undefined, "mousemove touchmove", this.dragRangeBarMove, this);
        EventHandler.add(undefined, "mouseup touchend", this.dragRangeBarUp, this);
      }
    };
    Slider2.prototype.elementClick = function(event) {
      if (this.isDragComplete) {
        this.isDragComplete = false;
        return;
      }
      event.preventDefault();
      this.focusSliderElement();
      this.sliderBarClick(event);
      this.focusHandle();
    };
    Slider2.prototype.wireEvents = function() {
      this.onresize = this.reposition.bind(this);
      (undefined).addEventListener("resize", this.onresize);
      if (this.enabled && !this.readonly) {
        EventHandler.add(this.element, "click", this.elementClick, this);
        if (this.type === "Range" && this.drag) {
          EventHandler.add(this.rangeBar, "mousedown touchstart", this.rangeBarMousedown, this);
        }
        EventHandler.add(this.sliderContainer, "keydown", this.keyDown, this);
        EventHandler.add(this.sliderContainer, "keyup", this.keyUp, this);
        EventHandler.add(this.element, "focusout", this.sliderFocusOut, this);
        EventHandler.add(this.sliderContainer, "mouseover mouseout touchstart touchend", this.hover, this);
        this.wireFirstHandleEvt(false);
        if (this.type === "Range") {
          this.wireSecondHandleEvt(false);
        }
        if (this.showButtons) {
          this.wireButtonEvt(false);
        }
        this.wireMaterialTooltipEvent(false);
        if (this.isForm) {
          EventHandler.add(this.formElement, "reset", this.formResetHandler, this);
        }
      }
    };
    Slider2.prototype.unwireEvents = function() {
      EventHandler.remove(this.element, "click", this.elementClick);
      if (this.type === "Range" && this.drag) {
        EventHandler.remove(this.rangeBar, "mousedown touchstart", this.rangeBarMousedown);
      }
      EventHandler.remove(this.sliderContainer, "keydown", this.keyDown);
      EventHandler.remove(this.sliderContainer, "keyup", this.keyUp);
      EventHandler.remove(this.element, "focusout", this.sliderFocusOut);
      EventHandler.remove(this.sliderContainer, "mouseover mouseout touchstart touchend", this.hover);
      this.wireFirstHandleEvt(true);
      if (this.type === "Range") {
        this.wireSecondHandleEvt(true);
      }
      if (this.showButtons) {
        this.wireButtonEvt(true);
      }
      this.wireMaterialTooltipEvent(true);
      EventHandler.remove(this.element, "reset", this.formResetHandler);
    };
    Slider2.prototype.formResetHandler = function() {
      this.setProperties({ "value": this.formResetValue }, true);
      this.setValue();
    };
    Slider2.prototype.keyUp = function(event) {
      if (event.keyCode === 9 && event.target.classList.contains(classNames$1.sliderHandle)) {
        this.focusSliderElement();
        if (!event.target.classList.contains(classNames$1.sliderTabHandle)) {
          if (this.element.querySelector("." + classNames$1.sliderTabHandle)) {
            this.element.querySelector("." + classNames$1.sliderTabHandle).classList.remove(classNames$1.sliderTabHandle);
          }
          event.target.classList.add(classNames$1.sliderTabHandle);
          var parentElement = event.target.parentElement;
          if (parentElement === this.element) {
            parentElement.querySelector("." + classNames$1.sliderTrack).classList.add(classNames$1.sliderTabTrack);
            if (this.type === "Range" || this.type === "MinRange") {
              parentElement.querySelector("." + classNames$1.rangeBar).classList.add(classNames$1.sliderTabRange);
            }
          }
          if (this.type === "Range") {
            var previousSibling = event.target.previousSibling;
            if (previousSibling && previousSibling.classList.contains(classNames$1.sliderHandle)) {
              this.activeHandle = 2;
            } else {
              this.activeHandle = 1;
            }
          }
          this.getHandle().focus();
          this.tooltipToggle(this.getHandle());
        }
      }
      this.closeTooltip();
      this.changeEvent("changed", event);
    };
    Slider2.prototype.hover = function(event) {
      if (!isNullOrUndefined(event)) {
        if (event.type === "mouseover" || event.type === "touchmove" || event.type === "mousemove" || event.type === "pointermove" || event.type === "touchstart") {
          this.sliderContainer.classList.add(classNames$1.sliderHover);
        } else {
          this.sliderContainer.classList.remove(classNames$1.sliderHover);
          var curTarget = event.currentTarget;
          if (this.tooltip.isVisible && this.tooltip.showOn !== "Always" && this.tooltipObj && this.isMaterialTooltip && !curTarget.classList.contains(classNames$1.sliderHandleFocused) && !curTarget.classList.contains(classNames$1.sliderTabHandle)) {
            this.closeMaterialTooltip();
          }
        }
      }
    };
    Slider2.prototype.sliderFocusOut = function(event) {
      if (event.relatedTarget !== this.secondHandle && event.relatedTarget !== this.firstHandle && event.relatedTarget !== this.element && event.relatedTarget !== this.firstBtn && event.relatedTarget !== this.secondBtn) {
        this.closeMaterialTooltip();
        this.closeTooltip();
        if (this.element.querySelector("." + classNames$1.sliderTabHandle)) {
          this.element.querySelector("." + classNames$1.sliderTabHandle).classList.remove(classNames$1.sliderTabHandle);
        }
        if (this.element.querySelector("." + classNames$1.sliderTabTrack)) {
          this.element.querySelector("." + classNames$1.sliderTabTrack).classList.remove(classNames$1.sliderTabTrack);
          if ((this.type === "Range" || this.type === "MinRange") && this.element.querySelector("." + classNames$1.sliderTabRange)) {
            this.element.querySelector("." + classNames$1.sliderTabRange).classList.remove(classNames$1.sliderTabRange);
          }
        }
        this.hiddenInput.focus();
        this.hiddenInput.blur();
        this.isElementFocused = false;
      }
    };
    Slider2.prototype.removeElement = function(element2) {
      if (element2.parentNode) {
        element2.parentNode.removeChild(element2);
      }
    };
    Slider2.prototype.changeSliderType = function(type, args) {
      if (this.isMaterialTooltip && this.materialHandle) {
        this.sliderContainer.classList.remove(classNames$1.materialSlider);
        this.removeElement(this.materialHandle);
        this.materialHandle = undefined;
      }
      this.removeElement(this.firstHandle);
      this.firstHandle = undefined;
      if (type !== "Default") {
        if (type === "Range") {
          this.removeElement(this.secondHandle);
          this.secondHandle = undefined;
        }
        this.removeElement(this.rangeBar);
        this.rangeBar = undefined;
      }
      if (this.tooltip.isVisible && !isNullOrUndefined(this.tooltipObj)) {
        this.tooltipObj.destroy();
        this.tooltipElement = undefined;
        this.tooltipCollidedPosition = undefined;
      }
      if (this.limits.enabled) {
        if (type === "MinRange" || type === "Default") {
          if (!isNullOrUndefined(this.limitBarFirst)) {
            this.removeElement(this.limitBarFirst);
            this.limitBarFirst = undefined;
          }
        } else {
          if (!isNullOrUndefined(this.limitBarSecond)) {
            this.removeElement(this.limitBarSecond);
            this.limitBarSecond = undefined;
          }
        }
      }
      this.activeHandle = 1;
      this.getThemeInitialization();
      if (this.type === "Range") {
        this.rangeValueUpdate();
      }
      this.createRangeBar();
      if (this.limits.enabled) {
        this.createLimitBar();
      }
      this.setHandler();
      this.setOrientClass();
      this.wireFirstHandleEvt(!this.enabled);
      if (this.type === "Range") {
        this.wireSecondHandleEvt(!this.enabled);
      }
      this.setValue();
      if (this.tooltip.isVisible) {
        this.renderTooltip();
        this.wireMaterialTooltipEvent(false);
      }
      this.setBarColor();
      if (args !== "tooltip") {
        this.updateConfig();
      }
      if (this.readonly) {
        this.sliderContainer.classList.remove(classNames$1.readonly);
        this.setReadOnly();
      }
    };
    Slider2.prototype.changeRtl = function() {
      if (!this.enableRtl && this.type === "Range") {
        this.value = [this.handleVal2, this.handleVal1];
      }
      this.updateConfig();
      if (this.tooltip.isVisible) {
        this.tooltipObj.refresh(this.firstHandle);
      }
      if (this.showButtons) {
        var enabledRTL = this.enableRtl && this.orientation !== "Vertical";
        attributes(enabledRTL ? this.secondBtn : this.firstBtn, { "aria-label": "Decrease", title: "Decrease" });
        attributes(enabledRTL ? this.firstBtn : this.secondBtn, { "aria-label": "Increase", title: "Increase" });
      }
    };
    Slider2.prototype.changeOrientation = function() {
      this.changeSliderType(this.type, "null");
    };
    Slider2.prototype.updateConfig = function() {
      this.setEnableRTL();
      this.setValue();
      if (this.tooltip.isVisible) {
        this.refreshTooltip(this.tooltipTarget);
      }
      if (this.ticks.placement !== "None") {
        if (this.ul) {
          this.removeElement(this.ul);
          this.ul = undefined;
          this.renderScale();
        }
      }
      this.limitsPropertyChange();
    };
    Slider2.prototype.limitsPropertyChange = function() {
      if (this.limits.enabled) {
        if (isNullOrUndefined(this.limitBarFirst) && this.type !== "Range") {
          this.createLimitBar();
        }
        if (isNullOrUndefined(this.limitBarFirst) && isNullOrUndefined(this.limitBarSecond) && this.type === "Range") {
          this.createLimitBar();
        }
        this.setLimitBar();
        this.setValue();
      } else {
        if (!isNullOrUndefined(this.limitBarFirst)) {
          detach(this.limitBarFirst);
        }
        if (!isNullOrUndefined(this.limitBarSecond)) {
          detach(this.limitBarSecond);
        }
      }
    };
    Slider2.prototype.getPersistData = function() {
      var keyEntity = ["value"];
      return this.addOnPersist(keyEntity);
    };
    Slider2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.unwireEvents();
      (undefined).removeEventListener("resize", this.onresize);
      removeClass([this.sliderContainer], [classNames$1.sliderDisabled]);
      this.firstHandle.removeAttribute("aria-orientation");
      if (this.type === "Range") {
        this.secondHandle.removeAttribute("aria-orientation");
      }
      if (this.sliderContainer.parentNode) {
        this.sliderContainer.parentNode.insertBefore(this.element, this.sliderContainer);
      }
      detach(this.sliderContainer);
      if (this.tooltip.isVisible) {
        this.tooltipObj.destroy();
      }
      this.element.innerHTML = "";
      this.hiddenInput = null;
      this.sliderContainer = null;
      this.sliderTrack = null;
      this.rangeBar = null;
      this.firstHandle = null;
      this.secondHandle = null;
      this.tickElementCollection = null;
      this.ul = null;
      this.firstBtn = null;
      this.secondBtn = null;
      this.materialHandle = null;
      this.tooltipObj = null;
      this.tooltipTarget = null;
      this.limitBarFirst = null;
      this.limitBarSecond = null;
      this.firstChild = null;
      this.lastChild = null;
      this.tooltipElement = null;
    };
    Slider2.prototype.onPropertyChanged = function(newProp, oldProp) {
      var _this = this;
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "cssClass":
            this.setCSSClass(oldProp.cssClass);
            break;
          case "value":
            if (newProp && oldProp) {
              var value = isNullOrUndefined(newProp.value) ? this.type === "Range" ? [this.min, this.max] : this.min : newProp.value;
              this.setProperties({ "value": value }, true);
              if (!isNullOrUndefined(oldProp.value) && oldProp.value.toString() !== value.toString()) {
                this.setValue();
                this.refreshTooltip(this.tooltipTarget);
                if (this.type === "Range") {
                  if (isNullOrUndefined(newProp.value) || oldProp.value[1] === value[1]) {
                    this.activeHandle = 1;
                  } else {
                    this.activeHandle = 2;
                  }
                }
              }
            }
            break;
          case "min":
          case "step":
          case "max":
            this.setMinMaxValue();
            break;
          case "tooltip":
            if (!isNullOrUndefined(newProp.tooltip) && !isNullOrUndefined(oldProp.tooltip)) {
              this.initialTooltip = true;
              this.setTooltip(prop);
              if (!this.showButtons) {
                this.wireEvents();
              }
            }
            break;
          case "type":
            if (!isNullOrUndefined(oldProp) && Object.keys(oldProp).length && !isNullOrUndefined(oldProp.type)) {
              this.changeSliderType(oldProp.type, prop);
              this.setZindex();
            }
            break;
          case "enableRtl":
            if (oldProp.enableRtl !== newProp.enableRtl && this.orientation !== "Vertical") {
              this.rtl = oldProp.enableRtl;
              this.changeRtl();
            }
            break;
          case "limits":
            this.limitsPropertyChange();
            break;
          case "orientation":
            this.changeOrientation();
            break;
          case "ticks":
            if (!isNullOrUndefined(this.sliderContainer.querySelector("." + classNames$1.scale))) {
              detach(this.ul);
              Array.prototype.forEach.call(this.sliderContainer.classList, function(className) {
                if (className.match(/e-scale-/)) {
                  _this.sliderContainer.classList.remove(className);
                }
              });
            }
            if (this.ticks.placement !== "None") {
              this.renderScale();
              this.setZindex();
            }
            break;
          case "locale":
            if (this.showButtons) {
              this.buttonTitle();
            }
            break;
          case "showButtons":
            if (newProp.showButtons) {
              this.setButtons();
              this.reposition();
              if (this.enabled && !this.readonly) {
                this.wireButtonEvt(false);
              }
            } else {
              if (this.firstBtn && this.secondBtn) {
                this.sliderContainer.removeChild(this.firstBtn);
                this.sliderContainer.removeChild(this.secondBtn);
                this.sliderContainer.classList.remove(classNames$1.sliderButtonClass);
                this.firstBtn = undefined;
                this.secondBtn = undefined;
                this.reposition();
              }
            }
            break;
          case "enabled":
            this.setEnabled();
            break;
          case "readonly":
            this.setReadOnly();
            break;
          case "customValues":
            this.setValue();
            this.reposition();
            break;
          case "colorRange":
            this.reposition();
            break;
          case "width":
            this.setElementWidth(newProp.width);
            this.setMinMaxValue();
            if (this.limits) {
              this.limitsPropertyChange();
            }
            break;
        }
      }
    };
    Slider2.prototype.setReadOnly = function() {
      if (this.readonly) {
        this.unwireEvents();
        this.sliderContainer.classList.add(classNames$1.readonly);
      } else {
        this.wireEvents();
        this.sliderContainer.classList.remove(classNames$1.readonly);
      }
    };
    Slider2.prototype.setMinMaxValue = function() {
      var _this = this;
      this.setValue();
      this.refreshTooltip(this.tooltipTarget);
      if (!isNullOrUndefined(this.sliderContainer.querySelector("." + classNames$1.scale))) {
        if (this.ul) {
          detach(this.ul);
          Array.prototype.forEach.call(this.sliderContainer.classList, function(className) {
            if (className.match(/e-scale-/)) {
              _this.sliderContainer.classList.remove(className);
            }
          });
        }
      }
      if (this.ticks.placement !== "None") {
        this.renderScale();
        this.setZindex();
      }
    };
    Slider2.prototype.setZindex = function() {
      this.zIndex = 6;
      if (!isNullOrUndefined(this.ticks) && this.ticks.placement !== "None" && !isNullOrUndefined(this.ul) && !isNullOrUndefined(this.element)) {
        this.ul.style.zIndex = this.zIndex + -7 + "";
        this.element.style.zIndex = this.zIndex + 2 + "";
      }
      if (!this.isMaterial && !this.isMaterial3 && !isNullOrUndefined(this.ticks) && this.ticks.placement === "Both") {
        this.element.style.zIndex = this.zIndex + 2 + "";
      }
      if (!isNullOrUndefined(this.firstHandle)) {
        this.firstHandle.style.zIndex = this.zIndex + 3 + "";
      }
      if (this.type === "Range" && !isNullOrUndefined(this.secondHandle)) {
        this.secondHandle.style.zIndex = this.zIndex + 4 + "";
      }
    };
    Slider2.prototype.setTooltip = function(args) {
      this.changeSliderType(this.type, args);
    };
    Slider2.prototype.setBarColor = function() {
      var trackPosition;
      var trackClassName;
      var child = this.sliderTrack.lastElementChild;
      while (child) {
        this.sliderTrack.removeChild(child);
        child = this.sliderTrack.lastElementChild;
      }
      for (var i = 0; i < this.colorRange.length; i++) {
        if (!isNullOrUndefined(this.colorRange[i].start) && !isNullOrUndefined(this.colorRange[i].end)) {
          if (this.colorRange[i].end > this.colorRange[i].start) {
            if (this.colorRange[i].start < this.min) {
              this.colorRange[i].start = this.min;
            }
            if (this.colorRange[i].end > this.max) {
              this.colorRange[i].end = this.max;
            }
            var startingPosition = this.checkHandlePosition(this.colorRange[i].start);
            var endPosition = this.checkHandlePosition(this.colorRange[i].end);
            var trackContainer = this.createElement("div");
            trackContainer.style.backgroundColor = this.colorRange[i].color;
            trackContainer.style.border = "1px solid " + this.colorRange[i].color;
            if (this.orientation === "Horizontal") {
              trackClassName = classNames$1.sliderHorizantalColor;
              if (this.enableRtl) {
                if (isNullOrUndefined(this.customValues)) {
                  trackPosition = this.checkHandlePosition(this.max) - this.checkHandlePosition(this.colorRange[i].end);
                } else {
                  trackPosition = this.checkHandlePosition(this.customValues.length - this.colorRange[i].end - 1);
                }
              } else {
                trackPosition = this.checkHandlePosition(this.colorRange[i].start);
              }
              trackContainer.style.width = endPosition - startingPosition + "px";
              trackContainer.style.left = trackPosition + "px";
            } else {
              trackClassName = classNames$1.sliderVerticalColor;
              trackPosition = this.checkHandlePosition(this.colorRange[i].start);
              trackContainer.style.height = endPosition - startingPosition + "px";
              trackContainer.style.bottom = trackPosition + "px";
            }
            trackContainer.classList.add(trackClassName);
            this.sliderTrack.appendChild(trackContainer);
          }
        }
      }
    };
    Slider2.prototype.getModuleName = function() {
      return "slider";
    };
    __decorate$a([
      Property(null)
    ], Slider2.prototype, "value", undefined);
    __decorate$a([
      Property(null)
    ], Slider2.prototype, "customValues", undefined);
    __decorate$a([
      Property(1)
    ], Slider2.prototype, "step", undefined);
    __decorate$a([
      Property(null)
    ], Slider2.prototype, "width", undefined);
    __decorate$a([
      Property(0)
    ], Slider2.prototype, "min", undefined);
    __decorate$a([
      Property(100)
    ], Slider2.prototype, "max", undefined);
    __decorate$a([
      Property(false)
    ], Slider2.prototype, "readonly", undefined);
    __decorate$a([
      Property("Default")
    ], Slider2.prototype, "type", undefined);
    __decorate$a([
      Collection([{}], ColorRangeData)
    ], Slider2.prototype, "colorRange", undefined);
    __decorate$a([
      Complex({}, TicksData)
    ], Slider2.prototype, "ticks", undefined);
    __decorate$a([
      Complex({}, LimitData)
    ], Slider2.prototype, "limits", undefined);
    __decorate$a([
      Property(true)
    ], Slider2.prototype, "enabled", undefined);
    __decorate$a([
      Complex({}, TooltipData)
    ], Slider2.prototype, "tooltip", undefined);
    __decorate$a([
      Property(false)
    ], Slider2.prototype, "showButtons", undefined);
    __decorate$a([
      Property(true)
    ], Slider2.prototype, "enableAnimation", undefined);
    __decorate$a([
      Property("Horizontal")
    ], Slider2.prototype, "orientation", undefined);
    __decorate$a([
      Property("")
    ], Slider2.prototype, "cssClass", undefined);
    __decorate$a([
      Property(true)
    ], Slider2.prototype, "enableHtmlSanitizer", undefined);
    __decorate$a([
      Event()
    ], Slider2.prototype, "created", undefined);
    __decorate$a([
      Event()
    ], Slider2.prototype, "change", undefined);
    __decorate$a([
      Event()
    ], Slider2.prototype, "changed", undefined);
    __decorate$a([
      Event()
    ], Slider2.prototype, "renderingTicks", undefined);
    __decorate$a([
      Event()
    ], Slider2.prototype, "renderedTicks", undefined);
    __decorate$a([
      Event()
    ], Slider2.prototype, "tooltipChange", undefined);
    Slider2 = __decorate$a([
      NotifyPropertyChanges
    ], Slider2);
    return Slider2;
  }(Component)
);
var __extends$9 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate$9 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CONTROL_WRAPPER = "e-upload e-control-wrapper";
var INPUT_WRAPPER = "e-file-select";
var DROP_AREA = "e-file-drop";
var DROP_WRAPPER = "e-file-select-wrap";
var LIST_PARENT = "e-upload-files";
var FILE = "e-upload-file-list";
var STATUS = "e-file-status";
var ACTION_BUTTONS = "e-upload-actions";
var UPLOAD_BUTTONS = "e-file-upload-btn e-css e-btn e-flat e-primary";
var CLEAR_BUTTONS = "e-file-clear-btn e-css e-btn e-flat";
var FILE_NAME = "e-file-name";
var FILE_TYPE = "e-file-type";
var FILE_SIZE = "e-file-size";
var REMOVE_ICON = "e-file-remove-btn";
var DELETE_ICON = "e-file-delete-btn";
var SPINNER_PANE = "e-spinner-pane";
var ABORT_ICON = "e-file-abort-btn";
var RETRY_ICON = "e-file-reload-btn";
var DRAG_HOVER = "e-upload-drag-hover";
var PROGRESS_WRAPPER = "e-upload-progress-wrap";
var PROGRESSBAR = "e-upload-progress-bar";
var PROGRESSBAR_TEXT = "e-progress-bar-text";
var UPLOAD_INPROGRESS = "e-upload-progress";
var UPLOAD_SUCCESS = "e-upload-success";
var UPLOAD_FAILED = "e-upload-fails";
var TEXT_CONTAINER = "e-file-container";
var VALIDATION_FAILS = "e-validation-fails";
var RTL$2 = "e-rtl";
var DISABLED$1 = "e-disabled";
var RTL_CONTAINER = "e-rtl-container";
var ICON_FOCUSED = "e-clear-icon-focus";
var PROGRESS_INNER_WRAPPER = "e-progress-inner-wrap";
var PAUSE_UPLOAD = "e-file-pause-btn";
var RESUME_UPLOAD = "e-file-play-btn";
var RESTRICT_RETRY = "e-restrict-retry";
var wrapperAttr = ["title", "style", "class"];
var FORM_UPLOAD = "e-form-upload";
var HIDDEN_INPUT = "e-hidden-file-input";
var INVALID_FILE = "e-file-invalid";
var INFORMATION = "e-file-information";
var FilesProp = (
  /** @class */
  function(_super) {
    __extends$9(FilesProp2, _super);
    function FilesProp2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$9([
      Property("")
    ], FilesProp2.prototype, "name", undefined);
    __decorate$9([
      Property(null)
    ], FilesProp2.prototype, "size", undefined);
    __decorate$9([
      Property("")
    ], FilesProp2.prototype, "type", undefined);
    return FilesProp2;
  }(ChildProperty)
);
var ButtonsProps = (
  /** @class */
  function(_super) {
    __extends$9(ButtonsProps2, _super);
    function ButtonsProps2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$9([
      Property("Browse...")
    ], ButtonsProps2.prototype, "browse", undefined);
    __decorate$9([
      Property("Upload")
    ], ButtonsProps2.prototype, "upload", undefined);
    __decorate$9([
      Property("Clear")
    ], ButtonsProps2.prototype, "clear", undefined);
    return ButtonsProps2;
  }(ChildProperty)
);
var AsyncSettings = (
  /** @class */
  function(_super) {
    __extends$9(AsyncSettings2, _super);
    function AsyncSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$9([
      Property("")
    ], AsyncSettings2.prototype, "saveUrl", undefined);
    __decorate$9([
      Property("")
    ], AsyncSettings2.prototype, "removeUrl", undefined);
    __decorate$9([
      Property(0)
    ], AsyncSettings2.prototype, "chunkSize", undefined);
    __decorate$9([
      Property(3)
    ], AsyncSettings2.prototype, "retryCount", undefined);
    __decorate$9([
      Property(500)
    ], AsyncSettings2.prototype, "retryAfterDelay", undefined);
    return AsyncSettings2;
  }(ChildProperty)
);
var Uploader = (
  /** @class */
  function(_super) {
    __extends$9(Uploader2, _super);
    function Uploader2(options, element2) {
      var _this = _super.call(this, options, element2) || this;
      _this.initialAttr = { accept: null, multiple: false, disabled: false };
      _this.uploadedFilesData = [];
      _this.base64String = [];
      _this.isForm = false;
      _this.allTypes = false;
      _this.pausedData = [];
      _this.uploadMetaData = [];
      _this.tabIndex = "0";
      _this.btnTabIndex = "0";
      _this.disableKeyboardNavigation = false;
      _this.count = -1;
      _this.actionCompleteCount = 0;
      _this.flag = true;
      _this.selectedFiles = [];
      _this.uploaderName = "UploadFiles";
      _this.fileStreams = [];
      _this.newFileRef = 0;
      _this.isFirstFileOnSelection = false;
      _this.dragCounter = 0;
      _this.fileList = [];
      _this.filesData = [];
      _this.uploaderOptions = options;
      return _this;
    }
    Uploader2.prototype.onPropertyChanged = function(newProp, oldProp) {
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "allowedExtensions":
            this.setExtensions(this.allowedExtensions);
            this.clearAll();
            break;
          case "enabled":
            this.setControlStatus();
            break;
          case "multiple":
            this.setMultipleSelection();
            break;
          case "enableRtl":
            this.setRTL();
            this.reRenderFileList();
            break;
          case "buttons":
            this.buttons.browse = isNullOrUndefined(this.buttons.browse) ? "" : this.buttons.browse;
            this.buttons.clear = isNullOrUndefined(this.buttons.clear) ? "" : this.buttons.clear;
            this.buttons.upload = isNullOrUndefined(this.buttons.upload) ? "" : this.buttons.upload;
            this.renderButtonTemplates();
            break;
          case "dropArea":
            this.unBindDropEvents();
            this.updateDropArea();
            break;
          case "htmlAttributes":
            this.updateHTMLAttrToElement();
            this.updateHTMLAttrToWrapper();
            this.checkHTMLAttributes(true);
            break;
          case "files":
            this.renderPreLoadFiles();
            break;
          case "directoryUpload":
            this.updateDirectoryAttributes();
            break;
          case "template":
            if (this.isReact) {
              this.reRenderFileList();
            } else {
              this.clearAll();
            }
            break;
          case "minFileSize":
          case "maxFileSize":
          case "autoUpload":
            this.clearAll();
            break;
          case "sequentialUpload":
            this.clearAll();
            break;
          case "locale":
            this.l10n.setLocale(this.locale);
            this.setLocalizedTexts();
            this.preLocaleObj = getValue("currentLocale", this.l10n);
            break;
          case "cssClass":
            this.setCSSClass(oldProp.cssClass);
            break;
        }
      }
    };
    Uploader2.prototype.setLocalizedTexts = function() {
      if (isNullOrUndefined(this.template)) {
        if (typeof this.buttons.browse === "string") {
          this.browseButton.innerText = this.buttons.browse === "Browse..." ? this.localizedTexts("Browse") : this.buttons.browse;
          this.browseButton.setAttribute("title", this.browseButton.innerText);
          if (this.uploadWrapper && !isNullOrUndefined(this.uploadWrapper.querySelector("." + DROP_AREA))) {
            this.uploadWrapper.querySelector("." + DROP_AREA).innerHTML = this.localizedTexts("dropFilesHint");
          }
        }
        this.updateFileList();
      }
    };
    Uploader2.prototype.getKeyValue = function(val) {
      var keyValue;
      for (var _i = 0, _a = Object.keys(this.preLocaleObj); _i < _a.length; _i++) {
        var key = _a[_i];
        if (this.preLocaleObj["" + key] === val) {
          keyValue = key;
        }
      }
      return keyValue;
    };
    Uploader2.prototype.updateFileList = function() {
      var element2;
      if (this.fileList.length > 0 && !isNullOrUndefined(this.uploadWrapper.querySelector("." + LIST_PARENT))) {
        for (var i = 0; i < this.fileList.length; i++) {
          element2 = this.fileList[i].querySelector(".e-file-status");
          element2.innerHTML = this.localizedTexts(this.getKeyValue(this.filesData[i].status));
          this.filesData[i].status = this.localizedTexts(this.getKeyValue(this.filesData[i].status));
          if (this.fileList[i].classList.contains(UPLOAD_SUCCESS)) {
            this.fileList[i].querySelector(".e-icons").setAttribute("title", this.localizedTexts("delete"));
          }
          if (this.fileList[i].querySelector(".e-file-play-btn")) {
            this.fileList[i].querySelector(".e-icons").setAttribute("title", this.localizedTexts("resume"));
          }
          if (this.fileList[i].querySelector(".e-file-remove-btn")) {
            this.fileList[i].querySelector(".e-icons").setAttribute("title", this.localizedTexts("remove"));
          }
          if (this.fileList[i].querySelector(".e-file-reload-btn")) {
            this.fileList[i].querySelector(".e-icons").setAttribute("title", this.localizedTexts("retry"));
          }
          if (!this.autoUpload) {
            this.uploadButton.innerText = this.buttons.upload === "Upload" ? this.localizedTexts("Upload") : this.buttons.upload;
            this.uploadButton.setAttribute("title", this.localizedTexts("Upload"));
            this.clearButton.innerText = this.buttons.clear === "Clear" ? this.localizedTexts("Clear") : this.buttons.clear;
            this.clearButton.setAttribute("title", this.localizedTexts("Clear"));
          }
        }
      }
    };
    Uploader2.prototype.reRenderFileList = function() {
      if (this.listParent) {
        detach(this.listParent);
        this.listParent = null;
        this.fileList = [];
        this.internalCreateFileList(this.filesData);
        if (this.actionButtons) {
          this.removeActionButtons();
          this.renderActionButtons();
          this.checkActionButtonStatus();
        }
      }
    };
    Uploader2.prototype.preRender = function() {
      this.localeText = {
        Browse: "Browse...",
        Clear: "Clear",
        Upload: "Upload",
        invalidFileName: "File Name is not allowed",
        dropFilesHint: "Or drop files here",
        invalidMaxFileSize: "File size is too large",
        invalidMinFileSize: "File size is too small",
        invalidFileType: "File type is not allowed",
        uploadFailedMessage: "File failed to upload",
        uploadSuccessMessage: "File uploaded successfully",
        removedSuccessMessage: "File removed successfully",
        removedFailedMessage: "Unable to remove file",
        inProgress: "Uploading",
        readyToUploadMessage: "Ready to upload",
        abort: "Abort",
        remove: "Remove",
        cancel: "Cancel",
        delete: "Delete file",
        pauseUpload: "File upload paused",
        pause: "Pause",
        resume: "Resume",
        retry: "Retry",
        fileUploadCancel: "File upload canceled",
        invalidFileSelection: "Invalid files selected",
        totalFiles: "Total files",
        size: "Size"
      };
      this.l10n = new L10n("uploader", this.localeText, this.locale);
      this.preLocaleObj = getValue("currentLocale", this.l10n);
      this.formRendered();
      this.updateHTMLAttrToElement();
      this.checkHTMLAttributes(false);
      var ejInstance = getValue("ej2_instances", this.element);
      if (this.element.tagName === "EJS-UPLOADER") {
        var inputElement = this.createElement("input", { attrs: { type: "file" } });
        var index = 0;
        for (index; index < this.element.attributes.length; index++) {
          if (this.element.attributes[index].nodeName !== "id") {
            inputElement.setAttribute(this.element.attributes[index].nodeName, this.element.attributes[index].nodeValue);
          } else if (this.element.attributes[index].nodeName === "id") {
            inputElement.setAttribute(this.element.attributes[index].nodeName, getUniqueID("uploader"));
          }
          inputElement.innerHTML = this.element.innerHTML;
        }
        if (!inputElement.hasAttribute("name")) {
          inputElement.setAttribute("name", "UploadFiles");
        }
        this.element.appendChild(inputElement);
        this.element = inputElement;
        setValue("ej2_instances", ejInstance, this.element);
      }
      if (ejInstance[0].isPureReactComponent) {
        if (!isNullOrUndefined(ejInstance[0].props.name)) {
          this.element.setAttribute("name", ejInstance[0].props.name);
        } else if (!isNullOrUndefined(ejInstance[0].props.id) && isNullOrUndefined(ejInstance[0].props.name)) {
          this.element.setAttribute("name", ejInstance[0].props.id);
        } else {
          this.element.setAttribute("name", "UploadFiles");
        }
      }
      if (isNullOrUndefined(this.element.getAttribute("name"))) {
        this.element.setAttribute("name", this.element.getAttribute("id"));
      }
      if (!this.element.hasAttribute("type")) {
        this.element.setAttribute("type", "file");
      }
      this.updateDirectoryAttributes();
      this.keyConfigs = {
        enter: "enter"
      };
      if (this.element.hasAttribute("tabindex")) {
        this.tabIndex = this.element.getAttribute("tabindex");
      }
      this.browserName = Browser.info.name;
      this.uploaderName = this.element.getAttribute("name");
    };
    Uploader2.prototype.formRendered = function() {
      var parentEle = closest(this.element, "form");
      if (!isNullOrUndefined(parentEle)) {
        for (; parentEle && parentEle !== (undefined).documentElement; parentEle = parentEle.parentElement) {
          if (parentEle.tagName === "FORM") {
            this.isForm = true;
            this.formElement = parentEle;
            parentEle.setAttribute("enctype", "multipart/form-data");
            parentEle.setAttribute("encoding", "multipart/form-data");
          }
        }
      }
    };
    Uploader2.prototype.getPersistData = function() {
      return this.addOnPersist(["filesData"]);
    };
    Uploader2.prototype.getModuleName = function() {
      return "uploader";
    };
    Uploader2.prototype.updateDirectoryAttributes = function() {
      if (this.directoryUpload) {
        this.element.setAttribute("directory", "true");
        this.element.setAttribute("webkitdirectory", "true");
      } else {
        this.element.removeAttribute("directory");
        this.element.removeAttribute("webkitdirectory");
      }
    };
    Uploader2.prototype.render = function() {
      this.renderBrowseButton();
      this.initializeUpload();
      this.updateHTMLAttrToWrapper();
      this.wireEvents();
      this.setMultipleSelection();
      this.setExtensions(this.allowedExtensions);
      this.setRTL();
      this.renderPreLoadFiles();
      this.setControlStatus();
      this.setCSSClass();
    };
    Uploader2.prototype.renderBrowseButton = function() {
      this.browseButton = this.createElement("button", { className: "e-css e-btn", attrs: { "type": "button" } });
      this.browseButton.setAttribute("tabindex", this.tabIndex);
      if (typeof this.buttons.browse === "string") {
        this.browseButton.textContent = this.buttons.browse === "Browse..." ? this.localizedTexts("Browse") : this.buttons.browse;
        this.browseButton.setAttribute("title", this.browseButton.innerText);
      } else {
        this.browseButton.appendChild(this.buttons.browse);
      }
      this.element.setAttribute("aria-label", "Uploader");
    };
    Uploader2.prototype.renderActionButtons = function() {
      this.element.setAttribute("tabindex", "-1");
      this.actionButtons = this.createElement("div", { className: ACTION_BUTTONS });
      this.uploadButton = this.createElement("button", {
        className: UPLOAD_BUTTONS,
        attrs: { "type": "button", "tabindex": this.btnTabIndex, "aria-label": this.localizedTexts("Upload") }
      });
      this.clearButton = this.createElement("button", {
        className: CLEAR_BUTTONS,
        attrs: { "type": "button", "tabindex": this.btnTabIndex, "aria-label": this.localizedTexts("Clear") }
      });
      this.actionButtons.appendChild(this.clearButton);
      this.actionButtons.appendChild(this.uploadButton);
      this.renderButtonTemplates();
      this.uploadWrapper.appendChild(this.actionButtons);
      this.browseButton.blur();
      if (!this.isPreloadFiles) {
        this.uploadButton.focus();
      }
      this.wireActionButtonEvents();
    };
    Uploader2.prototype.serverActionButtonsEventBind = function(element2) {
      if (element2 && !this.isForm) {
        this.browseButton.blur();
        this.actionButtons = element2;
        this.uploadButton = this.actionButtons.querySelector(".e-file-upload-btn");
        this.clearButton = this.actionButtons.querySelector(".e-file-clear-btn");
        this.uploadButton.focus();
        this.unwireActionButtonEvents();
        this.wireActionButtonEvents();
        this.checkActionButtonStatus();
      }
    };
    Uploader2.prototype.wireActionButtonEvents = function() {
      EventHandler.add(this.uploadButton, "click", this.uploadButtonClick, this);
      EventHandler.add(this.clearButton, "click", this.clearButtonClick, this);
    };
    Uploader2.prototype.unwireActionButtonEvents = function() {
      EventHandler.remove(this.uploadButton, "click", this.uploadButtonClick);
      EventHandler.remove(this.clearButton, "click", this.clearButtonClick);
    };
    Uploader2.prototype.removeActionButtons = function() {
      if (this.actionButtons) {
        this.unwireActionButtonEvents();
        detach(this.actionButtons);
        this.actionButtons = null;
      }
    };
    Uploader2.prototype.renderButtonTemplates = function() {
      if (typeof this.buttons.browse === "string") {
        this.browseButton.textContent = this.buttons.browse === "Browse..." ? this.localizedTexts("Browse") : this.buttons.browse;
        this.browseButton.setAttribute("title", this.browseButton.textContent);
      } else {
        this.browseButton.innerHTML = "";
        this.browseButton.appendChild(this.buttons.browse);
      }
      if (this.uploadButton) {
        var uploadText = isNullOrUndefined(this.buttons.upload) ? "Upload" : this.buttons.upload;
        this.buttons.upload = uploadText;
        if (typeof this.buttons.upload === "string") {
          this.uploadButton.textContent = this.buttons.upload === "Upload" ? this.localizedTexts("Upload") : this.buttons.upload;
          this.uploadButton.setAttribute("title", this.uploadButton.textContent);
        } else {
          this.uploadButton.innerHTML = "";
          this.uploadButton.appendChild(this.buttons.upload);
        }
      }
      if (this.clearButton) {
        var clearText = isNullOrUndefined(this.buttons.clear) ? "Clear" : this.buttons.clear;
        this.buttons.clear = clearText;
        if (typeof this.buttons.clear === "string") {
          this.clearButton.textContent = this.buttons.clear === "Clear" ? this.localizedTexts("Clear") : this.buttons.clear;
          this.clearButton.setAttribute("title", this.clearButton.textContent);
        } else {
          this.clearButton.innerHTML = "";
          this.clearButton.appendChild(this.buttons.clear);
        }
      }
    };
    Uploader2.prototype.initializeUpload = function() {
      this.element.setAttribute("tabindex", "-1");
      var inputWrapper = this.createElement("span", { className: INPUT_WRAPPER });
      this.element.parentElement.insertBefore(inputWrapper, this.element);
      this.dropAreaWrapper = this.createElement("div", { className: DROP_WRAPPER });
      this.element.parentElement.insertBefore(this.dropAreaWrapper, this.element);
      inputWrapper.appendChild(this.element);
      this.dropAreaWrapper.appendChild(this.browseButton);
      this.dropAreaWrapper.appendChild(inputWrapper);
      this.uploadWrapper = this.createElement("div", { className: CONTROL_WRAPPER });
      this.dropAreaWrapper.parentElement.insertBefore(this.uploadWrapper, this.dropAreaWrapper);
      this.uploadWrapper.appendChild(this.dropAreaWrapper);
      this.setDropArea();
    };
    Uploader2.prototype.renderPreLoadFiles = function() {
      if (this.files.length) {
        if (this.enablePersistence && this.filesData.length) {
          this.internalCreateFileList(this.filesData);
          return;
        }
        if (isNullOrUndefined(this.files[0].size)) {
          return;
        }
        this.isPreloadFiles = true;
        var files = [].slice.call(this.files);
        var filesData = [];
        if (!this.multiple) {
          this.clearData();
          files = [files[0]];
        }
        for (var _i = 0, files_1 = files; _i < files_1.length; _i++) {
          var data = files_1[_i];
          var fileData = {
            name: data.name + "." + data.type.split(".")[data.type.split(".").length - 1],
            rawFile: "",
            size: data.size,
            status: this.localizedTexts("uploadSuccessMessage"),
            type: data.type,
            validationMessages: { minSize: "", maxSize: "" },
            statusCode: "2"
          };
          filesData.push(fileData);
          this.filesData.push(fileData);
        }
        this.internalCreateFileList(filesData);
        if (!this.autoUpload && this.listParent && !this.actionButtons && (!this.isForm || this.allowUpload()) && this.showFileList) {
          this.renderActionButtons();
        }
        this.checkActionButtonStatus();
        if (this.sequentialUpload) {
          this.count = this.filesData.length - 1;
        }
        this.isPreloadFiles = false;
      }
    };
    Uploader2.prototype.checkActionButtonStatus = function() {
      if (this.actionButtons) {
        var length_1 = this.uploadWrapper.querySelectorAll("." + VALIDATION_FAILS).length + this.uploadWrapper.querySelectorAll(".e-upload-fails:not(.e-upload-progress)").length + this.uploadWrapper.querySelectorAll("span." + UPLOAD_SUCCESS).length + this.uploadWrapper.querySelectorAll("span." + UPLOAD_INPROGRESS).length;
        if (length_1 > 0 && length_1 === this.uploadWrapper.querySelectorAll("li").length) {
          this.uploadButton.setAttribute("disabled", "disabled");
        } else {
          this.uploadButton.removeAttribute("disabled");
        }
      }
    };
    Uploader2.prototype.setDropArea = function() {
      var dropTextArea = this.dropAreaWrapper.querySelector(".e-file-drop");
      if (this.dropArea) {
        this.dropZoneElement = typeof this.dropArea !== "string" ? this.dropArea : select(this.dropArea, undefined);
        var element2 = this.element;
        var enableDropText = false;
        while (element2.parentNode) {
          element2 = element2.parentNode;
          if (element2 === this.dropZoneElement) {
            enableDropText = true;
            if (!dropTextArea) {
              this.createDropTextHint();
            } else {
              dropTextArea.innerHTML = this.localizedTexts("dropFilesHint");
            }
          }
        }
        if (!enableDropText && dropTextArea) {
          remove(dropTextArea);
        }
      } else if (!isNullOrUndefined(this.uploaderOptions) && this.uploaderOptions.dropArea === undefined) {
        this.createDropTextHint();
        this.dropZoneElement = this.uploadWrapper;
        this.setProperties({ dropArea: this.uploadWrapper }, true);
      }
      this.bindDropEvents();
    };
    Uploader2.prototype.updateDropArea = function() {
      if (this.dropArea) {
        this.setDropArea();
      } else {
        this.dropZoneElement = null;
        var dropTextArea = this.dropAreaWrapper.querySelector(".e-file-drop");
        if (dropTextArea) {
          remove(dropTextArea);
        }
      }
    };
    Uploader2.prototype.createDropTextHint = function() {
      var fileDropArea = this.createElement("span", { className: DROP_AREA });
      fileDropArea.innerHTML = this.localizedTexts("dropFilesHint");
      this.dropAreaWrapper.appendChild(fileDropArea);
    };
    Uploader2.prototype.updateHTMLAttrToElement = function() {
      if (!isNullOrUndefined(this.htmlAttributes)) {
        for (var _i = 0, _a = Object.keys(this.htmlAttributes); _i < _a.length; _i++) {
          var pro = _a[_i];
          if (wrapperAttr.indexOf(pro) < 0) {
            this.element.setAttribute(pro, this.htmlAttributes["" + pro]);
          }
        }
      }
    };
    Uploader2.prototype.updateHTMLAttrToWrapper = function() {
      if (!isNullOrUndefined(this.htmlAttributes)) {
        for (var _i = 0, _a = Object.keys(this.htmlAttributes); _i < _a.length; _i++) {
          var pro = _a[_i];
          if (wrapperAttr.indexOf(pro) > -1) {
            if (pro === "class") {
              var updatedClassValues = this.htmlAttributes["" + pro].replace(/\s+/g, " ").trim();
              if (updatedClassValues !== "") {
                addClass([this.uploadWrapper], updatedClassValues.split(" "));
              }
            } else if (pro === "style") {
              var uploadStyle = this.uploadWrapper.getAttribute(pro);
              uploadStyle = !isNullOrUndefined(uploadStyle) ? uploadStyle + this.htmlAttributes["" + pro] : this.htmlAttributes["" + pro];
              this.uploadWrapper.setAttribute(pro, uploadStyle);
            } else {
              this.uploadWrapper.setAttribute(pro, this.htmlAttributes["" + pro]);
            }
          }
        }
      }
    };
    Uploader2.prototype.setMultipleSelection = function() {
      if (this.multiple && !this.element.hasAttribute("multiple")) {
        var newAttr = (undefined).createAttribute("multiple");
        newAttr.value = "multiple";
        this.element.setAttributeNode(newAttr);
      } else if (!this.multiple) {
        this.element.removeAttribute("multiple");
      }
    };
    Uploader2.prototype.checkAutoUpload = function(fileData) {
      if (this.autoUpload) {
        if (this.sequentialUpload) {
          this.sequenceUpload(fileData);
        } else {
          this.upload(fileData);
        }
        this.removeActionButtons();
      } else if (!this.actionButtons) {
        this.renderActionButtons();
      }
      this.checkActionButtonStatus();
    };
    Uploader2.prototype.sequenceUpload = function(fileData) {
      if (this.filesData.length - fileData.length === 0 || this.filesData[this.filesData.length - fileData.length - 1].statusCode !== "1") {
        if (this.multiple || this.count < 0) {
          ++this.count;
        }
        var isFileListCreated = this.showFileList ? false : true;
        if (typeof this.filesData[this.count] === "object") {
          this.isFirstFileOnSelection = false;
          this.upload(this.filesData[this.count], isFileListCreated);
          if (this.filesData[this.count].statusCode === "0") {
            this.sequenceUpload(fileData);
          }
        } else {
          --this.count;
        }
      }
    };
    Uploader2.prototype.setCSSClass = function(oldCSSClass) {
      var updatedOldCssClass = oldCSSClass;
      if (!isNullOrUndefined(oldCSSClass)) {
        updatedOldCssClass = oldCSSClass.replace(/\s+/g, " ").trim();
      }
      if (!isNullOrUndefined(oldCSSClass) && updatedOldCssClass !== "") {
        removeClass([this.uploadWrapper], updatedOldCssClass.split(" "));
      }
      var updatedCssClassValue = this.cssClass;
      if (!isNullOrUndefined(this.cssClass) && this.cssClass !== "") {
        updatedCssClassValue = this.cssClass.replace(/\s+/g, " ").trim();
      }
      if (!isNullOrUndefined(this.cssClass) && updatedCssClassValue !== "") {
        addClass([this.uploadWrapper], updatedCssClassValue.split(updatedCssClassValue.indexOf(",") > -1 ? "," : " "));
      }
    };
    Uploader2.prototype.wireEvents = function() {
      EventHandler.add(this.browseButton, "click", this.browseButtonClick, this);
      EventHandler.add(this.element, "change", this.onSelectFiles, this);
      EventHandler.add(undefined, "click", this.removeFocus, this);
      this.keyboardModule = new KeyboardEvents(this.uploadWrapper, {
        keyAction: this.keyActionHandler.bind(this),
        keyConfigs: this.keyConfigs,
        eventName: "keydown"
      });
      if (this.isForm) {
        EventHandler.add(this.formElement, "reset", this.resetForm, this);
      }
    };
    Uploader2.prototype.unWireEvents = function() {
      EventHandler.remove(this.browseButton, "click", this.browseButtonClick);
      EventHandler.remove(this.element, "change", this.onSelectFiles);
      EventHandler.remove(undefined, "click", this.removeFocus);
      if (this.isForm) {
        EventHandler.remove(this.formElement, "reset", this.resetForm);
      }
      if (this.keyboardModule) {
        this.keyboardModule.destroy();
      }
    };
    Uploader2.prototype.resetForm = function() {
      this.clearAll();
    };
    Uploader2.prototype.keyActionHandler = function(e) {
      var targetElement2 = e.target;
      switch (e.action) {
        case "enter":
          if (e.target === this.clearButton) {
            this.clearButtonClick();
          } else if (e.target === this.uploadButton) {
            this.uploadButtonClick();
          } else if (e.target === this.browseButton) {
            this.browseButtonClick();
          } else if (targetElement2.classList.contains(PAUSE_UPLOAD)) {
            var metaData = this.getCurrentMetaData(null, e);
            metaData.file.statusCode = "4";
            metaData.file.status = this.localizedTexts("pauseUpload");
            this.abortUpload(metaData, false);
          } else if (targetElement2.classList.contains(RESUME_UPLOAD)) {
            this.resumeUpload(this.getCurrentMetaData(null, e), e);
          } else if (targetElement2.classList.contains(RETRY_ICON)) {
            var metaData = this.getCurrentMetaData(null, e);
            if (!isNullOrUndefined(metaData)) {
              metaData.file.statusCode = "1";
              metaData.file.status = this.localizedTexts("readyToUploadMessage");
              this.chunkUpload(metaData.file);
            } else {
              var target = e.target.parentElement;
              var fileData = this.filesData[this.fileList.indexOf(target)];
              this.retry(fileData);
            }
          } else {
            this.removeFiles(e);
            if (!targetElement2.classList.contains(ABORT_ICON)) {
              this.browseButton.focus();
            }
          }
          e.preventDefault();
          e.stopPropagation();
          break;
      }
    };
    Uploader2.prototype.getCurrentMetaData = function(fileInfo, e) {
      var fileData;
      var targetMetaData;
      if (isNullOrUndefined(fileInfo)) {
        var target = e.target.parentElement;
        fileData = this.filesData[this.fileList.indexOf(target)];
      } else {
        fileData = fileInfo;
      }
      for (var i = 0; i < this.uploadMetaData.length; i++) {
        if (this.uploadMetaData[i].file.name === fileData.name) {
          targetMetaData = this.uploadMetaData[i];
        }
      }
      return targetMetaData;
    };
    Uploader2.prototype.removeFocus = function() {
      if (this.uploadWrapper && this.listParent && this.listParent.querySelector("." + ICON_FOCUSED)) {
        (undefined).activeElement.blur();
        this.listParent.querySelector("." + ICON_FOCUSED).classList.remove(ICON_FOCUSED);
      }
    };
    Uploader2.prototype.browseButtonClick = function() {
      this.element.click();
    };
    Uploader2.prototype.uploadButtonClick = function() {
      if (this.sequentialUpload) {
        this.sequenceUpload(this.filesData);
      } else {
        this.upload(this.filesData);
      }
    };
    Uploader2.prototype.clearButtonClick = function() {
      this.clearAll();
      if (this.sequentialUpload) {
        this.count = -1;
      }
      this.actionCompleteCount = 0;
    };
    Uploader2.prototype.bindDropEvents = function() {
      if (this.dropZoneElement) {
        EventHandler.add(this.dropZoneElement, "drop", this.dropElement, this);
        EventHandler.add(this.dropZoneElement, "dragover", this.dragHover, this);
        EventHandler.add(this.dropZoneElement, "dragleave", this.onDragLeave, this);
        EventHandler.add(this.dropZoneElement, "paste", this.onPasteFile, this);
        EventHandler.add(this.dropZoneElement, "dragenter", this.onDragEnter, this);
      }
    };
    Uploader2.prototype.unBindDropEvents = function() {
      if (this.dropZoneElement) {
        EventHandler.remove(this.dropZoneElement, "drop", this.dropElement);
        EventHandler.remove(this.dropZoneElement, "dragover", this.dragHover);
        EventHandler.remove(this.dropZoneElement, "dragleave", this.onDragLeave);
        EventHandler.remove(this.dropZoneElement, "dragenter", this.onDragEnter);
      }
    };
    Uploader2.prototype.onDragEnter = function(e) {
      if (!this.enabled) {
        return;
      }
      this.dropZoneElement.classList.add(DRAG_HOVER);
      this.dragCounter = this.dragCounter + 1;
      e.preventDefault();
      e.stopPropagation();
    };
    Uploader2.prototype.onDragLeave = function() {
      if (!this.enabled) {
        return;
      }
      this.dragCounter = this.dragCounter - 1;
      if (!this.dragCounter) {
        this.dropZoneElement.classList.remove(DRAG_HOVER);
      }
    };
    Uploader2.prototype.dragHover = function(e) {
      if (!this.enabled) {
        return;
      }
      if (this.dropEffect !== "Default") {
        e.dataTransfer.dropEffect = this.dropEffect.toLowerCase();
      }
      e.preventDefault();
      e.stopPropagation();
    };
    Uploader2.prototype.dropElement = function(e) {
      this.dragCounter = 0;
      this.dropZoneElement.classList.remove(DRAG_HOVER);
      this.onSelectFiles(e);
      e.preventDefault();
      e.stopPropagation();
    };
    Uploader2.prototype.onPasteFile = function(event) {
      var item = event.clipboardData.items;
      if (event.type === "paste" && this.browserName !== "msie" && this.browserName !== "edge" && this.browserName !== "safari") {
        this.element.files = event.clipboardData.files;
      }
      if (item.length !== 1 && !this.multiple) {
        return;
      }
      for (var file = 0; file < item.length; file++) {
        var pasteFile = [].slice.call(item)[file];
        if (!isNullOrUndefined(pasteFile.getAsFile()) && (pasteFile.kind === "file" || pasteFile.type.match("^image/"))) {
          this.renderSelectedFiles(event, [pasteFile.getAsFile()], false, true);
        }
      }
    };
    Uploader2.prototype.getSelectedFiles = function(index) {
      var data = [];
      var liElement = this.fileList[index];
      var allFiles = this.getFilesData();
      var nameElements = +liElement.getAttribute("data-files-count");
      var startIndex = 0;
      for (var i = 0; i < index; i++) {
        startIndex += +this.fileList[i].getAttribute("data-files-count");
      }
      for (var j = startIndex; j < startIndex + nameElements; j++) {
        data.push(allFiles[j]);
      }
      return data;
    };
    Uploader2.prototype.removeFiles = function(args) {
      if (!this.enabled) {
        return;
      }
      var selectedElement = args.target.parentElement;
      var index = this.fileList.indexOf(selectedElement);
      var liElement = this.fileList[index];
      var formUpload = this.isFormUpload();
      var fileData = formUpload ? this.getSelectedFiles(index) : this.getFilesInArray(this.filesData[index]);
      if (isNullOrUndefined(fileData)) {
        return;
      }
      if (args.target.classList.contains(ABORT_ICON) && !formUpload) {
        fileData[0].statusCode = "5";
        if (!isNullOrUndefined(liElement)) {
          var spinnerTarget = liElement.querySelector("." + ABORT_ICON);
          createSpinner({ target: spinnerTarget, width: "20px" });
          showSpinner(spinnerTarget);
        }
        if (this.sequentialUpload) {
          this.uploadSequential();
        }
        if (!liElement.classList.contains(RESTRICT_RETRY)) {
          this.checkActionComplete(true);
        }
      } else if (!closest(args.target, "." + SPINNER_PANE)) {
        this.remove(fileData, false, false, true, args);
      }
      if (this.isForm && liElement && liElement.classList.contains(INVALID_FILE)) {
        this.element.value = "";
      }
      this.checkActionButtonStatus();
      if (this.actionButtons && this.clearButton && this.uploadWrapper) {
        var progressBarElements = this.uploadWrapper.querySelectorAll(".e-upload-progress-bar.e-upload-progress:not(.e-upload-success):not(.e-upload-fails)");
        if (progressBarElements.length === 1 && selectedElement.contains(progressBarElements[0]) && this.clearButton.hasAttribute("disabled")) {
          this.clearButton.removeAttribute("disabled");
        }
      }
    };
    Uploader2.prototype.removeFilesData = function(file, customTemplate) {
      var index;
      if (customTemplate) {
        if (!this.showFileList) {
          index = this.filesData.indexOf(file);
          this.filesData.splice(index, 1);
        }
        return;
      }
      var selectedElement = this.getLiElement(file);
      if (isNullOrUndefined(selectedElement)) {
        return;
      }
      this.element.value = "";
      detach(selectedElement);
      index = this.fileList.indexOf(selectedElement);
      this.fileList.splice(index, 1);
      this.filesData.splice(index, 1);
      if (this.fileList.length === 0 && !isNullOrUndefined(this.listParent)) {
        detach(this.listParent);
        this.listParent = null;
        this.removeActionButtons();
      }
      if (this.sequentialUpload) {
        if (index <= this.count) {
          --this.count;
        }
      }
    };
    Uploader2.prototype.removeUploadedFile = function(file, eventArgs, removeDirectly, custom) {
      var _this = this;
      var selectedFiles = file;
      var ajax = new Ajax(this.asyncSettings.removeUrl, "POST", true, null);
      ajax.emitError = false;
      var formData = new FormData();
      ajax.beforeSend = function(e) {
        eventArgs.currentRequest = ajax.httpRequest;
        if (!removeDirectly) {
          _this.trigger("removing", eventArgs, function(eventArgs2) {
            if (eventArgs2.cancel) {
              e.cancel = true;
            } else {
              _this.removingEventCallback(eventArgs2, formData, selectedFiles, file);
            }
          });
        } else {
          _this.removingEventCallback(eventArgs, formData, selectedFiles, file);
        }
      };
      ajax.onLoad = function(e) {
        _this.removeCompleted(e, selectedFiles, custom);
        return {};
      };
      ajax.onError = function(e) {
        _this.removeFailed(e, selectedFiles, custom);
        return {};
      };
      ajax.send(formData);
    };
    Uploader2.prototype.removingEventCallback = function(eventArgs, formData, selectedFiles, file) {
      var name = this.element.getAttribute("name");
      var liElement = this.getLiElement(file);
      if (!isNullOrUndefined(liElement) && (!isNullOrUndefined(liElement.querySelector("." + DELETE_ICON)) || !isNullOrUndefined(liElement.querySelector("." + REMOVE_ICON)))) {
        var spinnerTarget = liElement.querySelector("." + DELETE_ICON) ? liElement.querySelector("." + DELETE_ICON) : liElement.querySelector("." + REMOVE_ICON);
        createSpinner({ target: spinnerTarget, width: "20px" });
        showSpinner(spinnerTarget);
      }
      if (eventArgs.postRawFile && !isNullOrUndefined(selectedFiles.rawFile) && selectedFiles.rawFile !== "") {
        formData.append(name, selectedFiles.rawFile, selectedFiles.name);
      } else {
        formData.append(name, selectedFiles.name);
      }
      this.updateFormData(formData, eventArgs.customFormData);
    };
    Uploader2.prototype.updateFormData = function(formData, customData) {
      if (customData.length > 0 && customData[0]) {
        var _loop_1 = function(i2) {
          var data = customData[i2];
          var value = Object.keys(data).map(function(e) {
            return data["" + e];
          });
          formData.append(Object.keys(data)[0], value);
        };
        for (var i = 0; i < customData.length; i++) {
          _loop_1(i);
        }
      }
    };
    Uploader2.prototype.updateCustomheader = function(request, currentRequest) {
      if (currentRequest.length > 0 && currentRequest[0]) {
        var _loop_2 = function(i2) {
          var data = currentRequest[i2];
          var value = Object.keys(data).map(function(e) {
            return data["" + e];
          });
          request.setRequestHeader(Object.keys(data)[0], value);
        };
        for (var i = 0; i < currentRequest.length; i++) {
          _loop_2(i);
        }
      }
    };
    Uploader2.prototype.removeCompleted = function(e, files, customTemplate) {
      var response = e && e.currentTarget ? this.getResponse(e) : null;
      var status = e.target;
      if (status.readyState === 4 && status.status >= 200 && status.status <= 299) {
        var args = {
          e,
          response,
          operation: "remove",
          file: this.updateStatus(files, this.localizedTexts("removedSuccessMessage"), "2")
        };
        this.trigger("success", args);
        this.removeFilesData(files, customTemplate);
        var index = this.uploadedFilesData.indexOf(files);
        this.uploadedFilesData.splice(index, 1);
        this.trigger("change", { files: this.uploadedFilesData });
      } else {
        this.removeFailed(e, files, customTemplate);
      }
    };
    Uploader2.prototype.removeFailed = function(e, files, customTemplate) {
      var response = e && e.currentTarget ? this.getResponse(e) : null;
      var args = {
        e,
        response,
        operation: "remove",
        file: this.updateStatus(files, this.localizedTexts("removedFailedMessage"), "0")
      };
      if (!customTemplate) {
        var index = this.filesData.indexOf(files);
        var rootElement = this.fileList[index];
        if (rootElement) {
          rootElement.classList.remove(UPLOAD_SUCCESS);
          rootElement.classList.add(UPLOAD_FAILED);
          var statusElement = rootElement.querySelector("." + STATUS);
          if (statusElement) {
            statusElement.classList.remove(UPLOAD_SUCCESS);
            statusElement.classList.add(UPLOAD_FAILED);
          }
        }
        this.checkActionButtonStatus();
      }
      this.trigger("failure", args);
      var liElement = this.getLiElement(files);
      if (!isNullOrUndefined(liElement) && !isNullOrUndefined(liElement.querySelector("." + DELETE_ICON))) {
        var spinnerTarget = liElement.querySelector("." + DELETE_ICON);
        hideSpinner(spinnerTarget);
        detach(liElement.querySelector(".e-spinner-pane"));
      }
    };
    Uploader2.prototype.getFilesFromFolder = function(event) {
      this.filesEntries = [];
      var items = this.multiple ? event.dataTransfer.items : [event.dataTransfer.items[0]];
      var validDirectoryUpload = this.checkDirectoryUpload(items);
      if (!validDirectoryUpload) {
        return;
      }
      var _loop_3 = function(i2) {
        var item = items[i2].webkitGetAsEntry();
        if (item.isFile) {
          var files_2 = [];
          item.file(function(fileObj) {
            var path = item.fullPath;
            files_2.push({ "path": path, "file": fileObj });
          });
          this_1.renderSelectedFiles(event, files_2, true);
        } else if (item.isDirectory) {
          this_1.traverseFileTree(item, event);
        }
      };
      var this_1 = this;
      for (var i = 0; i < items.length; i++) {
        _loop_3(i);
      }
    };
    Uploader2.prototype.checkDirectoryUpload = function(items) {
      for (var i = 0; items && i < items.length; i++) {
        var item = items[i].webkitGetAsEntry();
        if (item.isDirectory) {
          return true;
        }
      }
      return false;
    };
    Uploader2.prototype.traverseFileTree = function(item, event) {
      if (item.isFile) {
        this.filesEntries.push(item);
      } else if (item.isDirectory) {
        var directoryReader = item.createReader();
        this.readFileFromDirectory(directoryReader, event);
      }
    };
    Uploader2.prototype.readFileFromDirectory = function(directoryReader, event) {
      var _this = this;
      directoryReader.readEntries(function(entries) {
        for (var i = 0; i < entries.length; i++) {
          _this.traverseFileTree(entries[i], event);
        }
        _this.pushFilesEntries(event);
        if (entries.length) {
          _this.readFileFromDirectory(directoryReader);
        }
      });
    };
    Uploader2.prototype.pushFilesEntries = function(event) {
      var _this = this;
      var files = [];
      var _loop_4 = function(i2) {
        this_2.filesEntries[i2].file(function(fileObj) {
          if (_this.filesEntries.length) {
            var path = _this.filesEntries[i2].fullPath;
            files.push({ "path": path, "file": fileObj });
            if (i2 === _this.filesEntries.length - 1) {
              _this.filesEntries = [];
              _this.renderSelectedFiles(event, files, true);
            }
          }
        });
      };
      var this_2 = this;
      for (var i = 0; i < this.filesEntries.length; i++) {
        _loop_4(i);
      }
    };
    Uploader2.prototype.onSelectFiles = function(args) {
      if (!this.enabled) {
        return;
      }
      var targetFiles;
      if (args.type === "drop") {
        if (this.directoryUpload) {
          this.getFilesFromFolder(args);
        } else {
          var files = this.sortFilesList = args.dataTransfer.files;
          if (this.browserName !== "msie" && this.browserName !== "edge" && this.browserName !== "safari") {
            this.element.files = files;
          }
          if (files.length > 0) {
            targetFiles = this.multiple ? this.sortFileList(files) : [files[0]];
            this.renderSelectedFiles(args, targetFiles);
          }
        }
      } else {
        targetFiles = [].slice.call(args.target.files);
        this.renderSelectedFiles(args, targetFiles);
      }
      if (this.isAngular || this.isReact) {
        args.stopPropagation();
      }
    };
    Uploader2.prototype.getBase64 = function(file) {
      return new Promise(function(resolve, reject) {
        var fileReader = new FileReader();
        fileReader.readAsDataURL(file);
        fileReader.onload = function() {
          return resolve(fileReader.result);
        };
        fileReader.onerror = function(error) {
          return reject(error);
        };
      });
    };
    Uploader2.prototype.renderSelectedFiles = function(args, targetFiles, directory, paste) {
      var _this = this;
      this.base64String = [];
      var eventArgs = {
        event: args,
        cancel: false,
        filesData: [],
        isModified: false,
        modifiedFilesData: [],
        progressInterval: "",
        isCanceled: false,
        currentRequest: null,
        customFormData: null
      };
      if (targetFiles.length < 1) {
        eventArgs.isCanceled = true;
        this.trigger("selected", eventArgs);
        return;
      }
      this.flag = true;
      var fileData = [];
      if (!this.multiple) {
        this.clearData(true);
        this.actionCompleteCount = 0;
        targetFiles = [targetFiles[0]];
      }
      for (var i = 0; i < targetFiles.length; i++) {
        var file = directory ? targetFiles[i].file : targetFiles[i];
        this.updateInitialFileDetails(args, targetFiles, file, i, fileData, directory, paste);
      }
      eventArgs.filesData = fileData;
      if (!isNullOrUndefined(this.allowedExtensions) && this.allowedExtensions.indexOf("*") > -1) {
        this.allTypes = true;
      }
      if (this.enableHtmlSanitizer) {
        for (var i = 0; i < fileData.length; i++) {
          var sanitizeFile = SanitizeHtmlHelper.beforeSanitize();
          var sanitizeFileName = SanitizeHtmlHelper.serializeValue(sanitizeFile, fileData[parseInt(i.toString(), 10)].name);
          var currentFileName = fileData[parseInt(i.toString(), 10)].name;
          var isUTF8 = false;
          for (var i_1 = 0; i_1 < currentFileName.length; i_1++) {
            if (currentFileName.charCodeAt(i_1) > 127) {
              isUTF8 = true;
              break;
            }
          }
          var htmlTagRegex = /<([a-z][a-z0-9]*)\b[^>]*>(.*?)<\/\1>/i;
          var hasHTMLString = htmlTagRegex.test(currentFileName);
          if (sanitizeFileName !== fileData[parseInt(i.toString(), 10)].name && !(isUTF8 && !hasHTMLString)) {
            var encodedFileName = targetFiles[parseInt(i.toString(), 10)].name.replace(/[\u00A0-\u9999<>\\&]/g, function(i2) {
              return "&#" + i2.charCodeAt(0) + ";";
            });
            fileData[parseInt(i.toString(), 10)].name = encodedFileName;
            fileData[parseInt(i.toString(), 10)].status = this.localizedTexts("invalidFileName");
            fileData[parseInt(i.toString(), 10)].statusCode = "0";
          }
        }
      }
      if (!this.allTypes) {
        fileData = this.checkExtension(fileData);
      }
      this.trigger("selected", eventArgs, function(eventArgs2) {
        _this._internalRenderSelect(eventArgs2, fileData);
      });
    };
    Uploader2.prototype.updateInitialFileDetails = function(args, targetFiles, file, i, fileData, directory, paste) {
      var fileName = directory ? targetFiles[i].path.substring(1, targetFiles[i].path.length) : paste ? getUniqueID(file.name.substring(0, file.name.lastIndexOf("."))) + "." + this.getFileType(file.name) : this.directoryUpload ? targetFiles[i].webkitRelativePath : file.name;
      var fileDetails = {
        name: fileName,
        rawFile: file,
        size: file.size,
        status: this.localizedTexts("readyToUploadMessage"),
        type: this.getFileType(file.name),
        validationMessages: this.validatedFileSize(file.size),
        statusCode: "1",
        id: getUniqueID(file.name.substring(0, file.name.lastIndexOf("."))) + "." + this.getFileType(file.name)
      };
      if (paste) {
        fileDetails.fileSource = "paste";
      }
      fileDetails.status = fileDetails.validationMessages.minSize !== "" ? this.localizedTexts("invalidMinFileSize") : fileDetails.validationMessages.maxSize !== "" ? this.localizedTexts("invalidMaxFileSize") : fileDetails.status;
      if (fileDetails.validationMessages.minSize !== "" || fileDetails.validationMessages.maxSize !== "") {
        fileDetails.statusCode = "0";
        this.checkActionComplete(true);
      }
      fileData.push(fileDetails);
    };
    Uploader2.prototype._internalRenderSelect = function(eventArgs, fileData) {
      if (!eventArgs.cancel) {
        this.selectedFiles = this.selectedFiles.concat(fileData);
        this.btnTabIndex = this.disableKeyboardNavigation ? "-1" : "0";
        if (this.showFileList) {
          if (eventArgs.isModified && eventArgs.modifiedFilesData.length > 0) {
            for (var j = 0; j < eventArgs.modifiedFilesData.length; j++) {
              for (var k = 0; k < fileData.length; k++) {
                if (eventArgs.modifiedFilesData[j].id === fileData[k].id) {
                  eventArgs.modifiedFilesData[j].rawFile = fileData[k].rawFile;
                }
              }
            }
            var dataFiles = this.allTypes ? eventArgs.modifiedFilesData : this.checkExtension(eventArgs.modifiedFilesData);
            this.updateSortedFileList(dataFiles);
            this.filesData = this.filesData.concat(dataFiles);
            if (!this.isForm || this.allowUpload()) {
              this.checkAutoUpload(dataFiles);
            }
          } else {
            this.internalCreateFileList(fileData);
            if (this.autoUpload && this.sequenceUpload && this.sequentialUpload && this.filesData.length > 0 && this.filesData[this.filesData.length - 1].statusCode !== "2" && this.filesData[this.filesData.length - 1].statusCode !== "0") {
              this.filesData = this.filesData.concat(fileData);
              return;
            }
            this.filesData = this.filesData.concat(fileData);
            if (!this.isForm || this.allowUpload()) {
              this.checkAutoUpload(fileData);
            }
          }
          if (!isNullOrUndefined(eventArgs.progressInterval) && eventArgs.progressInterval !== "") {
            this.progressInterval = eventArgs.progressInterval;
          }
        } else {
          this.filesData = this.filesData.concat(fileData);
          if (this.autoUpload) {
            this.upload(this.filesData, true);
          }
        }
        this.raiseActionComplete();
        this.isFirstFileOnSelection = true;
      }
    };
    Uploader2.prototype.allowUpload = function() {
      var allowFormUpload = false;
      if (this.isForm && (!isNullOrUndefined(this.asyncSettings.saveUrl) && this.asyncSettings.saveUrl !== "")) {
        allowFormUpload = true;
      }
      return allowFormUpload;
    };
    Uploader2.prototype.isFormUpload = function() {
      var isFormUpload = false;
      if (this.isForm && ((isNullOrUndefined(this.asyncSettings.saveUrl) || this.asyncSettings.saveUrl === "") && (isNullOrUndefined(this.asyncSettings.removeUrl) || this.asyncSettings.removeUrl === ""))) {
        isFormUpload = true;
      }
      return isFormUpload;
    };
    Uploader2.prototype.clearData = function(singleUpload) {
      if (!isNullOrUndefined(this.listParent)) {
        detach(this.listParent);
        this.listParent = null;
      }
      if (this.browserName !== "msie" && !singleUpload) {
        this.element.value = "";
      }
      this.fileList = [];
      this.filesData = [];
      this.removeActionButtons();
    };
    Uploader2.prototype.updateSortedFileList = function(filesData) {
      var previousListClone = this.createElement("div", { id: "clonewrapper" });
      var added = -1;
      if (this.listParent) {
        for (var i = 0; i < this.listParent.querySelectorAll("li").length; i++) {
          var liElement = this.listParent.querySelectorAll("li")[i];
          previousListClone.appendChild(liElement.cloneNode(true));
        }
        this.removeActionButtons();
        var oldList = [].slice.call(previousListClone.childNodes);
        this.createParentUL();
        for (var index = 0; index < filesData.length; index++) {
          for (var j = 0; j < this.filesData.length; j++) {
            if (this.filesData[j].name === filesData[index].name) {
              this.listParent.appendChild(oldList[j]);
              EventHandler.add(oldList[j].querySelector(".e-icons"), "click", this.removeFiles, this);
              this.fileList.push(oldList[j]);
              added = index;
            }
          }
          if (added !== index) {
            this.internalCreateFileList([filesData[index]]);
          }
        }
      } else {
        this.internalCreateFileList(filesData);
      }
    };
    Uploader2.prototype.isBlank = function(str) {
      return !str || /^\s*$/.test(str);
    };
    Uploader2.prototype.checkGenericExtension = function(genericType, fileExtension) {
      var validExtensions = [];
      switch (genericType.toLowerCase()) {
        case "image/*":
          validExtensions.push("jpg", "jpeg", "png", "gif", "bmp", "tiff", "svg", "webp", "heic");
          break;
        case "audio/*":
          validExtensions.push("mp3", "wav", "aac", "flac", "ogg", "m4a");
          break;
        case "video/*":
          validExtensions.push("mp4", "mov", "avi", "mkv", "flv", "wmv", "webm", "mpeg");
          break;
        case "application/*":
          validExtensions.push("doc", "docx", "xls", "xlsx", "ppt", "pptx", "zip", "rar", "7z", "tar", "pdf");
          break;
        case "text/*":
          validExtensions.push("txt", "csv", "html", "css", "js", "json", "xml", "md");
          break;
      }
      return validExtensions.includes(fileExtension.toLowerCase());
    };
    Uploader2.prototype.checkExtension = function(files) {
      var dropFiles = files;
      if (!this.isBlank(this.allowedExtensions)) {
        var allowedExtensions = [];
        var extensions = !isNullOrUndefined(allowedExtensions) ? this.allowedExtensions.split(",") : [""];
        for (var _i = 0, extensions_1 = extensions; _i < extensions_1.length; _i++) {
          var extension = extensions_1[_i];
          allowedExtensions.push(extension.trim().toLocaleLowerCase());
        }
        for (var i = 0; i < files.length; i++) {
          var checkFileType = files[i].type.indexOf(".") !== -1 ? files[i].type.replace(".", "") : files[i].type;
          if (allowedExtensions[0].indexOf("/*") !== -1) {
            var isValidExtension = this.checkGenericExtension(allowedExtensions[0], checkFileType);
            if (!isValidExtension) {
              files[i].status = this.localizedTexts("invalidFileType");
              files[i].statusCode = "0";
            }
          } else if (allowedExtensions.indexOf(("." + checkFileType).toLocaleLowerCase()) === -1) {
            files[i].status = this.localizedTexts("invalidFileType");
            files[i].statusCode = "0";
          }
        }
      }
      return dropFiles;
    };
    Uploader2.prototype.validatedFileSize = function(fileSize) {
      var minSizeError = "";
      var maxSizeError = "";
      if (fileSize < this.minFileSize) {
        minSizeError = this.localizedTexts("invalidMinFileSize");
      } else if (fileSize > this.maxFileSize) {
        maxSizeError = this.localizedTexts("invalidMaxFileSize");
      } else {
        minSizeError = "";
        maxSizeError = "";
      }
      var errorMessage = { minSize: minSizeError, maxSize: maxSizeError };
      return errorMessage;
    };
    Uploader2.prototype.isPreLoadFile = function(fileData) {
      var isPreload = false;
      for (var i = 0; i < this.files.length; i++) {
        if (this.files[i].name === fileData.name.slice(0, fileData.name.lastIndexOf(".")) && this.files[i].type === fileData.type) {
          isPreload = true;
        }
      }
      return isPreload;
    };
    Uploader2.prototype.createCustomfileList = function(fileData) {
      this.createParentUL();
      for (var _i = 0, fileData_1 = fileData; _i < fileData_1.length; _i++) {
        var listItem = fileData_1[_i];
        var listElement = this.createElement("li", { className: FILE, attrs: { "data-file-name": listItem.name } });
        this.uploadTemplateFn = this.templateComplier(this.template);
        var liTempCompiler = this.uploadTemplateFn(listItem, this, "template", this.element.id + "Template", this.isStringTemplate, null, listElement);
        if (liTempCompiler) {
          var fromElements = [].slice.call(liTempCompiler);
          append(fromElements, listElement);
        }
        var index = fileData.indexOf(listItem);
        var eventArgs = {
          element: listElement,
          fileInfo: listItem,
          index,
          isPreload: this.isPreLoadFile(listItem)
        };
        var eventsArgs = {
          element: listElement,
          fileInfo: listItem,
          index,
          isPreload: this.isPreLoadFile(listItem)
        };
        this.trigger("rendering", eventArgs);
        this.trigger("fileListRendering", eventsArgs);
        this.listParent.appendChild(listElement);
        this.fileList.push(listElement);
      }
      this.renderReactTemplates();
    };
    Uploader2.prototype.createParentUL = function() {
      if (isNullOrUndefined(this.listParent)) {
        this.listParent = this.createElement("ul", { className: LIST_PARENT });
        this.uploadWrapper.appendChild(this.listParent);
      }
    };
    Uploader2.prototype.formFileList = function(fileData, files) {
      var fileList = this.createElement("li", { className: FILE });
      fileList.setAttribute("data-files-count", fileData.length + "");
      var fileContainer = this.createElement("span", { className: TEXT_CONTAINER });
      var statusMessage;
      for (var _i = 0, fileData_2 = fileData; _i < fileData_2.length; _i++) {
        var listItem = fileData_2[_i];
        var fileNameEle = this.createElement("span", { className: FILE_NAME });
        fileNameEle.innerHTML = this.getFileNameOnly(listItem.name);
        var fileTypeEle = this.createElement("span", { className: FILE_TYPE });
        var fileType = this.getFileType(listItem.name);
        fileTypeEle.innerHTML = "." + fileType;
        if (!fileType) {
          fileTypeEle.classList.add("e-hidden");
        }
        if (!this.enableRtl) {
          fileContainer.appendChild(fileNameEle);
          fileContainer.appendChild(fileTypeEle);
        } else {
          var rtlContainer = this.createElement("span", { className: RTL_CONTAINER });
          rtlContainer.appendChild(fileTypeEle);
          rtlContainer.appendChild(fileNameEle);
          fileContainer.appendChild(rtlContainer);
        }
        this.truncateName(fileNameEle);
        statusMessage = this.formValidateFileInfo(listItem, fileList);
      }
      fileList.appendChild(fileContainer);
      this.setListToFileInfo(fileData, fileList);
      var index = this.listParent.querySelectorAll("li").length;
      var infoEle = this.createElement("span");
      if (fileList.classList.contains(INVALID_FILE)) {
        infoEle.classList.add(STATUS);
        infoEle.classList.add(INVALID_FILE);
        infoEle.innerText = fileData.length > 1 ? this.localizedTexts("invalidFileSelection") : statusMessage;
      } else {
        infoEle.classList.add(fileData.length > 1 ? INFORMATION : FILE_SIZE);
        infoEle.innerText = fileData.length > 1 ? this.localizedTexts("totalFiles") + ": " + fileData.length + " , " + this.localizedTexts("size") + ": " + this.bytesToSize(this.getFileSize(fileData)) : this.bytesToSize(fileData[0].size);
        this.createFormInput(fileData);
      }
      fileContainer.appendChild(infoEle);
      if (isNullOrUndefined(fileList.querySelector(".e-icons"))) {
        var iconElement = this.createElement("span", { className: "e-icons", attrs: { "tabindex": this.btnTabIndex } });
        if (this.browserName === "msie") {
          iconElement.classList.add("e-msie");
        }
        iconElement.setAttribute("title", this.localizedTexts("remove"));
        fileList.appendChild(fileContainer);
        fileList.appendChild(iconElement);
        EventHandler.add(iconElement, "click", this.removeFiles, this);
        iconElement.classList.add(REMOVE_ICON);
      }
      var eventArgs = {
        element: fileList,
        fileInfo: this.mergeFileInfo(fileData, fileList),
        index,
        isPreload: this.isPreLoadFile(this.mergeFileInfo(fileData, fileList))
      };
      var eventsArgs = {
        element: fileList,
        fileInfo: this.mergeFileInfo(fileData, fileList),
        index,
        isPreload: this.isPreLoadFile(this.mergeFileInfo(fileData, fileList))
      };
      this.trigger("rendering", eventArgs);
      this.trigger("fileListRendering", eventsArgs);
      this.listParent.appendChild(fileList);
      this.fileList.push(fileList);
    };
    Uploader2.prototype.formValidateFileInfo = function(listItem, fileList) {
      var statusMessage = listItem.status;
      var validationMessages = this.validatedFileSize(listItem.size);
      if (validationMessages.minSize !== "" || validationMessages.maxSize !== "") {
        this.addInvalidClass(fileList);
        statusMessage = validationMessages.minSize !== "" ? this.localizedTexts("invalidMinFileSize") : validationMessages.maxSize !== "" ? this.localizedTexts("invalidMaxFileSize") : statusMessage;
      }
      var typeValidationMessage = this.checkExtension(this.getFilesInArray(listItem))[0].status;
      if (typeValidationMessage === this.localizedTexts("invalidFileType")) {
        this.addInvalidClass(fileList);
        statusMessage = typeValidationMessage;
      }
      return statusMessage;
    };
    Uploader2.prototype.addInvalidClass = function(fileList) {
      fileList.classList.add(INVALID_FILE);
    };
    Uploader2.prototype.createFormInput = function(fileData) {
      if (this.browserName !== "safari") {
        var inputElement = this.element.cloneNode(true);
        inputElement.classList.add(HIDDEN_INPUT);
        for (var _i = 0, fileData_3 = fileData; _i < fileData_3.length; _i++) {
          var listItem = fileData_3[_i];
          listItem.input = inputElement;
        }
        inputElement.setAttribute("id", getUniqueID("hiddenUploader"));
        inputElement.setAttribute("name", this.uploaderName);
        this.uploadWrapper.querySelector("." + INPUT_WRAPPER).appendChild(inputElement);
        if (this.browserName !== "msie" && this.browserName !== "edge") {
          this.element.value = "";
        }
      }
    };
    Uploader2.prototype.getFileSize = function(fileData) {
      var fileSize = 0;
      for (var _i = 0, fileData_4 = fileData; _i < fileData_4.length; _i++) {
        var file = fileData_4[_i];
        fileSize += file.size;
      }
      return fileSize;
    };
    Uploader2.prototype.mergeFileInfo = function(fileData, fileList) {
      var result = {
        name: "",
        rawFile: "",
        size: 0,
        status: "",
        type: "",
        validationMessages: { minSize: "", maxSize: "" },
        statusCode: "1",
        list: fileList
      };
      var fileNames = [];
      var type = "";
      for (var _i = 0, fileData_5 = fileData; _i < fileData_5.length; _i++) {
        var listItem = fileData_5[_i];
        fileNames.push(listItem.name);
        type = listItem.type;
      }
      result.name = fileNames.join(", ");
      result.size = this.getFileSize(fileData);
      result.type = type;
      result.status = this.statusForFormUpload(fileData, fileList);
      return result;
    };
    Uploader2.prototype.statusForFormUpload = function(fileData, fileList) {
      var isValid = true;
      var statusMessage;
      for (var _i = 0, fileData_6 = fileData; _i < fileData_6.length; _i++) {
        var listItem = fileData_6[_i];
        statusMessage = listItem.status;
        var validationMessages = this.validatedFileSize(listItem.size);
        if (validationMessages.minSize !== "" || validationMessages.maxSize !== "") {
          isValid = false;
          statusMessage = validationMessages.minSize !== "" ? this.localizedTexts("invalidMinFileSize") : validationMessages.maxSize !== "" ? this.localizedTexts("invalidMaxFileSize") : statusMessage;
        }
        var typeValidationMessage = this.checkExtension(this.getFilesInArray(listItem))[0].status;
        if (typeValidationMessage === this.localizedTexts("invalidFileType")) {
          isValid = false;
          statusMessage = typeValidationMessage;
        }
      }
      if (!isValid) {
        fileList.classList.add(INVALID_FILE);
        statusMessage = fileData.length > 1 ? this.localizedTexts("invalidFileSelection") : statusMessage;
      } else {
        statusMessage = this.localizedTexts("totalFiles") + ": " + fileData.length + " , " + this.localizedTexts("size") + ": " + this.bytesToSize(this.getFileSize(fileData));
      }
      return statusMessage;
    };
    Uploader2.prototype.formCustomFileList = function(fileData, files) {
      this.createParentUL();
      var fileList = this.createElement("li", { className: FILE });
      fileList.setAttribute("data-files-count", fileData.length + "");
      this.setListToFileInfo(fileData, fileList);
      var result = this.mergeFileInfo(fileData, fileList);
      fileList.setAttribute("data-file-name", result.name);
      this.uploadTemplateFn = this.templateComplier(this.template);
      var liTempCompiler = this.uploadTemplateFn(result, this, "template", this.element.id + "Template", this.isStringTemplate, null, fileList);
      if (liTempCompiler) {
        var fromElements = [].slice.call(liTempCompiler);
        append(fromElements, fileList);
      }
      var index = this.listParent.querySelectorAll("li").length;
      if (!fileList.classList.contains(INVALID_FILE)) {
        this.createFormInput(fileData);
      }
      var eventArgs = {
        element: fileList,
        fileInfo: result,
        index,
        isPreload: this.isPreLoadFile(result)
      };
      var eventsArgs = {
        element: fileList,
        fileInfo: result,
        index,
        isPreload: this.isPreLoadFile(result)
      };
      this.trigger("rendering", eventArgs);
      this.trigger("fileListRendering", eventsArgs);
      this.listParent.appendChild(fileList);
      this.fileList.push(fileList);
      this.renderReactTemplates();
    };
    Uploader2.prototype.createFileList = function(fileData) {
      this.filesData = this.filesData && this.filesData.length > 0 ? this.filesData.concat(fileData) : fileData;
      this.internalCreateFileList(fileData);
    };
    Uploader2.prototype.internalCreateFileList = function(fileData) {
      this.createParentUL();
      if (this.template !== "" && !isNullOrUndefined(this.template)) {
        if (this.isFormUpload()) {
          this.uploadWrapper.classList.add(FORM_UPLOAD);
          this.formCustomFileList(fileData, this.element.files);
        } else {
          this.createCustomfileList(fileData);
        }
      } else if (this.isFormUpload()) {
        this.uploadWrapper.classList.add(FORM_UPLOAD);
        this.formFileList(fileData, this.element.files);
      } else {
        for (var _i = 0, fileData_7 = fileData; _i < fileData_7.length; _i++) {
          var listItem = fileData_7[_i];
          var liElement = this.createElement("li", {
            className: FILE,
            attrs: { "data-file-name": listItem.name, "data-files-count": "1" }
          });
          var textContainer = this.createElement("span", { className: TEXT_CONTAINER });
          var textElement = this.createElement("span", { className: FILE_NAME, attrs: { "title": listItem.name } });
          textElement.innerHTML = this.getFileNameOnly(listItem.name);
          var fileExtension = this.createElement("span", { className: FILE_TYPE });
          var fileType = this.getFileType(listItem.name);
          fileExtension.innerHTML = "." + fileType;
          if (!fileType) {
            fileExtension.classList.add("e-hidden");
          }
          if (!this.enableRtl) {
            textContainer.appendChild(textElement);
            textContainer.appendChild(fileExtension);
          } else {
            var rtlContainer = this.createElement("span", { className: RTL_CONTAINER });
            rtlContainer.appendChild(fileExtension);
            rtlContainer.appendChild(textElement);
            textContainer.appendChild(rtlContainer);
          }
          var fileSize = this.createElement("span", { className: FILE_SIZE });
          fileSize.innerHTML = this.bytesToSize(listItem.size);
          textContainer.appendChild(fileSize);
          var statusElement = this.createElement("span", { className: STATUS });
          textContainer.appendChild(statusElement);
          statusElement.innerHTML = listItem.status;
          liElement.appendChild(textContainer);
          var iconElement = this.createElement("span", {
            className: " e-icons",
            attrs: { "tabindex": this.btnTabIndex }
          });
          if (this.browserName === "msie") {
            iconElement.classList.add("e-msie");
          }
          iconElement.setAttribute("title", this.localizedTexts("remove"));
          liElement.appendChild(iconElement);
          EventHandler.add(iconElement, "click", this.removeFiles, this);
          if (listItem.statusCode === "2") {
            statusElement.classList.add(UPLOAD_SUCCESS);
            iconElement.classList.add(DELETE_ICON);
            iconElement.setAttribute("title", this.localizedTexts("delete"));
            iconElement.setAttribute("aria-label", this.localizedTexts("delete"));
          } else if (listItem.statusCode !== "1") {
            statusElement.classList.remove(UPLOAD_SUCCESS);
            statusElement.classList.add(VALIDATION_FAILS);
          }
          if (this.autoUpload && listItem.statusCode === "1" && this.asyncSettings.saveUrl !== "") {
            statusElement.innerHTML = "";
          }
          if (!iconElement.classList.contains(DELETE_ICON)) {
            iconElement.classList.add(REMOVE_ICON);
            iconElement.setAttribute("aria-label", this.localizedTexts("remove"));
          }
          var index = fileData.indexOf(listItem);
          var eventArgs = {
            element: liElement,
            fileInfo: listItem,
            index,
            isPreload: this.isPreLoadFile(listItem)
          };
          var eventsArgs = {
            element: liElement,
            fileInfo: listItem,
            index,
            isPreload: this.isPreLoadFile(listItem)
          };
          this.trigger("rendering", eventArgs);
          this.trigger("fileListRendering", eventsArgs);
          this.listParent.appendChild(liElement);
          this.fileList.push(liElement);
          this.truncateName(textElement);
          var preventActionComplete = this.flag;
          if (this.isPreLoadFile(listItem)) {
            this.flag = false;
            this.checkActionComplete(true);
            this.flag = preventActionComplete;
          }
        }
      }
    };
    Uploader2.prototype.getSlicedName = function(nameElement) {
      var text = nameElement.textContent;
      nameElement.dataset.tail = text.slice(text.length - 10);
    };
    Uploader2.prototype.setListToFileInfo = function(fileData, fileList) {
      for (var _i = 0, fileData_8 = fileData; _i < fileData_8.length; _i++) {
        var listItem = fileData_8[_i];
        listItem.list = fileList;
      }
    };
    Uploader2.prototype.truncateName = function(name) {
      var nameElement = name;
      if (this.browserName !== "edge" && nameElement.offsetWidth < nameElement.scrollWidth) {
        this.getSlicedName(nameElement);
      } else if (nameElement.offsetWidth + 1 < nameElement.scrollWidth) {
        this.getSlicedName(nameElement);
      }
    };
    Uploader2.prototype.getFileType = function(name) {
      var extension;
      var index = name.lastIndexOf(".");
      if (index >= 0) {
        extension = name.substring(index + 1);
      }
      return extension ? extension : "";
    };
    Uploader2.prototype.getFileNameOnly = function(name) {
      var type = this.getFileType(name);
      var names = name.split("." + type);
      return type = names[0];
    };
    Uploader2.prototype.setInitialAttributes = function() {
      if (this.initialAttr.accept) {
        this.element.setAttribute("accept", this.initialAttr.accept);
      }
      if (this.initialAttr.disabled) {
        this.element.setAttribute("disabled", "disabled");
      }
      if (this.initialAttr.multiple) {
        var newAttr = (undefined).createAttribute("multiple");
        this.element.setAttributeNode(newAttr);
      }
    };
    Uploader2.prototype.filterfileList = function(files) {
      var filterFiles = [];
      var li;
      for (var i = 0; i < files.length; i++) {
        li = this.getLiElement(files[i]);
        if (!isNullOrUndefined(li) && !li.classList.contains(UPLOAD_SUCCESS)) {
          filterFiles.push(files[i]);
        } else if (!this.showFileList && files[i].status !== "File uploaded successfully") {
          filterFiles.push(files[i]);
        }
      }
      return filterFiles;
    };
    Uploader2.prototype.updateStatus = function(files, status, statusCode, updateLiStatus) {
      if (updateLiStatus === undefined) {
        updateLiStatus = true;
      }
      if (!(status === "" || isNullOrUndefined(status)) && !(statusCode === "" || isNullOrUndefined(statusCode))) {
        files.status = status;
        files.statusCode = statusCode;
      }
      if (updateLiStatus) {
        var li = this.getLiElement(files);
        if (!isNullOrUndefined(li)) {
          if (!isNullOrUndefined(li.querySelector("." + STATUS)) && !(status === "" || isNullOrUndefined(status))) {
            li.querySelector("." + STATUS).textContent = status;
          }
        }
      }
      return files;
    };
    Uploader2.prototype.getLiElement = function(files) {
      var index;
      for (var i = 0; i < this.filesData.length; i++) {
        if (!isNullOrUndefined(files) && (!isNullOrUndefined(this.filesData[i].id) && !isNullOrUndefined(files.id) ? this.filesData[i].name === files.name && this.filesData[i].id === files.id : this.filesData[i].name === files.name)) {
          index = i;
        }
      }
      return this.fileList[index];
    };
    Uploader2.prototype.createProgressBar = function(liElement) {
      var progressbarWrapper = this.createElement("span", { className: PROGRESS_WRAPPER });
      var progressBar = this.createElement("progressbar", { className: PROGRESSBAR, attrs: { value: "0", max: "100" } });
      var progressbarInnerWrapper = this.createElement("span", { className: PROGRESS_INNER_WRAPPER });
      progressBar.setAttribute("style", "width: 0%");
      var progressbarText = this.createElement("span", { className: PROGRESSBAR_TEXT });
      progressbarText.textContent = "0%";
      progressbarInnerWrapper.appendChild(progressBar);
      progressbarWrapper.appendChild(progressbarInnerWrapper);
      progressbarWrapper.appendChild(progressbarText);
      liElement.querySelector("." + TEXT_CONTAINER).appendChild(progressbarWrapper);
    };
    Uploader2.prototype.updateProgressbar = function(e, li) {
      if (!isNaN(Math.round(e.loaded / e.total * 100)) && !isNullOrUndefined(li.querySelector("." + PROGRESSBAR))) {
        if (!isNullOrUndefined(this.progressInterval) && this.progressInterval !== "") {
          var value = Math.round(e.loaded / e.total * 100) % parseInt(this.progressInterval, 10);
          if (value === 0 || value === 100) {
            this.changeProgressValue(li, Math.round(e.loaded / e.total * 100).toString() + "%");
          }
        } else {
          this.changeProgressValue(li, Math.round(e.loaded / e.total * 100).toString() + "%");
        }
      }
    };
    Uploader2.prototype.changeProgressValue = function(li, progressValue) {
      li.querySelector("." + PROGRESSBAR).setAttribute("style", "width:" + progressValue);
      li.querySelector("." + PROGRESSBAR_TEXT).textContent = progressValue;
    };
    Uploader2.prototype.uploadInProgress = function(e, files, customUI, request) {
      var li = this.getLiElement(files);
      if (isNullOrUndefined(li) && !customUI) {
        return;
      }
      if (!isNullOrUndefined(li)) {
        if (files.statusCode === "5") {
          this.cancelUploadingFile(files, e, request, li);
        }
        if (!(li.querySelectorAll("." + PROGRESS_WRAPPER).length > 0) && li.querySelector("." + STATUS)) {
          li.querySelector("." + STATUS).classList.add(UPLOAD_INPROGRESS);
          this.createProgressBar(li);
          this.updateProgressBarClasses(li, UPLOAD_INPROGRESS);
          li.querySelector("." + STATUS).classList.remove(UPLOAD_FAILED);
        }
        this.updateProgressbar(e, li);
        var iconEle = li.querySelector("." + REMOVE_ICON);
        if (!isNullOrUndefined(iconEle)) {
          iconEle.classList.add(ABORT_ICON, UPLOAD_INPROGRESS);
          iconEle.setAttribute("title", this.localizedTexts("abort"));
          iconEle.classList.remove(REMOVE_ICON);
        }
      } else {
        this.cancelUploadingFile(files, e, request);
      }
      var args = { e, operation: "upload", file: this.updateStatus(files, this.localizedTexts("inProgress"), "3") };
      this.trigger("progress", args);
    };
    Uploader2.prototype.cancelUploadingFile = function(files, e, request, li) {
      var _this = this;
      if (files.statusCode === "5") {
        var eventArgs = {
          event: e,
          fileData: files,
          cancel: false,
          customFormData: [],
          currentRequest: null
        };
        this.trigger("canceling", eventArgs, function(eventArgs2) {
          if (eventArgs2.cancel) {
            files.statusCode = "3";
            if (!isNullOrUndefined(li)) {
              var spinnerTarget = li.querySelector("." + ABORT_ICON);
              if (!isNullOrUndefined(spinnerTarget)) {
                hideSpinner(spinnerTarget);
                detach(li.querySelector(".e-spinner-pane"));
              }
            }
          } else {
            request.emitError = false;
            request.httpRequest.abort();
            var formData = new FormData();
            if (files.statusCode === "5") {
              var name_1 = _this.element.getAttribute("name");
              formData.append(name_1, files.name);
              formData.append("cancel-uploading", files.name);
              _this.updateFormData(formData, eventArgs2.customFormData);
              var ajax_1 = new Ajax(_this.asyncSettings.removeUrl, "POST", true, null);
              ajax_1.emitError = false;
              ajax_1.beforeSend = function(e2) {
                if (eventArgs2.currentRequest) {
                  _this.updateCustomheader(ajax_1.httpRequest, eventArgs2.currentRequest);
                }
              };
              ajax_1.onLoad = function(e2) {
                _this.removecanceledFile(e2, files);
                return {};
              };
              ajax_1.send(formData);
            }
          }
        });
      }
    };
    Uploader2.prototype.removecanceledFile = function(e, file) {
      var liElement = this.getLiElement(file);
      if (isNullOrUndefined(liElement) || liElement.querySelector("." + RETRY_ICON) || isNullOrUndefined(liElement.querySelector("." + ABORT_ICON))) {
        return;
      }
      this.updateStatus(file, this.localizedTexts("fileUploadCancel"), "5");
      this.renderFailureState(e, file, liElement);
      var spinnerTarget = liElement.querySelector("." + REMOVE_ICON);
      if (!isNullOrUndefined(liElement)) {
        hideSpinner(spinnerTarget);
        if (!isNullOrUndefined(liElement.querySelector(".e-spinner-pane"))) {
          detach(liElement.querySelector(".e-spinner-pane"));
        }
      }
      var requestResponse = e && e.currentTarget ? this.getResponse(e) : null;
      var args = { event: e, response: requestResponse, operation: "cancel", file };
      this.trigger("success", args);
    };
    Uploader2.prototype.renderFailureState = function(e, file, liElement) {
      var _this = this;
      this.updateProgressBarClasses(liElement, UPLOAD_FAILED);
      this.removeProgressbar(liElement, "failure");
      if (!isNullOrUndefined(liElement.querySelector(".e-file-status"))) {
        liElement.querySelector(".e-file-status").classList.add(UPLOAD_FAILED);
      }
      var deleteIcon = liElement.querySelector("." + ABORT_ICON);
      if (isNullOrUndefined(deleteIcon)) {
        return;
      }
      deleteIcon.classList.remove(ABORT_ICON, UPLOAD_INPROGRESS);
      deleteIcon.classList.add(REMOVE_ICON);
      deleteIcon.setAttribute("title", this.localizedTexts("remove"));
      this.pauseButton = this.createElement("span", { className: "e-icons e-file-reload-btn", attrs: { "tabindex": this.btnTabIndex } });
      deleteIcon.parentElement.insertBefore(this.pauseButton, deleteIcon);
      this.pauseButton.setAttribute("title", this.localizedTexts("retry"));
      this.pauseButton.setAttribute("aria-label", this.localizedTexts("retry"));
      var retryElement = liElement.querySelector("." + RETRY_ICON);
      retryElement.addEventListener("click", function(e2) {
        _this.reloadcanceledFile(e2, file, liElement, false);
      }, false);
    };
    Uploader2.prototype.reloadcanceledFile = function(e, file, liElement, custom) {
      file.statusCode = "1";
      file.status = this.localizedTexts("readyToUploadMessage");
      if (!custom) {
        if (!isNullOrUndefined(liElement.querySelector("." + STATUS))) {
          liElement.querySelector("." + STATUS).classList.remove(UPLOAD_FAILED);
        }
        if (!isNullOrUndefined(liElement.querySelector("." + RETRY_ICON))) {
          detach(liElement.querySelector("." + RETRY_ICON));
        }
        this.pauseButton = null;
      }
      if (!isNullOrUndefined(liElement)) {
        liElement.classList.add(RESTRICT_RETRY);
      }
      this.upload([file]);
    };
    Uploader2.prototype.uploadComplete = function(e, file, customUI) {
      var status = e.target;
      if (status.readyState === 4 && status.status >= 200 && status.status <= 299) {
        var li = this.getLiElement(file);
        if (isNullOrUndefined(li) && (!customUI || isNullOrUndefined(customUI)) && this.showFileList) {
          return;
        }
        if (!isNullOrUndefined(li)) {
          this.updateProgressBarClasses(li, UPLOAD_SUCCESS);
          this.removeProgressbar(li, "success");
          var iconEle = li.querySelector("." + ABORT_ICON);
          if (!isNullOrUndefined(iconEle)) {
            iconEle.classList.add(DELETE_ICON);
            iconEle.setAttribute("title", this.localizedTexts("delete"));
            iconEle.setAttribute("aria-label", this.localizedTexts("delete"));
            iconEle.classList.remove(ABORT_ICON);
            iconEle.classList.remove(UPLOAD_INPROGRESS);
          }
        }
        this.raiseSuccessEvent(e, file);
      } else {
        this.uploadFailed(e, file);
      }
    };
    Uploader2.prototype.getResponse = function(e) {
      var target = e.currentTarget;
      var response = {
        readyState: target.readyState,
        statusCode: target.status,
        statusText: target.statusText,
        headers: target.getAllResponseHeaders(),
        withCredentials: target.withCredentials
      };
      return response;
    };
    Uploader2.prototype.raiseSuccessEvent = function(e, file) {
      var _this = this;
      var response = e && e.currentTarget ? this.getResponse(e) : null;
      var statusMessage = this.localizedTexts("uploadSuccessMessage");
      var args = {
        e,
        response,
        operation: "upload",
        file: this.updateStatus(file, statusMessage, "2", false),
        statusText: statusMessage
      };
      var liElement = this.getLiElement(file);
      if (!isNullOrUndefined(liElement)) {
        var spinnerEle = liElement.querySelector("." + SPINNER_PANE);
        if (!isNullOrUndefined(spinnerEle)) {
          hideSpinner(liElement);
          detach(spinnerEle);
        }
      }
      this.trigger("success", args, function(args2) {
        _this.updateStatus(file, args2.statusText, "2");
        if (_this.multiple) {
          _this.uploadedFilesData.push(file);
        } else {
          _this.uploadedFilesData = [file];
        }
        _this.trigger("change", { file: _this.uploadedFilesData });
        _this.checkActionButtonStatus();
        if (_this.fileList.length > 0) {
          if (!_this.getLiElement(file).classList.contains(RESTRICT_RETRY)) {
            _this.uploadSequential();
            _this.checkActionComplete(true);
          } else {
            _this.getLiElement(file).classList.remove(RESTRICT_RETRY);
          }
        } else if (!_this.showFileList) {
          _this.checkActionComplete(true);
        }
      });
    };
    Uploader2.prototype.uploadFailed = function(e, file) {
      var _this = this;
      var li = this.getLiElement(file);
      var response = e && e.currentTarget ? this.getResponse(e) : null;
      var statusMessage = this.localizedTexts("uploadFailedMessage");
      var args = {
        e,
        response,
        operation: "upload",
        file: this.updateStatus(file, statusMessage, "0", false),
        statusText: statusMessage
      };
      if (!isNullOrUndefined(li)) {
        this.renderFailureState(e, file, li);
      }
      this.trigger("failure", args, function(args2) {
        _this.updateStatus(file, args2.statusText, "0");
        _this.checkActionButtonStatus();
        _this.uploadSequential();
        _this.checkActionComplete(true);
      });
    };
    Uploader2.prototype.uploadSequential = function() {
      if (this.sequentialUpload) {
        if (this.autoUpload) {
          this.checkAutoUpload(this.filesData);
        } else {
          this.uploadButtonClick();
        }
      }
    };
    Uploader2.prototype.checkActionComplete = function(increment) {
      if (increment) {
        ++this.actionCompleteCount;
      } else {
        --this.actionCompleteCount;
      }
      this.raiseActionComplete();
    };
    Uploader2.prototype.raiseActionComplete = function() {
      if (this.filesData.length === this.actionCompleteCount && this.flag) {
        this.flag = false;
        var eventArgs = {
          fileData: []
        };
        eventArgs.fileData = this.getSelectedFileStatus(this.selectedFiles);
        this.trigger("actionComplete", eventArgs);
      }
    };
    Uploader2.prototype.getSelectedFileStatus = function(selectedFiles) {
      var matchFiles = [];
      var matchFilesIndex = 0;
      for (var selectFileIndex = 0; selectFileIndex < selectedFiles.length; selectFileIndex++) {
        var selectedFileData = selectedFiles[selectFileIndex];
        for (var fileDataIndex = 0; fileDataIndex < this.filesData.length; fileDataIndex++) {
          if (this.filesData[fileDataIndex].name === selectedFileData.name && this.filesData[fileDataIndex].status === selectedFileData.status) {
            matchFiles[matchFilesIndex] = this.filesData[fileDataIndex];
            ++matchFilesIndex;
            break;
          }
        }
      }
      return matchFiles;
    };
    Uploader2.prototype.updateProgressBarClasses = function(li, className) {
      var progressBar = li.querySelector("." + PROGRESSBAR);
      if (!isNullOrUndefined(progressBar)) {
        progressBar.classList.add(className);
        if (this.actionButtons && this.clearButton && this.uploadWrapper) {
          if (className === "e-upload-progress" && !this.clearButton.hasAttribute("disabled")) {
            this.clearButton.setAttribute("disabled", "disabled");
          } else if ((className === "e-upload-success" || className === "e-upload-fails") && this.uploadWrapper.querySelectorAll(".e-upload-progress-bar.e-upload-progress:not(.e-upload-success):not(.e-upload-fails)").length === 0 && this.clearButton.hasAttribute("disabled")) {
            this.clearButton.removeAttribute("disabled");
          }
        }
      }
    };
    Uploader2.prototype.removeProgressbar = function(li, callType) {
      var _this = this;
      if (!isNullOrUndefined(li.querySelector("." + PROGRESS_WRAPPER))) {
        this.progressAnimation = new Animation$1({ duration: 1250 });
        this.progressAnimation.animate(li.querySelector("." + PROGRESS_WRAPPER), { name: "FadeOut" });
        this.progressAnimation.animate(li.querySelector("." + PROGRESSBAR_TEXT), { name: "FadeOut" });
        setTimeout(function() {
          _this.animateProgressBar(li, callType);
        }, 750);
      }
    };
    Uploader2.prototype.animateProgressBar = function(li, callType) {
      if (callType === "success") {
        li.classList.add(UPLOAD_SUCCESS);
        if (!isNullOrUndefined(li.querySelector("." + STATUS))) {
          li.querySelector("." + STATUS).classList.remove(UPLOAD_INPROGRESS);
          this.progressAnimation.animate(li.querySelector("." + STATUS), { name: "FadeIn" });
          li.querySelector("." + STATUS).classList.add(UPLOAD_SUCCESS);
        }
      } else {
        if (!isNullOrUndefined(li.querySelector("." + STATUS))) {
          li.querySelector("." + STATUS).classList.remove(UPLOAD_INPROGRESS);
          this.progressAnimation.animate(li.querySelector("." + STATUS), { name: "FadeIn" });
          li.querySelector("." + STATUS).classList.add(UPLOAD_FAILED);
        }
      }
      if (li.querySelector("." + PROGRESS_WRAPPER)) {
        detach(li.querySelector("." + PROGRESS_WRAPPER));
      }
    };
    Uploader2.prototype.setExtensions = function(extensions) {
      if (extensions !== "" && !isNullOrUndefined(extensions)) {
        this.element.setAttribute("accept", extensions);
      } else {
        this.element.removeAttribute("accept");
      }
    };
    Uploader2.prototype.templateComplier = function(uploadTemplate) {
      if (uploadTemplate) {
        try {
          if (typeof uploadTemplate !== "function" && selectAll(uploadTemplate, void 0).length) {
            return compile$1(select(uploadTemplate, void 0).innerHTML.trim());
          } else {
            return compile$1(uploadTemplate);
          }
        } catch (exception) {
          return compile$1(uploadTemplate);
        }
      }
      return undefined;
    };
    Uploader2.prototype.setRTL = function() {
      if (this.enableRtl) {
        addClass([this.uploadWrapper], RTL$2);
      } else {
        removeClass([this.uploadWrapper], RTL$2);
      }
    };
    Uploader2.prototype.localizedTexts = function(localeText) {
      this.l10n.setLocale(this.locale);
      return this.l10n.getConstant(localeText);
    };
    Uploader2.prototype.setControlStatus = function() {
      if (!this.enabled) {
        this.uploadWrapper.classList.add(DISABLED$1);
        this.element.setAttribute("disabled", "disabled");
        this.browseButton.setAttribute("disabled", "disabled");
        if (!isNullOrUndefined(this.clearButton)) {
          this.clearButton.setAttribute("disabled", "disabled");
        }
        if (!isNullOrUndefined(this.uploadButton)) {
          this.uploadButton.setAttribute("disabled", "disabled");
        }
      } else {
        if (this.uploadWrapper.classList.contains(DISABLED$1)) {
          this.uploadWrapper.classList.remove(DISABLED$1);
        }
        if (!isNullOrUndefined(this.browseButton) && this.element.hasAttribute("disabled")) {
          this.element.removeAttribute("disabled");
          this.browseButton.removeAttribute("disabled");
        }
        if (!isNullOrUndefined(this.clearButton) && this.clearButton.hasAttribute("disabled")) {
          this.clearButton.removeAttribute("disabled");
        }
        if (!isNullOrUndefined(this.uploadButton) && this.uploadButton.hasAttribute("disabled")) {
          this.uploadButton.hasAttribute("disabled");
        }
      }
    };
    Uploader2.prototype.checkHTMLAttributes = function(isDynamic) {
      var attributes2 = isDynamic ? isNullOrUndefined(this.htmlAttributes) ? [] : Object.keys(this.htmlAttributes) : ["accept", "multiple", "disabled"];
      for (var _i = 0, attributes_1 = attributes2; _i < attributes_1.length; _i++) {
        var prop = attributes_1[_i];
        if (!isNullOrUndefined(this.element.getAttribute(prop))) {
          switch (prop) {
            case "accept":
              if (isNullOrUndefined(this.uploaderOptions) || this.uploaderOptions["allowedExtensions"] === undefined || isDynamic) {
                this.setProperties({ allowedExtensions: this.element.getAttribute("accept") }, !isDynamic);
                this.initialAttr.accept = this.allowedExtensions;
              }
              break;
            case "multiple":
              if (isNullOrUndefined(this.uploaderOptions) || this.uploaderOptions["multiple"] === undefined || isDynamic) {
                var isMutiple = this.element.getAttribute(prop) === "multiple" || this.element.getAttribute(prop) === "" || this.element.getAttribute(prop) === "true" ? true : false;
                this.setProperties({ multiple: isMutiple }, !isDynamic);
                this.initialAttr.multiple = true;
              }
              break;
            case "disabled":
              if (isNullOrUndefined(this.uploaderOptions) || this.uploaderOptions["enabled"] === undefined || isDynamic) {
                var isDisabled = this.element.getAttribute(prop) === "disabled" || this.element.getAttribute(prop) === "" || this.element.getAttribute(prop) === "true" ? false : true;
                this.setProperties({ enabled: isDisabled }, !isDynamic);
                this.initialAttr.disabled = true;
              }
          }
        }
      }
    };
    Uploader2.prototype.chunkUpload = function(file, custom, fileIndex) {
      var start = 0;
      var end = Math.min(this.asyncSettings.chunkSize, file.size);
      var index = 0;
      var blob = file.rawFile.slice(start, end);
      var metaData = { chunkIndex: index, blob, file, start, end, retryCount: 0, request: null };
      this.sendRequest(file, metaData, custom, fileIndex);
    };
    Uploader2.prototype.sendRequest = function(file, metaData, custom, fileIndex) {
      var _this = this;
      var formData = new FormData();
      var blob = file.rawFile.slice(metaData.start, metaData.end);
      formData.append(this.uploaderName, blob, file.name);
      formData.append("chunk-index", metaData.chunkIndex.toString());
      formData.append("chunkIndex", metaData.chunkIndex.toString());
      var totalChunk = Math.max(Math.ceil(file.size / this.asyncSettings.chunkSize), 1);
      formData.append("total-chunk", totalChunk.toString());
      formData.append("totalChunk", totalChunk.toString());
      var ajax = new Ajax({ url: this.asyncSettings.saveUrl, type: "POST", async: true, contentType: null });
      ajax.emitError = false;
      ajax.onLoad = function(e) {
        _this.chunkUploadComplete(e, metaData, custom);
        return {};
      };
      ajax.onUploadProgress = function(e) {
        _this.chunkUploadInProgress(e, metaData, custom);
        return {};
      };
      var eventArgs = {
        fileData: file,
        customFormData: [],
        cancel: false,
        chunkSize: this.asyncSettings.chunkSize === 0 ? null : this.asyncSettings.chunkSize
      };
      ajax.beforeSend = function(e) {
        eventArgs.currentRequest = ajax.httpRequest;
        eventArgs.currentChunkIndex = metaData.chunkIndex;
        if (eventArgs.currentChunkIndex === 0) {
          _this.trigger("uploading", eventArgs, function(eventArgs2) {
            _this.uploadingEventCallback(formData, eventArgs2, e, file);
          });
        } else {
          _this.trigger("chunkUploading", eventArgs, function(eventArgs2) {
            _this.uploadingEventCallback(formData, eventArgs2, e, file);
          });
        }
      };
      ajax.onError = function(e) {
        _this.chunkUploadFailed(e, metaData, custom);
        return {};
      };
      ajax.send(formData);
      metaData.request = ajax;
    };
    Uploader2.prototype.uploadingEventCallback = function(formData, eventArgs, e, file) {
      if (eventArgs.cancel) {
        this.eventCancelByArgs(e, eventArgs, file);
      } else {
        this.updateFormData(formData, eventArgs.customFormData);
      }
    };
    Uploader2.prototype.eventCancelByArgs = function(e, eventArgs, file) {
      var _this = this;
      e.cancel = true;
      if (eventArgs.fileData.statusCode === "5") {
        return;
      }
      eventArgs.fileData.statusCode = "5";
      eventArgs.fileData.status = this.localizedTexts("fileUploadCancel");
      var liElement = this.getLiElement(eventArgs.fileData);
      if (liElement) {
        if (!isNullOrUndefined(liElement.querySelector("." + STATUS))) {
          liElement.querySelector("." + STATUS).innerHTML = this.localizedTexts("fileUploadCancel");
          liElement.querySelector("." + STATUS).classList.add(UPLOAD_FAILED);
        }
        this.pauseButton = this.createElement("span", { className: "e-icons e-file-reload-btn", attrs: { "tabindex": this.btnTabIndex } });
        var removeIcon = liElement.querySelector("." + REMOVE_ICON);
        if (removeIcon) {
          removeIcon.parentElement.insertBefore(this.pauseButton, removeIcon);
        }
        this.pauseButton.setAttribute("title", this.localizedTexts("retry"));
        this.pauseButton.addEventListener("click", function(e2) {
          _this.reloadcanceledFile(e2, file, liElement);
        }, false);
        this.checkActionButtonStatus();
      }
    };
    Uploader2.prototype.checkChunkUpload = function() {
      return this.asyncSettings.chunkSize <= 0 || isNullOrUndefined(this.asyncSettings.chunkSize) ? false : true;
    };
    Uploader2.prototype.chunkUploadComplete = function(e, metaData, custom) {
      var _this = this;
      var response = e.target;
      var liElement;
      if (response.readyState === 4 && response.status >= 200 && response.status < 300) {
        var requestResponse = e && e.currentTarget ? this.getResponse(e) : null;
        var totalChunk = Math.max(Math.ceil(metaData.file.size / this.asyncSettings.chunkSize), 1);
        var eventArgs = {
          event: e,
          file: metaData.file,
          chunkIndex: metaData.chunkIndex,
          totalChunk,
          chunkSize: this.asyncSettings.chunkSize,
          response: requestResponse
        };
        this.trigger("chunkSuccess", eventArgs);
        if (isNullOrUndefined(custom) || !custom) {
          liElement = this.getLiElement(metaData.file);
        }
        this.updateMetaData(metaData);
        if (metaData.end === metaData.file.size) {
          metaData.file.statusCode = "3";
        }
        if (metaData.file.statusCode === "5") {
          var eventArgs_1 = { event: e, fileData: metaData.file, cancel: false, customFormData: [] };
          this.trigger("canceling", eventArgs_1, function(eventArgs2) {
            if (eventArgs2.cancel) {
              metaData.file.statusCode = "3";
              var spinnerTarget = liElement.querySelector("." + ABORT_ICON);
              if (!isNullOrUndefined(liElement) && !isNullOrUndefined(spinnerTarget)) {
                hideSpinner(spinnerTarget);
                detach(liElement.querySelector(".e-spinner-pane"));
              }
              _this.sendNextRequest(metaData);
            } else {
              metaData.request.emitError = false;
              response.abort();
              var formData = new FormData();
              var name_2 = _this.element.getAttribute("name");
              formData.append(name_2, metaData.file.name);
              formData.append("cancel-uploading", metaData.file.name);
              formData.append("cancelUploading", metaData.file.name);
              _this.updateFormData(formData, eventArgs2.customFormData);
              var ajax = new Ajax(_this.asyncSettings.removeUrl, "POST", true, null);
              ajax.emitError = false;
              ajax.onLoad = function(e2) {
                _this.removeChunkFile(e2, metaData, custom);
                return {};
              };
              ajax.send(formData);
            }
          });
        } else {
          if (totalChunk - 1 === metaData.chunkIndex && totalChunk > metaData.chunkIndex) {
            var index = this.pausedData.indexOf(metaData);
            if (index >= 0) {
              this.pausedData.splice(index, 1);
            }
            if (isNullOrUndefined(this.template) && (isNullOrUndefined(custom) || !custom) && liElement) {
              if (liElement && !isNullOrUndefined(liElement.querySelector("." + PAUSE_UPLOAD))) {
                detach(liElement.querySelector("." + PAUSE_UPLOAD));
              }
              this.removeChunkProgressBar(metaData);
            }
            this.raiseSuccessEvent(e, metaData.file);
            return;
          }
          if (metaData.file.statusCode !== "4") {
            this.sendNextRequest(metaData);
          }
        }
      } else {
        this.chunkUploadFailed(e, metaData);
      }
    };
    Uploader2.prototype.sendNextRequest = function(metaData) {
      metaData.start = metaData.end;
      metaData.end += this.asyncSettings.chunkSize;
      metaData.end = Math.min(metaData.end, metaData.file.size);
      metaData.chunkIndex += 1;
      this.sendRequest(metaData.file, metaData);
    };
    Uploader2.prototype.removeChunkFile = function(e, metaData, custom) {
      if (isNullOrUndefined(this.template) && (isNullOrUndefined(custom) && !custom)) {
        var liElement = this.getLiElement(metaData.file);
        var deleteIcon = liElement.querySelector("." + ABORT_ICON);
        var spinnerTarget = deleteIcon;
        this.updateStatus(metaData.file, this.localizedTexts("fileUploadCancel"), "5");
        this.updateProgressBarClasses(liElement, UPLOAD_FAILED);
        this.removeProgressbar(liElement, "failure");
        if (deleteIcon) {
          deleteIcon.classList.remove(ABORT_ICON);
          deleteIcon.classList.add(REMOVE_ICON);
          deleteIcon.setAttribute("title", this.localizedTexts("remove"));
        }
        var pauseIcon = liElement.querySelector("." + PAUSE_UPLOAD);
        if (pauseIcon) {
          pauseIcon.classList.add(RETRY_ICON);
          pauseIcon.classList.remove(PAUSE_UPLOAD);
          pauseIcon.setAttribute("title", this.localizedTexts("retry"));
        }
        if (!isNullOrUndefined(liElement) && !isNullOrUndefined(deleteIcon) && !isNullOrUndefined(liElement.querySelector(".e-spinner-pane"))) {
          hideSpinner(spinnerTarget);
          detach(liElement.querySelector(".e-spinner-pane"));
        }
      }
    };
    Uploader2.prototype.pauseUpload = function(metaData, e, custom) {
      metaData.file.statusCode = "4";
      metaData.file.status = this.localizedTexts("pause");
      this.updateMetaData(metaData);
      var eventArgs = {
        event: e ? e : null,
        file: metaData.file,
        chunkIndex: metaData.chunkIndex,
        chunkCount: Math.round(metaData.file.size / this.asyncSettings.chunkSize),
        chunkSize: this.asyncSettings.chunkSize
      };
      this.abortUpload(metaData, custom, eventArgs);
      if (this.sequentialUpload) {
        this.uploadSequential();
      }
    };
    Uploader2.prototype.abortUpload = function(metaData, custom, eventArgs) {
      if (metaData.file.statusCode !== "4") {
        metaData.request.emitError = false;
        metaData.request.httpRequest.abort();
      }
      var liElement = this.getLiElement(metaData.file);
      if (isNullOrUndefined(this.template) && (isNullOrUndefined(custom) || !custom)) {
        var targetElement2 = liElement.querySelector("." + PAUSE_UPLOAD);
        targetElement2.classList.remove(PAUSE_UPLOAD);
        targetElement2.classList.add(RESUME_UPLOAD);
        targetElement2.setAttribute("title", this.localizedTexts("resume"));
        targetElement2.nextElementSibling.classList.add(REMOVE_ICON);
        targetElement2.nextElementSibling.classList.remove(ABORT_ICON);
        targetElement2.nextElementSibling.setAttribute("title", this.localizedTexts("remove"));
      }
      for (var i = 0; i < this.pausedData.length; i++) {
        if (this.pausedData[i].file.name === metaData.file.name) {
          this.pausedData.splice(i, 1);
        }
      }
      this.pausedData.push(metaData);
      this.trigger("pausing", eventArgs);
    };
    Uploader2.prototype.resumeUpload = function(metaData, e, custom) {
      var liElement = this.getLiElement(metaData.file);
      var targetElement2;
      if (!isNullOrUndefined(liElement)) {
        targetElement2 = liElement.querySelector("." + RESUME_UPLOAD);
      }
      if (!isNullOrUndefined(targetElement2) && (isNullOrUndefined(custom) || !custom)) {
        targetElement2.classList.remove(RESUME_UPLOAD);
        targetElement2.classList.add(PAUSE_UPLOAD);
        targetElement2.setAttribute("title", this.localizedTexts("pause"));
        targetElement2.nextElementSibling.classList.remove(REMOVE_ICON);
        targetElement2.nextElementSibling.classList.add(ABORT_ICON);
        targetElement2.nextElementSibling.setAttribute("title", this.localizedTexts("abort"));
      }
      metaData.file.status = this.localizedTexts("inProgress");
      metaData.file.statusCode = "3";
      this.updateMetaData(metaData);
      var eventArgs = {
        event: e ? e : null,
        file: metaData.file,
        chunkIndex: metaData.chunkIndex,
        chunkCount: Math.round(metaData.file.size / this.asyncSettings.chunkSize),
        chunkSize: this.asyncSettings.chunkSize
      };
      this.trigger("resuming", eventArgs);
      for (var i = 0; i < this.pausedData.length; i++) {
        if (this.pausedData[i].end === this.pausedData[i].file.size) {
          this.chunkUploadComplete(e, metaData, custom);
        } else {
          if (this.pausedData[i].file.name === metaData.file.name) {
            this.pausedData[i].start = this.pausedData[i].end;
            this.pausedData[i].end = this.pausedData[i].end + this.asyncSettings.chunkSize;
            this.pausedData[i].end = Math.min(this.pausedData[i].end, this.pausedData[i].file.size);
            this.pausedData[i].chunkIndex = this.pausedData[i].chunkIndex + 1;
            this.sendRequest(this.pausedData[i].file, this.pausedData[i], custom);
          }
        }
      }
    };
    Uploader2.prototype.updateMetaData = function(metaData) {
      if (this.uploadMetaData.indexOf(metaData) === -1) {
        this.uploadMetaData.push(metaData);
      } else {
        this.uploadMetaData.splice(this.uploadMetaData.indexOf(metaData), 1);
        this.uploadMetaData.push(metaData);
      }
    };
    Uploader2.prototype.removeChunkProgressBar = function(metaData) {
      var liElement = this.getLiElement(metaData.file);
      if (!isNullOrUndefined(liElement)) {
        this.updateProgressBarClasses(liElement, UPLOAD_SUCCESS);
        this.removeProgressbar(liElement, "success");
        var cancelButton = liElement.querySelector("." + ABORT_ICON);
        if (!isNullOrUndefined(cancelButton)) {
          cancelButton.classList.add(DELETE_ICON);
          cancelButton.setAttribute("title", this.localizedTexts("delete"));
          cancelButton.classList.remove(ABORT_ICON, UPLOAD_INPROGRESS);
        }
      }
    };
    Uploader2.prototype.chunkUploadFailed = function(e, metaData, custom) {
      var _this = this;
      var chunkCount = Math.max(Math.ceil(metaData.file.size / this.asyncSettings.chunkSize), 1);
      var liElement;
      if (isNullOrUndefined(this.template) && (isNullOrUndefined(custom) || !custom)) {
        liElement = this.getLiElement(metaData.file);
      }
      var requestResponse = e && e.currentTarget ? this.getResponse(e) : null;
      var eventArgs = {
        event: e,
        file: metaData.file,
        chunkIndex: metaData.chunkIndex,
        totalChunk: chunkCount,
        chunkSize: this.asyncSettings.chunkSize,
        cancel: false,
        response: requestResponse
      };
      this.trigger("chunkFailure", eventArgs, function(eventArgs2) {
        if (!eventArgs2.cancel) {
          if (metaData.retryCount < _this.asyncSettings.retryCount) {
            setTimeout(function() {
              _this.retryRequest(liElement, metaData, custom);
            }, _this.asyncSettings.retryAfterDelay);
          } else {
            if (!isNullOrUndefined(liElement)) {
              var pauseButton = liElement.querySelector("." + PAUSE_UPLOAD) ? liElement.querySelector("." + PAUSE_UPLOAD) : liElement.querySelector("." + RESUME_UPLOAD);
              if (!isNullOrUndefined(pauseButton)) {
                pauseButton.classList.add(RETRY_ICON);
                pauseButton.classList.remove(PAUSE_UPLOAD, RESUME_UPLOAD);
              }
              _this.updateProgressBarClasses(liElement, UPLOAD_FAILED);
              _this.removeProgressbar(liElement, "failure");
              liElement.querySelector(".e-icons").classList.remove(UPLOAD_INPROGRESS);
              var iconElement = liElement.querySelector("." + ABORT_ICON) ? liElement.querySelector("." + ABORT_ICON) : liElement.querySelector("." + REMOVE_ICON);
              iconElement.classList.remove(ABORT_ICON);
              if (!isNullOrUndefined(liElement.querySelector("." + PAUSE_UPLOAD))) {
                detach(liElement.querySelector("." + PAUSE_UPLOAD));
              }
              if (metaData.start > 0) {
                iconElement.classList.add(DELETE_ICON);
                iconElement.setAttribute("title", _this.localizedTexts("delete"));
              } else {
                iconElement.classList.add(REMOVE_ICON);
                iconElement.setAttribute("title", _this.localizedTexts("remove"));
              }
            }
            metaData.retryCount = 0;
            var file_1 = metaData.file;
            var failureMessage = _this.localizedTexts("uploadFailedMessage");
            var args = {
              e,
              response: requestResponse,
              operation: "upload",
              file: _this.updateStatus(file_1, failureMessage, "0", false),
              statusText: failureMessage
            };
            _this.trigger("failure", args, function(args2) {
              _this.updateStatus(file_1, args2.statusText, "0");
              _this.uploadSequential();
              _this.checkActionComplete(true);
            });
          }
        }
      });
    };
    Uploader2.prototype.retryRequest = function(liElement, metaData, custom) {
      if (isNullOrUndefined(this.template) && (isNullOrUndefined(custom) || !custom) && liElement) {
        this.updateProgressBarClasses(liElement, UPLOAD_FAILED);
      }
      metaData.retryCount += 1;
      this.sendRequest(metaData.file, metaData);
    };
    Uploader2.prototype.checkPausePlayAction = function(e) {
      var targetElement2 = e.target;
      var selectedElement = e.target.parentElement;
      var index = this.fileList.indexOf(selectedElement);
      var fileData = this.filesData[index];
      var metaData = this.getCurrentMetaData(fileData);
      if (targetElement2.classList.contains(PAUSE_UPLOAD)) {
        this.pauseUpload(metaData, e);
      } else if (targetElement2.classList.contains(RESUME_UPLOAD)) {
        this.resumeUpload(metaData, e);
      } else if (targetElement2.classList.contains(RETRY_ICON)) {
        if (metaData.file.status === this.localizedTexts("fileUploadCancel")) {
          this.retryUpload(metaData, false);
        } else {
          this.retryUpload(metaData, true);
        }
      }
    };
    Uploader2.prototype.retryUpload = function(metaData, fromcanceledStage) {
      if (fromcanceledStage) {
        metaData.end = metaData.end + this.asyncSettings.chunkSize;
        metaData.start = metaData.start + this.asyncSettings.chunkSize;
        this.sendRequest(metaData.file, metaData);
      } else {
        metaData.file.statusCode = "1";
        metaData.file.status = this.localizedTexts("readyToUploadMessage");
        this.chunkUpload(metaData.file);
      }
      this.getLiElement(metaData.file).classList.add(RESTRICT_RETRY);
    };
    Uploader2.prototype.chunkUploadInProgress = function(e, metaData, custom) {
      var _this = this;
      if (metaData.file.statusCode === "4") {
        return;
      }
      if (metaData.file.statusCode !== "4" && metaData.file.statusCode !== "5") {
        metaData.file.statusCode = "3";
        metaData.file.status = this.localizedTexts("inProgress");
      }
      this.updateMetaData(metaData);
      var liElement = this.getLiElement(metaData.file);
      if (isNullOrUndefined(liElement)) {
        return;
      }
      var retryElement = liElement.querySelector("." + RETRY_ICON);
      if (!isNullOrUndefined(retryElement)) {
        retryElement.classList.add(PAUSE_UPLOAD);
        retryElement.setAttribute("title", this.localizedTexts("pause"));
        retryElement.classList.remove(RETRY_ICON);
      }
      if (!isNullOrUndefined(liElement)) {
        if (!(liElement.querySelectorAll("." + PROGRESS_WRAPPER).length > 0)) {
          var statusElement = liElement.querySelector("." + STATUS);
          if (isNullOrUndefined(this.template)) {
            statusElement.classList.add(UPLOAD_INPROGRESS);
            statusElement.classList.remove(UPLOAD_FAILED);
            this.createProgressBar(liElement);
            this.updateProgressBarClasses(liElement, UPLOAD_INPROGRESS);
          }
          var clearIcon = liElement.querySelector("." + REMOVE_ICON) ? liElement.querySelector("." + REMOVE_ICON) : liElement.querySelector("." + DELETE_ICON);
          if (!isNullOrUndefined(clearIcon)) {
            clearIcon.classList.add(ABORT_ICON);
            clearIcon.setAttribute("title", this.localizedTexts("abort"));
            clearIcon.classList.remove(REMOVE_ICON);
          }
        }
        if (!isNaN(Math.round(e.loaded / e.total * 100)) && isNullOrUndefined(this.template) && metaData.file.statusCode !== "4") {
          var progressVal = undefined;
          var totalChunks = Math.ceil(metaData.file.size / this.asyncSettings.chunkSize) - 1;
          if (this.asyncSettings.chunkSize && totalChunks) {
            progressVal = Math.round(metaData.chunkIndex / totalChunks * 100);
            this.changeProgressValue(liElement, progressVal.toString() + "%");
          }
        }
        if (metaData.chunkIndex === 0) {
          this.checkActionButtonStatus();
        }
      }
      if (isNullOrUndefined(liElement.querySelector("." + PAUSE_UPLOAD)) && isNullOrUndefined(this.template) && isNullOrUndefined(liElement.querySelector("." + DELETE_ICON))) {
        this.pauseButton = this.createElement("span", { className: "e-icons e-file-pause-btn", attrs: { "tabindex": this.btnTabIndex } });
        if (this.browserName === "msie") {
          this.pauseButton.classList.add("e-msie");
        }
        var abortIcon = liElement.querySelector("." + ABORT_ICON);
        abortIcon.parentElement.insertBefore(this.pauseButton, abortIcon);
        this.pauseButton.setAttribute("title", this.localizedTexts("pause"));
        this.pauseButton.addEventListener("click", function(e2) {
          _this.checkPausePlayAction(e2);
        }, false);
      }
    };
    Uploader2.prototype.bytesToSize = function(bytes) {
      var i = -1;
      if (!bytes) {
        return "0.0 KB";
      }
      do {
        bytes = bytes / 1024;
        i++;
      } while (bytes > 99);
      if (i >= 2) {
        bytes = bytes * 1024;
        i = 1;
      }
      return Math.max(bytes, 0).toFixed(1) + " " + ["KB", "MB"][i];
    };
    Uploader2.prototype.sortFileList = function(filesData) {
      filesData = filesData ? filesData : this.sortFilesList;
      var files = filesData;
      var fileNames = [];
      for (var i = 0; i < files.length; i++) {
        fileNames.push(files[i].name);
      }
      var sortedFileNames = fileNames.sort();
      var sortedFilesData = [];
      for (var _i = 0, sortedFileNames_1 = sortedFileNames; _i < sortedFileNames_1.length; _i++) {
        var name_3 = sortedFileNames_1[_i];
        for (var i = 0; i < files.length; i++) {
          if (name_3 === files[i].name) {
            sortedFilesData.push(files[i]);
          }
        }
      }
      return sortedFilesData;
    };
    Uploader2.prototype.destroy = function() {
      this.element.value = null;
      this.clearTemplate();
      this.clearAll();
      this.unWireEvents();
      this.unBindDropEvents();
      if (this.multiple) {
        this.element.removeAttribute("multiple");
      }
      if (!this.enabled) {
        this.element.removeAttribute("disabled");
      }
      this.element.removeAttribute("accept");
      this.setInitialAttributes();
      var attributes2 = ["aria-label", "directory", "webkitdirectory", "tabindex"];
      for (var _i = 0, attributes_2 = attributes2; _i < attributes_2.length; _i++) {
        var key = attributes_2[_i];
        this.element.removeAttribute(key);
      }
      if (!isNullOrUndefined(this.uploadWrapper)) {
        this.uploadWrapper.parentElement.appendChild(this.element);
        detach(this.uploadWrapper);
      }
      this.uploadWrapper = null;
      this.uploadWrapper = null;
      this.browseButton = null;
      this.dropAreaWrapper = null;
      this.dropZoneElement = null;
      this.dropArea = null;
      this.keyboardModule = null;
      this.clearButton = null;
      this.uploadButton = null;
      _super.prototype.destroy.call(this);
    };
    Uploader2.prototype.upload = function(files, custom) {
      var _this = this;
      files = files ? files : this.filesData;
      if (this.sequentialUpload && (this.isFirstFileOnSelection || custom)) {
        this.sequenceUpload(files);
      } else {
        var uploadFiles_1 = this.getFilesInArray(files);
        var eventArgs = {
          customFormData: [],
          currentRequest: null,
          cancel: false
        };
        this.trigger("beforeUpload", eventArgs, function(eventArgs2) {
          if (!eventArgs2.cancel) {
            _this.customFormDatas = eventArgs2.customFormData && eventArgs2.customFormData.length > 0 ? eventArgs2.customFormData : _this.customFormDatas;
            _this.uploadFiles(uploadFiles_1, custom);
          }
        });
      }
    };
    Uploader2.prototype.getFilesInArray = function(files) {
      var uploadFiles = [];
      if (files) {
        if (files instanceof Array) {
          uploadFiles = files;
        } else {
          uploadFiles.push(files);
        }
      }
      return uploadFiles;
    };
    Uploader2.prototype.serverReadFileBase64 = function(fileIndex, position, totalCount) {
      var _this = this;
      return new Promise(function(resolve, reject) {
        var file = _this.fileStreams[fileIndex].rawFile;
        try {
          var reader = new FileReader();
          reader.onload = /* @__PURE__ */ function(args) {
            return function() {
              try {
                var contents = args.result;
                var data = contents ? contents.split(";base64,")[1] : null;
                resolve(data);
              } catch (e) {
                reject(e);
              }
            };
          }(reader);
          reader.readAsDataURL(file.slice(position, position + totalCount));
        } catch (e) {
          reject(e);
        }
      });
    };
    Uploader2.prototype.uploadFileCount = function(ele) {
      var files = this.filesData;
      if (!files || files.length === 0) {
        return -1;
      }
      var result = files.length;
      return result;
    };
    Uploader2.prototype.getFileRead = function(index, ele) {
      var files = this.filesData;
      if (!files || files.length === 0) {
        return -1;
      }
      var file = files[index];
      var fileCount = this.newFileRef++;
      this.fileStreams[fileCount] = file;
      return fileCount;
    };
    Uploader2.prototype.uploadFiles = function(files, custom) {
      var selectedFiles = [];
      if (this.asyncSettings.saveUrl === "" || isNullOrUndefined(this.asyncSettings.saveUrl)) {
        return;
      }
      if (!custom || isNullOrUndefined(custom)) {
        if (!this.multiple) {
          var file = [];
          file.push(files[0]);
          selectedFiles = this.filterfileList(file);
        } else {
          selectedFiles = this.filterfileList(files);
        }
      } else {
        selectedFiles = files;
      }
      for (var i = 0; i < selectedFiles.length; i++) {
        this.uploadFilesRequest(selectedFiles, i, custom);
      }
    };
    Uploader2.prototype.uploadFilesRequest = function(selectedFiles, i, custom) {
      var _this = this;
      var chunkEnabled = this.checkChunkUpload();
      var ajax = new Ajax(this.asyncSettings.saveUrl, "POST", true, null);
      ajax.emitError = false;
      var eventArgs = {
        fileData: selectedFiles[i],
        customFormData: [],
        cancel: false
      };
      var formData = new FormData();
      ajax.beforeSend = function(e) {
        eventArgs.currentRequest = ajax.httpRequest;
        _this.trigger("uploading", eventArgs, function(eventArgs2) {
          if (eventArgs2.cancel) {
            _this.eventCancelByArgs(e, eventArgs2, selectedFiles[i]);
          }
          if (_this.customFormDatas && _this.customFormDatas.length > 0) {
            _this.updateFormData(formData, _this.customFormDatas);
          }
          _this.updateFormData(formData, eventArgs2.customFormData);
        });
      };
      if (selectedFiles[i].statusCode === "1") {
        var name_4 = this.element.getAttribute("name");
        formData.append(name_4, selectedFiles[i].rawFile, selectedFiles[i].name);
        if (chunkEnabled && selectedFiles[i].size > this.asyncSettings.chunkSize) {
          this.chunkUpload(selectedFiles[i], custom, i);
        } else {
          ajax.onLoad = function(e) {
            if (eventArgs.cancel) {
              return {};
            } else {
              _this.uploadComplete(e, selectedFiles[i], custom);
              return {};
            }
          };
          ajax.onUploadProgress = function(e) {
            if (eventArgs.cancel) {
              return {};
            } else {
              _this.uploadInProgress(e, selectedFiles[i], custom, ajax);
              return {};
            }
          };
          ajax.onError = function(e) {
            _this.uploadFailed(e, selectedFiles[i]);
            return {};
          };
          ajax.send(formData);
        }
      }
    };
    Uploader2.prototype.spliceFiles = function(liIndex) {
      var liElement = this.fileList[liIndex];
      var allFiles = this.getFilesData();
      var nameElements = +liElement.getAttribute("data-files-count");
      var startIndex = 0;
      for (var i = 0; i < liIndex; i++) {
        startIndex += +this.fileList[i].getAttribute("data-files-count");
      }
      var endIndex = startIndex + nameElements - 1;
      for (var j = endIndex; j >= startIndex; j--) {
        allFiles.splice(j, 1);
      }
    };
    Uploader2.prototype.remove = function(fileData, customTemplate, removeDirectly, postRawFile, args) {
      var _this = this;
      if (isNullOrUndefined(postRawFile)) {
        postRawFile = true;
      }
      var eventArgs = {
        event: args,
        cancel: false,
        filesData: [],
        customFormData: [],
        postRawFile,
        currentRequest: null
      };
      var beforeEventArgs = {
        cancel: false,
        customFormData: [],
        currentRequest: null
      };
      this.trigger("beforeRemove", beforeEventArgs, function(beforeEventArgs2) {
        if (!beforeEventArgs2.cancel) {
          if (_this.isFormUpload()) {
            eventArgs.filesData = fileData;
            _this.trigger("removing", eventArgs, function(eventArgs2) {
              if (!eventArgs2.cancel) {
                var removingFiles = _this.getFilesInArray(fileData);
                var isLiRemoved = false;
                var liIndex = undefined;
                for (var _i2 = 0, removingFiles_1 = removingFiles; _i2 < removingFiles_1.length; _i2++) {
                  var data = removingFiles_1[_i2];
                  if (!isLiRemoved) {
                    liIndex = _this.fileList.indexOf(data.list);
                  }
                  if (liIndex > -1) {
                    var inputElement = !isNullOrUndefined(data.input) ? data.input : null;
                    if (inputElement) {
                      detach(inputElement);
                    }
                    _this.spliceFiles(liIndex);
                    detach(_this.fileList[liIndex]);
                    _this.fileList.splice(liIndex, 1);
                    isLiRemoved = true;
                    liIndex = -1;
                  }
                }
              }
            });
          } else if (_this.isForm && (isNullOrUndefined(_this.asyncSettings.removeUrl) || _this.asyncSettings.removeUrl === "")) {
            eventArgs.filesData = _this.getFilesData();
            _this.trigger("removing", eventArgs, function(eventArgs2) {
              if (!eventArgs2.cancel) {
                _this.clearAll();
              }
            });
          } else {
            var removeFiles = [];
            fileData = !isNullOrUndefined(fileData) ? fileData : _this.filesData;
            if (fileData instanceof Array) {
              removeFiles = fileData;
            } else {
              removeFiles.push(fileData);
            }
            eventArgs.filesData = removeFiles;
            var removeUrl = _this.asyncSettings.removeUrl;
            var validUrl = removeUrl === "" || isNullOrUndefined(removeUrl) ? false : true;
            var _loop_5 = function(files2) {
              var fileUploadedIndex = _this.uploadedFilesData.indexOf(files2);
              if ((files2.statusCode === "2" || files2.statusCode === "4" || files2.statusCode === "0" && fileUploadedIndex !== -1) && validUrl) {
                _this.removeUploadedFile(files2, eventArgs, removeDirectly, customTemplate);
              } else {
                if (!removeDirectly) {
                  _this.trigger("removing", eventArgs, function(eventArgs2) {
                    if (!eventArgs2.cancel) {
                      _this.removeFilesData(files2, customTemplate);
                    }
                  });
                } else {
                  _this.removeFilesData(files2, customTemplate);
                }
              }
              if (args && !args.target.classList.contains(REMOVE_ICON)) {
                _this.checkActionComplete(false);
              }
            };
            for (var _i = 0, removeFiles_1 = removeFiles; _i < removeFiles_1.length; _i++) {
              var files = removeFiles_1[_i];
              _loop_5(files);
            }
          }
        }
      });
    };
    Uploader2.prototype.clearAll = function() {
      var _this = this;
      if (isNullOrUndefined(this.listParent)) {
        if (this.browserName !== "msie") {
          this.element.value = "";
        }
        this.filesData = [];
        return;
      }
      var eventArgs = {
        cancel: false,
        filesData: this.filesData
      };
      this.trigger("clearing", eventArgs, function(eventArgs2) {
        if (!eventArgs2.cancel) {
          _this.clearData();
          _this.actionCompleteCount = 0;
          _this.count = -1;
        }
      });
    };
    Uploader2.prototype.getFilesData = function(index) {
      if (isNullOrUndefined(index)) {
        return this.filesData;
      } else {
        return this.getSelectedFiles(index);
      }
    };
    Uploader2.prototype.pause = function(fileData, custom) {
      fileData = fileData ? fileData : this.filesData;
      var fileDataFiles = this.getFilesInArray(fileData);
      this.pauseUploading(fileDataFiles, custom);
    };
    Uploader2.prototype.pauseUploading = function(fileData, custom) {
      var files = this.getFiles(fileData);
      for (var i = 0; i < files.length; i++) {
        if (files[i].statusCode === "3") {
          this.pauseUpload(this.getCurrentMetaData(files[i], null), null, custom);
        }
      }
    };
    Uploader2.prototype.getFiles = function(fileData) {
      var files = [];
      if (!isNullOrUndefined(fileData) && !(fileData instanceof Array)) {
        files.push(fileData);
      } else {
        files = fileData;
      }
      return files;
    };
    Uploader2.prototype.resume = function(fileData, custom) {
      fileData = fileData ? fileData : this.filesData;
      var fileDataFiles = this.getFilesInArray(fileData);
      this.resumeFiles(fileDataFiles, custom);
    };
    Uploader2.prototype.resumeFiles = function(fileData, custom) {
      var files = this.getFiles(fileData);
      for (var i = 0; i < files.length; i++) {
        if (files[i].statusCode === "4") {
          this.resumeUpload(this.getCurrentMetaData(files[i], null), null, custom);
        }
      }
    };
    Uploader2.prototype.retry = function(fileData, fromcanceledStage, custom) {
      fileData = fileData ? fileData : this.filesData;
      var fileDataFiles = this.getFilesInArray(fileData);
      if (this.sequentialUpload && this.isFirstFileOnSelection) {
        this.isFirstFileOnSelection = false;
      }
      this.retryFailedFiles(fileDataFiles, fromcanceledStage, custom);
    };
    Uploader2.prototype.retryFailedFiles = function(fileData, fromcanceledStage, custom) {
      var files = this.getFiles(fileData);
      for (var i = 0; i < files.length; i++) {
        if (files[i].statusCode === "5" || files[i].statusCode === "0") {
          if (this.asyncSettings.chunkSize > 0 && this.getCurrentMetaData(files[i], null)) {
            this.retryUpload(this.getCurrentMetaData(files[i], null), fromcanceledStage);
          } else {
            var liElement = undefined;
            if (!custom) {
              liElement = this.fileList[this.filesData.indexOf(files[i])];
            }
            this.reloadcanceledFile(null, files[i], liElement, custom);
          }
        }
      }
    };
    Uploader2.prototype.cancel = function(fileData) {
      fileData = fileData ? fileData : this.filesData;
      var cancelingFiles = this.getFilesInArray(fileData);
      this.cancelUpload(cancelingFiles);
    };
    Uploader2.prototype.cancelUpload = function(fileData) {
      var files = this.getFiles(fileData);
      if (this.asyncSettings.chunkSize > 0) {
        for (var i = 0; i < files.length; i++) {
          if (files[i].statusCode === "3") {
            var metaData = this.getCurrentMetaData(files[i], null);
            metaData.file.statusCode = "5";
            metaData.file.status = this.localizedTexts("fileUploadCancel");
            this.updateMetaData(metaData);
            this.showHideUploadSpinner(files[i]);
          }
        }
      } else {
        for (var i = 0; i < files.length; i++) {
          if (files[i].statusCode === "3") {
            files[i].statusCode = "5";
            files[i].status = this.localizedTexts("fileUploadCancel");
            this.showHideUploadSpinner(files[i]);
          }
        }
      }
    };
    Uploader2.prototype.showHideUploadSpinner = function(files) {
      var liElement = this.getLiElement(files);
      if (!isNullOrUndefined(liElement) && isNullOrUndefined(this.template)) {
        var spinnerTarget = liElement.querySelector("." + ABORT_ICON);
        createSpinner({ target: spinnerTarget, width: "20px" });
        showSpinner(spinnerTarget);
      }
    };
    __decorate$9([
      Complex({ saveUrl: "", removeUrl: "" }, AsyncSettings)
    ], Uploader2.prototype, "asyncSettings", undefined);
    __decorate$9([
      Property(false)
    ], Uploader2.prototype, "sequentialUpload", undefined);
    __decorate$9([
      Property({})
    ], Uploader2.prototype, "htmlAttributes", undefined);
    __decorate$9([
      Property("")
    ], Uploader2.prototype, "cssClass", undefined);
    __decorate$9([
      Property(true)
    ], Uploader2.prototype, "enabled", undefined);
    __decorate$9([
      Property(null)
    ], Uploader2.prototype, "template", undefined);
    __decorate$9([
      Property(true)
    ], Uploader2.prototype, "multiple", undefined);
    __decorate$9([
      Property(true)
    ], Uploader2.prototype, "autoUpload", undefined);
    __decorate$9([
      Property(true)
    ], Uploader2.prototype, "enableHtmlSanitizer", undefined);
    __decorate$9([
      Complex({}, ButtonsProps)
    ], Uploader2.prototype, "buttons", undefined);
    __decorate$9([
      Property("")
    ], Uploader2.prototype, "allowedExtensions", undefined);
    __decorate$9([
      Property(0)
    ], Uploader2.prototype, "minFileSize", undefined);
    __decorate$9([
      Property(3e7)
    ], Uploader2.prototype, "maxFileSize", undefined);
    __decorate$9([
      Property(null)
    ], Uploader2.prototype, "dropArea", undefined);
    __decorate$9([
      Collection([{}], FilesProp)
    ], Uploader2.prototype, "files", undefined);
    __decorate$9([
      Property(true)
    ], Uploader2.prototype, "showFileList", undefined);
    __decorate$9([
      Property(false)
    ], Uploader2.prototype, "directoryUpload", undefined);
    __decorate$9([
      Property("Default")
    ], Uploader2.prototype, "dropEffect", undefined);
    __decorate$9([
      Event()
    ], Uploader2.prototype, "created", undefined);
    __decorate$9([
      Event()
    ], Uploader2.prototype, "actionComplete", undefined);
    __decorate$9([
      Event()
    ], Uploader2.prototype, "rendering", undefined);
    __decorate$9([
      Event()
    ], Uploader2.prototype, "beforeUpload", undefined);
    __decorate$9([
      Event()
    ], Uploader2.prototype, "fileListRendering", undefined);
    __decorate$9([
      Event()
    ], Uploader2.prototype, "selected", undefined);
    __decorate$9([
      Event()
    ], Uploader2.prototype, "uploading", undefined);
    __decorate$9([
      Event()
    ], Uploader2.prototype, "success", undefined);
    __decorate$9([
      Event()
    ], Uploader2.prototype, "failure", undefined);
    __decorate$9([
      Event()
    ], Uploader2.prototype, "removing", undefined);
    __decorate$9([
      Event()
    ], Uploader2.prototype, "beforeRemove", undefined);
    __decorate$9([
      Event()
    ], Uploader2.prototype, "clearing", undefined);
    __decorate$9([
      Event()
    ], Uploader2.prototype, "progress", undefined);
    __decorate$9([
      Event()
    ], Uploader2.prototype, "change", undefined);
    __decorate$9([
      Event()
    ], Uploader2.prototype, "chunkSuccess", undefined);
    __decorate$9([
      Event()
    ], Uploader2.prototype, "chunkFailure", undefined);
    __decorate$9([
      Event()
    ], Uploader2.prototype, "chunkUploading", undefined);
    __decorate$9([
      Event()
    ], Uploader2.prototype, "canceling", undefined);
    __decorate$9([
      Event()
    ], Uploader2.prototype, "pausing", undefined);
    __decorate$9([
      Event()
    ], Uploader2.prototype, "resuming", undefined);
    Uploader2 = __decorate$9([
      NotifyPropertyChanges
    ], Uploader2);
    return Uploader2;
  }(Component)
);
var __extends$8 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate$8 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
function getModel(props2, model) {
  var obj = extend({}, props2);
  for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {
    var prop = _a[_i];
    if (model.indexOf(prop) < 0) {
      deleteObject(obj, prop);
    }
  }
  return obj;
}
function upDownKeyHandler(ul, keyCode2) {
  var defaultIdx = keyCode2 === 40 ? 0 : ul.childElementCount - 1;
  var liIdx = defaultIdx;
  var li;
  var selectedLi = ul.querySelector(".e-selected");
  if (selectedLi) {
    selectedLi.classList.remove("e-selected");
  }
  for (var i = 0, len = ul.children.length; i < len; i++) {
    if (ul.children[i].classList.contains("e-focused")) {
      li = ul.children[i];
      liIdx = i;
      li.classList.remove("e-focused");
      if (keyCode2 === 40) {
        liIdx++;
      } else {
        liIdx--;
      }
      if (liIdx === (keyCode2 === 40 ? ul.childElementCount : -1)) {
        liIdx = defaultIdx;
      }
    }
  }
  li = ul.children[liIdx];
  liIdx = isValidLI(ul, li, liIdx, keyCode2);
  if (liIdx !== -1) {
    addClass([ul.children[liIdx]], "e-focused");
    ul.children[liIdx].focus();
  }
}
function isValidLI(ul, li, index, keyCode2, count) {
  if (count === undefined) {
    count = 0;
  }
  if (li.classList.contains("e-separator") || li.classList.contains("e-disabled")) {
    if (index === (keyCode2 === 40 ? ul.childElementCount - 1 : 0)) {
      index = keyCode2 === 40 ? 0 : ul.childElementCount - 1;
    } else {
      if (keyCode2 === 40) {
        index++;
      } else {
        index--;
      }
    }
  }
  li = ul.children[index];
  if (li.classList.contains("e-separator") || li.classList.contains("e-disabled")) {
    count++;
    if (count === ul.childElementCount) {
      return index = -1;
    }
    index = isValidLI(ul, li, index, keyCode2, count);
  }
  return index;
}
function setBlankIconStyle(popup, blankIcon) {
  var blankIconList = [].slice.call(popup.getElementsByClassName("e-blank-icon"));
  if (!blankIconList.length) {
    return;
  }
  var iconLi = popup.querySelector(".e-item:not(.e-blank-icon):not(.e-separator)");
  if (isNullOrUndefined(iconLi)) {
    return;
  }
  if (iconLi.classList.contains("e-url")) {
    iconLi = iconLi.querySelector(".e-menu-url");
  }
  var icon = iconLi.querySelector(".e-menu-icon");
  var cssProp;
  var enableRtl = popup.classList.contains("e-rtl");
  if (enableRtl) {
    cssProp = { padding: "paddingRight", margin: "marginLeft" };
  } else {
    cssProp = { padding: "paddingLeft", margin: "marginRight" };
  }
  var size = parseInt(getComputedStyle(icon).fontSize, 10) + parseInt(enableRtl ? getComputedStyle(icon)[cssProp.margin] : getComputedStyle(icon)[cssProp.margin], 10) + parseInt(getComputedStyle(iconLi).paddingLeft, 10) + "px";
  blankIconList.forEach(function(li) {
    if (li.classList.contains("e-url") && li.querySelector(".e-menu-url")) {
      li.querySelector(".e-menu-url").style[cssProp.padding] = size;
    } else {
      li.style[cssProp.padding] = size;
    }
  });
}
var Item$1 = (
  /** @class */
  function(_super) {
    __extends$8(Item2, _super);
    function Item2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$8([
      Property("")
    ], Item2.prototype, "iconCss", undefined);
    __decorate$8([
      Property("")
    ], Item2.prototype, "id", undefined);
    __decorate$8([
      Property(false)
    ], Item2.prototype, "separator", undefined);
    __decorate$8([
      Property("")
    ], Item2.prototype, "text", undefined);
    __decorate$8([
      Property("")
    ], Item2.prototype, "url", undefined);
    __decorate$8([
      Property(false)
    ], Item2.prototype, "disabled", undefined);
    return Item2;
  }(ChildProperty)
);
var __extends$7 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate$7 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var classNames = {
  DISABLED: "e-disabled",
  FOCUS: "e-focused",
  ICON: "e-menu-icon",
  ITEM: "e-item",
  POPUP: "e-dropdown-popup",
  RTL: "e-rtl",
  SEPARATOR: "e-separator",
  VERTICAL: "e-vertical",
  POPUPWIDTH: "e-dropdown-popup-width"
};
var DropDownMenuAnimationSettings = (
  /** @class */
  function(_super) {
    __extends$7(DropDownMenuAnimationSettings2, _super);
    function DropDownMenuAnimationSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$7([
      Property("SlideDown")
    ], DropDownMenuAnimationSettings2.prototype, "effect", undefined);
    __decorate$7([
      Property(400)
    ], DropDownMenuAnimationSettings2.prototype, "duration", undefined);
    __decorate$7([
      Property("ease")
    ], DropDownMenuAnimationSettings2.prototype, "easing", undefined);
    return DropDownMenuAnimationSettings2;
  }(ChildProperty)
);
var DropDownButton = (
  /** @class */
  function(_super) {
    __extends$7(DropDownButton2, _super);
    function DropDownButton2(options, element2) {
      var _this = _super.call(this, options, element2) || this;
      _this.isPopupCreated = true;
      return _this;
    }
    DropDownButton2.prototype.preRender = function() {
    };
    DropDownButton2.prototype.getPersistData = function() {
      return this.addOnPersist([]);
    };
    DropDownButton2.prototype.toggle = function() {
      if (this.canOpen()) {
        this.openPopUp();
      } else if (this.createPopupOnClick && !this.isPopupCreated) {
        this.createPopup();
        this.openPopUp();
      } else {
        this.closePopup();
      }
    };
    DropDownButton2.prototype.render = function() {
      this.initialize();
      if (!this.disabled) {
        this.wireEvents();
      }
      this.renderComplete();
    };
    DropDownButton2.prototype.addItems = function(items, text) {
      var newItem;
      var idx = this.items.length;
      for (var j = 0, len = this.items.length; j < len; j++) {
        if (text === this.items[j].text) {
          idx = j;
          break;
        }
      }
      for (var i = items.length - 1; i >= 0; i--) {
        newItem = new Item$1(this, "items", items[i], true);
        this.items.splice(idx, 0, newItem);
      }
      if (!this.canOpen()) {
        this.createItems();
      }
    };
    DropDownButton2.prototype.removeItems = function(items, isUniqueId) {
      var refresh = false;
      for (var i = 0, len = items.length; i < len; i++) {
        for (var j = 0, len_1 = this.items.length; j < len_1; j++) {
          if (items[i] === (isUniqueId ? this.items[j].id : this.items[j].text)) {
            this.items.splice(j, 1);
            refresh = true;
            break;
          }
        }
      }
      if (refresh && this.getULElement()) {
        this.createItems();
      }
    };
    DropDownButton2.prototype.createPopup = function() {
      var _a;
      var div = this.createElement("div", {
        className: this.popupWidth !== "auto" ? classNames.POPUP + " " + classNames.POPUPWIDTH : classNames.POPUP,
        id: this.element.id + "-popup"
      });
      (undefined).body.appendChild(div);
      this.dropDown = new Popup(div, {
        width: this.popupWidth,
        relateTo: this.element,
        collision: { X: "fit", Y: "flip" },
        position: { X: "left", Y: "bottom" },
        targetType: "relative",
        content: this.target ? this.getTargetElement() : "",
        enableRtl: this.enableRtl
      });
      this.dropDown.element.setAttribute("role", "dialog");
      this.dropDown.element.setAttribute("aria-label", "dropdown menu");
      if (!isNullOrUndefined(this.popupContent)) {
        this.popupContent.style.display = "";
      }
      if (this.dropDown.element.style.position === "fixed") {
        this.dropDown.refreshPosition(this.element);
      }
      this.dropDown.hide();
      attributes(this.element, (_a = {}, _a["aria-haspopup"] = this.items.length || this.target ? "true" : "false", _a["aria-expanded"] = "false", _a["type"] = "button", _a));
      if (this.cssClass) {
        addClass([div], this.cssClass.replace(/\s+/g, " ").trim().split(" "));
      }
      this.isPopupCreated = true;
      if (this.createPopupOnClick) {
        var splitButton = getComponent(this.activeElem[0], "split-btn");
        if (splitButton) {
          splitButton.isPopupCreated = true;
        }
      }
    };
    DropDownButton2.prototype.getTargetElement = function() {
      if (this.createPopupOnClick && !this.isColorPicker() && !isNullOrUndefined(this.popupContent)) {
        return this.popupContent;
      }
      return typeof this.target === "string" ? select(this.target) : this.target;
    };
    DropDownButton2.prototype.createItems = function(appendItems) {
      var _this = this;
      var items = this.items;
      var showIcon = this.hasIcon(this.items, "iconCss");
      var span;
      var item;
      var li;
      var eventArgs;
      var ul = this.getULElement();
      if (ul) {
        ul.innerHTML = "";
      } else {
        ul = this.createElement("ul", {
          attrs: { "role": "menu", "tabindex": "0" }
        });
      }
      if (this.itemTemplate) {
        var compiledTemplate_1 = this.compiletemplate(this.itemTemplate);
        items.forEach(function(item2) {
          var li2 = _this.createElement("li", {
            className: item2.separator ? classNames.ITEM + " " + classNames.SEPARATOR : classNames.ITEM,
            attrs: item2.separator ? { "role": "separator", "tabindex": "-1", "aria-label": "separator", "aria-hidden": "true" } : { "role": "menuitem", "tabindex": "-1", "aria-label": item2.text },
            id: item2.id ? item2.id : getUniqueID("e-" + _this.getModuleName() + "-item")
          });
          var compiledElement = compiledTemplate_1(item2, _this, "template", null, false, null, li2);
          if (compiledElement) {
            append(compiledElement, li2);
          }
          if (item2.disabled) {
            li2.classList.add("e-disabled");
          }
          var eventArgs2 = { item: item2, element: li2 };
          _this.trigger("beforeItemRender", eventArgs2);
          if (eventArgs2.item.disabled !== item2.disabled) {
            li2.classList[eventArgs2.item.disabled ? "add" : "remove"]("e-disabled");
          }
          ul.appendChild(li2);
        });
        if (this.isReact) {
          this.renderReactTemplates();
        }
      } else {
        for (var i = 0; i < items.length; i++) {
          item = items[i];
          if (this.enableHtmlSanitizer) {
            item.text = SanitizeHtmlHelper.sanitize(item.text);
          }
          var tempItem = item.text;
          li = this.createElement("li", {
            innerHTML: item.url ? "" : tempItem,
            className: item.separator ? classNames.ITEM + " " + classNames.SEPARATOR : classNames.ITEM,
            attrs: item.separator ? { "role": "separator", "tabindex": "-1", "aria-label": "separator", "aria-hidden": "true" } : { "role": "menuitem", "tabindex": "-1", "aria-label": tempItem },
            id: item.id ? item.id : getUniqueID("e-" + this.getModuleName() + "-item")
          });
          if (this.enableHtmlSanitizer) {
            li.textContent = item.url ? "" : tempItem;
          } else {
            li.innerHTML = item.url ? "" : tempItem;
          }
          if (item.url) {
            li.appendChild(this.createAnchor(item));
            li.classList.add("e-url");
          }
          if (item.iconCss) {
            span = this.createElement("span", { className: classNames.ICON + " " + item.iconCss });
            if (item.url) {
              li.childNodes[0].appendChild(span);
            } else {
              li.insertBefore(span, li.childNodes[0]);
            }
          } else {
            if (showIcon && !item.separator) {
              li.classList.add("e-blank-icon");
            }
          }
          var beforeDisabled = item.disabled;
          if (item.disabled) {
            li.classList.add("e-disabled");
          }
          eventArgs = { item, element: li };
          this.trigger("beforeItemRender", eventArgs);
          var afterDisabled = eventArgs.item.disabled;
          if (beforeDisabled !== afterDisabled) {
            if (eventArgs.item.disabled) {
              li.classList.add("e-disabled");
            } else {
              li.classList.remove("e-disabled");
            }
          }
          ul.appendChild(li);
        }
      }
      if (appendItems) {
        this.getPopUpElement().appendChild(ul);
      }
      if (showIcon) {
        setBlankIconStyle(this.getPopUpElement());
      }
    };
    DropDownButton2.prototype.compiletemplate = function(template) {
      if (!this.itemTemplate) {
        return undefined;
      }
      try {
        if (typeof this.itemTemplate !== "function") {
          var templateElement = (void 0).querySelector(this.itemTemplate);
          if (templateElement) {
            return compile$1(templateElement.innerHTML.trim());
          }
        }
        return compile$1(template);
      } catch (_a) {
        return compile$1(template);
      }
    };
    DropDownButton2.prototype.hasIcon = function(items, field) {
      for (var i = 0, len = items.length; i < len; i++) {
        if (items[i]["" + field]) {
          return true;
        }
      }
      return false;
    };
    DropDownButton2.prototype.createAnchor = function(item) {
      var tempItem = item.text;
      var anchor = this.createElement("a", { className: "e-menu-text e-menu-url", attrs: { "href": item.url } });
      if (this.enableHtmlSanitizer) {
        anchor.textContent = tempItem;
      } else {
        anchor.innerHTML = tempItem;
      }
      return anchor;
    };
    DropDownButton2.prototype.initialize = function() {
      this.button = new Button({
        iconCss: this.iconCss,
        iconPosition: this.iconPosition,
        cssClass: this.cssClass,
        content: this.content,
        disabled: this.disabled,
        enableRtl: this.enableRtl,
        enablePersistence: this.enablePersistence
      });
      this.button.createElement = this.createElement;
      this.button.appendTo(this.element);
      if (!this.element.id) {
        this.element.id = getUniqueID("e-" + this.getModuleName());
      }
      this.appendArrowSpan();
      this.setActiveElem([this.element]);
      this.element.setAttribute("tabindex", "0");
      this.element.setAttribute("aria-label", this.element.textContent ? this.element.textContent : "dropdownbutton");
      if (this.target && !this.isColorPicker() && !this.createPopupOnClick || !this.createPopupOnClick) {
        this.createPopup();
      } else {
        this.isPopupCreated = false;
        if (this.target && !this.isColorPicker() && this.createPopupOnClick) {
          this.popupContent = this.getTargetElement();
          this.popupContent.style.display = "none";
        }
      }
    };
    DropDownButton2.prototype.isColorPicker = function() {
      if (!this.element) {
        return false;
      }
      var prevElem = this.element.previousSibling;
      if (prevElem && prevElem.classList && prevElem.classList.contains("e-split-colorpicker")) {
        return true;
      }
      return false;
    };
    DropDownButton2.prototype.appendArrowSpan = function() {
      this.cssClass = isNullOrUndefined(this.cssClass) ? "" : this.cssClass;
      this.element.appendChild(this.createElement("span", {
        className: "e-btn-icon e-icons e-icon-" + (this.cssClass.indexOf(classNames.VERTICAL) > -1 ? "bottom" : "right") + " e-caret"
      }));
    };
    DropDownButton2.prototype.setActiveElem = function(elem) {
      this.activeElem = elem;
    };
    DropDownButton2.prototype.getModuleName = function() {
      return "dropdown-btn";
    };
    DropDownButton2.prototype.canOpen = function() {
      var val = false;
      if (this.isPopupCreated) {
        val = this.getPopUpElement().classList.contains("e-popup-close");
      }
      return val;
    };
    DropDownButton2.prototype.destroy = function() {
      var _this = this;
      _super.prototype.destroy.call(this);
      if (this.getModuleName() === "dropdown-btn") {
        var classList_1;
        if (this.element.querySelector("span.e-caret")) {
          detach(this.element.querySelector("span.e-caret"));
        }
        if (this.cssClass) {
          classList_1 = this.cssClass.split(" ");
        }
        this.button.destroy();
        if (classList_1) {
          removeClass([this.element], classList_1);
        }
        removeClass(this.activeElem, ["e-active"]);
        var attrList = this.element.getAttribute("class") ? ["aria-haspopup", "aria-expanded", "aria-owns", "type"] : ["aria-haspopup", "aria-expanded", "aria-owns", "type", "class"];
        attrList.forEach(function(key) {
          _this.element.removeAttribute(key);
        });
        this.popupUnWireEvents();
        this.destroyPopup();
        this.isPopupCreated = false;
        if (!this.disabled) {
          this.unWireEvents();
        }
      }
    };
    DropDownButton2.prototype.destroyPopup = function() {
      if (this.isPopupCreated) {
        this.dropDown.destroy();
        if (this.getPopUpElement()) {
          var popupEle = (undefined).getElementById(this.getPopUpElement().id);
          if (popupEle) {
            removeClass([popupEle], ["e-popup-open", "e-popup-close"]);
            detach(popupEle);
          }
        }
        EventHandler.remove(this.getPopUpElement(), "click", this.clickHandler);
        EventHandler.remove(this.getPopUpElement(), "keydown", this.keyBoardHandler);
        if (this.isPopupCreated && this.dropDown) {
          this.dropDown.element = null;
          this.dropDown = undefined;
        }
      }
      this.isPopupCreated = false;
      var splitButton = getComponent(this.activeElem[0], "split-btn");
      if (this.createPopupOnClick && splitButton) {
        var dropDownButton = getComponent(this.activeElem[1], "dropdown-btn");
        if (dropDownButton) {
          dropDownButton.isPopupCreated = false;
        }
      }
    };
    DropDownButton2.prototype.getPopUpElement = function() {
      var val = null;
      if (!this.dropDown && this.activeElem[0].classList.contains("e-split-btn")) {
        var dropDownBtn = getComponent(this.activeElem[1], "dropdown-btn");
        if (dropDownBtn) {
          this.dropDown = dropDownBtn.dropDown;
        }
      }
      if (this.dropDown) {
        val = this.dropDown.element;
      }
      return val;
    };
    DropDownButton2.prototype.getULElement = function() {
      var val = null;
      if (this.getPopUpElement()) {
        val = this.getPopUpElement().children[0];
      }
      return val;
    };
    DropDownButton2.prototype.wireEvents = function() {
      this.delegateMousedownHandler = this.mousedownHandler.bind(this);
      if (!this.createPopupOnClick) {
        EventHandler.add(undefined, "mousedown touchstart", this.delegateMousedownHandler, this);
      }
      EventHandler.add(this.element, "click", this.clickHandler, this);
      EventHandler.add(this.element, "keydown", this.keyBoardHandler, this);
      EventHandler.add(undefined, "resize", this.windowResize, this);
    };
    DropDownButton2.prototype.windowResize = function() {
      if (!this.canOpen() && this.dropDown) {
        this.dropDown.refreshPosition(this.element);
      }
    };
    DropDownButton2.prototype.popupWireEvents = function() {
      if (!this.delegateMousedownHandler) {
        this.delegateMousedownHandler = this.mousedownHandler.bind(this);
      }
      var popupElement = this.getPopUpElement();
      if (this.createPopupOnClick) {
        EventHandler.add(undefined, "mousedown touchstart", this.delegateMousedownHandler, this);
      }
      if (popupElement) {
        EventHandler.add(popupElement, "click", this.clickHandler, this);
        EventHandler.add(popupElement, "keydown", this.keyBoardHandler, this);
        if (this.closeActionEvents) {
          EventHandler.add(popupElement, this.closeActionEvents, this.focusoutHandler, this);
        }
      }
      this.rippleFn = rippleEffect(popupElement, { selector: "." + classNames.ITEM });
    };
    DropDownButton2.prototype.popupUnWireEvents = function() {
      var popupElement = this.getPopUpElement();
      if (this.createPopupOnClick) {
        EventHandler.remove(undefined, "mousedown touchstart", this.delegateMousedownHandler);
      }
      if (popupElement && popupElement.parentElement) {
        EventHandler.remove(popupElement, "click", this.clickHandler);
        EventHandler.remove(popupElement, "keydown", this.keyBoardHandler);
        if (this.closeActionEvents) {
          EventHandler.remove(popupElement, this.closeActionEvents, this.focusoutHandler);
        }
      }
    };
    DropDownButton2.prototype.keyBoardHandler = function(e) {
      if (e.target === this.element && (e.keyCode === 9 || !e.altKey && e.keyCode === 40 || e.keyCode === 38)) {
        return;
      }
      if (e.target && (e.target.classList.contains("e-item") || e.target.parentElement && e.target.parentElement.classList.contains("e-split-btn-wrapper")) && e.keyCode === 13) {
        e.preventDefault();
      }
      switch (e.keyCode) {
        case 38:
        case 40:
          if (e.altKey && (e.keyCode === 38 || e.keyCode === 40)) {
            this.keyEventHandler(e);
          } else {
            this.upDownKeyHandler(e);
          }
          break;
        case 9:
        case 13:
        case 27:
        case 32:
          this.keyEventHandler(e);
          break;
      }
    };
    DropDownButton2.prototype.isSafari = function() {
      return /^((?!chrome|android).)*safari/i.test((undefined).userAgent);
    };
    DropDownButton2.prototype.upDownKeyHandler = function(e) {
      if (this.target && (e.keyCode === 38 || e.keyCode === 40)) {
        return;
      }
      e.preventDefault();
      upDownKeyHandler(this.getULElement(), e.keyCode);
    };
    DropDownButton2.prototype.keyEventHandler = function(e) {
      if (this.target && (e.keyCode === 13 || e.keyCode === 9)) {
        return;
      }
      if (e.keyCode === 13 && this.activeElem[0].classList.contains("e-split-btn")) {
        this.triggerSelect(e);
        this.activeElem[0].focus();
        return;
      }
      if (e.target && e.target.className.indexOf("e-edit-template") > -1 && e.keyCode === 32) {
        return;
      }
      if (e.keyCode !== 9) {
        e.preventDefault();
      }
      if (e.keyCode === 27 || e.keyCode === 38 || e.keyCode === 9) {
        if (!this.canOpen()) {
          this.closePopup(e, this.element);
        }
      } else {
        this.clickHandler(e);
      }
    };
    DropDownButton2.prototype.getLI = function(elem) {
      return elem.tagName === "LI" ? elem : closest(elem, "li");
    };
    DropDownButton2.prototype.mousedownHandler = function(e) {
      var trgt = e.target;
      if (this.dropDown && !this.canOpen() && this.getPopUpElement() && !(closest(trgt, '[id="' + this.getPopUpElement().id + '"]') || closest(trgt, '[id="' + this.element.id + '"]'))) {
        this.closePopup(e);
      }
    };
    DropDownButton2.prototype.focusoutHandler = function(e) {
      if (this.isPopupCreated && !this.canOpen()) {
        var liTarget = e.relatedTarget || e.target;
        if (liTarget && liTarget.className.indexOf("e-item") > -1) {
          var li = this.getLI(liTarget);
          if (li) {
            var liIdx = Array.prototype.indexOf.call(this.getULElement().children, li);
            var item = this.items[liIdx];
            if (item) {
              var selectEventArgs = { element: li, item, event: e };
              this.trigger("select", selectEventArgs);
            }
          }
        }
        this.closePopup(e);
      }
    };
    DropDownButton2.prototype.clickHandler = function(e) {
      var trgt = e.target;
      if (closest(trgt, '[id="' + this.element.id + '"]')) {
        if (!this.createPopupOnClick || this.target && this.target !== "" && !this.isColorPicker() && !this.createPopupOnClick) {
          if (this.getPopUpElement().classList.contains("e-popup-close")) {
            this.openPopUp(e);
          } else {
            this.closePopup(e);
          }
        } else if (this.isPopupCreated) {
          this.closePopup(e, this.activeElem[0]);
        } else {
          this.createPopup();
          this.openPopUp(e);
        }
      } else {
        if (closest(trgt, '[id="' + this.getPopUpElement().id + '"]')) {
          var li = this.getLI(e.target);
          if (li) {
            this.triggerSelect(e);
            this.closePopup(e, this.activeElem[0]);
          }
        }
      }
    };
    DropDownButton2.prototype.triggerSelect = function(e) {
      var eventArgs;
      var liIdx;
      var item;
      var li = this.getLI(e.target);
      if (li) {
        liIdx = Array.prototype.indexOf.call(this.getULElement().children, li);
        item = this.items[liIdx];
        if (item) {
          eventArgs = { element: li, item, event: e };
          this.trigger("select", eventArgs);
        }
      }
    };
    DropDownButton2.prototype.openPopUp = function(e) {
      var _this = this;
      if (e === undefined) {
        e = null;
      }
      var popupElem = this.getPopUpElement();
      if (this.activeElem[0] && this.activeElem[0].classList.contains("e-dropdown-btn") && popupElem.style.width && popupElem.style.width !== "auto") {
        this.setWidth(popupElem);
      }
      if (!this.target) {
        this.createItems(true);
      } else {
        if (this.activeElem.length > 1) {
          var splitButton = getComponent(this.activeElem[0], "split-btn");
          if (splitButton.isReact && popupElem.childNodes.length < 1) {
            if (splitButton.appendReactElement) {
              splitButton.appendReactElement(this.getTargetElement(), this.getPopUpElement());
            }
            this.renderReactTemplates();
          }
        } else {
          if (this.isReact && popupElem.childNodes.length < 1) {
            if (this.appendReactElement) {
              this.appendReactElement(this.getTargetElement(), this.getPopUpElement());
            }
            this.renderReactTemplates();
          }
        }
      }
      var ul = this.getULElement();
      this.popupWireEvents();
      var beforeOpenArgs = { element: ul, items: this.items, event: e, cancel: false };
      this.trigger("beforeOpen", beforeOpenArgs, function(observedArgs) {
        if (!observedArgs.cancel) {
          var ul_1 = _this.getULElement();
          var animationOptions = _this.animationSettings.effect !== "None" ? {
            name: _this.animationSettings.effect,
            duration: _this.animationSettings.duration,
            timingFunction: _this.animationSettings.easing
          } : null;
          if (animationOptions) {
            _this.animatePopup(animationOptions, ul_1);
          }
          _this.dropDown.show(null, _this.element);
          addClass([_this.element], "e-active");
          _this.element.setAttribute("aria-expanded", "true");
          _this.element.setAttribute("aria-owns", _this.getPopUpElement().id);
          if (ul_1 && !_this.isSafari()) {
            ul_1.focus();
          }
          if (_this.enableRtl && ul_1.parentElement.style.left !== "0px") {
            var wrapperWidth = undefined;
            if (_this.element.parentElement && _this.element.parentElement.classList.contains("e-split-btn-wrapper")) {
              wrapperWidth = _this.element.parentElement.offsetWidth;
            } else {
              wrapperWidth = _this.element.offsetWidth;
            }
            var popupRect2 = ul_1.parentElement.offsetWidth - wrapperWidth;
            var popupLeft = parseFloat(ul_1.parentElement.style.left) - popupRect2;
            if (popupLeft < 0) {
              popupLeft = 0;
            }
            ul_1.parentElement.style.left = popupLeft + "px";
          }
          var openArgs = { element: ul_1, items: _this.items };
          _this.trigger("open", openArgs);
          if (ul_1 && _this.isSafari()) {
            ul_1.focus();
          }
        }
      });
    };
    DropDownButton2.prototype.animatePopup = function(animationOptions, element2) {
      new Animation$1(animationOptions).animate(element2, {
        begin: function(args) {
          args.element.parentElement.style.height = args.element.parentElement.offsetHeight + "px";
        }
      });
    };
    DropDownButton2.prototype.setWidth = function(popupElem) {
      var width = formatUnit(popupElem.style.width);
      if (width.indexOf("%") > -1) {
        var btnWidth = this.element.offsetWidth * parseFloat(width) / 100;
        popupElem.style.width = btnWidth + "px";
      }
    };
    DropDownButton2.prototype.closePopup = function(e, focusEle) {
      var _this = this;
      if (e === undefined) {
        e = null;
      }
      var ul = this.getULElement();
      var beforeCloseArgs = { element: ul, items: this.items, event: e, cancel: false };
      this.trigger("beforeClose", beforeCloseArgs, function(observedArgs) {
        if (!observedArgs.cancel) {
          var popupElement = _this.getPopUpElement();
          if (popupElement) {
            EventHandler.remove(popupElement, "keydown", _this.keyBoardHandler);
          }
          _this.popupUnWireEvents();
          var ul_2 = _this.getULElement();
          var selectedLi = undefined;
          if (ul_2) {
            selectedLi = ul_2.querySelector(".e-selected");
          }
          if (selectedLi) {
            selectedLi.classList.remove("e-selected");
          }
          if (_this.dropDown) {
            _this.dropDown.hide();
          }
          removeClass(_this.activeElem, "e-active");
          _this.element.setAttribute("aria-expanded", "false");
          _this.element.removeAttribute("aria-owns");
          if (focusEle) {
            if (!_this.isSafari()) {
              focusEle.focus();
            } else {
              focusEle.focus({ preventScroll: true });
            }
          }
          var closeArgs = { element: ul_2, items: _this.items };
          _this.trigger("close", closeArgs);
          if (!_this.target && ul_2) {
            detach(ul_2);
          }
          if (!_this.target || _this.isColorPicker() || _this.target && !_this.isColorPicker()) {
            if (_this.createPopupOnClick) {
              _this.destroyPopup();
            }
          }
        } else {
          if (ul) {
            ul.focus();
          }
        }
      });
    };
    DropDownButton2.prototype.unWireEvents = function() {
      if (!this.createPopupOnClick) {
        EventHandler.remove(undefined, "mousedown touchstart", this.delegateMousedownHandler);
      }
      EventHandler.remove(this.element, "click", this.clickHandler);
      EventHandler.remove(this.element, "keydown", this.keyBoardHandler);
      if (this.isPopupCreated) {
        EventHandler.remove(this.getPopUpElement(), "click", this.clickHandler);
        EventHandler.remove(this.getPopUpElement(), "keydown", this.keyBoardHandler);
      }
      EventHandler.remove(undefined, "resize", this.windowResize);
    };
    DropDownButton2.prototype.onPropertyChanged = function(newProp, oldProp) {
      var btnModel = ["content", "cssClass", "iconCss", "iconPosition", "disabled", "enableRtl"];
      this.button.setProperties(getModel(newProp, btnModel));
      var popupElement;
      if (this.isPopupCreated) {
        popupElement = this.getPopUpElement();
        this.dropDown.setProperties(getModel(newProp, ["enableRtl"]));
      }
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "content":
            if (!this.element.querySelector("span.e-caret")) {
              this.appendArrowSpan();
            }
            break;
          case "disabled":
            if (newProp.disabled) {
              this.unWireEvents();
              if (this.isPopupCreated && !this.canOpen()) {
                this.closePopup();
              }
            } else {
              this.wireEvents();
            }
            break;
          case "cssClass":
            oldProp.cssClass = isNullOrUndefined(oldProp.cssClass) ? "" : oldProp.cssClass;
            if (newProp.cssClass.indexOf(classNames.VERTICAL) > -1 || oldProp.cssClass.indexOf(classNames.VERTICAL) > -1) {
              if (!this.element.querySelector("span.e-caret")) {
                this.appendArrowSpan();
              }
              var arrowSpan = this.element.querySelector("span.e-caret");
              newProp.cssClass.indexOf(classNames.VERTICAL) > -1 ? classList(arrowSpan, ["e-icon-bottom"], ["e-icon-right"]) : classList(arrowSpan, ["e-icon-right"], ["e-icon-bottom"]);
            }
            if (this.isPopupCreated) {
              if (oldProp.cssClass) {
                removeClass([popupElement], oldProp.cssClass.split(" "));
              }
              if (newProp.cssClass) {
                addClass([popupElement], newProp.cssClass.replace(/\s+/g, " ").trim().split(" "));
              }
            }
            break;
          case "target":
            this.dropDown.content = this.getTargetElement();
            this.dropDown.dataBind();
            break;
          case "items":
            if (this.isPopupCreated && this.getULElement()) {
              this.createItems();
            }
            break;
          case "createPopupOnClick":
            if (newProp.createPopupOnClick) {
              this.destroyPopup();
            } else {
              this.createPopup();
            }
            break;
        }
      }
    };
    DropDownButton2.prototype.focusIn = function() {
      this.element.focus();
    };
    __decorate$7([
      Property("")
    ], DropDownButton2.prototype, "content", undefined);
    __decorate$7([
      Property("")
    ], DropDownButton2.prototype, "cssClass", undefined);
    __decorate$7([
      Property(false)
    ], DropDownButton2.prototype, "disabled", undefined);
    __decorate$7([
      Property("")
    ], DropDownButton2.prototype, "iconCss", undefined);
    __decorate$7([
      Property("Left")
    ], DropDownButton2.prototype, "iconPosition", undefined);
    __decorate$7([
      Property(true)
    ], DropDownButton2.prototype, "enableHtmlSanitizer", undefined);
    __decorate$7([
      Collection([], Item$1)
    ], DropDownButton2.prototype, "items", undefined);
    __decorate$7([
      Property(false)
    ], DropDownButton2.prototype, "createPopupOnClick", undefined);
    __decorate$7([
      Property("")
    ], DropDownButton2.prototype, "target", undefined);
    __decorate$7([
      Property("")
    ], DropDownButton2.prototype, "closeActionEvents", undefined);
    __decorate$7([
      Property(null)
    ], DropDownButton2.prototype, "itemTemplate", undefined);
    __decorate$7([
      Property("auto")
    ], DropDownButton2.prototype, "popupWidth", undefined);
    __decorate$7([
      Complex({ effect: "None" }, DropDownMenuAnimationSettings)
    ], DropDownButton2.prototype, "animationSettings", undefined);
    __decorate$7([
      Event()
    ], DropDownButton2.prototype, "beforeItemRender", undefined);
    __decorate$7([
      Event()
    ], DropDownButton2.prototype, "beforeOpen", undefined);
    __decorate$7([
      Event()
    ], DropDownButton2.prototype, "beforeClose", undefined);
    __decorate$7([
      Event()
    ], DropDownButton2.prototype, "close", undefined);
    __decorate$7([
      Event()
    ], DropDownButton2.prototype, "open", undefined);
    __decorate$7([
      Event()
    ], DropDownButton2.prototype, "select", undefined);
    __decorate$7([
      Event()
    ], DropDownButton2.prototype, "created", undefined);
    DropDownButton2 = __decorate$7([
      NotifyPropertyChanges
    ], DropDownButton2);
    return DropDownButton2;
  }(Component)
);
var __extends$6 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate$6 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var RTL$1 = "e-rtl";
var TAGNAME = "EJS-SPLITBUTTON";
var SplitButton = (
  /** @class */
  function(_super) {
    __extends$6(SplitButton2, _super);
    function SplitButton2(options, element2) {
      return _super.call(this, options, element2) || this;
    }
    SplitButton2.prototype.preRender = function() {
      var ele = this.element;
      if (ele.tagName === TAGNAME) {
        var ejInstance = getValue("ej2_instances", ele);
        var btn = this.createElement("button", { attrs: { "type": "button" } });
        var wrapper = this.createElement(TAGNAME, { className: "e-" + this.getModuleName() + "-wrapper" });
        for (var idx = 0, len = ele.attributes.length; idx < len; idx++) {
          btn.setAttribute(ele.attributes[idx].nodeName, ele.attributes[idx].nodeValue);
        }
        ele.parentNode.insertBefore(wrapper, ele);
        detach(ele);
        ele = btn;
        wrapper.appendChild(ele);
        setValue("ej2_instances", ejInstance, ele);
        this.wrapper = wrapper;
        this.element = ele;
      }
      if (!this.element.id) {
        this.element.id = getUniqueID("e-" + this.getModuleName());
      }
    };
    SplitButton2.prototype.render = function() {
      this.initWrapper();
      this.createPrimaryButton();
      this.renderControl();
    };
    SplitButton2.prototype.renderControl = function() {
      this.createSecondaryButton();
      this.setActiveElem([this.element, this.secondaryBtnObj.element]);
      this.setAria();
      this.wireEvents();
      this.renderComplete();
    };
    SplitButton2.prototype.addItems = function(items, text) {
      _super.prototype.addItems.call(this, items, text);
      this.secondaryBtnObj.items = this.items;
    };
    SplitButton2.prototype.removeItems = function(items, isUniqueId) {
      _super.prototype.removeItems.call(this, items, isUniqueId);
      this.secondaryBtnObj.items = this.items;
    };
    SplitButton2.prototype.initWrapper = function() {
      if (!this.wrapper) {
        this.wrapper = this.createElement("div", { className: "e-" + this.getModuleName() + "-wrapper" });
        this.element.parentNode.insertBefore(this.wrapper, this.element);
      }
      this.element.classList.remove("e-" + this.getModuleName());
      if (this.enableRtl) {
        this.wrapper.classList.add(RTL$1);
      }
      if (this.cssClass) {
        addClass([this.wrapper], this.cssClass.replace(/\s+/g, " ").trim().split(" "));
      }
    };
    SplitButton2.prototype.createPrimaryButton = function() {
      var btnModel = {
        cssClass: this.cssClass,
        enableRtl: this.enableRtl,
        iconCss: this.iconCss,
        iconPosition: this.iconPosition,
        content: this.content,
        disabled: this.disabled
      };
      this.primaryBtnObj = new Button(btnModel);
      this.primaryBtnObj.createElement = this.createElement;
      this.primaryBtnObj.appendTo(this.element);
      this.element.classList.add("e-" + this.getModuleName());
      this.element.type = "button";
      this.wrapper.appendChild(this.element);
    };
    SplitButton2.prototype.createSecondaryButton = function() {
      var _this = this;
      var btnElem = this.createElement("button", {
        className: "e-icon-btn",
        attrs: { "tabindex": "-1" },
        id: this.element.id + "_dropdownbtn"
      });
      this.wrapper.appendChild(btnElem);
      var dropDownBtnModel = {
        cssClass: this.cssClass,
        disabled: this.disabled,
        enableRtl: this.enableRtl,
        items: this.items,
        target: this.target,
        createPopupOnClick: this.createPopupOnClick
      };
      dropDownBtnModel.beforeItemRender = function(args) {
        if (_this.createPopupOnClick) {
          _this.secondaryBtnObj.dropDown.relateTo = _this.wrapper;
          _this.dropDown = _this.secondaryBtnObj.dropDown;
        }
        _this.trigger("beforeItemRender", args);
      };
      dropDownBtnModel.open = function(args) {
        _this.trigger("open", args);
      };
      dropDownBtnModel.close = function(args) {
        _this.trigger("close", args);
      };
      dropDownBtnModel.select = function(args) {
        _this.trigger("select", args);
      };
      dropDownBtnModel.beforeOpen = function(args) {
        if (_this.createPopupOnClick && _this.items.length === 0) {
          _this.secondaryBtnObj.dropDown.relateTo = _this.wrapper;
          _this.dropDown = _this.secondaryBtnObj.dropDown;
        }
        var callBackPromise = new Deferred();
        _this.trigger("beforeOpen", args, function(observedArgs) {
          callBackPromise.resolve(observedArgs);
        });
        return callBackPromise;
      };
      dropDownBtnModel.beforeClose = function(args) {
        var callBackPromise = new Deferred();
        _this.trigger("beforeClose", args, function(observedArgs) {
          callBackPromise.resolve(observedArgs);
        });
        return callBackPromise;
      };
      this.secondaryBtnObj = new DropDownButton(dropDownBtnModel);
      this.secondaryBtnObj.createElement = this.createElement;
      this.secondaryBtnObj.appendTo(btnElem);
      if (!this.createPopupOnClick) {
        this.secondaryBtnObj.dropDown.relateTo = this.wrapper;
        this.dropDown = this.secondaryBtnObj.dropDown;
      }
      this.isPopupCreated = this.secondaryBtnObj.isPopupCreated;
      this.secondaryBtnObj.activeElem = [this.element, this.secondaryBtnObj.element];
      this.secondaryBtnObj.element.querySelector(".e-btn-icon").classList.remove("e-icon-right");
      if (this.disabled) {
        this.wrapper.classList.add("e-splitbtn-disabled");
      }
    };
    SplitButton2.prototype.setAria = function() {
      attributes(this.element, {
        "aria-expanded": "false",
        "aria-haspopup": "true",
        "aria-label": this.element.textContent ? this.element.textContent + " splitbutton" : "splitbutton",
        "aria-owns": this.element.id + "_dropdownbtn-popup"
      });
    };
    SplitButton2.prototype.getModuleName = function() {
      return "split-btn";
    };
    SplitButton2.prototype.toggle = function() {
      this.secondaryBtnObj.toggle();
    };
    SplitButton2.prototype.destroy = function() {
      var _this = this;
      var classList2 = [RTL$1];
      if (this.cssClass) {
        classList2 = classList2.concat(this.cssClass.split(" "));
      }
      if (this.element) {
        var element2 = (undefined).getElementById(this.element.id);
        if (element2 && element2.parentElement === this.wrapper) {
          if (this.wrapper.tagName === TAGNAME) {
            this.wrapper.innerHTML = "";
            removeClass([this.wrapper], ["e-rtl", "e-" + this.getModuleName() + "-wrapper"]);
            removeClass([this.wrapper], this.cssClass.split(" "));
          } else {
            removeClass([this.element], classList2);
            ["aria-label", "aria-haspopup", "aria-expanded", "aria-owns", "type"].forEach(function(key) {
              _this.element.removeAttribute(key);
            });
            this.wrapper.parentNode.insertBefore(this.element, this.wrapper);
            remove(this.wrapper);
          }
          this.unWireEvents();
        }
      }
      this.primaryBtnObj.destroy();
      this.secondaryBtnObj.destroy();
      _super.prototype.destroy.call(this);
      if (this.element && !this.element.getAttribute("class")) {
        this.element.removeAttribute("class");
      }
      if (this.refreshing && this.isAngular) {
        this.element = this.wrapper;
        ["e-control", "e-split-btn", "e-lib"].forEach(function(key) {
          _this.element.classList.add(key);
        });
        setValue("ej2_instances", [this], this.element);
      }
      this.wrapper = null;
    };
    SplitButton2.prototype.wireEvents = function() {
      EventHandler.add(this.element, "click", this.primaryBtnClickHandler, this);
      new KeyboardEvents(this.element, {
        keyAction: this.btnKeyBoardHandler.bind(this),
        keyConfigs: {
          altdownarrow: "alt+downarrow",
          enter: "enter"
        }
      });
    };
    SplitButton2.prototype.unWireEvents = function() {
      EventHandler.remove(this.element, "click", this.primaryBtnClickHandler);
      getInstance(this.element, KeyboardEvents).destroy();
    };
    SplitButton2.prototype.primaryBtnClickHandler = function() {
      this.trigger("click", { element: this.element });
    };
    SplitButton2.prototype.btnKeyBoardHandler = function(e) {
      switch (e.action) {
        case "altdownarrow":
          this.clickHandler(e);
          break;
        case "enter":
          this.clickHandler(e);
          if (this.getPopUpElement() && !this.getPopUpElement().classList.contains("e-popup-close")) {
            this.element.classList.remove("e-active");
            this.secondaryBtnObj.element.classList.add("e-active");
          } else {
            this.secondaryBtnObj.element.classList.remove("e-active");
          }
          break;
      }
    };
    SplitButton2.prototype.onPropertyChanged = function(newProp, oldProp) {
      var model = ["content", "iconCss", "iconPosition", "cssClass", "disabled", "enableRtl"];
      this.primaryBtnObj.setProperties(getModel(newProp, model));
      model = [
        "beforeOpen",
        "beforeItemRender",
        "select",
        "open",
        "close",
        "cssClass",
        "disabled",
        "enableRtl",
        "createPopupOnClick"
      ];
      if (Object.keys(newProp).indexOf("items") > -1) {
        this.secondaryBtnObj.items = newProp.items;
        this.secondaryBtnObj.dataBind();
      }
      this.secondaryBtnObj.setProperties(getModel(newProp, model));
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "cssClass":
            if (oldProp.cssClass) {
              removeClass([this.wrapper], oldProp.cssClass.split(" "));
            }
            addClass([this.wrapper], newProp.cssClass.replace(/\s+/g, " ").trim().split(" "));
            break;
          case "enableRtl":
            if (newProp.enableRtl) {
              addClass([this.wrapper], RTL$1);
            } else {
              removeClass([this.wrapper], RTL$1);
            }
            break;
          case "disabled":
            if (newProp.disabled) {
              addClass([this.wrapper], "e-splitbtn-disabled");
            } else {
              removeClass([this.wrapper], "e-splitbtn-disabled");
            }
        }
      }
    };
    SplitButton2.prototype.focusIn = function() {
      this.element.focus();
    };
    __decorate$6([
      Property("")
    ], SplitButton2.prototype, "content", undefined);
    __decorate$6([
      Property("")
    ], SplitButton2.prototype, "cssClass", undefined);
    __decorate$6([
      Property(false)
    ], SplitButton2.prototype, "disabled", undefined);
    __decorate$6([
      Property("")
    ], SplitButton2.prototype, "iconCss", undefined);
    __decorate$6([
      Property("Left")
    ], SplitButton2.prototype, "iconPosition", undefined);
    __decorate$6([
      Property(false)
    ], SplitButton2.prototype, "createPopupOnClick", undefined);
    __decorate$6([
      Collection([], Item$1)
    ], SplitButton2.prototype, "items", undefined);
    __decorate$6([
      Property("")
    ], SplitButton2.prototype, "target", undefined);
    __decorate$6([
      Event()
    ], SplitButton2.prototype, "beforeItemRender", undefined);
    __decorate$6([
      Event()
    ], SplitButton2.prototype, "beforeOpen", undefined);
    __decorate$6([
      Event()
    ], SplitButton2.prototype, "beforeClose", undefined);
    __decorate$6([
      Event()
    ], SplitButton2.prototype, "click", undefined);
    __decorate$6([
      Event()
    ], SplitButton2.prototype, "close", undefined);
    __decorate$6([
      Event()
    ], SplitButton2.prototype, "open", undefined);
    __decorate$6([
      Event()
    ], SplitButton2.prototype, "select", undefined);
    __decorate$6([
      Event()
    ], SplitButton2.prototype, "created", undefined);
    SplitButton2 = __decorate$6([
      NotifyPropertyChanges
    ], SplitButton2);
    return SplitButton2;
  }(DropDownButton)
);
var Deferred = (
  /** @class */
  /* @__PURE__ */ function() {
    function Deferred2() {
      var _this = this;
      this.promise = new Promise(function(resolve, reject) {
        _this.resolve = resolve;
        _this.reject = reject;
      });
      this.catch = this.promise.catch.bind(this.promise);
      this.then = this.promise.then.bind(this.promise);
    }
    return Deferred2;
  }()
);
var __extends$5 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate$5 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var APPLY = "e-apply";
var CANCEL = "e-cancel";
var CURRENT = "e-current";
var CONTAINER = "e-container";
var CTRLBTN = "e-ctrl-btn";
var CTRLSWITCH = "e-switch-ctrl-btn";
var DISABLED = "e-disabled";
var FORMATSWITCH = "e-value-switch-btn";
var HANDLER = "e-handler";
var HEX = "e-hex";
var HIDEHEX = "e-hide-hex-value";
var HIDEOPACITY = "e-hide-opacity";
var HIDERGBA = "e-hide-switchable-value";
var HIDEVALUE = "e-hide-value";
var HIDEVALUESWITCH = "e-hide-valueswitcher";
var HSVAREA = "e-hsv-color";
var HSVCONTAINER = "e-hsv-container";
var INPUTWRAPPER = "e-selected-value";
var MODESWITCH = "e-mode-switch-btn";
var NOCOLOR = "e-nocolor-item";
var OPACITY = "e-opacity-value";
var PALETTES = "e-palette";
var PALETTECONTENT = "e-color-palette";
var PICKERCONTENT = "e-color-picker";
var PREVIEW = "e-preview-container";
var PREVIOUS = "e-previous";
var RTL = "e-rtl";
var SHOWVALUE = "e-show-value";
var SELECT = "e-selected";
var SPLITPREVIEW = "e-split-preview";
var TILE = "e-tile";
var presets = {
  default: [
    "#000000",
    "#f44336",
    "#e91e63",
    "#9c27b0",
    "#673ab7",
    "#2196f3",
    "#03a9f4",
    "#00bcd4",
    "#009688",
    "#ffeb3b",
    "#ffffff",
    "#ffebee",
    "#fce4ec",
    "#f3e5f5",
    "#ede7f6",
    "#e3f2fd",
    "#e1f5fe",
    "#e0f7fa",
    "#e0f2f1",
    "#fffde7",
    "#f2f2f2",
    "#ffcdd2",
    "#f8bbd0",
    "#e1bee7",
    "#d1c4e9",
    "#bbdefb",
    "#b3e5fc",
    "#b2ebf2",
    "#b2dfdb",
    "#fff9c4",
    "#e6e6e6",
    "#ef9a9a",
    "#f48fb1",
    "#ce93d8",
    "#b39ddb",
    "#90caf9",
    "#81d4fa",
    "#80deea",
    "#80cbc4",
    "#fff59d",
    "#cccccc",
    "#e57373",
    "#f06292",
    "#ba68c8",
    "#9575cd",
    "#64b5f6",
    "#4fc3f7",
    "#4dd0e1",
    "#4db6ac",
    "#fff176",
    "#b3b3b3",
    "#ef5350",
    "#ec407a",
    "#ab47bc",
    "#7e57c2",
    "#42a5f5",
    "#29b6f6",
    "#26c6da",
    "#26a69a",
    "#ffee58",
    "#999999",
    "#e53935",
    "#d81b60",
    "#8e24aa",
    "#5e35b1",
    "#1e88e5",
    "#039be5",
    "#00acc1",
    "#00897b",
    "#fdd835",
    "#808080",
    "#d32f2f",
    "#c2185b",
    "#7b1fa2",
    "#512da8",
    "#1976d2",
    "#0288d1",
    "#0097a7",
    "#00796b",
    "#fbc02d",
    "#666666",
    "#c62828",
    "#ad1457",
    "#6a1b9a",
    "#4527a0",
    "#1565c0",
    "#0277bd",
    "#00838f",
    "#00695c",
    "#f9a825",
    "#4d4d4d",
    "#b71c1c",
    "#880e4f",
    "#4a148c",
    "#311b92",
    "#0d47a1",
    "#01579b",
    "#006064",
    "#004d40",
    "#f57f17"
  ]
};
var ColorPicker = (
  /** @class */
  function(_super) {
    __extends$5(ColorPicker2, _super);
    function ColorPicker2(options, element2) {
      var _this = _super.call(this, options, element2) || this;
      _this.recentColors = [];
      return _this;
    }
    ColorPicker2.prototype.preRender = function() {
      var ele = this.element;
      this.formElement = closest(this.element, "form");
      if (this.formElement) {
        EventHandler.add(this.formElement, "reset", this.formResetHandler, this);
      }
      var localeText = { Apply: "Apply", Cancel: "Cancel", ModeSwitcher: "Switch Mode", RecentColors: "Recent colors" };
      this.l10n = new L10n("colorpicker", localeText, this.locale);
      if (ele.getAttribute("ejs-for") && !ele.getAttribute("name")) {
        ele.setAttribute("name", ele.id);
      }
    };
    ColorPicker2.prototype.render = function() {
      this.initWrapper();
      if (this.inline) {
        this.createWidget();
      } else {
        this.createSplitBtn();
      }
      if (!this.enableOpacity) {
        addClass([this.container.parentElement], HIDEOPACITY);
      }
      this.renderComplete();
    };
    ColorPicker2.prototype.initWrapper = function() {
      var wrapper = this.createElement("div", { className: "e-" + this.getModuleName() + "-wrapper" });
      this.element.parentNode.insertBefore(wrapper, this.element);
      wrapper.appendChild(this.element);
      attributes(this.element, { "tabindex": "-1", "spellcheck": "false", "aria-label": "colorpicker" });
      this.container = this.createElement("div", { className: CONTAINER });
      this.getWrapper().appendChild(this.container);
      var value = this.value ? this.roundValue(this.value).toLowerCase() : "#008000ff";
      if (this.noColor && this.mode === "Palette" && this.value === "") {
        value = "";
      }
      var slicedValue = value.slice(0, 7);
      if (isNullOrUndefined(this.initialInputValue)) {
        this.initialInputValue = slicedValue;
      }
      this.element.value = slicedValue;
      if (this.enableOpacity) {
        this.setProperties({ "value": value }, true);
      } else {
        this.setProperties({ "value": slicedValue }, true);
      }
      if (this.enableRtl) {
        wrapper.classList.add(RTL);
      }
      if (this.cssClass) {
        addClass([wrapper], this.cssClass.replace(/\s+/g, " ").trim().split(" "));
      }
      this.tileRipple = rippleEffect(this.container, { selector: "." + TILE });
      this.ctrlBtnRipple = rippleEffect(this.container, { selector: ".e-btn" });
    };
    ColorPicker2.prototype.getWrapper = function() {
      return this.element.parentElement;
    };
    ColorPicker2.prototype.createWidget = function() {
      if (this.mode === "Palette") {
        this.createPalette();
        if (!this.inline) {
          this.firstPaletteFocus();
        }
      } else {
        this.createPicker();
        if (!this.inline) {
          this.getDragHandler().focus();
        }
      }
      this.isRgb = true;
      this.createInput();
      this.createCtrlBtn();
      if (!this.disabled) {
        this.wireEvents();
      }
      if (this.inline && this.disabled) {
        this.toggleDisabled(true);
      }
      if (Browser.isDevice) {
        this.refreshPopupPos();
      }
    };
    ColorPicker2.prototype.createSplitBtn = function() {
      var _this = this;
      var splitButton = this.createElement("button", { className: "e-split-colorpicker" });
      this.getWrapper().appendChild(splitButton);
      this.splitBtn = new SplitButton({
        iconCss: "e-selected-color",
        target: this.container,
        disabled: this.disabled,
        enableRtl: this.enableRtl,
        createPopupOnClick: this.createPopupOnClick,
        open: this.onOpen.bind(this),
        click: function() {
          var ev = new MouseEvent("click", { bubbles: true, cancelable: false });
          _this.trigger("change", {
            currentValue: { hex: _this.value.slice(0, 7), rgba: _this.convertToRgbString(_this.hexToRgb(_this.value)) },
            previousValue: { hex: null, rgba: null },
            value: _this.value,
            event: ev
          });
        }
      });
      this.splitBtn.createElement = this.createElement;
      this.splitBtn.appendTo(splitButton);
      this.splitBtn.element.setAttribute("aria-label", "colorpicker");
      var preview = this.createElement("span", { className: SPLITPREVIEW });
      select(".e-selected-color", splitButton).appendChild(preview);
      preview.style.backgroundColor = this.convertToRgbString(this.hexToRgb(this.value));
      var popupEle = this.getPopupEle();
      addClass([popupEle], "e-colorpicker-popup");
      if (this.cssClass) {
        addClass([popupEle], this.cssClass.replace(/\s+/g, " ").trim().split(" "));
      }
      if (Browser.isDevice && !this.createPopupOnClick) {
        var popupInst = this.getPopupInst();
        popupInst.relateTo = (undefined).body;
        popupInst.position = { X: "center", Y: "center" };
        popupInst.targetType = "container";
        popupInst.collision = { X: "fit", Y: "fit" };
        popupInst.offsetY = 4;
        popupEle.style.zIndex = getZindexPartial(this.splitBtn.element).toString();
      }
      this.bindCallBackEvent();
    };
    ColorPicker2.prototype.onOpen = function() {
      this.trigger("open", { element: this.container });
      if (!Browser.isDevice) {
        var popupInst = this.getPopupInst();
        var collision = isCollide(popupInst.element);
        if (collision.length > 0) {
          popupInst.collision = { X: "flip", Y: "fit" };
          popupInst.position = { X: "right", Y: "bottom" };
          popupInst.targetType = "container";
        }
      }
    };
    ColorPicker2.prototype.getPopupInst = function() {
      return getInstance(this.getPopupEle(), Popup);
    };
    ColorPicker2.prototype.bindCallBackEvent = function() {
      var _this = this;
      this.splitBtn.beforeOpen = function(args) {
        var callBackPromise = new Deferred();
        _this.trigger("beforeOpen", args, function(observeOpenArgs) {
          if (!observeOpenArgs.cancel) {
            var popupEle = _this.getPopupEle();
            popupEle.style.top = formatUnit(0 + pageYOffset);
            popupEle.style.left = formatUnit(0 + pageXOffset);
            popupEle.style.display = "block";
            _this.createWidget();
            popupEle.style.display = "";
            if (Browser.isDevice) {
              if (_this.createPopupOnClick) {
                var popupInst = _this.getPopupInst();
                popupInst.relateTo = (undefined).body;
                popupInst.position = { X: "center", Y: "center" };
                popupInst.targetType = "container";
                popupInst.collision = { X: "fit", Y: "fit" };
                popupInst.offsetY = 4;
                popupEle.style.zIndex = getZindexPartial(_this.splitBtn.element).toString();
              }
              _this.modal = _this.createElement("div");
              _this.modal.className = "e-" + _this.getModuleName() + " e-modal";
              _this.modal.style.display = "none";
              (undefined).body.insertBefore(_this.modal, popupEle);
              (undefined).body.className += " e-colorpicker-overflow";
              _this.modal.style.display = "block";
              _this.modal.style.zIndex = (Number(popupEle.style.zIndex) - 1).toString();
            }
          }
          args.cancel = observeOpenArgs.cancel;
          callBackPromise.resolve(observeOpenArgs);
        });
        return callBackPromise;
      };
      this.splitBtn.beforeClose = function(args) {
        var callBackPromise = new Deferred();
        if (!isNullOrUndefined(args.event)) {
          var beforeCloseArgs = { element: _this.container, event: args.event, cancel: false };
          _this.trigger("beforeClose", beforeCloseArgs, function(observedCloseArgs) {
            if (Browser.isDevice && args.event.target === _this.modal) {
              observedCloseArgs.cancel = true;
            }
            if (!observedCloseArgs.cancel) {
              _this.onPopupClose();
            }
            args.cancel = observedCloseArgs.cancel;
            callBackPromise.resolve(observedCloseArgs);
          });
        } else {
          callBackPromise.resolve(args);
        }
        return callBackPromise;
      };
    };
    ColorPicker2.prototype.onPopupClose = function() {
      this.unWireEvents();
      this.destroyOtherComp();
      this.container.style.width = "";
      select("." + SPLITPREVIEW, this.splitBtn.element).style.backgroundColor = this.convertToRgbString(this.hexToRgb(this.value));
      this.container.innerHTML = "";
      removeClass([this.container], [PICKERCONTENT, PALETTECONTENT]);
      if (Browser.isDevice && this.modal) {
        removeClass([(undefined).body], "e-colorpicker-overflow");
        this.modal.style.display = "none";
        this.modal.outerHTML = "";
        this.modal = null;
      }
    };
    ColorPicker2.prototype.createPalette = function() {
      classList(this.container, [PALETTECONTENT], [PICKERCONTENT]);
      if (this.presetColors) {
        var paletteGroup = this.createElement("div", { className: "e-custom-palette" });
        this.appendElement(paletteGroup);
        var keys2 = Object.keys(this.presetColors);
        if (keys2.length === 1) {
          this.appendPalette(this.presetColors[keys2[0]], keys2[0], paletteGroup);
        } else {
          for (var i = 0, len = keys2.length; i < len; i++) {
            this.appendPalette(this.presetColors[keys2[i]], keys2[i], paletteGroup);
          }
        }
        if (selectAll(".e-row", paletteGroup).length > 10) {
          addClass([paletteGroup], "e-palette-group");
        }
      } else {
        this.appendPalette(presets.default, "default");
      }
      if (this.mode === "Palette" && !this.modeSwitcher && this.noColor) {
        this.setNoColor();
      }
      if (this.showRecentColors && this.recentColors && this.recentColors.length > 0) {
        this.renderRecentColor();
      }
      var width = parseInt(getComputedStyle(this.container).borderBottomWidth, 10);
      this.container.style.width = formatUnit(this.container.children[0].offsetWidth + width + width);
      this.rgb = this.hexToRgb(this.roundValue(this.value));
      this.hsv = this.rgbToHsv.apply(this, this.rgb);
    };
    ColorPicker2.prototype.renderRecentColor = function() {
      var _this = this;
      var recentClrWpr = this.container.querySelector(".e-clr-pal-rec-wpr");
      if (recentClrWpr) {
        detach(recentClrWpr);
      }
      var recentColorWrapper = this.createElement("div", { className: "e-clr-pal-rec-wpr" });
      var refEle = this.container.querySelector(".e-switch-ctrl-btn");
      if (refEle) {
        this.container.insertBefore(recentColorWrapper, refEle);
      } else {
        this.container.appendChild(recentColorWrapper);
      }
      var recentClrSpan = this.createElement("label", { className: "e-recent-clr-span" });
      recentClrSpan.textContent = this.l10n.getConstant("RecentColors");
      recentColorWrapper.appendChild(recentClrSpan);
      if (this.recentColors.length > 0) {
        this.recentColors = this.recentColors.filter(function(item, index) {
          return _this.recentColors.indexOf(item) === index;
        });
        while (this.recentColors.length > 10) {
          this.recentColors.pop();
        }
        this.appendPalette(this.recentColors, "recent-color", recentColorWrapper);
      }
    };
    ColorPicker2.prototype.firstPaletteFocus = function() {
      if (!select("." + SELECT, this.container.children[0])) {
        selectAll("." + PALETTES, this.container)[0].focus();
      }
    };
    ColorPicker2.prototype.appendPalette = function(colors, key, refEle) {
      var palette = this.createElement("div", { className: PALETTES, attrs: { "tabindex": "0", "role": "grid" } });
      if (key === "recent-color") {
        palette.classList.add("e-recent-palette");
      }
      if (refEle) {
        refEle.appendChild(palette);
      } else {
        this.appendElement(palette);
      }
      var row;
      var tile;
      var roundedColor;
      for (var i = 0, len = colors.length; i < len; i++) {
        if (i === 0 || i % this.columns === 0) {
          row = this.createElement("div", {
            className: "e-row",
            attrs: { "role": "row" }
          });
          palette.appendChild(row);
        }
        roundedColor = this.roundValue(colors[i]).toLowerCase();
        tile = this.createElement("span", {
          className: TILE,
          attrs: { "role": "gridcell", "aria-label": roundedColor, "aria-selected": "false" }
        });
        this.trigger("beforeTileRender", { element: tile, presetName: key, value: colors[i] });
        row.appendChild(tile);
        if (this.value === roundedColor && key !== "recent-color") {
          this.addTileSelection(tile);
          palette.focus();
        }
        tile.style.backgroundColor = this.convertToRgbString(this.hexToRgb(roundedColor));
      }
    };
    ColorPicker2.prototype.setNoColor = function() {
      var noColorEle = this.container.querySelector(".e-row").children[0];
      noColorEle.classList.add(NOCOLOR);
      if (!this.value) {
        noColorEle.classList.add(SELECT);
        closest(noColorEle, "." + PALETTES).focus();
      }
      ["aria-selected", "aria-label"].forEach(function(attr) {
        noColorEle.removeAttribute(attr);
      });
      noColorEle.style.backgroundColor = "";
    };
    ColorPicker2.prototype.appendElement = function(ele, insertPos) {
      if (insertPos === undefined) {
        insertPos = 0;
      }
      var refEle = this.container.children[insertPos];
      if (refEle) {
        this.container.insertBefore(ele, refEle);
      } else {
        this.container.appendChild(ele);
      }
    };
    ColorPicker2.prototype.addTileSelection = function(ele) {
      if (ele) {
        ele.classList.add(SELECT);
        ele.setAttribute("aria-selected", "true");
      }
    };
    ColorPicker2.prototype.createPicker = function() {
      classList(this.container, [PICKERCONTENT], [PALETTECONTENT]);
      var hsvContainer = this.createElement("div", { className: HSVCONTAINER });
      this.appendElement(hsvContainer);
      hsvContainer.appendChild(this.createElement("div", { className: HSVAREA }));
      var dragHandler = this.createElement("span", { className: HANDLER, attrs: { "tabindex": "0" } });
      hsvContainer.appendChild(dragHandler);
      if (this.value === null || this.value === "") {
        this.value = "#008000ff";
      }
      this.rgb = this.hexToRgb(this.value);
      this.hsv = this.rgbToHsv.apply(this, this.rgb);
      this.setHsvContainerBg();
      this.setHandlerPosition();
      this.createSlider();
      this.createDragTooltip();
    };
    ColorPicker2.prototype.setHsvContainerBg = function(h) {
      if (h === undefined) {
        h = this.hsv[0];
      }
      this.getHsvContainer().style.backgroundColor = this.convertToRgbString(this.hsvToRgb(h, 100, 100, 1));
    };
    ColorPicker2.prototype.getHsvContainer = function() {
      return select("." + HSVCONTAINER, this.container);
    };
    ColorPicker2.prototype.setHandlerPosition = function() {
      var dragHandler = this.getDragHandler();
      var hsvArea = select("." + HSVAREA, this.container);
      if (this.enableRtl) {
        dragHandler.style.left = formatUnit((hsvArea.offsetWidth - dragHandler.offsetWidth / 2.5) * Math.abs(100 - this.hsv[1]) / 100);
      } else {
        dragHandler.style.left = formatUnit((hsvArea.offsetWidth - dragHandler.offsetWidth / 2.5) * this.hsv[1] / 100);
      }
      dragHandler.style.top = formatUnit((hsvArea.offsetHeight - dragHandler.offsetHeight / 2.5) * (100 - this.hsv[2]) / 100);
    };
    ColorPicker2.prototype.createSlider = function() {
      var sliderPreviewWrapper = this.createElement("div", { className: "e-slider-preview" });
      this.appendElement(sliderPreviewWrapper, 1);
      this.createPreview(sliderPreviewWrapper);
      var sliderWrapper = this.createElement("div", { className: "e-colorpicker-slider" });
      sliderPreviewWrapper.insertBefore(sliderWrapper, sliderPreviewWrapper.children[0]);
      var slider = this.createElement("div", { className: "e-hue-slider" });
      sliderWrapper.appendChild(slider);
      this.hueSlider = new Slider({
        value: this.hsv[0],
        min: 0,
        max: 359,
        enableRtl: this.enableRtl,
        enabled: !this.disabled,
        change: this.hueChange.bind(this)
      });
      this.hueSlider.createElement = this.createElement;
      this.hueSlider.appendTo(slider);
      if (this.enableOpacity) {
        slider = this.createElement("div", { className: "e-opacity-slider" });
        sliderWrapper.appendChild(slider);
        this.createOpacitySlider(slider);
      }
    };
    ColorPicker2.prototype.createOpacitySlider = function(slider) {
      this.opacitySlider = new Slider({
        value: this.rgb[3] * 100,
        min: 0,
        max: 100,
        enableRtl: this.enableRtl,
        enabled: !this.disabled,
        change: this.opacityChange.bind(this)
      });
      this.opacitySlider.createElement = this.createElement;
      this.opacitySlider.appendTo(slider);
      var opacityBgTrack = this.createElement("div", { className: "e-opacity-empty-track" });
      slider.appendChild(opacityBgTrack);
      this.updateOpacitySliderBg();
    };
    ColorPicker2.prototype.updateOpacitySliderBg = function() {
      var direction = this.enableRtl ? "to left" : "to right";
      var opacityEle = select(".e-opacity-empty-track", this.opacitySlider.element);
      if (opacityEle) {
        opacityEle.style.background = "linear-gradient(" + direction + ", rgba(" + this.rgb.slice(0, 3) + ", 0) 0%, " + this.convertToRgbString(this.rgb.slice(0, 3)) + " 100%)";
      }
    };
    ColorPicker2.prototype.hueChange = function(args) {
      this.hsv[0] = args.value;
      this.setHsvContainerBg();
      this.convertToOtherFormat();
    };
    ColorPicker2.prototype.opacityChange = function(args) {
      var value = args.value;
      var pValue = this.rgbToHex(this.rgb);
      this.hsv[3] = value / 100;
      this.rgb[3] = value / 100;
      var cValue = this.rgbToHex(this.rgb);
      this.updateOpacityInput(value);
      var rgb = this.convertToRgbString(this.rgb);
      this.updatePreview(rgb);
      this.triggerEvent(cValue, pValue, rgb);
    };
    ColorPicker2.prototype.updateOpacityInput = function(value) {
      if (this.enableOpacity && !this.getWrapper().classList.contains(HIDEVALUE)) {
        var opacityTextBoxInst = getInstance(select("." + OPACITY, this.container), NumericTextBox);
        opacityTextBoxInst.value = value;
        opacityTextBoxInst.dataBind();
      }
    };
    ColorPicker2.prototype.createPreview = function(parentEle) {
      var previewContainer = this.createElement("div", { className: PREVIEW });
      parentEle.appendChild(previewContainer);
      var preview = this.createElement("span", { className: "e-preview " + CURRENT });
      previewContainer.appendChild(preview);
      var colorValue = this.convertToRgbString(this.rgb);
      preview.style.backgroundColor = colorValue;
      preview = this.createElement("span", { className: "e-preview " + PREVIOUS });
      previewContainer.appendChild(preview);
      preview.style.backgroundColor = colorValue;
    };
    ColorPicker2.prototype.isPicker = function() {
      return !this.container.classList.contains(PALETTECONTENT);
    };
    ColorPicker2.prototype.getPopupEle = function() {
      return this.container.parentElement;
    };
    ColorPicker2.prototype.createNumericInput = function(element2, value, label, max) {
      var _this = this;
      var numericInput = new NumericTextBox({
        value,
        placeholder: label,
        min: 0,
        max,
        format: "###.##",
        showSpinButton: false,
        floatLabelType: "Always",
        enableRtl: this.enableRtl,
        enabled: !this.disabled,
        readonly: this.isPicker() ? false : true,
        change: function(args) {
          if (args.event) {
            _this.inputHandler(args.event);
          }
        }
      });
      numericInput.createElement = this.createElement;
      numericInput.appendTo(element2);
    };
    ColorPicker2.prototype.createInput = function() {
      var isPicker = this.isPicker();
      var wrapper = this.getWrapper();
      if (isPicker && !wrapper.classList.contains(HIDEVALUE) || !isPicker && wrapper.classList.contains(SHOWVALUE)) {
        var inputWrap = this.createElement("div", { className: INPUTWRAPPER });
        if (isPicker) {
          this.appendElement(inputWrap, 2);
        } else {
          this.appendElement(inputWrap, 1);
        }
        var container = this.createElement("div", { className: "e-input-container" });
        inputWrap.appendChild(container);
        if (!wrapper.classList.contains(HIDEVALUESWITCH)) {
          this.appendValueSwitchBtn(inputWrap);
        }
        if (!wrapper.classList.contains(HIDEHEX)) {
          var hexInput = this.createElement("input", {
            className: HEX,
            attrs: { "maxlength": "7", "spellcheck": "false", "aria-label": "HEX" }
          });
          container.appendChild(hexInput);
          Input.createInput({
            element: hexInput,
            floatLabelType: "Always",
            properties: {
              placeholder: "HEX",
              enableRtl: this.enableRtl,
              enabled: !this.disabled,
              readonly: this.isPicker() ? false : true
            }
          }, this.createElement);
          Input.setValue(this.value.slice(0, 7), hexInput);
          hexInput.addEventListener("input", this.inputHandler.bind(this));
        }
        if (!wrapper.classList.contains(HIDERGBA)) {
          var label = undefined;
          var value = undefined;
          if (this.isRgb) {
            label = "RGB";
            value = this.rgb;
          } else {
            label = "HSV";
            value = this.hsv;
          }
          var clsName = ["rh", "gs", "bv"];
          for (var i = 0; i < 3; i++) {
            this.createNumericInput(container.appendChild(this.createElement("input", { className: "e-" + clsName[i] + "-value" })), value[i], label[i], 255);
          }
          if (this.enableOpacity) {
            this.appendOpacityValue(container);
          }
        }
      }
    };
    ColorPicker2.prototype.appendOpacityValue = function(container) {
      this.createNumericInput(container.appendChild(this.createElement("input", { className: OPACITY })), this.rgb[3] * 100, "A", 100);
    };
    ColorPicker2.prototype.appendValueSwitchBtn = function(targetEle) {
      var valueSwitchBtn = this.createElement("button", {
        className: "e-icons e-css e-btn e-flat e-icon-btn " + FORMATSWITCH,
        attrs: { "title": "Toggle format" }
      });
      targetEle.appendChild(valueSwitchBtn);
      if (this.isPicker() && !this.getWrapper().classList.contains(HIDERGBA)) {
        valueSwitchBtn.addEventListener("click", this.formatSwitchHandler.bind(this));
      }
    };
    ColorPicker2.prototype.createCtrlBtn = function() {
      if (this.modeSwitcher || this.showButtons) {
        this.l10n.setLocale(this.locale);
        var btnWrapper = this.createElement("div", { className: CTRLSWITCH });
        this.container.appendChild(btnWrapper);
        if (this.showButtons) {
          var controlBtnWrapper = this.createElement("div", { className: CTRLBTN });
          btnWrapper.appendChild(controlBtnWrapper);
          var apply = this.l10n.getConstant("Apply");
          controlBtnWrapper.appendChild(this.createElement("button", {
            innerHTML: apply,
            className: "e-btn e-css e-flat e-primary e-small " + APPLY,
            attrs: { "title": apply }
          }));
          var cancel = this.l10n.getConstant("Cancel");
          controlBtnWrapper.appendChild(this.createElement("button", {
            innerHTML: cancel,
            className: "e-btn e-css e-flat e-small " + CANCEL,
            attrs: { "title": cancel }
          }));
        }
        if (this.modeSwitcher) {
          this.appendModeSwitchBtn();
        }
      }
    };
    ColorPicker2.prototype.appendModeSwitchBtn = function() {
      var modeSwitcher = this.createElement("button", {
        className: "e-icons e-btn e-flat e-icon-btn " + MODESWITCH,
        attrs: { title: this.l10n.getConstant("ModeSwitcher") }
      });
      select("." + CTRLSWITCH, this.container).insertBefore(modeSwitcher, select("." + CTRLBTN, this.container));
    };
    ColorPicker2.prototype.createDragTooltip = function() {
      var _this = this;
      var tooltip = new Tooltip({
        opensOn: "Custom",
        showTipPointer: false,
        cssClass: "e-color-picker-tooltip",
        htmlAttributes: { title: "tooltip" },
        beforeOpen: function(args) {
          _this.tooltipEle = args.element;
        },
        animation: { open: { effect: "None" }, close: { effect: "None" } }
      });
      tooltip.createElement = this.createElement;
      tooltip.appendTo(this.container);
      tooltip.open(this.container);
      this.tooltipEle.style.zIndex = getZindexPartial(this.tooltipEle).toString();
      this.tooltipEle.setAttribute("aria-label", "colorpicker-tooltip");
      select(".e-tip-content", this.tooltipEle).appendChild(this.createElement("div", { className: "e-tip-transparent" }));
    };
    ColorPicker2.prototype.getTooltipInst = function() {
      return getInstance(this.container, Tooltip);
    };
    ColorPicker2.prototype.setTooltipOffset = function(value) {
      this.getTooltipInst().offsetY = value;
    };
    ColorPicker2.prototype.toggleDisabled = function(enable) {
      if (enable) {
        this.getWrapper().classList.add(DISABLED);
      } else {
        this.getWrapper().classList.remove(DISABLED);
      }
      if (this.showButtons) {
        [].slice.call(selectAll(".e-btn", this.container)).forEach(function(ele) {
          if (enable) {
            attributes(ele, { "disabled": "" });
          } else {
            ele.removeAttribute("disabled");
          }
        });
      }
    };
    ColorPicker2.prototype.convertToRgbString = function(rgb) {
      return rgb.length ? rgb.length === 4 ? "rgba(" + rgb.join() + ")" : "rgb(" + rgb.join() + ")" : "";
    };
    ColorPicker2.prototype.convertToHsvString = function(hsv) {
      return hsv.length === 4 ? "hsva(" + hsv.join() + ")" : "hsv(" + hsv.join() + ")";
    };
    ColorPicker2.prototype.updateHsv = function() {
      this.hsv[1] = this.hsv[1] > 100 ? 100 : this.hsv[1];
      this.hsv[2] = this.hsv[2] > 100 ? 100 : this.hsv[2];
      this.setHandlerPosition();
    };
    ColorPicker2.prototype.convertToOtherFormat = function(isKey, e) {
      if (isKey === undefined) {
        isKey = false;
      }
      var pValue = this.rgbToHex(this.rgb);
      this.rgb = this.hsvToRgb.apply(this, this.hsv);
      var cValue = this.rgbToHex(this.rgb);
      var rgba = this.convertToRgbString(this.rgb);
      this.updatePreview(rgba);
      this.updateInput(cValue);
      this.triggerEvent(cValue, pValue, rgba, isKey, e);
    };
    ColorPicker2.prototype.updateInput = function(value) {
      var wrapper = this.getWrapper();
      if (!wrapper.classList.contains(HIDEVALUE)) {
        if (!wrapper.classList.contains(HIDEHEX)) {
          Input.setValue(value.substr(0, 7), select("." + HEX, this.container));
        }
        if (!wrapper.classList.contains(HIDERGBA)) {
          if (this.isRgb) {
            this.updateValue(this.rgb, false);
          } else {
            this.updateValue(this.hsv, false);
          }
        }
      }
    };
    ColorPicker2.prototype.updatePreview = function(value) {
      if (this.enableOpacity) {
        this.updateOpacitySliderBg();
      }
      select(".e-tip-transparent", this.tooltipEle).style.backgroundColor = value;
      select("." + PREVIEW + " ." + CURRENT, this.container).style.backgroundColor = value;
      select("." + PREVIEW + " ." + PREVIOUS, this.container).style.backgroundColor = this.convertToRgbString(this.hexToRgb(this.value));
    };
    ColorPicker2.prototype.getDragHandler = function() {
      return select("." + HANDLER, this.container);
    };
    ColorPicker2.prototype.removeTileSelection = function() {
      var selectedEle = [].slice.call(selectAll("." + SELECT, this.container));
      selectedEle.forEach(function(ele) {
        ele.classList.remove(SELECT);
        ele.setAttribute("aria-selected", "false");
      });
    };
    ColorPicker2.prototype.convertRgbToNumberArray = function(value) {
      return value.slice(value.indexOf("(") + 1, value.indexOf(")")).split(",").map(function(n, i) {
        return i !== 3 ? parseInt(n, 10) : parseFloat(n);
      });
    };
    ColorPicker2.prototype.getValue = function(value, type) {
      if (!value) {
        value = this.value;
      }
      type = !type ? "hex" : type.toLowerCase();
      if (value[0] === "r") {
        var cValue = this.convertRgbToNumberArray(value);
        if (type === "hex" || type === "hexa") {
          var hex = this.rgbToHex(cValue);
          return type === "hex" ? hex.slice(0, 7) : hex;
        } else {
          if (type === "hsv") {
            return this.convertToHsvString(this.rgbToHsv.apply(this, cValue.slice(0, 3)));
          } else {
            if (type === "hsva") {
              return this.convertToHsvString(this.rgbToHsv.apply(this, cValue));
            } else {
              return "null";
            }
          }
        }
      } else {
        if (value[0] === "h") {
          var cValue = this.hsvToRgb.apply(this, this.convertRgbToNumberArray(value));
          if (type === "rgba") {
            return this.convertToRgbString(cValue);
          } else {
            if (type === "hex" || type === "hexa") {
              var hex = this.rgbToHex(cValue);
              return type === "hex" ? hex.slice(0, 7) : hex;
            } else {
              if (type === "rgb") {
                return this.convertToRgbString(cValue.slice(0, 3));
              } else {
                return "null";
              }
            }
          }
        } else {
          value = this.roundValue(value);
          var rgb = this.hexToRgb(value);
          if (type === "rgb" || type === "hsv") {
            rgb = rgb.slice(0, 3);
          }
          if (type === "rgba" || type === "rgb") {
            return this.convertToRgbString(rgb);
          } else {
            if (type === "hsva" || type === "hsv") {
              return this.convertToHsvString(this.rgbToHsv.apply(this, rgb));
            } else {
              if (type === "hex") {
                return value.slice(0, 7);
              } else {
                if (type === "a") {
                  return rgb[3].toString();
                } else {
                  return "null";
                }
              }
            }
          }
        }
      }
    };
    ColorPicker2.prototype.toggle = function() {
      if (this.container.parentElement.classList.contains("e-popup-close")) {
        this.splitBtn.toggle();
      } else {
        this.closePopup(null);
      }
    };
    ColorPicker2.prototype.getModuleName = function() {
      return "colorpicker";
    };
    ColorPicker2.prototype.getPersistData = function() {
      return this.addOnPersist(["value"]);
    };
    ColorPicker2.prototype.wireEvents = function() {
      if (this.isPicker()) {
        var dragHandler = this.getDragHandler();
        EventHandler.add(dragHandler, "keydown", this.pickerKeyDown, this);
        var ctrlBtn = select("." + CTRLBTN, this.container);
        if (ctrlBtn) {
          EventHandler.add(ctrlBtn, "keydown", this.ctrlBtnKeyDown, this);
        }
        EventHandler.add(this.getHsvContainer(), "mousedown touchstart", this.handlerDown, this);
        if (this.modeSwitcher || this.showButtons) {
          this.addCtrlSwitchEvent();
        }
        EventHandler.add(select("." + PREVIOUS, this.container), "click", this.previewHandler, this);
      } else {
        EventHandler.add(this.container, "click", this.paletteClickHandler, this);
        EventHandler.add(this.container, "keydown", this.paletteKeyDown, this);
      }
    };
    ColorPicker2.prototype.formResetHandler = function() {
      this.value = this.initialInputValue;
      attributes(this.element, { "value": this.initialInputValue });
    };
    ColorPicker2.prototype.addCtrlSwitchEvent = function() {
      var ctrlSwitchBtn = select("." + CTRLSWITCH, this.container);
      if (ctrlSwitchBtn) {
        EventHandler.add(ctrlSwitchBtn, "click", this.btnClickHandler, this);
      }
    };
    ColorPicker2.prototype.ctrlBtnKeyDown = function(e) {
      if (e.keyCode === 13) {
        var applyBtn = select("." + APPLY, this.container);
        if (applyBtn) {
          var cValue = this.rgbToHex(this.rgb);
          this.triggerChangeEvent(cValue);
        }
        this.splitBtn.element.focus();
      }
    };
    ColorPicker2.prototype.pickerKeyDown = function(e) {
      switch (e.keyCode) {
        case 39:
          this.handlerDragPosition(1, this.enableRtl ? -1 : 1, e);
          break;
        case 37:
          this.handlerDragPosition(1, this.enableRtl ? 1 : -1, e);
          break;
        case 38:
          this.handlerDragPosition(2, 1, e);
          break;
        case 40:
          this.handlerDragPosition(2, -1, e);
          break;
        case 13: {
          e.preventDefault();
          var cValue = this.rgbToHex(this.rgb);
          this.enterKeyHandler(cValue);
        }
      }
    };
    ColorPicker2.prototype.enterKeyHandler = function(value) {
      this.triggerChangeEvent(value);
      if (!this.inline) {
        this.splitBtn.element.focus();
      }
    };
    ColorPicker2.prototype.closePopup = function(e) {
      var _this = this;
      var beforeCloseArgs = { element: this.container, event: e, cancel: false };
      this.trigger("beforeClose", beforeCloseArgs, function(observedcloseArgs) {
        if (!observedcloseArgs.cancel) {
          _this.splitBtn.toggle();
          _this.onPopupClose();
        }
      });
    };
    ColorPicker2.prototype.triggerChangeEvent = function(value, e) {
      var hex = value.slice(0, 7);
      this.trigger("change", {
        currentValue: { hex, rgba: this.convertToRgbString(this.rgb) },
        event: e,
        previousValue: { hex: this.value.slice(0, 7), rgba: this.convertToRgbString(this.hexToRgb(this.value)) },
        value: this.enableOpacity ? value : hex
      });
      if (this.showRecentColors) {
        this.recentColors.unshift(hex);
        if (this.inline) {
          this.renderRecentColor();
        }
      }
      if (this.enableOpacity) {
        this.setProperties({ "value": value }, true);
      } else {
        this.setProperties({ "value": hex }, true);
      }
      this.element.value = hex ? hex : "#000000";
    };
    ColorPicker2.prototype.handlerDragPosition = function(prob, value, e) {
      e.preventDefault();
      this.hsv[prob] += value * (e.ctrlKey ? 1 : 3);
      if (this.hsv[prob] < 0) {
        this.hsv[prob] = 0;
      }
      this.updateHsv();
      this.convertToOtherFormat(true, e);
    };
    ColorPicker2.prototype.handlerDown = function(e) {
      e.preventDefault();
      if (e.type === "mousedown") {
        this.clientX = Math.abs(e.pageX - pageXOffset);
        this.clientY = Math.abs(e.pageY - pageYOffset);
        this.setTooltipOffset(8);
      } else {
        this.clientX = Math.abs(e.changedTouches[0].pageX - pageXOffset);
        this.clientY = Math.abs(e.changedTouches[0].pageY - pageYOffset);
        this.setTooltipOffset(-8);
      }
      this.setHsv(this.clientX, this.clientY);
      this.getDragHandler().style.transition = "left .4s cubic-bezier(.25, .8, .25, 1), top .4s cubic-bezier(.25, .8, .25, 1)";
      this.updateHsv();
      this.convertToOtherFormat(false, e);
      this.getDragHandler().focus();
      EventHandler.add(undefined, "mousemove touchmove", this.handlerMove, this);
      EventHandler.add(undefined, "mouseup touchend", this.handlerEnd, this);
    };
    ColorPicker2.prototype.handlerMove = function(e) {
      if (e.type !== "touchmove") {
        e.preventDefault();
      }
      var x;
      var y;
      if (e.type === "mousemove") {
        x = Math.abs(e.pageX - pageXOffset);
        y = Math.abs(e.pageY - pageYOffset);
      } else {
        x = Math.abs(e.changedTouches[0].pageX - pageXOffset);
        y = Math.abs(e.changedTouches[0].pageY - pageYOffset);
      }
      this.setHsv(x, y);
      var dragHandler = this.getDragHandler();
      this.updateHsv();
      this.convertToOtherFormat(false, e);
      this.getTooltipInst().refresh(dragHandler);
      if (!this.tooltipEle.style.transform) {
        if (Math.abs(this.clientX - x) > 8 || Math.abs(this.clientY - y) > 8) {
          select("." + HSVAREA, this.container).style.cursor = "pointer";
          dragHandler.style.transition = "none";
          if (!this.inline) {
            this.tooltipEle.style.zIndex = (parseInt(this.getPopupEle().style.zIndex, 10) + 1).toString();
          }
          this.tooltipEle.style.transform = "rotate(45deg)";
          dragHandler.classList.add("e-hide-handler");
        }
      }
    };
    ColorPicker2.prototype.setHsv = function(clientX, clientY) {
      var ele = select("." + HSVAREA, this.container);
      var position = ele.getBoundingClientRect();
      if (this.enableRtl) {
        clientX = clientX > position.right ? 0 : Math.abs(clientX - position.right);
      } else {
        clientX = clientX > position.left ? Math.abs(clientX - position.left) : 0;
      }
      clientY = clientY > position.top ? Math.abs(clientY - position.top) : 0;
      this.hsv[2] = Math.round(Number(100 * (ele.offsetHeight - Math.max(0, Math.min(ele.offsetHeight, clientY - ele.offsetTop))) / ele.offsetHeight) * 10) / 10;
      this.hsv[1] = Math.round(Number(100 * Math.max(0, Math.min(ele.offsetWidth, clientX - ele.offsetLeft)) / ele.offsetWidth) * 10) / 10;
    };
    ColorPicker2.prototype.handlerEnd = function(e) {
      if (e.type !== "touchend") {
        e.preventDefault();
      }
      EventHandler.remove(undefined, "mousemove touchmove", this.handlerMove);
      EventHandler.remove(undefined, "mouseup touchend", this.handlerEnd);
      var dragHandler = this.getDragHandler();
      select("." + HSVAREA, this.container).style.cursor = "";
      if (this.tooltipEle.style.transform) {
        this.tooltipEle.style.transform = "";
        dragHandler.classList.remove("e-hide-handler");
      }
      if (!this.inline && !this.showButtons) {
        this.closePopup(e);
      }
    };
    ColorPicker2.prototype.btnClickHandler = function(e) {
      var target = e.target;
      if (closest(target, "." + MODESWITCH)) {
        e.stopPropagation();
        this.switchToPalette();
      } else {
        if (target.classList.contains(APPLY) || target.classList.contains(CANCEL)) {
          this.ctrlBtnClick(target, e);
        }
      }
    };
    ColorPicker2.prototype.switchToPalette = function() {
      this.trigger("beforeModeSwitch", { element: this.container, mode: "Palette" });
      this.unWireEvents();
      this.destroyOtherComp();
      detach(select(".e-slider-preview", this.container));
      if (!this.getWrapper().classList.contains(HIDEVALUE)) {
        remove(select("." + INPUTWRAPPER, this.container));
      }
      detach(this.getHsvContainer());
      this.createPalette();
      this.firstPaletteFocus();
      this.createInput();
      this.refreshPopupPos();
      if (this.element.parentElement && this.element.parentElement.parentElement && this.element.parentElement.parentElement.classList.contains("e-ie-ddb-popup")) {
        this.refreshImageEditorPopupPos();
      }
      this.wireEvents();
      this.trigger("onModeSwitch", { element: this.container, mode: "Palette" });
    };
    ColorPicker2.prototype.refreshImageEditorPopupPos = function() {
      if (Browser.isDevice) {
        var popupEle = this.getPopupEle();
        popupEle.style.left = formatUnit(0 + pageXOffset);
        popupEle.style.top = formatUnit(0 + pageYOffset);
        var btnElem = (undefined).querySelector("#" + this.element.parentElement.parentElement.id.split("-popup")[0]);
        if (btnElem) {
          popupEle.parentElement.ej2_instances[0].refreshPosition(btnElem);
        }
      }
    };
    ColorPicker2.prototype.refreshPopupPos = function() {
      if (!this.inline) {
        var popupEle = this.getPopupEle();
        popupEle.style.left = formatUnit(0 + pageXOffset);
        popupEle.style.top = formatUnit(0 + pageYOffset);
        this.getPopupInst().refreshPosition(this.splitBtn.element.parentElement);
      }
    };
    ColorPicker2.prototype.formatSwitchHandler = function() {
      if (this.isRgb) {
        this.updateValue(this.hsv, true, 3, [360, 100, 100]);
        this.isRgb = false;
      } else {
        this.updateValue(this.rgb, true, 2);
        this.isRgb = true;
      }
    };
    ColorPicker2.prototype.updateValue = function(value, format, idx, max) {
      var clsName = ["e-rh-value", "e-gs-value", "e-bv-value"];
      var inst;
      for (var i = 0, len = clsName.length; i < len; i++) {
        inst = getInstance(select("." + clsName[i], this.container), NumericTextBox);
        inst.value = Math.round(value[i]);
        if (format) {
          inst.placeholder = clsName[i].substr(idx, 1).toUpperCase();
          inst.max = max ? max[i] : 255;
        }
        inst.dataBind();
      }
    };
    ColorPicker2.prototype.previewHandler = function(e) {
      var target = e.target;
      var pValue = this.rgbToHex(this.rgb);
      this.rgb = this.convertRgbToNumberArray(target.style.backgroundColor);
      if (!this.rgb[3]) {
        this.rgb[3] = 1;
      }
      var cValue = this.rgbToHex(this.rgb);
      var hsv = this.rgbToHsv.apply(this, this.rgb);
      if (hsv[0] !== this.hsv[0]) {
        this.hueSlider.setProperties({ "value": hsv[0] }, true);
        this.hueSlider.refresh();
      }
      this.setHsvContainerBg(hsv[0]);
      if (this.enableOpacity && hsv[3] !== this.hsv[3]) {
        this.opacitySlider.setProperties({ "value": hsv[3] * 100 }, true);
        this.opacitySlider.refresh();
        this.updateOpacitySliderBg();
      }
      this.hsv = hsv;
      this.setHandlerPosition();
      this.updateInput(cValue);
      select("." + PREVIEW + " ." + CURRENT, this.container).style.backgroundColor = this.convertToRgbString(this.rgb);
      this.triggerEvent(cValue, pValue, this.convertToRgbString(this.rgb), false, e);
    };
    ColorPicker2.prototype.paletteClickHandler = function(e) {
      e.preventDefault();
      var target = e.target;
      if (target.classList.contains(TILE)) {
        this.removeTileSelection();
        this.addTileSelection(target);
        if (target.classList.contains(NOCOLOR)) {
          this.noColorTile();
        } else {
          var cValue = target.getAttribute("aria-label");
          var pValue = this.rgbToHex(this.rgb);
          this.rgb = this.hexToRgb(this.roundValue(cValue));
          this.hsv = this.rgbToHsv.apply(this, this.rgb);
          if (this.getWrapper().classList.contains(SHOWVALUE)) {
            this.updateInput(cValue);
          }
          this.triggerEvent(cValue, pValue, this.convertToRgbString(this.rgb), false, e);
        }
        if (!this.inline && !this.showButtons) {
          this.closePopup(e);
        }
      } else {
        if (closest(target, "." + MODESWITCH)) {
          this.switchToPicker();
        } else {
          if (target.classList.contains(APPLY) || target.classList.contains(CANCEL)) {
            this.ctrlBtnClick(target, e);
          } else {
            if (this.getWrapper().classList.contains(SHOWVALUE) && closest(target, "." + FORMATSWITCH)) {
              this.formatSwitchHandler();
            }
          }
        }
      }
    };
    ColorPicker2.prototype.noColorTile = function(isKey) {
      if (isKey === undefined) {
        isKey = false;
      }
      var pValue = this.rgbToHex(this.rgb);
      this.rgb = [];
      this.hsv = [];
      this.triggerEvent("", pValue, "", isKey);
    };
    ColorPicker2.prototype.switchToPicker = function() {
      var wrapper = this.getWrapper();
      this.trigger("beforeModeSwitch", { element: this.container, mode: "Picker" });
      this.unWireEvents();
      [].slice.call(selectAll("." + PALETTES, this.container)).forEach(function(ele) {
        detach(ele);
      });
      if (this.container.querySelector(".e-clr-pal-rec-wpr")) {
        detach(this.container.querySelector(".e-clr-pal-rec-wpr"));
      }
      if (wrapper.classList.contains(SHOWVALUE)) {
        detach(select("." + INPUTWRAPPER, this.container));
      }
      this.container.style.width = "";
      var grpEle = select(".e-custom-palette", this.container);
      if (this.presetColors) {
        remove(grpEle);
      }
      this.createPicker();
      this.getDragHandler().focus();
      this.createInput();
      this.refreshPopupPos();
      if (this.element.parentElement && this.element.parentElement.parentElement && this.element.parentElement.parentElement.classList.contains("e-ie-ddb-popup")) {
        this.refreshImageEditorPopupPos();
      }
      this.wireEvents();
      this.trigger("onModeSwitch", { element: this.container, mode: "Picker" });
    };
    ColorPicker2.prototype.ctrlBtnClick = function(ele, e) {
      if (ele.classList.contains(APPLY)) {
        var cValue = this.rgbToHex(this.rgb);
        this.triggerChangeEvent(cValue, e);
      }
      if (!this.inline) {
        this.closePopup(e);
        this.splitBtn.element.focus();
      } else if (ele.classList.contains(CANCEL)) {
        var beforeCloseArgs = { element: this.container, event: e, cancel: false };
        this.trigger("beforeClose", beforeCloseArgs);
      }
    };
    ColorPicker2.prototype.paletteKeyDown = function(e) {
      var target = e.target;
      if (!target.classList.contains(PALETTES)) {
        return;
      }
      var selectedEle;
      var idx;
      var tiles = [].slice.call(selectAll("." + TILE, target));
      var prevSelectedEle = tiles.filter(function(tile) {
        return tile.classList.contains("e-selected");
      }).pop();
      switch (!e.altKey && e.keyCode) {
        case 39:
          e.preventDefault();
          selectedEle = prevSelectedEle ? tiles[this.tilePosition(tiles, prevSelectedEle, this.enableRtl ? -1 : 1)] : tiles[this.enableRtl ? tiles.length - 1 : 0];
          this.keySelectionChanges(selectedEle);
          break;
        case 37:
          e.preventDefault();
          selectedEle = prevSelectedEle ? tiles[this.tilePosition(tiles, prevSelectedEle, this.enableRtl ? 1 : -1)] : tiles[this.enableRtl ? 0 : tiles.length - 1];
          this.keySelectionChanges(selectedEle);
          break;
        case 38:
          e.preventDefault();
          idx = prevSelectedEle ? this.tilePosition(tiles, prevSelectedEle, -this.columns) : 0;
          selectedEle = tiles[idx] ? tiles[idx] : tiles[idx - this.columns];
          this.keySelectionChanges(selectedEle);
          break;
        case 40:
          e.preventDefault();
          idx = prevSelectedEle ? this.tilePosition(tiles, prevSelectedEle, this.columns) : tiles.length - 1;
          if (tiles[idx]) {
            selectedEle = tiles[idx];
          } else {
            idx %= tiles.length;
            idx += tiles[tiles.length - 1].parentElement.childElementCount;
            selectedEle = tiles[idx];
          }
          this.keySelectionChanges(selectedEle);
          break;
        case 13:
          e.preventDefault();
          if (prevSelectedEle) {
            var cValue = prevSelectedEle.getAttribute("aria-label");
            this.enterKeyHandler(cValue ? cValue : "");
          }
          break;
      }
    };
    ColorPicker2.prototype.keySelectionChanges = function(newEle) {
      this.removeTileSelection();
      this.addTileSelection(newEle);
      if (newEle.classList.contains(NOCOLOR)) {
        this.noColorTile(true);
      } else {
        var cValue = newEle.getAttribute("aria-label");
        var pValue = this.rgbToHex(this.rgb);
        this.rgb = this.hexToRgb(cValue);
        this.hsv = this.rgbToHsv.apply(this, this.rgb);
        if (this.getWrapper().classList.contains(SHOWVALUE)) {
          this.updateInput(cValue);
        }
        this.triggerEvent(cValue, pValue, this.convertToRgbString(this.rgb), true);
      }
    };
    ColorPicker2.prototype.tilePosition = function(items, element2, cIdx) {
      items = Array.prototype.slice.call(items);
      var n = items.length;
      var emptyCount = this.columns - items[n - 1].parentElement.childElementCount;
      var idx = items.indexOf(element2);
      idx += cIdx;
      if (idx < 0) {
        idx += n + emptyCount;
      } else {
        idx %= n + emptyCount;
      }
      return idx;
    };
    ColorPicker2.prototype.inputHandler = function(e) {
      var target = e.target;
      if (!target.value.length) {
        return;
      }
      var hsv;
      var pValue;
      var label = select(".e-float-text", target.parentElement).textContent;
      switch (label) {
        case "HEX": {
          var value = "";
          if (target.value[0] === "#" && target.value.length !== 5 || target.value[0] !== "#" && target.value.length !== 4) {
            value = this.roundValue(target.value);
          }
          if (value.length === 9) {
            pValue = this.rgbToHex(this.rgb);
            this.rgb = this.hexToRgb(value + value.substr(-2));
            this.inputValueChange(this.rgbToHsv.apply(this, this.rgb), pValue, target.value, e);
          } else {
            return;
          }
          break;
        }
        case "R":
          if (this.rgb[0] !== Number(target.value)) {
            pValue = this.rgbToHex(this.rgb);
            this.rgb[0] = Number(target.value);
            hsv = this.rgbToHsv.apply(this, this.rgb);
            this.inputValueChange(hsv, pValue, null, e);
          }
          break;
        case "G":
          if (this.rgb[1] !== Number(target.value)) {
            pValue = this.rgbToHex(this.rgb);
            this.rgb[1] = Number(target.value);
            hsv = this.rgbToHsv.apply(this, this.rgb);
            this.inputValueChange(hsv, pValue, null, e);
          }
          break;
        case "B":
          if (this.rgb[2] !== Number(target.value)) {
            pValue = this.rgbToHex(this.rgb);
            this.rgb[2] = Number(target.value);
            hsv = this.rgbToHsv.apply(this, this.rgb);
            this.inputValueChange(hsv, pValue, null, e);
          }
          break;
        case "H":
          this.hueSlider.value = Number(target.value);
          break;
        case "S":
          if (this.hsv[1] !== Number(target.value)) {
            this.hsv[1] = Number(target.value);
            this.updateHsv();
            this.convertToOtherFormat(false, e);
          }
          break;
        case "V":
          if (this.hsv[2] !== Number(target.value)) {
            this.hsv[2] = Number(target.value);
            this.updateHsv();
            this.convertToOtherFormat(false, e);
          }
          break;
        case "A":
          this.opacitySlider.value = Number(target.value);
          break;
      }
    };
    ColorPicker2.prototype.inputValueChange = function(hsv, pValue, value, e) {
      if (hsv[0] !== this.hsv[0]) {
        this.hueSlider.setProperties({ "value": hsv[0] }, true);
        this.hueSlider.refresh();
        this.setHsvContainerBg(hsv[0]);
      }
      this.hsv = hsv;
      var cValue = this.rgbToHex(this.rgb);
      this.setHandlerPosition();
      this.updateInput(value ? value : cValue);
      var rgba = this.convertToRgbString(this.rgb);
      this.updatePreview(rgba);
      this.triggerEvent(cValue, pValue, rgba, false, e);
    };
    ColorPicker2.prototype.triggerEvent = function(cValue, pValue, rgba, isKey, e) {
      if (isKey === undefined) {
        isKey = false;
      }
      var hex = cValue.slice(0, 7);
      if (isNullOrUndefined(e)) {
        e = new MouseEvent("click", { bubbles: true, cancelable: false });
      }
      if (!this.showButtons && !isKey) {
        this.trigger("change", {
          currentValue: { hex, rgba },
          event: e,
          previousValue: { hex: this.value.slice(0, 7), rgba: this.convertToRgbString(this.hexToRgb(this.value)) },
          value: cValue
        });
        if (this.showRecentColors) {
          this.recentColors.unshift(hex);
          if (this.inline) {
            this.renderRecentColor();
          }
        }
        if (this.enableOpacity) {
          this.setProperties({ "value": cValue }, true);
        } else {
          this.setProperties({ "value": hex }, true);
        }
        this.element.value = hex ? hex : "#000000";
      } else {
        this.trigger("select", {
          currentValue: { hex, rgba },
          event: e,
          previousValue: { hex: pValue.slice(0, 7), rgba: this.convertToRgbString(this.hexToRgb(pValue)) }
        });
      }
    };
    ColorPicker2.prototype.destroy = function() {
      var _this = this;
      var wrapper = this.getWrapper();
      _super.prototype.destroy.call(this);
      ["tabindex", "spellcheck"].forEach(function(attr) {
        _this.element.removeAttribute(attr);
      });
      if (this.inline) {
        this.unWireEvents();
        this.destroyOtherComp();
      } else {
        if (this.isPopupOpen()) {
          this.unWireEvents();
          this.destroyOtherComp();
        }
        this.splitBtn.destroy();
        this.splitBtn = null;
      }
      this.tileRipple();
      this.tileRipple = null;
      this.ctrlBtnRipple();
      this.ctrlBtnRipple = null;
      if (this.element.nextElementSibling) {
        detach(this.element.nextElementSibling);
      }
      if (wrapper) {
        wrapper.parentElement.insertBefore(this.element, wrapper);
        detach(wrapper);
      }
      this.container = null;
      if (this.formElement) {
        EventHandler.remove(this.formElement, "reset", this.formResetHandler);
      }
    };
    ColorPicker2.prototype.destroyOtherComp = function() {
      if (this.isPicker()) {
        var popup = closest(this.hueSlider.element, ".e-color-picker");
        var numericElemColl = popup.querySelectorAll(".e-numerictextbox");
        for (var i = 0; i < numericElemColl.length; i++) {
          getInstance(numericElemColl[i], NumericTextBox).destroy();
        }
        this.hueSlider.destroy();
        if (this.enableOpacity) {
          this.opacitySlider.destroy();
          this.opacitySlider = null;
        }
        this.hueSlider = null;
        var tooltipInst = this.getTooltipInst();
        tooltipInst.close();
        tooltipInst.destroy();
        this.tooltipEle = null;
      }
    };
    ColorPicker2.prototype.isPopupOpen = function() {
      return this.getPopupEle().classList.contains("e-popup-open");
    };
    ColorPicker2.prototype.unWireEvents = function() {
      if (this.isPicker()) {
        var dragHandler = this.getDragHandler();
        EventHandler.remove(dragHandler, "keydown", this.pickerKeyDown);
        var ctrlBtn = select("." + CTRLBTN, this.container);
        if (ctrlBtn) {
          EventHandler.remove(ctrlBtn, "keydown", this.ctrlBtnKeyDown);
        }
        EventHandler.remove(this.getHsvContainer(), "mousedown touchstart", this.handlerDown);
        if (this.modeSwitcher || this.showButtons) {
          EventHandler.remove(select("." + CTRLSWITCH, this.container), "click", this.btnClickHandler);
        }
        EventHandler.remove(select("." + PREVIOUS, this.container), "click", this.previewHandler);
      } else {
        EventHandler.remove(this.container, "click", this.paletteClickHandler);
        EventHandler.remove(this.container, "keydown", this.paletteKeyDown);
      }
    };
    ColorPicker2.prototype.roundValue = function(value) {
      if (!value) {
        return "";
      }
      if (value[0] !== "#") {
        value = "#" + value;
      }
      var len = value.length;
      if (len === 4) {
        value += "f";
        len = 5;
      }
      if (len === 5) {
        var tempValue = "";
        for (var i = 1, len_1 = value.length; i < len_1; i++) {
          tempValue += value.charAt(i) + value.charAt(i);
        }
        value = "#" + tempValue;
        len = 9;
      }
      if (len === 7) {
        value += "ff";
      }
      return value;
    };
    ColorPicker2.prototype.hexToRgb = function(hex) {
      if (!hex) {
        return [];
      }
      hex = hex.trim();
      if (hex.length !== 9) {
        hex = this.roundValue(hex);
      }
      var opacity = Number((parseInt(hex.slice(-2), 16) / 255).toFixed(2));
      hex = hex.slice(1, 7);
      var bigInt = parseInt(hex, 16);
      var h = [];
      h.push(bigInt >> 16 & 255);
      h.push(bigInt >> 8 & 255);
      h.push(bigInt & 255);
      h.push(opacity);
      return h;
    };
    ColorPicker2.prototype.rgbToHsv = function(r, g, b, opacity) {
      if (this.rgb && !this.rgb.length) {
        return [];
      }
      r /= 255;
      g /= 255;
      b /= 255;
      var max = Math.max(r, g, b);
      var min = Math.min(r, g, b);
      var h;
      var v = max;
      var d = max - min;
      var s = max === 0 ? 0 : d / max;
      if (max === min) {
        h = 0;
      } else {
        switch (max) {
          case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / d + 2;
            break;
          case b:
            h = (r - g) / d + 4;
            break;
        }
        h /= 6;
      }
      var hsv = [Math.round(h * 360), Math.round(s * 1e3) / 10, Math.round(v * 1e3) / 10];
      if (!isNullOrUndefined(opacity)) {
        hsv.push(opacity);
      }
      return hsv;
    };
    ColorPicker2.prototype.hsvToRgb = function(h, s, v, opacity) {
      var r;
      var g;
      var b;
      s /= 100;
      v /= 100;
      if (s === 0) {
        r = g = b = v;
        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255), opacity];
      }
      h /= 60;
      var i = Math.floor(h);
      var f = h - i;
      var p = v * (1 - s);
      var q = v * (1 - s * f);
      var t = v * (1 - s * (1 - f));
      switch (i) {
        case 0:
          r = v;
          g = t;
          b = p;
          break;
        case 1:
          r = q;
          g = v;
          b = p;
          break;
        case 2:
          r = p;
          g = v;
          b = t;
          break;
        case 3:
          r = p;
          g = q;
          b = v;
          break;
        case 4:
          r = t;
          g = p;
          b = v;
          break;
        default:
          r = v;
          g = p;
          b = q;
      }
      var rgb = [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
      if (!isNullOrUndefined(opacity)) {
        rgb.push(opacity);
      }
      return rgb;
    };
    ColorPicker2.prototype.rgbToHex = function(rgb) {
      return rgb.length ? "#" + this.hex(rgb[0]) + this.hex(rgb[1]) + this.hex(rgb[2]) + (!isNullOrUndefined(rgb[3]) ? rgb[3] !== 0 ? (Math.round(rgb[3] * 255) + 65536).toString(16).substr(-2) : "00" : "") : "";
    };
    ColorPicker2.prototype.hex = function(x) {
      return ("0" + x.toString(16)).slice(-2);
    };
    ColorPicker2.prototype.changeModeSwitcherProp = function(prop) {
      var ctrlSwitchWrapper = select("." + CTRLSWITCH, this.container);
      if (prop) {
        if (ctrlSwitchWrapper) {
          this.appendModeSwitchBtn();
        } else {
          this.createCtrlBtn();
          if (this.isPicker() && !this.disabled) {
            this.addCtrlSwitchEvent();
          }
        }
      } else {
        if (ctrlSwitchWrapper) {
          if (this.showButtons) {
            detach(select("." + MODESWITCH, ctrlSwitchWrapper));
          } else {
            remove(ctrlSwitchWrapper);
          }
        }
      }
    };
    ColorPicker2.prototype.changeShowBtnProps = function(prop) {
      var ctrlBtnWrapper = select("." + CTRLSWITCH, this.container);
      if (prop) {
        if (ctrlBtnWrapper) {
          remove(ctrlBtnWrapper);
        }
        this.createCtrlBtn();
        if (this.isPicker() && !this.disabled) {
          this.addCtrlSwitchEvent();
        }
      } else {
        if (this.modeSwitcher) {
          detach(select("." + CTRLBTN, ctrlBtnWrapper));
        } else {
          remove(ctrlBtnWrapper);
        }
      }
    };
    ColorPicker2.prototype.changeValueProp = function(newProp) {
      if (this.isPicker()) {
        this.rgb = this.hexToRgb(newProp);
        this.hsv = this.rgbToHsv.apply(this, this.rgb);
        this.setHandlerPosition();
        detach(closest(this.hueSlider.element, ".e-slider-preview"));
        this.createSlider();
        this.setHsvContainerBg();
        this.updateInput(newProp);
        if (this.rgb.length === 4) {
          this.updateOpacityInput(this.rgb[3] * 100);
        }
      } else {
        this.removeTileSelection();
        var ele = this.container.querySelector('span[aria-label="' + this.roundValue(newProp) + '"]');
        if (ele) {
          this.addTileSelection(ele);
        }
      }
    };
    ColorPicker2.prototype.setInputEleProps = function() {
      remove(select("." + INPUTWRAPPER, this.container));
      this.createInput();
    };
    ColorPicker2.prototype.changeDisabledProp = function(newProp) {
      if (this.isPicker()) {
        this.hueSlider.enabled = !newProp;
        this.opacitySlider.enabled = !newProp;
        this.setInputEleProps();
      }
      if (newProp) {
        this.toggleDisabled(true);
        this.unWireEvents();
      } else {
        this.toggleDisabled(false);
        this.wireEvents();
      }
    };
    ColorPicker2.prototype.changeCssClassProps = function(newProp, oldProp) {
      var wrapper = this.getWrapper();
      var popupWrapper = this.getPopupEle();
      if (oldProp) {
        removeClass([wrapper, popupWrapper], oldProp.split(" "));
      }
      if (newProp) {
        addClass([wrapper, popupWrapper], newProp.replace(/\s+/g, " ").trim().split(" "));
      }
    };
    ColorPicker2.prototype.changeRtlProps = function(newProp) {
      if (newProp) {
        addClass([this.getWrapper()], "e-rtl");
      } else {
        removeClass([this.getWrapper()], "e-rtl");
      }
    };
    ColorPicker2.prototype.changePaletteProps = function() {
      detach(this.container.children[0]);
      this.container.style.width = "";
      this.createPalette();
    };
    ColorPicker2.prototype.changeOpacityProps = function(newProp) {
      var wrapper = this.getWrapper();
      if (newProp) {
        removeClass([this.container.parentElement], HIDEOPACITY);
        this.createOpacitySlider(select(".e-colorpicker-slider", this.container).appendChild(this.createElement("div", { className: "e-opacity-slider" })));
        if (!wrapper.classList.contains(HIDEVALUE) && !wrapper.classList.contains(HIDERGBA)) {
          this.appendOpacityValue(select(".e-input-container", this.container));
        }
      } else {
        addClass([this.container.parentElement], HIDEOPACITY);
        this.opacitySlider.destroy();
        remove(this.opacitySlider.element);
        this.opacitySlider = null;
        if (!wrapper.classList.contains(HIDEVALUE) && !wrapper.classList.contains(HIDERGBA)) {
          remove(select("." + OPACITY, this.container).parentElement);
        }
      }
    };
    ColorPicker2.prototype.onPropertyChanged = function(newProp, oldProp) {
      var _this = this;
      if (!isNullOrUndefined(newProp.value)) {
        var value = this.roundValue(newProp.value);
        if (value.length === 9) {
          this.element.value = this.roundValue(value).slice(0, 7);
          var preview = this.splitBtn && select("." + SPLITPREVIEW, this.splitBtn.element);
          if (preview) {
            preview.style.backgroundColor = this.convertToRgbString(this.hexToRgb(newProp.value));
          }
        } else if (this.noColor && this.mode === "Palette" && this.value === "") {
          var preview = this.splitBtn && select("." + SPLITPREVIEW, this.splitBtn.element);
          preview.style.backgroundColor = "";
        } else {
          this.value = oldProp.value;
        }
      }
      if (!this.inline && isNullOrUndefined(newProp.inline)) {
        var otherCompModel = ["disabled", "enableRtl"];
        this.splitBtn.setProperties(getModel(newProp, otherCompModel));
        if (!this.isPopupOpen()) {
          this.changeCssClassProps(newProp.cssClass, oldProp.cssClass);
          this.changeRtlProps(newProp.enableRtl);
          return;
        }
      }
      var _loop_1 = function(prop2) {
        switch (prop2) {
          case "inline":
            if (newProp.inline) {
              this_1.getWrapper().appendChild(this_1.container);
              this_1.splitBtn.destroy();
              detach(this_1.element.nextElementSibling);
              if (!this_1.container.children.length) {
                this_1.createWidget();
              }
            } else {
              this_1.destroyOtherComp();
              this_1.unWireEvents();
              this_1.container.innerHTML = "";
              this_1.createSplitBtn();
            }
            break;
          case "cssClass": {
            this_1.changeCssClassProps(newProp.cssClass, oldProp.cssClass);
            var props2 = newProp.cssClass.split(" ").concat(oldProp.cssClass.split(" "));
            props2 = props2.reduce(function(a, b) {
              if (a.indexOf(b) < 0) {
                a.push(b);
              }
              return a;
            }, []);
            var count_1 = 0;
            props2.forEach(function(cls) {
              if (count_1 === 0 && (cls === HIDEVALUE || cls === HIDEVALUESWITCH || cls === SHOWVALUE || cls === HIDEHEX || cls === HIDERGBA)) {
                var inputWrap = select("." + INPUTWRAPPER, _this.container);
                if (inputWrap) {
                  remove(select("." + INPUTWRAPPER, _this.container));
                }
                _this.createInput();
                count_1++;
              }
            });
            break;
          }
          case "enableRtl":
            if (this_1.isPicker()) {
              this_1.hueSlider.enableRtl = newProp.enableRtl;
              if (this_1.enableOpacity) {
                this_1.opacitySlider.enableRtl = newProp.enableRtl;
              }
              this_1.setInputEleProps();
            }
            this_1.changeRtlProps(newProp.enableRtl);
            break;
          case "disabled":
            this_1.changeDisabledProp(newProp.disabled);
            break;
          case "value":
            if (this_1.value !== oldProp.value) {
              this_1.changeValueProp(newProp.value);
            }
            break;
          case "showButtons":
            this_1.changeShowBtnProps(newProp.showButtons);
            break;
          case "mode":
            if (newProp.mode === "Picker") {
              this_1.switchToPicker();
            } else {
              this_1.switchToPalette();
            }
            break;
          case "modeSwitcher":
            this_1.changeModeSwitcherProp(newProp.modeSwitcher);
            break;
          case "columns":
          case "presetColors":
            if (!this_1.isPicker()) {
              this_1.changePaletteProps();
            }
            break;
          case "noColor":
            if (newProp.noColor) {
              if (this_1.mode === "Palette" && !this_1.modeSwitcher) {
                this_1.setNoColor();
              }
            } else {
              this_1.changePaletteProps();
            }
            break;
          case "enableOpacity":
            this_1.changeOpacityProps(newProp.enableOpacity);
            break;
          case "showRecentColors":
            if (!newProp.showRecentColors) {
              var recentClrWpr = this_1.container.querySelector(".e-clr-pal-rec-wpr");
              if (recentClrWpr) {
                detach(recentClrWpr);
              }
            }
            this_1.recentColors = [];
            break;
        }
      };
      var this_1 = this;
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        _loop_1(prop);
      }
    };
    ColorPicker2.prototype.focusIn = function() {
      this.element.parentElement.focus();
    };
    __decorate$5([
      Property("#008000ff")
    ], ColorPicker2.prototype, "value", undefined);
    __decorate$5([
      Property("")
    ], ColorPicker2.prototype, "cssClass", undefined);
    __decorate$5([
      Property(false)
    ], ColorPicker2.prototype, "disabled", undefined);
    __decorate$5([
      Property("Picker")
    ], ColorPicker2.prototype, "mode", undefined);
    __decorate$5([
      Property(true)
    ], ColorPicker2.prototype, "modeSwitcher", undefined);
    __decorate$5([
      Property(null)
    ], ColorPicker2.prototype, "presetColors", undefined);
    __decorate$5([
      Property(true)
    ], ColorPicker2.prototype, "showButtons", undefined);
    __decorate$5([
      Property(10)
    ], ColorPicker2.prototype, "columns", undefined);
    __decorate$5([
      Property(false)
    ], ColorPicker2.prototype, "inline", undefined);
    __decorate$5([
      Property(false)
    ], ColorPicker2.prototype, "noColor", undefined);
    __decorate$5([
      Property(false)
    ], ColorPicker2.prototype, "enablePersistence", undefined);
    __decorate$5([
      Property(true)
    ], ColorPicker2.prototype, "enableOpacity", undefined);
    __decorate$5([
      Property(false)
    ], ColorPicker2.prototype, "createPopupOnClick", undefined);
    __decorate$5([
      Property(false)
    ], ColorPicker2.prototype, "showRecentColors", undefined);
    __decorate$5([
      Event()
    ], ColorPicker2.prototype, "select", undefined);
    __decorate$5([
      Event()
    ], ColorPicker2.prototype, "change", undefined);
    __decorate$5([
      Event()
    ], ColorPicker2.prototype, "beforeTileRender", undefined);
    __decorate$5([
      Event()
    ], ColorPicker2.prototype, "beforeOpen", undefined);
    __decorate$5([
      Event()
    ], ColorPicker2.prototype, "open", undefined);
    __decorate$5([
      Event()
    ], ColorPicker2.prototype, "beforeClose", undefined);
    __decorate$5([
      Event()
    ], ColorPicker2.prototype, "beforeModeSwitch", undefined);
    __decorate$5([
      Event()
    ], ColorPicker2.prototype, "onModeSwitch", undefined);
    __decorate$5([
      Event()
    ], ColorPicker2.prototype, "created", undefined);
    ColorPicker2 = __decorate$5([
      NotifyPropertyChanges
    ], ColorPicker2);
    return ColorPicker2;
  }(Component)
);
var __extends$4 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate$4 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var HIDE_CLEAR = "e-clear-icon-hide";
var TextBox = (
  /** @class */
  function(_super) {
    __extends$4(TextBox2, _super);
    function TextBox2(options, element2) {
      var _this = _super.call(this, options, element2) || this;
      _this.previousValue = null;
      _this.isHiddenInput = false;
      _this.isForm = false;
      _this.inputPreviousValue = null;
      _this.textboxOptions = options;
      return _this;
    }
    TextBox2.prototype.onPropertyChanged = function(newProp, oldProp) {
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "floatLabelType":
            Input.removeFloating(this.textboxWrapper);
            Input.addFloating(this.respectiveElement, this.floatLabelType, this.placeholder);
            break;
          case "enabled":
            Input.setEnabled(this.enabled, this.respectiveElement, this.floatLabelType, this.textboxWrapper.container);
            this.bindClearEvent();
            break;
          case "width":
            Input.setWidth(newProp.width, this.textboxWrapper.container);
            break;
          case "value":
            {
              var prevOnChange = this.isProtectedOnChange;
              this.isProtectedOnChange = true;
              if (!Input.isBlank(this.value)) {
                this.value = this.value.toString();
              }
              this.isProtectedOnChange = prevOnChange;
              Input.setValue(this.value, this.respectiveElement, this.floatLabelType, this.showClearButton);
              if (this.isHiddenInput) {
                this.element.value = this.respectiveElement.value;
              }
              this.inputPreviousValue = this.respectiveElement.value;
              if ((this.isAngular || this.isVue) && this.preventChange === true) {
                this.previousValue = this.isAngular ? this.value : this.previousValue;
                this.preventChange = false;
              } else if (isNullOrUndefined(this.isAngular) || !this.isAngular || this.isAngular && !this.preventChange || this.isAngular && isNullOrUndefined(this.preventChange)) {
                this.raiseChangeEvent();
              }
            }
            break;
          case "htmlAttributes":
            {
              this.updateHTMLAttributesToElement();
              this.updateHTMLAttributesToWrapper();
              this.checkAttributes(true);
              if (this.multiline && !isNullOrUndefined(this.textarea)) {
                Input.validateInputType(this.textboxWrapper.container, this.textarea);
              } else {
                Input.validateInputType(this.textboxWrapper.container, this.element);
              }
            }
            break;
          case "readonly":
            Input.setReadonly(this.readonly, this.respectiveElement);
            break;
          case "type":
            if (this.respectiveElement.tagName !== "TEXTAREA") {
              this.respectiveElement.setAttribute("type", this.type);
              Input.validateInputType(this.textboxWrapper.container, this.element);
              this.raiseChangeEvent();
            }
            break;
          case "showClearButton":
            Input.setClearButton(this.showClearButton, this.respectiveElement, this.textboxWrapper);
            this.bindClearEvent();
            break;
          case "enableRtl":
            Input.setEnableRtl(this.enableRtl, [this.textboxWrapper.container]);
            break;
          case "placeholder":
            Input.setPlaceholder(this.placeholder, this.respectiveElement);
            Input.calculateWidth(this.respectiveElement, this.textboxWrapper.container);
            break;
          case "autocomplete":
            if (this.autocomplete !== "on" && this.autocomplete !== "") {
              this.respectiveElement.autocomplete = this.autocomplete;
            } else {
              this.removeAttributes(["autocomplete"]);
            }
            break;
          case "cssClass":
            Input.updateCssClass(newProp.cssClass, oldProp.cssClass, this.textboxWrapper.container);
            break;
          case "locale":
            this.globalize = new Internationalization(this.locale);
            this.l10n.setLocale(this.locale);
            this.setProperties({ placeholder: this.l10n.getConstant("placeholder") }, true);
            Input.setPlaceholder(this.placeholder, this.respectiveElement);
            break;
        }
      }
    };
    TextBox2.prototype.getModuleName = function() {
      return "textbox";
    };
    TextBox2.prototype.preRender = function() {
      this.cloneElement = this.element.cloneNode(true);
      this.formElement = closest(this.element, "form");
      if (!isNullOrUndefined(this.formElement)) {
        this.isForm = true;
      }
      if (this.element.tagName === "EJS-TEXTBOX") {
        var ejInstance = getValue("ej2_instances", this.element);
        var inputElement = this.multiline ? this.createElement("textarea") : this.createElement("input");
        var index = 0;
        for (index; index < this.element.attributes.length; index++) {
          var attributeName = this.element.attributes[index].nodeName;
          if (attributeName !== "id" && attributeName !== "class") {
            inputElement.setAttribute(attributeName, this.element.attributes[index].nodeValue);
            inputElement.innerHTML = this.element.innerHTML;
            if (attributeName === "name") {
              this.element.removeAttribute("name");
            }
          } else if (attributeName === "class") {
            inputElement.setAttribute(attributeName, this.element.className.split(" ").filter(function(item) {
              return item.indexOf("ng-") !== 0;
            }).join(" "));
          }
        }
        this.element.appendChild(inputElement);
        this.element = inputElement;
        setValue("ej2_instances", ejInstance, this.element);
      }
      this.updateHTMLAttributesToElement();
      this.checkAttributes(false);
      if ((isNullOrUndefined(this.textboxOptions) || this.textboxOptions["value"] === undefined) && this.element.value !== "") {
        this.setProperties({ value: this.element.value }, true);
      }
      if (this.element.tagName !== "TEXTAREA") {
        this.element.setAttribute("type", this.type);
      }
      if (this.type === "text" || this.element.tagName === "INPUT" && this.multiline && this.isReact) {
        this.element.setAttribute("role", "textbox");
      }
      this.globalize = new Internationalization(this.locale);
      var localeText = { placeholder: this.placeholder };
      this.l10n = new L10n("textbox", localeText, this.locale);
      if (this.l10n.getConstant("placeholder") !== "") {
        this.setProperties({ placeholder: this.placeholder || this.l10n.getConstant("placeholder") }, true);
      }
      if (!this.element.hasAttribute("id")) {
        this.element.setAttribute("id", getUniqueID("textbox"));
      }
      if (!this.element.hasAttribute("name")) {
        this.element.setAttribute("name", this.element.getAttribute("id"));
      }
      if (this.element.tagName === "INPUT" && this.multiline) {
        this.isHiddenInput = true;
        this.textarea = this.createElement("textarea");
        this.element.parentNode.insertBefore(this.textarea, this.element);
        this.element.setAttribute("type", "hidden");
        this.textarea.setAttribute("name", this.element.getAttribute("name"));
        this.element.removeAttribute("name");
        this.textarea.setAttribute("role", this.element.getAttribute("role"));
        this.element.removeAttribute("role");
        this.textarea.setAttribute("id", getUniqueID("textarea"));
        var apiAttributes = ["placeholder", "disabled", "value", "readonly", "type", "autocomplete"];
        for (var index = 0; index < this.element.attributes.length; index++) {
          var attributeName = this.element.attributes[index].nodeName;
          if (this.element.hasAttribute(attributeName) && containerAttributes.indexOf(attributeName) < 0 && !(attributeName === "id" || attributeName === "type" || attributeName === "e-mappinguid")) {
            this.textarea.setAttribute(attributeName, this.element.attributes[index].nodeValue);
            if (apiAttributes.indexOf(attributeName) < 0) {
              this.element.removeAttribute(attributeName);
              index--;
            }
          }
        }
      }
    };
    TextBox2.prototype.checkAttributes = function(isDynamic) {
      var attrs = isDynamic ? isNullOrUndefined(this.htmlAttributes) ? [] : Object.keys(this.htmlAttributes) : ["placeholder", "disabled", "value", "readonly", "type", "autocomplete"];
      for (var _i = 0, attrs_1 = attrs; _i < attrs_1.length; _i++) {
        var key = attrs_1[_i];
        if (!isNullOrUndefined(this.element.getAttribute(key))) {
          switch (key) {
            case "disabled":
              if (isNullOrUndefined(this.textboxOptions) || this.textboxOptions["enabled"] === undefined || isDynamic) {
                var enabled = this.element.getAttribute(key) === "disabled" || this.element.getAttribute(key) === "" || this.element.getAttribute(key) === "true" ? false : true;
                this.setProperties({ enabled }, !isDynamic);
              }
              break;
            case "readonly":
              if (isNullOrUndefined(this.textboxOptions) || this.textboxOptions["readonly"] === undefined || isDynamic) {
                var readonly = this.element.getAttribute(key) === "readonly" || this.element.getAttribute(key) === "" || this.element.getAttribute(key) === "true" ? true : false;
                this.setProperties({ readonly }, !isDynamic);
              }
              break;
            case "placeholder":
              if (isNullOrUndefined(this.textboxOptions) || this.textboxOptions["placeholder"] === undefined || isDynamic) {
                this.setProperties({ placeholder: this.element.placeholder }, !isDynamic);
              }
              break;
            case "autocomplete":
              if (isNullOrUndefined(this.textboxOptions) || this.textboxOptions["autocomplete"] === undefined || isDynamic) {
                var autoCompleteTxt = this.element.autocomplete === "off" ? "off" : "on";
                this.setProperties({ autocomplete: autoCompleteTxt }, !isDynamic);
              }
              break;
            case "value":
              if ((isNullOrUndefined(this.textboxOptions) || this.textboxOptions["value"] === undefined || isDynamic) && this.element.value !== "") {
                this.setProperties({ value: this.element.value }, !isDynamic);
              }
              break;
            case "type":
              if (isNullOrUndefined(this.textboxOptions) || this.textboxOptions["type"] === undefined || isDynamic) {
                this.setProperties({ type: this.element.type }, !isDynamic);
              }
              break;
          }
        }
      }
    };
    TextBox2.prototype.render = function() {
      var updatedCssClassValue = this.cssClass;
      if (!isNullOrUndefined(this.cssClass) && this.cssClass !== "") {
        updatedCssClassValue = Input.getInputValidClassList(this.cssClass);
      }
      this.respectiveElement = this.isHiddenInput ? this.textarea : this.element;
      this.textboxWrapper = Input.createInput({
        element: this.respectiveElement,
        floatLabelType: this.floatLabelType,
        properties: {
          enabled: this.enabled,
          enableRtl: this.enableRtl,
          cssClass: updatedCssClassValue,
          readonly: this.readonly,
          placeholder: this.placeholder,
          showClearButton: this.showClearButton
        }
      });
      this.updateHTMLAttributesToWrapper();
      if (this.isHiddenInput) {
        this.respectiveElement.parentNode.insertBefore(this.element, this.respectiveElement);
      }
      this.wireEvents();
      if (!isNullOrUndefined(this.value)) {
        Input.setValue(this.value, this.respectiveElement, this.floatLabelType, this.showClearButton);
        if (this.isHiddenInput) {
          this.element.value = this.respectiveElement.value;
        }
      }
      if (!isNullOrUndefined(this.value)) {
        this.initialValue = this.value;
        this.setInitialValue();
      }
      if (this.autocomplete !== "on" && this.autocomplete !== "") {
        this.respectiveElement.autocomplete = this.autocomplete;
      } else if (!isNullOrUndefined(this.textboxOptions) && this.textboxOptions["autocomplete"] !== undefined) {
        this.removeAttributes(["autocomplete"]);
      }
      this.previousValue = this.value;
      this.inputPreviousValue = this.value;
      this.respectiveElement.defaultValue = this.respectiveElement.value;
      Input.setWidth(this.width, this.textboxWrapper.container);
      if (!isNullOrUndefined(closest(this.element, "fieldset")) && closest(this.element, "fieldset").disabled) {
        this.enabled = false;
      }
      if (!this.element.hasAttribute("aria-labelledby") && !this.element.hasAttribute("placeholder") && !this.element.hasAttribute("aria-label")) {
        this.element.setAttribute("aria-label", "textbox");
      }
      this.renderComplete();
    };
    TextBox2.prototype.updateHTMLAttributesToWrapper = function() {
      Input.updateHTMLAttributesToWrapper(this.htmlAttributes, this.textboxWrapper.container);
    };
    TextBox2.prototype.updateHTMLAttributesToElement = function() {
      Input.updateHTMLAttributesToElement(this.htmlAttributes, this.respectiveElement ? this.respectiveElement : this.multiline && !isNullOrUndefined(this.textarea) ? this.textarea : this.element);
    };
    TextBox2.prototype.setInitialValue = function() {
      if (!this.isAngular) {
        this.respectiveElement.setAttribute("value", this.initialValue);
      }
    };
    TextBox2.prototype.wireEvents = function() {
      EventHandler.add(this.respectiveElement, "focus", this.focusHandler, this);
      EventHandler.add(this.respectiveElement, "blur", this.focusOutHandler, this);
      EventHandler.add(this.respectiveElement, "keydown", this.keydownHandler, this);
      EventHandler.add(this.respectiveElement, "input", this.inputHandler, this);
      EventHandler.add(this.respectiveElement, "change", this.changeHandler, this);
      if (this.isForm) {
        EventHandler.add(this.formElement, "reset", this.resetForm, this);
      }
      this.bindClearEvent();
      if (!isNullOrUndefined(this.textboxWrapper.container.querySelector(".e-float-text")) && this.floatLabelType === "Auto" && this.textboxWrapper.container.classList.contains("e-autofill") && this.textboxWrapper.container.classList.contains("e-outline")) {
        EventHandler.add(this.textboxWrapper.container.querySelector(".e-float-text"), "animationstart", this.animationHandler, this);
      }
    };
    TextBox2.prototype.animationHandler = function() {
      this.textboxWrapper.container.classList.add("e-valid-input");
      var label = this.textboxWrapper.container.querySelector(".e-float-text");
      if (!isNullOrUndefined(label)) {
        label.classList.add("e-label-top");
        if (label.classList.contains("e-label-bottom")) {
          label.classList.remove("e-label-bottom");
        }
      }
    };
    TextBox2.prototype.resetValue = function(value) {
      var prevOnChange = this.isProtectedOnChange;
      this.isProtectedOnChange = true;
      this.value = value;
      if (value == null && this.textboxWrapper.container.classList.contains("e-valid-input") && !(this.floatLabelType === "Always" && this.textboxWrapper.container.classList.contains("e-outline"))) {
        this.textboxWrapper.container.classList.remove("e-valid-input");
      }
      this.isProtectedOnChange = prevOnChange;
    };
    TextBox2.prototype.resetForm = function() {
      if (this.isAngular) {
        this.resetValue("");
      } else {
        this.resetValue(this.initialValue);
      }
      if (!isNullOrUndefined(this.textboxWrapper)) {
        var label = this.textboxWrapper.container.querySelector(".e-float-text");
        if (!isNullOrUndefined(label) && this.floatLabelType !== "Always") {
          if (isNullOrUndefined(this.initialValue) || this.initialValue === "") {
            label.classList.add("e-label-bottom");
            label.classList.remove("e-label-top");
          } else if (this.initialValue !== "") {
            label.classList.add("e-label-top");
            label.classList.remove("e-label-bottom");
          }
        }
      }
    };
    TextBox2.prototype.focusHandler = function(args) {
      var eventArgs = {
        container: this.textboxWrapper.container,
        event: args,
        value: this.value
      };
      this.trigger("focus", eventArgs);
    };
    TextBox2.prototype.focusOutHandler = function(args) {
      if (!(this.previousValue === null && this.value === null && this.respectiveElement.value === "") && this.previousValue !== this.value) {
        this.raiseChangeEvent(args, true);
      }
      var eventArgs = {
        container: this.textboxWrapper.container,
        event: args,
        value: this.value
      };
      this.trigger("blur", eventArgs);
    };
    TextBox2.prototype.keydownHandler = function(args) {
      if ((args.keyCode === 13 || args.keyCode === 9) && !((this.previousValue === null || this.previousValue === "") && (this.value === null || this.value === "") && this.respectiveElement.value === "")) {
        this.setProperties({ value: this.respectiveElement.value }, true);
      }
    };
    TextBox2.prototype.inputHandler = function(args) {
      var textboxObj = this;
      var eventArgs = {
        event: args,
        value: this.respectiveElement.value,
        previousValue: this.inputPreviousValue,
        container: this.textboxWrapper.container
      };
      this.inputPreviousValue = this.respectiveElement.value;
      if (this.isAngular) {
        textboxObj.localChange({ value: this.respectiveElement.value });
        this.preventChange = true;
      }
      if (this.isVue) {
        this.preventChange = true;
      }
      this.trigger("input", eventArgs);
      args.stopPropagation();
    };
    TextBox2.prototype.changeHandler = function(args) {
      this.setProperties({ value: this.respectiveElement.value }, true);
      if (this.previousValue !== this.value) {
        this.raiseChangeEvent(args, true);
      }
      args.stopPropagation();
    };
    TextBox2.prototype.raiseChangeEvent = function(event, interaction) {
      var eventArgs = {
        event,
        value: this.value,
        previousValue: this.previousValue,
        container: this.textboxWrapper.container,
        isInteraction: interaction ? interaction : false,
        isInteracted: interaction ? interaction : false
      };
      this.preventChange = false;
      this.trigger("change", eventArgs);
      this.previousValue = this.value;
      if (this.element.tagName === "INPUT" && this.multiline && Browser.info.name === "mozilla") {
        this.element.value = this.respectiveElement.value;
      }
    };
    TextBox2.prototype.bindClearEvent = function() {
      if (this.showClearButton) {
        if (this.enabled) {
          EventHandler.add(this.textboxWrapper.clearButton, "mousedown touchstart", this.resetInputHandler, this);
        } else {
          EventHandler.remove(this.textboxWrapper.clearButton, "mousedown touchstart", this.resetInputHandler);
        }
      }
    };
    TextBox2.prototype.resetInputHandler = function(event) {
      event.preventDefault();
      if (!this.textboxWrapper.clearButton.classList.contains(HIDE_CLEAR) || this.textboxWrapper.container.classList.contains("e-static-clear")) {
        Input.setValue("", this.respectiveElement, this.floatLabelType, this.showClearButton);
        if (this.isHiddenInput) {
          this.element.value = this.respectiveElement.value;
        }
        this.setProperties({ value: this.respectiveElement.value }, true);
        var eventArgs = {
          event,
          value: this.respectiveElement.value,
          previousValue: this.inputPreviousValue,
          container: this.textboxWrapper.container
        };
        this.trigger("input", eventArgs);
        this.inputPreviousValue = this.respectiveElement.value;
        this.raiseChangeEvent(event, true);
        if (closest(this.element, "form")) {
          var element2 = this.element;
          var keyupEvent = (undefined).createEvent("KeyboardEvent");
          keyupEvent.initEvent("keyup", false, true);
          element2.dispatchEvent(keyupEvent);
        }
      }
    };
    TextBox2.prototype.unWireEvents = function() {
      EventHandler.remove(this.respectiveElement, "focus", this.focusHandler);
      EventHandler.remove(this.respectiveElement, "blur", this.focusOutHandler);
      EventHandler.remove(this.respectiveElement, "keydown", this.keydownHandler);
      EventHandler.remove(this.respectiveElement, "input", this.inputHandler);
      EventHandler.remove(this.respectiveElement, "change", this.changeHandler);
      if (this.isForm) {
        EventHandler.remove(this.formElement, "reset", this.resetForm);
      }
      if (!isNullOrUndefined(this.textboxWrapper.container.querySelector(".e-float-text")) && this.floatLabelType === "Auto" && this.textboxWrapper.container.classList.contains("e-outline") && this.textboxWrapper.container.classList.contains("e-autofill")) {
        EventHandler.remove(this.textboxWrapper.container.querySelector(".e-float-text"), "animationstart", this.animationHandler);
      }
    };
    TextBox2.prototype.destroy = function() {
      this.unWireEvents();
      if (this.showClearButton) {
        this.clearButton = (undefined).getElementsByClassName("e-clear-icon")[0];
      }
      if (this.element.tagName === "INPUT" && this.multiline) {
        detach(this.textboxWrapper.container.getElementsByTagName("textarea")[0]);
        this.respectiveElement = this.element;
        this.element.removeAttribute("type");
      }
      this.respectiveElement.value = this.respectiveElement.defaultValue;
      this.respectiveElement.classList.remove("e-input");
      this.removeAttributes(["aria-disabled", "aria-readonly", "aria-labelledby"]);
      if (!isNullOrUndefined(this.textboxWrapper)) {
        this.textboxWrapper.container.insertAdjacentElement("afterend", this.respectiveElement);
        detach(this.textboxWrapper.container);
      }
      this.textboxWrapper = null;
      Input.destroy({
        element: this.respectiveElement,
        floatLabelType: this.floatLabelType,
        properties: this.properties
      }, this.clearButton);
      _super.prototype.destroy.call(this);
    };
    TextBox2.prototype.addIcon = function(position, icons) {
      Input.addIcon(position, icons, this.textboxWrapper.container, this.respectiveElement, this.createElement);
    };
    TextBox2.prototype.getPersistData = function() {
      var keyEntity = ["value"];
      return this.addOnPersist(keyEntity);
    };
    TextBox2.prototype.addAttributes = function(attributes2) {
      for (var _i = 0, _a = Object.keys(attributes2); _i < _a.length; _i++) {
        var key = _a[_i];
        if (key === "disabled") {
          this.setProperties({ enabled: false }, true);
          Input.setEnabled(this.enabled, this.respectiveElement, this.floatLabelType, this.textboxWrapper.container);
        } else if (key === "readonly") {
          this.setProperties({ readonly: true }, true);
          Input.setReadonly(this.readonly, this.respectiveElement);
        } else if (key === "class") {
          this.respectiveElement.classList.add(attributes2["" + key]);
        } else if (key === "placeholder") {
          this.setProperties({ placeholder: attributes2["" + key] }, true);
          Input.setPlaceholder(this.placeholder, this.respectiveElement);
        } else if (key === "rows" && this.respectiveElement.tagName === "TEXTAREA") {
          this.respectiveElement.setAttribute(key, attributes2["" + key]);
        } else {
          this.respectiveElement.setAttribute(key, attributes2["" + key]);
        }
      }
    };
    TextBox2.prototype.removeAttributes = function(attributes2) {
      for (var _i = 0, attributes_1 = attributes2; _i < attributes_1.length; _i++) {
        var key = attributes_1[_i];
        if (key === "disabled") {
          this.setProperties({ enabled: true }, true);
          Input.setEnabled(this.enabled, this.respectiveElement, this.floatLabelType, this.textboxWrapper.container);
        } else if (key === "readonly") {
          this.setProperties({ readonly: false }, true);
          Input.setReadonly(this.readonly, this.respectiveElement);
        } else if (key === "placeholder") {
          this.setProperties({ placeholder: null }, true);
          Input.setPlaceholder(this.placeholder, this.respectiveElement);
        } else {
          this.respectiveElement.removeAttribute(key);
        }
      }
    };
    TextBox2.prototype.focusIn = function() {
      if ((undefined).activeElement !== this.respectiveElement && this.enabled) {
        this.respectiveElement.focus();
        if (this.textboxWrapper.container.classList.contains("e-input-group") || this.textboxWrapper.container.classList.contains("e-outline") || this.textboxWrapper.container.classList.contains("e-filled")) {
          addClass([this.textboxWrapper.container], [TEXTBOX_FOCUS]);
        }
      }
    };
    TextBox2.prototype.focusOut = function() {
      if ((undefined).activeElement === this.respectiveElement && this.enabled) {
        this.respectiveElement.blur();
        if (this.textboxWrapper.container.classList.contains("e-input-group") || this.textboxWrapper.container.classList.contains("e-outline") || this.textboxWrapper.container.classList.contains("e-filled")) {
          removeClass([this.textboxWrapper.container], [TEXTBOX_FOCUS]);
        }
      }
    };
    __decorate$4([
      Property("text")
    ], TextBox2.prototype, "type", undefined);
    __decorate$4([
      Property(false)
    ], TextBox2.prototype, "readonly", undefined);
    __decorate$4([
      Property(null)
    ], TextBox2.prototype, "value", undefined);
    __decorate$4([
      Property("Never")
    ], TextBox2.prototype, "floatLabelType", undefined);
    __decorate$4([
      Property("")
    ], TextBox2.prototype, "cssClass", undefined);
    __decorate$4([
      Property(null)
    ], TextBox2.prototype, "placeholder", undefined);
    __decorate$4([
      Property("on")
    ], TextBox2.prototype, "autocomplete", undefined);
    __decorate$4([
      Property({})
    ], TextBox2.prototype, "htmlAttributes", undefined);
    __decorate$4([
      Property(false)
    ], TextBox2.prototype, "multiline", undefined);
    __decorate$4([
      Property(true)
    ], TextBox2.prototype, "enabled", undefined);
    __decorate$4([
      Property(false)
    ], TextBox2.prototype, "showClearButton", undefined);
    __decorate$4([
      Property(false)
    ], TextBox2.prototype, "enablePersistence", undefined);
    __decorate$4([
      Property(null)
    ], TextBox2.prototype, "width", undefined);
    __decorate$4([
      Event()
    ], TextBox2.prototype, "created", undefined);
    __decorate$4([
      Event()
    ], TextBox2.prototype, "destroyed", undefined);
    __decorate$4([
      Event()
    ], TextBox2.prototype, "change", undefined);
    __decorate$4([
      Event()
    ], TextBox2.prototype, "blur", undefined);
    __decorate$4([
      Event()
    ], TextBox2.prototype, "focus", undefined);
    __decorate$4([
      Event()
    ], TextBox2.prototype, "input", undefined);
    TextBox2 = __decorate$4([
      NotifyPropertyChanges
    ], TextBox2);
    return TextBox2;
  }(Component)
);
var __extends$3 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate$3 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var UploadSettings = (
  /** @class */
  function(_super) {
    __extends$3(UploadSettings2, _super);
    function UploadSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$3([
      Property(null)
    ], UploadSettings2.prototype, "allowedExtensions", undefined);
    __decorate$3([
      Property(null)
    ], UploadSettings2.prototype, "minFileSize", undefined);
    __decorate$3([
      Property(null)
    ], UploadSettings2.prototype, "maxFileSize", undefined);
    return UploadSettings2;
  }(ChildProperty)
);
var FinetuneSettings = (
  /** @class */
  function(_super) {
    __extends$3(FinetuneSettings2, _super);
    function FinetuneSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$3([
      Property(null)
    ], FinetuneSettings2.prototype, "brightness", undefined);
    __decorate$3([
      Property(null)
    ], FinetuneSettings2.prototype, "contrast", undefined);
    __decorate$3([
      Property(null)
    ], FinetuneSettings2.prototype, "hue", undefined);
    __decorate$3([
      Property(null)
    ], FinetuneSettings2.prototype, "saturation", undefined);
    __decorate$3([
      Property(null)
    ], FinetuneSettings2.prototype, "exposure", undefined);
    __decorate$3([
      Property(null)
    ], FinetuneSettings2.prototype, "opacity", undefined);
    __decorate$3([
      Property(null)
    ], FinetuneSettings2.prototype, "blur", undefined);
    return FinetuneSettings2;
  }(ChildProperty)
);
var ZoomSettings = (
  /** @class */
  function(_super) {
    __extends$3(ZoomSettings2, _super);
    function ZoomSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$3([
      Property(null)
    ], ZoomSettings2.prototype, "zoomTrigger", undefined);
    __decorate$3([
      Property(1)
    ], ZoomSettings2.prototype, "minZoomFactor", undefined);
    __decorate$3([
      Property(10)
    ], ZoomSettings2.prototype, "maxZoomFactor", undefined);
    __decorate$3([
      Property(1)
    ], ZoomSettings2.prototype, "zoomFactor", undefined);
    __decorate$3([
      Property(null)
    ], ZoomSettings2.prototype, "zoomPoint", undefined);
    return ZoomSettings2;
  }(ChildProperty)
);
var SelectionSettings = (
  /** @class */
  function(_super) {
    __extends$3(SelectionSettings2, _super);
    function SelectionSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$3([
      Property(true)
    ], SelectionSettings2.prototype, "showCircle", undefined);
    __decorate$3([
      Property(null)
    ], SelectionSettings2.prototype, "strokeColor", undefined);
    __decorate$3([
      Property(null)
    ], SelectionSettings2.prototype, "fillColor", undefined);
    return SelectionSettings2;
  }(ChildProperty)
);
var FontFamily = (
  /** @class */
  function(_super) {
    __extends$3(FontFamily2, _super);
    function FontFamily2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$3([
      Property("Arial")
    ], FontFamily2.prototype, "default", undefined);
    __decorate$3([
      Property(null)
    ], FontFamily2.prototype, "items", undefined);
    return FontFamily2;
  }(ChildProperty)
);
var ImageEditor = (
  /** @class */
  function(_super) {
    __extends$3(ImageEditor2, _super);
    function ImageEditor2(options, element2) {
      var _this = _super.call(this, options) || this;
      _this.isImageLoaded = false;
      _this.activeObj = {
        activePoint: { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 },
        flipObjColl: [],
        triangle: [],
        triangleRatio: [],
        rotatedAngle: 0,
        opacity: 1,
        order: null
      };
      _this.currObjType = {
        shape: "",
        isDragging: false,
        isActiveObj: false,
        isText: false,
        isInitialText: false,
        isLine: false,
        isInitialLine: false,
        isCustomCrop: false,
        isZoomed: false,
        isUndoZoom: false,
        isUndoAction: false,
        isFiltered: false,
        isSave: false,
        isResize: false,
        isRedact: false
      };
      _this.objColl = [];
      _this.pointColl = {};
      _this.freehandCounter = 0;
      _this.points = [];
      _this.togglePen = false;
      _this.togglePan = false;
      _this.img = { destLeft: 0, destTop: 0, destWidth: 0, destHeight: 0, srcLeft: 0, srcTop: 0, srcWidth: 0, srcHeight: 0 };
      _this.rotateFlipColl = [];
      _this.cropObj = {
        cropZoom: 0,
        defaultZoom: 0,
        totalPannedPoint: { x: 0, y: 0 },
        totalPannedClientPoint: { x: 0, y: 0 },
        totalPannedInternalPoint: { x: 0, y: 0 },
        tempFlipPanPoint: { x: 0, y: 0 },
        activeObj: {},
        rotateFlipColl: [],
        degree: 0,
        currFlipState: "",
        straighten: 0,
        destPoints: { startX: 0, startY: 0, width: 0, height: 0 },
        srcPoints: { startX: 0, startY: 0, width: 0, height: 0 },
        filter: "",
        isBrightAdjust: false,
        zoomFactor: 0,
        previousZoomValue: 0,
        aspectWidth: null,
        aspectHeight: null,
        frame: "none",
        straightenZoom: 0,
        adjustmentLevel: {
          brightness: 0,
          contrast: 0,
          hue: 0,
          opacity: 100,
          saturation: 0,
          blur: 0,
          exposure: 0,
          transparency: 100,
          sharpen: false,
          bw: false
        },
        currentFilter: ""
      };
      _this.afterCropActions = [];
      _this.transform = { degree: 0, currFlipState: "", zoomFactor: 0, cropZoomFactor: null, defaultZoomFactor: 0, straighten: 0 };
      _this.panPoint = {
        currentPannedPoint: { x: 0, y: 0 },
        totalPannedPoint: { x: 0, y: 0 },
        totalPannedInternalPoint: { x: 0, y: 0 },
        totalPannedClientPoint: { x: 0, y: 0 }
      };
      _this.isUndoRedo = false;
      _this.isCropTab = false;
      _this.isCircleCrop = false;
      _this.fontSizeColl = [];
      _this.initialAdjustmentValue = "";
      _this.currentFilter = "";
      _this.canvasFilter = "brightness(1) contrast(100%) hue-rotate(0deg) saturate(100%) opacity(1) blur(0px) sepia(0%) grayscale(0%) invert(0%)";
      _this.toolbarHeight = 0;
      _this.isPublicMethod = false;
      _this.isCropToolbar = false;
      _this.cursor = "default";
      _this.resizeSrc = { startX: _this.img.srcLeft, startY: _this.img.srcTop, width: _this.img.srcWidth, height: _this.img.srcHeight };
      _this.isResize = false;
      _this.isAspectRatio = false;
      _this.frameObj = { type: "none", color: "#fff", size: 20, inset: 20, offset: 20, radius: 0, amount: 1, border: "solid", gradientColor: "" };
      _this.tempFrameObj = { type: "none", color: "#fff", size: 20, inset: 20, offset: 20, radius: 0, amount: 1, border: "solid", gradientColor: "" };
      _this.allowDownScale = true;
      _this.gradientColor = "";
      _this.size = 20;
      _this.inset = 0;
      _this.offset = 0;
      _this.borderRadius = 0;
      _this.lineCount = 0;
      _this.prevStraightenedDegree = 0;
      _this.tempStraighten = 0;
      _this.isStraightening = false;
      _this.isFinetuning = false;
      _this.isZoomBtnClick = false;
      _this.isFinetuneBtnClick = false;
      _this.isFilterCanvasClick = false;
      _this.isFrameBtnClick = false;
      _this.isChangesSaved = false;
      _this.isShapeDrawing = false;
      _this.noPushUndo = false;
      _this.isUndoRedoStack = false;
      _this.shapeColl = [];
      _this.isKBDNavigation = false;
      _this.isMaskImage = false;
      _this.tempObjColl = [];
      _this.tempPointColl = [];
      _this.tempShapeColl = [];
      _this.isImageUpdated = false;
      _this.noRedact = false;
      _this.tempRedactBlur = 50;
      _this.tempRedactPixel = 40;
      _this.tempToolbarHeight = 0;
      _this.tempToolbar = [];
      ImageEditor_1.Inject(Crop, Draw, Selection, Transform, Export, ToolbarModule);
      ImageEditor_1.Inject(UndoRedo);
      ImageEditor_1.Inject(Filter);
      ImageEditor_1.Inject(Shape);
      ImageEditor_1.Inject(FreehandDrawing);
      if (element2) {
        _this.appendTo(element2);
      }
      return _this;
    }
    ImageEditor_1 = ImageEditor2;
    ImageEditor2.prototype.requiredModules = function() {
      var modules = [];
      modules.push({ member: "crop", args: [this] });
      modules.push({ member: "draw", args: [this] });
      modules.push({ member: "selection", args: [this] });
      modules.push({ member: "transform", args: [this] });
      modules.push({ member: "export", args: [this] });
      modules.push({ member: "toolbar-module", args: [this] });
      modules.push({ member: "undo-redo", args: [this] });
      modules.push({ member: "filter", args: [this] });
      modules.push({ member: "shape", args: [this] });
      modules.push({ member: "freehand-draw", args: [this] });
      return modules;
    };
    ImageEditor2.prototype.preRender = function() {
      this.element.id = this.element.id || getUniqueID("ej2-image-editor");
      this.isSafari = /^((?!chrome|android).)*safari/i.test((undefined).userAgent);
      if (Browser.isDevice) {
        this.element.classList.add("e-device");
      }
      this.initializeThemeColl();
    };
    ImageEditor2.prototype.render = function() {
      if (this.isAngular) {
        var originalElement = this.element;
        var clonedElement = originalElement.cloneNode(true);
        originalElement.parentNode.replaceChild(clonedElement, originalElement);
        this.element = clonedElement;
        setValue("ej2_instances", [this], this.element);
      }
      this.initialize();
    };
    ImageEditor2.prototype.getModuleName = function() {
      return "image-editor";
    };
    ImageEditor2.prototype.getPersistData = function() {
      return this.addOnPersist([]);
    };
    ImageEditor2.prototype.onPropertyChanged = function(newProperties, oldProperties) {
      var indexObj;
      for (var _i = 0, _a = Object.keys(newProperties); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "cssClass":
            if (oldProperties.cssClass) {
              removeClass([this.element], oldProperties.cssClass.replace(/\s+/g, " ").trim().split(" "));
            }
            if (newProperties.cssClass) {
              addClass([this.element], newProperties.cssClass.replace(/\s+/g, " ").trim().split(" "));
            }
            break;
          case "disabled":
            if (newProperties.disabled) {
              this.element.classList.add("e-disabled");
              this.unwireEvent();
            } else {
              this.element.classList.remove("e-disabled");
              this.wireEvent();
            }
            break;
          case "height":
            this.element.style.height = newProperties.height;
            this.update();
            break;
          case "width":
            this.element.style.width = newProperties.width;
            this.update();
            break;
          case "theme":
            if (newProperties.theme) {
              if (this.theme && this.theme !== "") {
                this.theme = this.toPascalCase(this.theme);
              } else {
                this.theme = "Bootstrap5";
              }
              this.upperContext.strokeStyle = this.themeColl[this.theme]["primaryColor"];
              this.upperContext.fillStyle = this.themeColl[this.theme]["secondaryColor"];
              this.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
                type: "main",
                isApplyBtn: null,
                isCropping: null,
                isZooming: null,
                cType: null
              } });
            }
            break;
          case "finetuneSettings":
            if (newProperties.finetuneSettings) {
              this.finetuneSettings = newProperties.finetuneSettings;
              this.notify("filter", { prop: "update-finetunes" });
            }
            break;
          case "locale":
            if (newProperties.locale) {
              this.notify("toolbar", { prop: "setLocale", onPropertyChange: false, value: { locale: newProperties.locale } });
              this.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
                type: "main",
                isApplyBtn: null,
                isCropping: null,
                isZooming: null,
                cType: null
              } });
            }
            break;
          case "allowUndoRedo":
            if (newProperties.allowUndoRedo) {
              this.allowUndoRedo = true;
            } else {
              this.allowUndoRedo = false;
            }
            this.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
              type: "main",
              isApplyBtn: null,
              isCropping: null,
              isZooming: null,
              cType: null
            } });
            break;
          case "showQuickAccessToolbar":
            if (newProperties.showQuickAccessToolbar) {
              this.showQuickAccessToolbar = true;
              this.notify("toolbar", { prop: "create-qa-toolbar", onPropertyChange: false });
              indexObj = { freehandSelectedIndex: null };
              this.notify("freehand-draw", { prop: "getFreehandSelectedIndex", onPropertyChange: false, value: { obj: indexObj } });
              if (this.activeObj.shape) {
                this.notify("toolbar", { prop: "renderQAT", onPropertyChange: false, value: { isPenEdit: null } });
              } else if (indexObj["freehandSelectedIndex"]) {
                this.notify("toolbar", { prop: "renderQAT", onPropertyChange: false, value: { isPenEdit: true } });
              }
            } else {
              this.showQuickAccessToolbar = false;
              this.notify("toolbar", { prop: "destroy-qa-toolbar", onPropertyChange: false });
            }
            break;
          case "zoomSettings":
            if (newProperties.zoomSettings) {
              this.zoomSettings.zoomTrigger = newProperties.zoomSettings.zoomTrigger;
            }
            if (isNullOrUndefined(this.zoomSettings.zoomTrigger)) {
              this.zoomSettings.zoomTrigger = ZoomTrigger.MouseWheel | ZoomTrigger.Pinch | ZoomTrigger.Toolbar | ZoomTrigger.Commands;
              this.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
                type: "main",
                isApplyBtn: null,
                isCropping: null,
                isZooming: null,
                cType: null
              } });
            } else if ((newProperties.zoomSettings.zoomTrigger & ZoomTrigger.Toolbar) === ZoomTrigger.Toolbar) {
              this.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
                type: "main",
                isApplyBtn: null,
                isCropping: null,
                isZooming: null,
                cType: null
              } });
            }
            break;
          case "selectionSettings":
            if (newProperties.selectionSettings) {
              this.selectionSettings = newProperties.selectionSettings;
              if (this.activeObj.shape) {
                this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
                this.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate", obj: this.activeObj } });
              }
            }
            break;
          case "toolbar":
            if (newProperties.toolbar) {
              this.toolbar = newProperties.toolbar;
              this.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
                type: "main",
                isApplyBtn: null,
                isCropping: null,
                isZooming: null,
                cType: null
              } });
            }
            break;
          case "toolbarTemplate":
            if (newProperties.toolbarTemplate) {
              this.notify("toolbar", { prop: "destroy-bottom-toolbar", onPropertyChange: false });
              this.notify("toolbar", { prop: "destroy-top-toolbar", onPropertyChange: false });
              this.element.appendChild(this.createElement("div", {
                id: this.element.id + "_toolbarArea",
                className: "e-toolbar-area"
              }));
              this.toolbarTemplateFn();
            }
            break;
          case "quickAccessToolbarTemplate":
            if (newProperties.quickAccessToolbarTemplate) {
              this.notify("toolbar", { prop: "destroy-qa-toolbar", onPropertyChange: false });
              this.quickAccessToolbarTemplateFn();
            }
            break;
          case "uploadSettings":
            if (newProperties.uploadSettings) {
              this.uploadSettings = newProperties.uploadSettings;
              if (!this.uploadSettings.allowedExtensions) {
                this.uploadSettings.allowedExtensions = ".jpg, .jpeg, .png, .svg, .webp";
                this.notify("draw", { prop: "setNullExtension", value: { extension: true } });
              } else {
                this.notify("draw", { prop: "setNullExtension", value: { extension: false } });
              }
              this.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
                type: "main",
                isApplyBtn: null,
                isCropping: null,
                isZooming: null,
                cType: null
              } });
            } else {
              this.notify("draw", { prop: "setNullExtension", value: { extension: true } });
            }
            this.updateDropInfoContent(this.element.querySelector(".e-ie-drop-info"));
            break;
        }
      }
    };
    ImageEditor2.prototype.destroy = function() {
      var classList2 = [];
      this.element.removeAttribute("tabindex");
      var saveDialog = this.element.querySelector("#" + this.element.id + "_saveDialog");
      if (saveDialog && saveDialog.style.display === "block") {
        getComponent((undefined).getElementById(this.element.id + "_saveDialog"), "dialog").destroy();
      }
      if (this.cssClass) {
        classList2 = classList2.concat(this.cssClass.replace(/\s+/g, " ").trim().split(" "));
      }
      removeClass([this.element], classList2);
      if (!this.element.getAttribute("class")) {
        this.element.removeAttribute("class");
      }
      this.unwireEvent();
      this.notify("toolbar", { prop: "destroySubComponents", onPropertyChange: false });
      this.notify("destroyed", null);
      _super.prototype.destroy.call(this);
      this.element.innerHTML = "";
    };
    ImageEditor2.prototype.initialize = function() {
      if (this.toolbarTemplate) {
        this.element.appendChild(this.createElement("div", {
          id: this.element.id + "_toolbarArea",
          className: "e-toolbar-area"
        }));
        this.toolbarTemplateFn();
      } else {
        this.notify("toolbar", { prop: "create-toolbar", onPropertyChange: false });
        this.notify("toolbar", { prop: "create-contextual-toolbar", onPropertyChange: false });
      }
      if (!this.uploadSettings.allowedExtensions) {
        this.setProperties({ uploadSettings: { allowedExtensions: ".jpg, .jpeg, .png, .svg, .webp" } }, true);
      } else {
        this.notify("draw", { prop: "setNullExtension", value: { extension: false } });
      }
      this.createCanvas();
      if (this.element.offsetWidth > 359 && this.element.querySelector(".e-ie-min-drop-content") && this.element.querySelector(".e-ie-drop-content")) {
        this.element.querySelector(".e-ie-min-drop-content").style.display = "none";
        this.element.querySelector(".e-ie-drop-content").style.display = "block";
      }
      this.createDropUploader();
      if (this.showQuickAccessToolbar) {
        var canvasWrapper = (undefined).querySelector("#" + this.element.id + "_canvasWrapper");
        canvasWrapper.appendChild(this.createElement("div", {
          id: this.element.id + "_quickAccessToolbarArea",
          className: "e-quick-access-toolbar-area"
        }));
        var quickAccessToolbar = (undefined).getElementById(this.element.id + "_quickAccessToolbarArea");
        quickAccessToolbar.style.position = "absolute";
        quickAccessToolbar.style.display = "none";
        if (this.activeObj) {
          quickAccessToolbar.style.left = this.activeObj.activePoint.startX + "px";
          quickAccessToolbar.style.top = this.activeObj.activePoint.startY + "px";
        }
        quickAccessToolbar.style.width = "100%";
      }
      if (this.quickAccessToolbarTemplate) {
        this.quickAccessToolbarTemplateFn();
      } else {
        this.notify("toolbar", { prop: "create-qa-toolbar", onPropertyChange: false });
      }
      this.wireEvent();
      this.lowerContext = this.lowerCanvas.getContext("2d");
      this.upperContext = this.upperCanvas.getContext("2d");
      this.inMemoryContext = this.inMemoryCanvas.getContext("2d");
      this.lowerContext.filter = this.getDefaultFilter();
      this.notify("filter", { prop: "setAdjustmentValue", onPropertyChange: false, value: { adjustmentValue: this.lowerContext.filter } });
      this.canvasFilter = this.lowerContext.filter;
      this.notify("toolbar", { prop: "setInitialAdjustmentValue", onPropertyChange: false, value: { value: this.lowerContext.filter } });
      if (this.cssClass) {
        addClass([this.element], this.cssClass.replace(/\s+/g, " ").trim().split(" "));
      }
      if (this.element) {
        createSpinner({
          target: this.element
        });
      }
      this.initializeZoomSettings();
      if (this.imgSrc) {
        this.open(this.imgSrc);
      }
    };
    ImageEditor2.prototype.createDropUploader = function() {
      var _this = this;
      var proxy = this;
      var uploadObj = new Uploader({
        dropArea: this.element.getElementsByClassName("e-canvas-wrapper")[0],
        allowedExtensions: this.uploadSettings.allowedExtensions,
        multiple: false,
        selected: function(args) {
          if (args.event.type === "change" || args.event.type === "drop") {
            var type = args.filesData[0].type;
            var errType = "unsupported";
            var extension = _this.getExtensionArray();
            var isAllowedFileType = extension.indexOf(type) > -1 || type === "jpeg" && (proxy.uploadSettings.allowedExtensions.indexOf("jpg") > -1 || proxy.uploadSettings.allowedExtensions.indexOf("jpeg") > -1);
            var size = args.filesData[0].size;
            var isInvalidSize = proxy.uploadSettings.minFileSize && size < proxy.uploadSettings.minFileSize || proxy.uploadSettings.maxFileSize && size > proxy.uploadSettings.maxFileSize;
            if ((args.event.type === "change" || args.event.type === "drop" && args.event.dataTransfer.files.length === 1) && isAllowedFileType && !isInvalidSize) {
              _this.notify("draw", { prop: "fileSelect", value: { inputElement: _this.element.querySelector("#" + _this.element.id + "_dropfileUpload"), args } });
            } else {
              if (args.event.type === "drop" && args.event.dataTransfer.files.length > 1) {
                errType = "multi-select-image";
              }
              _this.showDialogPopup(errType, !isAllowedFileType);
            }
          }
        }
      });
      uploadObj.appendTo("#" + this.element.id + "_dropfileUpload");
    };
    ImageEditor2.prototype.dlgCloseBtnClick = function() {
      getComponent((undefined).getElementById(this.element.id + "_dialog"), "dialog").destroy();
    };
    ImageEditor2.prototype.showDialogPopup = function(type, fileTypeError) {
      var content = "";
      this.element.querySelector("#" + this.element.id + "_dialog").style.display = "block";
      var headerObj;
      var okObj = { key: "DlgOK" };
      this.notify("toolbar", { prop: "getLocaleText", onPropertyChange: false, value: { obj: okObj } });
      if (type === "multi-select-image") {
        headerObj = { key: "ImageErrorDialogHeader" };
        this.notify("toolbar", { prop: "getLocaleText", onPropertyChange: false, value: { obj: headerObj } });
        var contentObj = { key: "ImageErrorDialogContent" };
        this.notify("toolbar", { prop: "getLocaleText", onPropertyChange: false, value: { obj: contentObj } });
        content = "<span>" + contentObj["value"] + "</span>";
      } else {
        headerObj = { key: "AlertDialogHeader" };
        this.notify("toolbar", { prop: "getLocaleText", onPropertyChange: false, value: { obj: headerObj } });
        var contentObj = { key: "AlertDialogContent" };
        this.notify("toolbar", { prop: "getLocaleText", onPropertyChange: false, value: { obj: contentObj } });
        var supportObj = { key: "SupportText" };
        this.notify("toolbar", { prop: "getLocaleText", onPropertyChange: false, value: { obj: supportObj } });
        var extension = this.getExtensionString();
        var fileSizeObj = { key: "MinMaxSizeAlert" };
        this.notify("toolbar", { prop: "getLocaleText", onPropertyChange: false, value: { obj: fileSizeObj } });
        var andObj = { key: "And" };
        this.notify("toolbar", { prop: "getLocaleText", onPropertyChange: false, value: { obj: andObj } });
        var size = undefined;
        if (this.uploadSettings.minFileSize && this.uploadSettings.maxFileSize) {
          size = " " + fileSizeObj["value"] + " <b> " + this.formatSizeUnits(this.uploadSettings.minFileSize) + " </b> " + andObj["value"] + " <b> " + this.formatSizeUnits(this.uploadSettings.maxFileSize) + " </b> ";
        } else if (this.uploadSettings.minFileSize) {
          fileSizeObj["key"] = "MinSizeAlert";
          this.notify("toolbar", { prop: "getLocaleText", onPropertyChange: false, value: { obj: fileSizeObj } });
          size = " " + fileSizeObj["value"] + " <b> " + this.formatSizeUnits(this.uploadSettings.minFileSize) + " </b> ";
        } else if (this.uploadSettings.maxFileSize) {
          fileSizeObj["key"] = "MaxSizeAlert";
          this.notify("toolbar", { prop: "getLocaleText", onPropertyChange: false, value: { obj: fileSizeObj } });
          size = " " + fileSizeObj["value"] + " <b> " + this.formatSizeUnits(this.uploadSettings.maxFileSize) + " </b> ";
        }
        if (fileTypeError) {
          content = "<span>" + contentObj["value"] + " " + supportObj["value"] + "<b>" + extension + "</b></span>";
        } else if (size) {
          content = "<span>" + contentObj["value"] + " " + supportObj["value"] + size + "</span>";
        }
      }
      var dialog = new Dialog({
        header: headerObj["value"],
        closeOnEscape: true,
        content,
        target: (undefined).getElementById("target"),
        width: Browser.isDevice ? "285px" : "400px",
        isModal: true,
        animationSettings: { effect: "Zoom" },
        close: this.dlgCloseBtnClick.bind(this),
        buttons: [
          {
            click: this.dlgCloseBtnClick.bind(this),
            buttonModel: { content: okObj["value"] }
          }
        ]
      });
      dialog.appendTo("#" + this.element.id + "_dialog");
    };
    ImageEditor2.prototype.formatSizeUnits = function(bytes) {
      var byte = "";
      if (bytes >= 1073741824) {
        byte = (bytes / 1073741824).toFixed(2) + " GB";
      } else if (bytes >= 1048576) {
        byte = (bytes / 1048576).toFixed(2) + " MB";
      } else if (bytes >= 1024) {
        byte = (bytes / 1024).toFixed(2) + " KB";
      } else if (bytes > 1) {
        byte = bytes + " bytes";
      } else if (bytes === 1) {
        byte = bytes + " byte";
      } else {
        byte = "0 bytes";
      }
      return byte;
    };
    ImageEditor2.prototype.getExtensionArray = function() {
      var validExtensions = ["jpeg", "jpg", "png", "svg", "webp"];
      var split = this.uploadSettings.allowedExtensions.split(",");
      var extension = [];
      for (var _i = 0, split_1 = split; _i < split_1.length; _i++) {
        var ext = split_1[_i];
        var trimmedExt = ext.trim();
        for (var _a = 0, validExtensions_1 = validExtensions; _a < validExtensions_1.length; _a++) {
          var valid = validExtensions_1[_a];
          if (trimmedExt.indexOf(valid) !== -1) {
            extension.push(valid);
            break;
          }
        }
      }
      return extension;
    };
    ImageEditor2.prototype.getExtensionString = function() {
      var andObj = { key: "And" };
      this.notify("toolbar", { prop: "getLocaleText", onPropertyChange: false, value: { obj: andObj } });
      var extension = this.getExtensionArray();
      var words = "";
      for (var i = 0; i < extension.length; i++) {
        if (i === extension.length - 1 && extension.length > 1 && !((extension[i] === "jpeg" || extension[i] === "jpg") && words.indexOf("JPG") > -1)) {
          if (extension.length === 2 || extension.length === 3 && extension.indexOf("jpeg") !== -1 && extension.indexOf("jpg") !== -1) {
            words = words.replace(/,\s*$/, "");
          }
          words += " " + andObj["value"];
        }
        switch (extension[i]) {
          case "jpeg":
          case "jpg":
            if (words.indexOf("JPG") === -1) {
              words += " JPG,";
            }
            break;
          case "png":
            words += " PNG,";
            break;
          case "svg":
            words += " SVG,";
            break;
          case "webp":
            words += " WebP,";
            break;
        }
        if (i === extension.length - 1) {
          words = words.slice(0, -1);
        }
      }
      return words;
    };
    ImageEditor2.prototype.wireEvent = function() {
      EventHandler.add(undefined, "keydown", this.keyDownEventHandler, this);
      EventHandler.add(undefined, "keypress", this.keyUpEventHandler, this);
      EventHandler.add(this.upperCanvas, "mousedown", this.mouseDownEventHandler, this);
      EventHandler.add(this.upperCanvas, "mousemove", this.mouseMoveEventHandler, this);
      EventHandler.add(this.upperCanvas, "mouseup", this.mouseUpEventHandler, this);
      EventHandler.add(undefined, "mouseup", this.mouseUpEventHandler, this);
      EventHandler.add(this.lowerCanvas, "mousedown", this.canvasMouseDownHandler, this);
      EventHandler.add(this.lowerCanvas, "mousemove", this.canvasMouseMoveHandler, this);
      EventHandler.add(this.lowerCanvas, "mouseup", this.canvasMouseUpHandler, this);
      EventHandler.add(this.upperCanvas, "touchstart", this.touchStartHandler, this);
      EventHandler.add(this.lowerCanvas, "touchstart", this.touchStartHandler, this);
      EventHandler.add(this.lowerCanvas, "mousewheel DOMMouseScroll", this.handleScroll, this);
      EventHandler.add(this.upperCanvas, "mousewheel DOMMouseScroll", this.handleScroll, this);
      (undefined).addEventListener("resize", this.windowResizeHandler.bind(this));
      if (!Browser.isIos && Browser.info.name !== "safari") {
        screen.orientation.addEventListener("change", this.screenOrientation.bind(this));
      }
      this.notify("shape", { prop: "wireEvent", onPropertyChange: false });
    };
    ImageEditor2.prototype.unwireEvent = function() {
      EventHandler.remove(undefined, "keydown", this.keyDownEventHandler);
      EventHandler.remove(undefined, "keypress", this.keyUpEventHandler);
      EventHandler.remove(this.upperCanvas, "mousedown", this.mouseDownEventHandler);
      EventHandler.remove(this.upperCanvas, "mousemove", this.mouseMoveEventHandler);
      EventHandler.remove(this.upperCanvas, "mouseup", this.mouseUpEventHandler);
      EventHandler.remove(undefined, "mouseup", this.mouseUpEventHandler);
      EventHandler.remove(this.lowerCanvas, "mousedown", this.canvasMouseDownHandler);
      EventHandler.remove(this.lowerCanvas, "mousemove", this.canvasMouseMoveHandler);
      EventHandler.remove(this.lowerCanvas, "mouseup", this.canvasMouseUpHandler);
      EventHandler.remove(this.upperCanvas, "touchstart", this.touchStartHandler);
      EventHandler.remove(this.lowerCanvas, "touchstart", this.touchStartHandler);
      EventHandler.remove(this.lowerCanvas, "mousewheel DOMMouseScroll", this.handleScroll);
      EventHandler.remove(this.upperCanvas, "mousewheel DOMMouseScroll", this.handleScroll);
      (undefined).removeEventListener("resize", this.windowResizeHandler.bind(this));
      if (!Browser.isIos && Browser.info.name !== "safari") {
        screen.orientation.removeEventListener("change", this.screenOrientation.bind(this));
      }
      this.notify("shape", { prop: "unWireEvent", onPropertyChange: false });
      this.notify("selection", { prop: "unWireEvent", onPropertyChange: false });
    };
    ImageEditor2.prototype.createCanvas = function() {
      this.element.style.boxSizing = "border-box";
      var obj = { toolbarHeight: 0 };
      this.notify("toolbar", { prop: "getToolbarHeight", value: { obj } });
      var height = obj["toolbarHeight"];
      if (this.toolbar && this.toolbar.length > 0 && this.toolbar.indexOf("Open") === -1) {
        height = 0;
      }
      this.element.style.width = this.width;
      this.element.style.height = this.height;
      var canvasWrapperElement = this.createElement("div", { id: this.element.id + "_canvasWrapper", className: "e-canvas-wrapper" });
      canvasWrapperElement.style.cssText = "height: " + (this.element.offsetHeight - height - 2) + "px; width: " + (this.element.offsetWidth - 2) + "px; position: relative; overflow: hidden; margin: 0 auto;";
      var canvasWrapper = this.element.appendChild(canvasWrapperElement);
      var dragObj = { key: "DragText" };
      this.notify("toolbar", { prop: "getLocaleText", onPropertyChange: false, value: { obj: dragObj } });
      var dropObj = { key: "DropText" };
      this.notify("toolbar", { prop: "getLocaleText", onPropertyChange: false, value: { obj: dropObj } });
      var browseObj = { key: "BrowseText" };
      this.notify("toolbar", { prop: "getLocaleText", onPropertyChange: false, value: { obj: browseObj } });
      var dropAreaElement = this.createElement("div", { id: this.element.id + "_dropArea", className: "e-ie-drop-area" });
      dropAreaElement.style.position = "relative";
      var dropIconElement = this.createElement("span", { className: "e-ie-drop-icon e-icons e-image" });
      dropIconElement.style.position = "absolute";
      var dropContentElement = this.createElement("span", { className: "e-ie-drop-content" });
      dropContentElement.style.cssText = "position: absolute; display: none;";
      dropContentElement.textContent = dragObj["value"] + " ";
      var minDropContentElem = this.createElement("span", { className: "e-ie-min-drop-content" });
      minDropContentElem.style.position = "absolute";
      minDropContentElem.textContent = dropObj["value"] + " ";
      var dropAnchorElement = this.createElement("a", { id: this.element.id + "_dropBrowse", className: "e-ie-drop-browse" });
      dropAnchorElement.textContent = browseObj["value"];
      var minDropAnchorElem = this.createElement("a", { id: this.element.id + "_dropBrowse", className: "e-ie-drop-browse" });
      minDropAnchorElem.textContent = browseObj["value"];
      dropContentElement.appendChild(dropAnchorElement);
      minDropContentElem.appendChild(minDropAnchorElem);
      dropAnchorElement.href = "";
      minDropAnchorElem.href = "";
      var dropInfoElement = this.createElement("span", { className: "e-ie-drop-info", attrs: { position: "absolute" } });
      this.updateDropInfoContent(dropInfoElement);
      var dropUploader = dropAreaElement.appendChild(this.createElement("input", {
        id: this.element.id + "_dropfileUpload",
        className: "e-fileUpload e-image-upload"
      }));
      dropUploader.setAttribute("type", "file");
      dropUploader.setAttribute("accept", "image/*");
      dropAreaElement.appendChild(dropIconElement);
      dropAreaElement.appendChild(dropContentElement);
      dropAreaElement.appendChild(minDropContentElem);
      dropAreaElement.appendChild(dropInfoElement);
      canvasWrapper.appendChild(dropAreaElement);
      this.lowerCanvas = canvasWrapper.appendChild(this.createElement("canvas", {
        id: this.element.id + "_lowerCanvas",
        attrs: { name: "canvasImage" }
      }));
      this.maskCanvas = canvasWrapper.appendChild(this.createElement("canvas", {
        id: this.element.id + "_maskCanvas",
        attrs: { name: "canvasImage" }
      }));
      this.upperCanvas = canvasWrapper.appendChild(this.createElement("canvas", {
        id: this.element.id + "_upperCanvas",
        attrs: { name: "canvasImage" }
      }));
      this.inMemoryCanvas = this.createElement("canvas", {
        id: this.element.id + "_inMemoryCanvas",
        attrs: { name: "canvasImage" }
      });
      this.baseImgCanvas = this.createElement("canvas", {
        id: this.element.id + "_baseImgCanvas",
        attrs: { name: "canvasImage" }
      });
      this.textArea = canvasWrapper.appendChild(this.createElement("textarea", {
        id: this.element.id + "_textArea",
        className: "e-textarea",
        attrs: { name: "textArea" }
      }));
      var dialog = this.element.appendChild(this.createElement("div", {
        id: this.element.id + "_dialog",
        className: "e-dialog"
      }));
      dialog.style.display = "none";
      var uploader = this.element.appendChild(this.createElement("input", {
        id: this.element.id + "_fileUpload",
        className: "e-fileUpload"
      }));
      uploader.setAttribute("type", "file");
      uploader.setAttribute("accept", "image/*");
      uploader.style.display = "none";
      this.textArea.setAttribute("spellcheck", "false");
      this.textArea.style.lineHeight = "normal";
      this.lowerCanvas.style.width = this.upperCanvas.style.width = this.maskCanvas.style.width = this.inMemoryCanvas.style.width = "100%";
      this.lowerCanvas.style.height = this.upperCanvas.style.height = this.maskCanvas.style.height = this.inMemoryCanvas.style.height = "100%";
      this.upperCanvas.style.position = this.lowerCanvas.style.position = this.maskCanvas.style.position = this.textArea.style.position = "absolute";
      this.textArea.style.backgroundColor = "transparent";
      this.textArea.style.display = "none";
      this.maskCanvas.style.display = this.textArea.style.resize = "none";
      this.lowerContext = this.lowerCanvas.getContext("2d");
      this.baseImg = this.createElement("img", {
        id: this.element.id + "_orgImg",
        attrs: { name: "Image", crossorigin: "anonymous" }
      });
      this.upperCanvas.style.cursor = this.cursor = "default";
      this.upperCanvas.style.display = "block";
      this.upperContext = this.upperCanvas.getContext("2d");
      dropAnchorElement.addEventListener("click", function(e) {
        e.preventDefault();
        dropUploader.click();
        return false;
      });
      minDropAnchorElem.addEventListener("click", function(e) {
        e.preventDefault();
        dropUploader.click();
        return false;
      });
    };
    ImageEditor2.prototype.touchStartHandler = function(e) {
      this.notify("selection", { prop: "touchStartHandler", onPropertyChange: false, value: { e } });
    };
    ImageEditor2.prototype.mouseDownEventHandler = function(e) {
      if (e.target.className === "e-ie-drop-browse") {
        return;
      }
      this.notify("selection", { prop: "mouseDownEventHandler", onPropertyChange: false, value: { e } });
    };
    ImageEditor2.prototype.mouseMoveEventHandler = function(e) {
      this.notify("selection", { prop: "mouseMoveEventHandler", onPropertyChange: false, value: { e } });
    };
    ImageEditor2.prototype.mouseUpEventHandler = function(e) {
      if (e.target.className === "e-ie-drop-browse") {
        return;
      }
      this.notify("selection", { prop: "mouseUpEventHandler", onPropertyChange: false, value: { e } });
    };
    ImageEditor2.prototype.keyDownEventHandler = function(e) {
      this.notify("selection", { prop: "keyDownEventHandler", onPropertyChange: false, value: { e } });
    };
    ImageEditor2.prototype.keyUpEventHandler = function(e) {
      if ((this.textArea.style.display === "block" || this.textArea.style.display === "inline-block") && e.target.id === this.element.id + "_textArea") {
        this.notify("selection", { prop: "textKeyDown", value: { e } });
      }
    };
    ImageEditor2.prototype.canvasMouseDownHandler = function(e) {
      if (e.target.className === "e-ie-drop-browse") {
        return;
      }
      this.notify("selection", { prop: "canvasMouseDownHandler", onPropertyChange: false, value: { e } });
    };
    ImageEditor2.prototype.canvasMouseMoveHandler = function(e) {
      this.notify("selection", { prop: "canvasMouseMoveHandler", onPropertyChange: false, value: { e } });
    };
    ImageEditor2.prototype.canvasMouseUpHandler = function(e) {
      if (e.target.className === "e-ie-drop-browse") {
        return;
      }
      this.notify("selection", { prop: "canvasMouseUpHandler", onPropertyChange: false, value: { e } });
    };
    ImageEditor2.prototype.handleScroll = function(e) {
      this.notify("selection", { prop: "handleScroll", onPropertyChange: false, value: { e } });
    };
    ImageEditor2.prototype.adjustToScreen = function() {
      this.update();
    };
    ImageEditor2.prototype.screenOrientation = function() {
      if (Browser.isDevice) {
        setTimeout(this.adjustToScreen.bind(this), 100);
      }
    };
    ImageEditor2.prototype.windowResizeHandler = function() {
      if (!Browser.isDevice && this.element.classList.contains("e-image-editor")) {
        this.adjustToScreen();
      }
    };
    ImageEditor2.prototype.notifyResetForAllModules = function() {
      var modules = this.requiredModules();
      for (var i = 0; i < modules.length; i++) {
        var module = modules[i].member;
        this.notify(module === "toolbar-module" ? "toolbar" : module, { prop: "reset", onPropertyChange: false });
      }
    };
    ImageEditor2.prototype.allowShape = function(x, y) {
      this.isPublicMethod = true;
      this.applyShapes();
      var obj = { inRange: false };
      this.notify("shape", {
        prop: "isPointsInRange",
        onPropertyChange: false,
        value: { x, y, obj }
      });
      return obj["inRange"];
    };
    ImageEditor2.prototype.manageActiveAction = function() {
      this.applyShapes();
      if (this.activeObj.shape && this.activeObj.shape.indexOf("crop") > -1) {
        this.discard();
      }
    };
    ImageEditor2.prototype.clearSelection = function(resetCrop) {
      this.notify("selection", { prop: "clearSelection", onPropertyChange: false, value: { resetCrop } });
    };
    ImageEditor2.prototype.crop = function() {
      var obj = { isCrop: false };
      this.notify("crop", { prop: "crop", onPropertyChange: false, value: { obj } });
      return obj["isCrop"];
    };
    ImageEditor2.prototype.flip = function(direction) {
      this.applyShapes();
      this.updateImageTransformColl(direction.toLowerCase() + "flip");
      this.notify("transform", { prop: "flip", value: { direction } });
      this.notify("draw", { prop: "redrawDownScale" });
      this.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
      var actionArgs = { action: "flip", actionEventArgs: this.editCompleteArgs };
      this.triggerEditCompleteEvent(actionArgs);
    };
    ImageEditor2.prototype.getImageData = function(includeAnnotations) {
      includeAnnotations = isNullOrUndefined(includeAnnotations) ? true : includeAnnotations;
      var imageData;
      if (includeAnnotations) {
        var obj = { canvas: null };
        this.applyShapes();
        this.notify("export", { prop: "exportToCanvas", value: { object: obj } });
        imageData = obj["canvas"].getContext("2d").getImageData(0, 0, obj["canvas"].width, obj["canvas"].height);
      } else if (this.isMaskImage && this.element.getAttribute("data-value") === "mask-drawing") {
        imageData = this.getData(true);
        this.updateColl("reset");
      } else {
        imageData = this.getData();
        this.notify("draw", { prop: "render-image", value: { isMouseWheel: false } });
      }
      return imageData;
    };
    ImageEditor2.prototype.open = function(data, resetChanges, imageSettings) {
      resetChanges = isNullOrUndefined(resetChanges) ? true : resetChanges;
      if (resetChanges) {
        if (isNullOrUndefined(data)) {
          return;
        }
        var dropArea = (undefined).getElementById(this.element.id + "_dropArea");
        if (dropArea) {
          dropArea.style.display = "none";
        }
        this.notify("draw", { prop: "open", value: { data } });
      } else {
        this.updateImage(data, imageSettings ? imageSettings.backgroundColor : null);
      }
    };
    ImageEditor2.prototype.reset = function() {
      this.updateColl("reset");
      var obj = { isErrorImage: false };
      this.notify("draw", { prop: "getErrorImage", value: { obj } });
      if (!this.disabled && !obj["isErrorImage"]) {
        this.clearContext(this.inMemoryContext);
        this.clearContext(this.lowerContext);
        this.clearContext(this.upperContext);
        this.notify("shape", { prop: "setRedactType", onPropertyChange: false, value: { redactType: "blur" } });
        this.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        this.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
          type: "main",
          isApplyBtn: false,
          isCropping: false,
          isZooming: null,
          cType: null
        } });
        if (Browser.isDevice && (undefined).getElementById(this.element.id + "_bottomToolbar")) {
          getComponent((undefined).getElementById(this.element.id + "_bottomToolbar"), "toolbar").destroy();
          this.notify("toolbar", { prop: "create-bottom-toolbar", onPropertyChange: false });
        }
        var isImageLoaded = this.isImageLoaded;
        this.currObjType.isUndoAction = this.isUndoRedo = this.togglePan = this.togglePen = this.isImageLoaded = this.isFinetuning = false;
        this.isCircleCrop = this.isCropTab = false;
        this.objColl = [];
        this.transform.degree = 0;
        this.upperCanvas.style.display = "block";
        this.transform.currFlipState = "";
        this.allowDownScale = true;
        this.upperCanvas.style.cursor = this.cursor = this.lowerCanvas.style.cursor = "default";
        this.lowerContext.lineWidth = this.upperContext.lineWidth = undefined;
        this.frameDestPoints = null;
        this.textArea.value = this.textArea.textContent = "";
        this.textArea.style.display = "none";
        this.lowerContext.filter = this.canvasFilter = this.getDefaultFilter();
        this.img.destLeft = this.img.destTop = this.img.srcLeft = this.img.srcTop = 0;
        this.img.destWidth = this.img.destHeight = this.img.srcWidth = this.img.srcHeight = null;
        this.currSelectionPoint = null;
        this.panPoint.currentPannedPoint = { x: 0, y: 0 };
        this.rotateFlipColl = [];
        this.points = [];
        this.pointColl = {};
        this.freehandCounter = 0;
        this.notify("draw", { prop: "resetPanPoints" });
        this.lowerCanvas.style.left = this.upperCanvas.style.left = "";
        this.fontSizeColl = [];
        this.lowerCanvas.style.top = this.upperCanvas.style.top = "";
        this.lowerCanvas.style.maxWidth = this.upperCanvas.style.maxWidth = "";
        this.lowerCanvas.style.maxHeight = this.upperCanvas.style.maxHeight = "";
        this.transform.defaultZoomFactor = this.transform.zoomFactor = 0;
        this.transform.cropZoomFactor = null;
        this.frameObj = { type: "none", color: "#fff", size: 20, inset: 20, offset: 20, radius: 0, amount: 1, border: "solid", gradientColor: "" };
        this.tempFrameObj = { type: "none", color: "#fff", size: 20, inset: 20, offset: 20, radius: 0, amount: 1, border: "solid", gradientColor: "" };
        this.currObjType = {
          shape: "",
          isDragging: false,
          isActiveObj: false,
          isText: false,
          isInitialText: false,
          isLine: false,
          isInitialLine: false,
          isCustomCrop: false,
          isZoomed: false,
          isUndoZoom: false,
          isUndoAction: false,
          isFiltered: false,
          isSave: false,
          isResize: false,
          isRedact: false
        };
        this.cropObj = {
          cropZoom: 0,
          defaultZoom: 0,
          totalPannedPoint: { x: 0, y: 0 },
          totalPannedClientPoint: { x: 0, y: 0 },
          totalPannedInternalPoint: { x: 0, y: 0 },
          tempFlipPanPoint: { x: 0, y: 0 },
          activeObj: {},
          rotateFlipColl: [],
          degree: 0,
          currFlipState: "",
          straighten: 0,
          zoomFactor: 0,
          previousZoomValue: 0,
          destPoints: { startX: 0, startY: 0, width: 0, height: 0 },
          frame: "none",
          srcPoints: { startX: 0, startY: 0, width: 0, height: 0 },
          filter: "",
          isBrightAdjust: false,
          aspectWidth: null,
          aspectHeight: null,
          straightenZoom: 0,
          adjustmentLevel: {
            brightness: 0,
            contrast: 0,
            hue: 0,
            opacity: 100,
            saturation: 0,
            blur: 0,
            exposure: 0,
            transparency: 100,
            sharpen: false,
            bw: false
          },
          currentFilter: ""
        };
        this.afterCropActions = [];
        this.currentFilter = "";
        this.tempFrameZoomLevel = null;
        this.cxtTbarHeight = null;
        this.straightenPoint = null;
        this.transform.straighten = 0;
        this.cancelCropSelection = null;
        this.aspectWidth = this.aspectHeight = null;
        this.isResize = this.isMaskImage = false;
        this.drawingShape = null;
        this.isShapeDrawing = this.noPushUndo = this.isUndoRedoStack = this.isKBDNavigation = false;
        this.shapeColl = [];
        this.tempObjColl = [];
        this.tempPointColl = [];
        this.tempShapeColl = [];
        this.isImageUpdated = false;
        this.tempToolbarHeight = 0;
        this.tempToolbar = [];
        this.tempRedactBlur = 50;
        this.tempRedactPixel = 40;
        var obj_1 = { initialZoomValue: false };
        this.editCompleteArgs = null;
        this.isFinetuneBtnClick = false;
        this.notify("draw", { prop: "getInitialZoomValue", onPropertyChange: false, value: { obj: obj_1 } });
        if (obj_1["initialZoomValue"]) {
          this.setProperties({ zoomSettings: { zoomFactor: obj_1["initialZoomValue"] } }, true);
        }
        var qtArea = (undefined).getElementById(this.element.id + "_quickAccessToolbarArea");
        if (qtArea) {
          qtArea.style.display = "none";
        }
        this.notifyResetForAllModules();
        this.notify("filter", { prop: "update-finetunes" });
        if (this.toolbarTemplate) {
          this.toolbarHeight = this.element.querySelector("#" + this.element.id + "_toolbarArea").clientHeight;
        } else if (this.element.querySelector("#" + this.element.id + "_toolbar")) {
          this.toolbarHeight = this.element.querySelector("#" + this.element.id + "_toolbar").clientHeight;
        }
        this.notify("toolbar", { prop: "setToolbarHeight", value: { height: this.toolbarHeight } });
        this.isImageLoaded = isImageLoaded;
        this.straightenBaseImageCanvas();
        this.isImageLoaded = false;
        this.notify("draw", { prop: "update-canvas", onPropertyChange: false });
        this.isImageLoaded = isImageLoaded;
        this.prevStraightenedDegree = 0;
        var ctWrapper = this.element.querySelector(".e-contextual-toolbar-wrapper");
        if (ctWrapper) {
          ctWrapper.classList.add("e-hide");
        }
        this.notify("toolbar", { prop: "refresh-dropdown-btn", value: { isDisabled: false } });
        this.notify("toolbar", { prop: "enable-disable-btns" });
        var straightenObj = { bool: this.isStraightening };
        if (Browser.isDevice && straightenObj["bool"]) {
          this.notify("crop", { prop: "resizeWrapper" });
        }
        var saveDialog = this.element.querySelector("#" + this.element.id + "_saveDialog");
        if (saveDialog) {
          getComponent(saveDialog, "dialog").close();
        }
        var actionArgs = { action: "reset", actionEventArgs: null };
        this.triggerEditCompleteEvent(actionArgs);
      }
    };
    ImageEditor2.prototype.rotate = function(degree) {
      var obj = { isRotate: false };
      this.applyShapes();
      if (degree === 90 || degree === -90) {
        this.updateImageTransformColl(degree === 90 ? "rotateright" : "rotateleft");
      }
      this.notify("transform", { prop: "rotate", value: { degree, obj } });
      this.notify("draw", { prop: "redrawDownScale" });
      var actionArgs = { action: "rotate", actionEventArgs: this.editCompleteArgs };
      this.triggerEditCompleteEvent(actionArgs);
      return obj["isRotate"];
    };
    ImageEditor2.prototype.export = function(type, fileName, imageQuality) {
      this.applyShapes();
      this.notify("export", { prop: "export", onPropertyChange: false, value: { type, fileName, imgQuality: imageQuality } });
    };
    ImageEditor2.prototype.select = function(type, startX, startY, width, height) {
      this.applyShapes();
      this.notify("toolbar", { prop: "performCropTransformClick", value: { shape: "crop-" + type } });
      this.notify("draw", {
        prop: "select",
        onPropertyChange: false,
        value: { type, startX, startY, width, height }
      });
      if (startX && startY || width && height) {
        this.notify("draw", {
          prop: "select",
          onPropertyChange: false,
          value: { type, startX, startY, width, height }
        });
      } else {
        this.cropObj = {
          cropZoom: 0,
          defaultZoom: 0,
          totalPannedPoint: { x: 0, y: 0 },
          totalPannedClientPoint: { x: 0, y: 0 },
          totalPannedInternalPoint: { x: 0, y: 0 },
          tempFlipPanPoint: { x: 0, y: 0 },
          activeObj: {},
          rotateFlipColl: [],
          degree: 0,
          currFlipState: "",
          straighten: 0,
          zoomFactor: 0,
          previousZoomValue: 0,
          destPoints: { startX: 0, startY: 0, width: 0, height: 0 },
          frame: "none",
          srcPoints: { startX: 0, startY: 0, width: 0, height: 0 },
          filter: "",
          isBrightAdjust: false,
          aspectWidth: null,
          aspectHeight: null,
          straightenZoom: 0,
          adjustmentLevel: {
            brightness: 0,
            contrast: 0,
            hue: 0,
            opacity: 100,
            saturation: 0,
            blur: 0,
            exposure: 0,
            transparency: 100,
            sharpen: false,
            bw: false
          },
          currentFilter: ""
        };
      }
    };
    ImageEditor2.prototype.freeHandDraw = function(value) {
      this.notify("freehand-draw", { prop: "freeHandDraw", onPropertyChange: false, value: { value } });
    };
    ImageEditor2.prototype.freehandDraw = function(value) {
      if (!this.disabled && this.isImageLoaded) {
        if (!value && this.isMaskImage) {
          this.discard();
          return;
        }
        this.manageActiveAction();
        this.freeHandDraw(value);
        var prevObj = { shapeSettingsObj: {} };
        this.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj: prevObj } });
        var shapeSettings = prevObj["shapeSettingsObj"];
        shapeSettings.type = ShapeType.FreehandDraw;
        var shapeChangingArgs = {
          cancel: false,
          action: "insert",
          previousShapeSettings: shapeSettings,
          currentShapeSettings: shapeSettings
        };
        this.notify("freehand-draw", { prop: "triggerShapeChanging", value: { shapeChangingArgs } });
      }
    };
    ImageEditor2.prototype.pan = function(value, x, y) {
      this.applyShapes();
      this.notify("transform", { prop: "pan", onPropertyChange: false, value: { value, x, y } });
    };
    ImageEditor2.prototype.zoom = function(zoomFactor, zoomPoint) {
      this.isZoomBtnClick = true;
      this.notify("transform", {
        prop: "zoom",
        onPropertyChange: false,
        value: { zoomFactor, zoomPoint }
      });
      this.notify("draw", { prop: "redrawDownScale" });
    };
    ImageEditor2.prototype.drawEllipse = function(x, y, radiusX, radiusY, strokeWidth, strokeColor, fillColor, degree, isSelected) {
      var isEllipse = false;
      var isPointsInRange = this.allowShape(x, y);
      if (!this.disabled && this.isImageLoaded && (isPointsInRange || isNullOrUndefined(x) && isNullOrUndefined(y))) {
        isEllipse = true;
        this.manageActiveAction();
        this.notify("shape", { prop: "drawEllipse", onPropertyChange: false, value: {
          x,
          y,
          radiusX,
          radiusY,
          strokeWidth,
          strokeColor,
          fillColor,
          degree,
          isSelected
        } });
        this.editCompleted();
      }
      return isEllipse;
    };
    ImageEditor2.prototype.drawLine = function(startX, startY, endX, endY, strokeWidth, strokeColor, isSelected) {
      var isLine = false;
      var isPointsInRange = this.allowShape(startX, startY);
      if (!this.disabled && this.isImageLoaded && (isPointsInRange || isNullOrUndefined(startX) && isNullOrUndefined(startY))) {
        isLine = true;
        this.manageActiveAction();
        this.notify("shape", { prop: "drawLine", onPropertyChange: false, value: {
          startX,
          startY,
          endX,
          endY,
          strokeWidth,
          strokeColor,
          isSelected
        } });
        this.editCompleted();
      }
      return isLine;
    };
    ImageEditor2.prototype.drawArrow = function(startX, startY, endX, endY, strokeWidth, strokeColor, arrowStart, arrowEnd, isSelected) {
      var isArrow = false;
      var isPointsInRange = this.allowShape(startX, startY);
      if (!this.disabled && this.isImageLoaded && (isPointsInRange || isNullOrUndefined(startX) && isNullOrUndefined(startY))) {
        isArrow = true;
        this.manageActiveAction();
        this.notify("shape", { prop: "drawArrow", onPropertyChange: false, value: {
          startX,
          startY,
          endX,
          endY,
          strokeWidth,
          strokeColor,
          arrowStart,
          arrowEnd,
          isSelected
        } });
        this.editCompleted();
      }
      return isArrow;
    };
    ImageEditor2.prototype.drawPath = function(pointColl, strokeWidth, strokeColor, isSelected) {
      this.isPublicMethod = true;
      var obj = { inRange: false };
      var isPath = false;
      if (pointColl && pointColl.length > 0) {
        for (var i = 0; i < pointColl.length; i++) {
          if (obj["inRange"]) {
            break;
          }
          this.notify("shape", {
            prop: "isPointsInRange",
            onPropertyChange: false,
            value: { x: pointColl[i].x, y: pointColl[i].y, obj }
          });
        }
      }
      if (!this.disabled && this.isImageLoaded && (obj["inRange"] || isNullOrUndefined(pointColl))) {
        isPath = true;
        this.manageActiveAction();
        this.notify("shape", { prop: "drawPath", onPropertyChange: false, value: {
          pointColl,
          strokeWidth,
          strokeColor,
          isSelected
        } });
        this.editCompleted();
      }
      return isPath;
    };
    ImageEditor2.prototype.drawRectangle = function(x, y, width, height, strokeWidth, strokeColor, fillColor, degree, isSelected, borderRadius) {
      var isRectangle = false;
      var isPointsInRange = this.allowShape(x, y);
      if (!this.disabled && this.isImageLoaded && (isPointsInRange || isNullOrUndefined(x) && isNullOrUndefined(y))) {
        isRectangle = true;
        this.manageActiveAction();
        this.notify("shape", { prop: "drawRectangle", onPropertyChange: false, value: {
          x,
          y,
          width,
          height,
          strokeWidth,
          strokeColor,
          fillColor,
          degree,
          isSelected,
          radius: borderRadius
        } });
        this.editCompleted();
      }
      return isRectangle;
    };
    ImageEditor2.prototype.drawText = function(x, y, text, fontFamily, fontSize, bold, italic, color, isSelected, degree, fillColor, strokeColor, strokeWidth, transformCollection) {
      var isText = false;
      var isPointsInRange = this.allowShape(x, y);
      if (!this.disabled && this.isImageLoaded && (isPointsInRange || isNullOrUndefined(x) && isNullOrUndefined(y))) {
        isText = true;
        this.manageActiveAction();
        this.notify("shape", { prop: "drawText", onPropertyChange: false, value: {
          x,
          y,
          text,
          fontFamily,
          fontSize,
          bold,
          italic,
          color,
          isSelected,
          degree,
          fillColor,
          outlineColor: strokeColor,
          outlineWidth: strokeWidth,
          transformCollection
        } });
        this.editCompleted();
      }
      return isText;
    };
    ImageEditor2.prototype.drawImage = function(data, x, y, width, height, isAspectRatio, degree, opacity, isSelected) {
      var isImage = false;
      var isPointsInRange = this.allowShape(x, y);
      if (!this.disabled && this.isImageLoaded && (isPointsInRange || isNullOrUndefined(x) && isNullOrUndefined(y))) {
        this.manageActiveAction();
        var length_1 = this.objColl.length;
        this.notify("shape", { prop: "drawImage", onPropertyChange: false, value: {
          x,
          y,
          width,
          height,
          src: data,
          degree,
          isAspectRatio,
          opacity,
          isSelected
        } });
        this.editCompleted();
        if (this.objColl.length > length_1) {
          isImage = true;
        }
      }
      return isImage;
    };
    ImageEditor2.prototype.updateShape = function(setting, isSelected) {
      var obj = { isSelected: false };
      var isTextArea = false;
      var freehandObj = { bool: false };
      if (isNullOrUndefined(setting.id)) {
        if (setting.strokeColor) {
          this.activeObj.strokeSettings.strokeColor = setting.strokeColor;
        }
        if (setting.fillColor) {
          this.activeObj.strokeSettings.fillColor = setting.fillColor;
        }
        if (setting.strokeWidth) {
          this.activeObj.strokeSettings.strokeWidth = setting.strokeWidth;
        }
        if (setting.index) {
          this.activeObj.order = setting.index;
        }
        if (setting.type === "FreehandDraw" && setting.strokeWidth) {
          this.notify("freehand-draw", { prop: "setPenStrokeWidth", onPropertyChange: false, value: { value: setting.strokeWidth } });
        }
      } else {
        if (setting.type.toLowerCase() === "text" && (this.textArea.style.display === "block" || this.textArea.style.display === "inline-block")) {
          this.okBtn(null, true);
          isTextArea = true;
        }
        this.notify("shape", { prop: "selectShape", onPropertyChange: false, value: { id: setting.id, obj, isShape: true } });
        this.notify("selection", { prop: "getFreehandDrawEditing", onPropertyChange: false, value: { obj: freehandObj } });
        if (obj["isSelected"]) {
          var tempFontSize = this.activeObj.textSettings.fontSize;
          this.notify("shape", {
            prop: "updateShapeChangeEventArgs",
            onPropertyChange: false,
            value: { shapeSettings: setting }
          });
          if (this.activeObj.shape === "text" && tempFontSize) {
            var diff = this.activeObj.textSettings.fontSize - tempFontSize;
            if (diff !== 0) {
              this.activeObj.activePoint.height += diff;
              this.activeObj.activePoint.startY -= diff / 2;
              this.activeObj.activePoint.endY += diff / 2;
              this.notify("draw", { prop: "updateActiveObject", onPropertyChange: false, value: {
                actPoint: this.activeObj.activePoint,
                obj: this.activeObj,
                isMouseMove: null,
                x: null,
                y: null
              } });
            }
          }
          var activeObj = extend({}, this.activeObj, {}, true);
          this.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
          this.notify("draw", { prop: "render-image", value: { isMouseWheel: null, isPreventClearRect: null, isFrame: null } });
          this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
          if (activeObj.shape) {
            this.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate", obj: activeObj } });
          }
          if (this.activeObj.shape === "text") {
            this.notify("toolbar", { prop: "editText", onPropertyChange: false });
          }
          if (freehandObj["bool"]) {
            this.notify("undo-redo", { prop: "setPreventUR", value: { bool: true } });
          }
          this.okBtn(isSelected, true);
          if (freehandObj["bool"]) {
            this.notify("undo-redo", { prop: "setPreventUR", value: { bool: false } });
          }
          this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
          this.editCompleteArgs = { action: "shape-update", currentShapeSettings: setting };
          this.editCompleted("shape-customize");
          if (isTextArea) {
            this.enableTextEditing();
          }
          if (isSelected) {
            this.noRedact = true;
            this.selectShape(setting.id);
          }
        }
      }
      return obj["isSelected"];
    };
    ImageEditor2.prototype.selectShape = function(id) {
      this.applyShapes();
      var obj = { isSelected: false };
      this.notify("shape", { prop: "selectShape", onPropertyChange: false, value: { id, obj, isShape: true } });
      this.editCompleted("shape-select");
      this.noRedact = false;
      return obj["isSelected"];
    };
    ImageEditor2.prototype.deleteShape = function(id) {
      var shape = this.getShapeSetting(id);
      if (shape.type === "Redact") {
        return;
      }
      this.applyShapes();
      this.notify("shape", { prop: "deleteShape", onPropertyChange: false, value: { id, isShape: true } });
      this.editCompleted("shape-delete");
    };
    ImageEditor2.prototype.getShapeSetting = function(id) {
      this.applyShapes();
      var obj = { shapeDetails: null };
      this.notify("shape", {
        prop: "getShapeSetting",
        onPropertyChange: false,
        value: { id, obj }
      });
      this.notify("draw", { prop: "redrawDownScale" });
      var shapeDetails = obj["shapeDetails"] ? obj["shapeDetails"] : {};
      return shapeDetails;
    };
    ImageEditor2.prototype.getShapeSettings = function() {
      this.applyShapes();
      var obj = { shapeDetailsColl: [] };
      this.notify("shape", { prop: "getShapeSettings", onPropertyChange: false, value: { obj } });
      this.notify("draw", { prop: "redrawDownScale" });
      return obj.shapeDetailsColl.filter(function(item) {
        return item.type !== "redact";
      });
    };
    ImageEditor2.prototype.getRedacts = function() {
      this.applyShapes();
      var obj = { shapeDetailsColl: [] };
      this.notify("shape", { prop: "getRedactSettings", onPropertyChange: false, value: { obj } });
      this.notify("draw", { prop: "redrawDownScale" });
      return obj.shapeDetailsColl.filter(function(item) {
        return item.type !== "redact";
      });
    };
    ImageEditor2.prototype.selectRedact = function(id) {
      this.applyShapes();
      var obj = { isSelected: false };
      this.notify("shape", { prop: "selectShape", onPropertyChange: false, value: { id, obj, isRedact: true } });
      this.editCompleted("redact-select");
      this.noRedact = false;
      return obj["isSelected"];
    };
    ImageEditor2.prototype.deleteRedact = function(id) {
      this.applyShapes();
      this.notify("shape", { prop: "deleteShape", onPropertyChange: false, value: { id, isRedact: true } });
      this.editCompleted("redact-delete");
    };
    ImageEditor2.prototype.updateRedact = function(setting, isSelected) {
      this.applyShapes();
      var obj = { isSelected: false };
      this.notify("shape", { prop: "selectShape", onPropertyChange: false, value: { id: setting.id, obj, isRedact: true } });
      if (obj["isSelected"]) {
        this.notify("shape", {
          prop: "updateShapeChangeEventArgs",
          onPropertyChange: false,
          value: { shapeSettings: setting }
        });
        if (setting.blurIntensity) {
          this.activeObj.redactBlur = setting.blurIntensity;
        }
        if (setting.pixelSize) {
          this.activeObj.redactPixelate = setting.pixelSize;
        }
        this.activeObj.redactType = setting.type.toLowerCase() === "blur" ? "blur" : "pixelate";
        var activeObj = extend({}, this.activeObj, {}, true);
        this.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        this.notify("draw", { prop: "render-image", value: { isMouseWheel: null, isPreventClearRect: null, isFrame: null } });
        this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
        if (activeObj.shape) {
          this.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate", obj: activeObj } });
        }
        this.okBtn(isSelected, true);
        this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
        this.editCompleteArgs = { action: "redact-update", currentShapeSettings: setting };
        this.editCompleted("redact-customize");
        if (isSelected) {
          this.selectRedact(setting.id);
        }
      }
      return obj["isSelected"];
    };
    ImageEditor2.prototype.update = function() {
      this.notify("transform", { prop: "update" });
    };
    ImageEditor2.prototype.finetuneImage = function(finetuneOption, value) {
      if (!this.disabled && this.isImageLoaded) {
        this.manageActiveAction();
        this.notify("filter", { prop: "finetuneImage", value: { value, option: finetuneOption } });
        this.editCompleteArgs = { finetune: finetuneOption, value };
        this.editCompleted("fine-tune");
      }
    };
    ImageEditor2.prototype.applyImageFilter = function(filterOption) {
      if (!this.disabled && this.isImageLoaded) {
        this.manageActiveAction();
        this.notify("filter", { prop: "applyImageFilter", value: { option: filterOption.toString() } });
        this.editCompleteArgs = { filter: filterOption };
        this.editCompleted("filter");
        this.canvasFilter = this.lowerContext.filter;
        this.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
      }
    };
    ImageEditor2.prototype.undo = function() {
      this.manageActiveAction();
      this.notify("undo-redo", { prop: "undo", onPropertyChange: false });
      this.notify("draw", { prop: "redrawDownScale" });
    };
    ImageEditor2.prototype.redo = function() {
      this.manageActiveAction();
      this.notify("undo-redo", { prop: "redo", onPropertyChange: false });
      this.notify("draw", { prop: "redrawDownScale" });
    };
    ImageEditor2.prototype.getImageDimension = function() {
      return { x: this.img.destLeft, y: this.img.destTop, width: this.img.destWidth, height: this.img.destHeight };
    };
    ImageEditor2.prototype.resize = function(width, height, isAspectRatio) {
      var isResized = false;
      if (width.toString().length <= 4 && height.toString().length <= 4 && (!this.isCircleCrop || isAspectRatio)) {
        this.manageActiveAction();
        this.notify("toolbar", { prop: "resizeClick", value: { bool: false } });
        var destPoints = {
          startX: this.img.destLeft,
          startY: this.img.destTop,
          width: this.img.destWidth,
          height: this.img.destHeight
        };
        if (isAspectRatio) {
          this.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
            type: "resize",
            isApplyBtn: false,
            isCropping: false
          } });
          this.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
            type: "resize",
            isApplyBtn: false,
            isCropping: false
          } });
        } else {
          this.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
            type: "resize",
            isApplyBtn: false,
            isCropping: false
          } });
        }
        var aspectRatioWidth = this.element.querySelector("#" + this.element.id + "_resizeWidth");
        var aspectRatioHeight = this.element.querySelector("#" + this.element.id + "_resizeHeight");
        if (aspectRatioWidth && aspectRatioHeight) {
          getComponent(aspectRatioWidth, "numerictextbox").value = Math.floor(width);
          aspectRatioWidth.value = Math.floor(width).toString() + " px";
          getComponent(aspectRatioHeight, "numerictextbox").value = Math.floor(height);
          aspectRatioHeight.value = Math.floor(height).toString() + " px";
        }
        this.notify("transform", { prop: "resize", value: { width, height, isAspectRatio } });
        if (destPoints.startX !== this.img.destLeft || destPoints.startY !== this.img.destTop || destPoints.width !== this.img.destWidth || destPoints.height !== this.img.destHeight) {
          isResized = true;
          this.aspectWidth = width;
          this.aspectHeight = height;
          if (isAspectRatio) {
            this.aspectHeight = null;
          }
          this.okBtn(false, false, true);
        } else {
          this.notify("draw", { prop: "performCancel", value: { isContextualToolbar: null } });
        }
        this.notify("draw", { prop: "redrawDownScale" });
      }
      return isResized;
    };
    ImageEditor2.prototype.drawFrame = function(frameType, color, gradientColor, size, inset, offset, borderRadius, frameLineStyle, lineCount) {
      this.manageActiveAction();
      var isFrame = false;
      var obj = { frameChangeEventArgs: null };
      color = color ? color : "#fff";
      gradientColor = gradientColor ? gradientColor : "";
      size = size ? size : 20;
      inset = inset ? inset : 0;
      offset = offset ? offset : 0;
      borderRadius = borderRadius ? borderRadius : 0;
      frameLineStyle = frameLineStyle ? frameLineStyle : FrameLineStyle.Solid;
      lineCount = lineCount ? lineCount : 0;
      var prevFrameSettings = {
        type: this.toPascalCase(this.frameObj.type),
        color: this.frameObj.color,
        gradientColor: this.frameObj.gradientColor,
        size: this.frameObj.size,
        inset: this.frameObj.inset,
        offset: this.frameObj.offset,
        borderRadius: this.frameObj.radius,
        frameLineStyle: this.toPascalCase(this.frameObj.border),
        lineCount: this.frameObj.amount
      };
      extend(this.tempFrameObj, this.frameObj);
      this.tempFrameZoomLevel = this.transform.zoomFactor;
      this.frameDestPoints = extend({}, this.img, {}, true);
      this.notify("toolbar", { prop: "frameToolbarClick" });
      this.frameObj.type = frameType.toLowerCase();
      this.frameObj.color = color;
      this.frameObj.gradientColor = gradientColor;
      this.frameObj.size = size;
      this.frameObj.inset = inset;
      this.frameObj.offset = offset;
      this.frameObj.radius = borderRadius;
      this.frameObj.border = frameLineStyle.toLowerCase();
      this.frameObj.amount = lineCount;
      this.notify("draw", { prop: "triggerFrameChange", value: { prevFrameSettings, obj } });
      if (obj["frameChangeEventArgs"] && !obj["frameChangeEventArgs"].cancel) {
        this.notify("draw", { prop: "render-image", value: { isMouseWheel: null } });
        if (JSON.stringify(this.frameObj) !== JSON.stringify(this.tempFrameObj)) {
          isFrame = true;
          this.okBtn();
        } else {
          this.tempFrameZoomLevel = null;
        }
      } else {
        this.notify("draw", { prop: "performCancel", value: { isContextualToolbar: null } });
        extend(this.frameObj, this.tempFrameObj);
        this.tempFrameZoomLevel = null;
      }
      this.notify("draw", { prop: "redrawDownScale" });
      var ctxTbar = this.element.querySelector(".e-contextual-toolbar-wrapper");
      if (ctxTbar) {
        ctxTbar.classList.add("e-hide");
      }
      return isFrame;
    };
    ImageEditor2.prototype.straightenImage = function(degree) {
      var isStraightened = false;
      if (degree >= -45 && degree <= 45) {
        this.applyShapes();
        isStraightened = true;
        this.notify("transform", { prop: "straightenImage", value: { degree } });
        this.notify("draw", { prop: "redrawDownScale" });
      }
      return isStraightened;
    };
    ImageEditor2.prototype.cloneShape = function(shapeId) {
      var obj = { isSelected: false };
      if (shapeId.split("_")[0] === "shape") {
        this.notify("shape", { prop: "selectShape", onPropertyChange: false, value: { id: shapeId, obj } });
        if (obj["isSelected"]) {
          this.notify("toolbar", { prop: "duplicateShape", onPropertyChange: false, value: { isPreventUndoRedo: false } });
          this.okBtn(null, true);
          this.notify("draw", { prop: "redrawDownScale" });
        }
      }
      return obj["isSelected"];
    };
    ImageEditor2.prototype.getImageFilter = function(filterOption) {
      var canvas = this.createElement("canvas");
      var ctx = canvas.getContext("2d");
      this.notify("filter", { prop: "updateAdj", value: { type: filterOption.toLowerCase(), value: null, isPreview: true, ctx } });
      return ctx.filter;
    };
    ImageEditor2.prototype.enableTextEditing = function() {
      var activeObj = extend({}, this.activeObj, {}, true);
      if (!activeObj.order) {
        this.noPushUndo = true;
        this.okBtn();
        this.noPushUndo = false;
        this.noRedact = true;
        this.selectShape(activeObj.currIndex);
        activeObj.order = this.activeObj.order;
      }
      this.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      this.notify("draw", { prop: "render-image", value: { isMouseWheel: null, isPreventClearRect: null, isFrame: false } });
      this.activeObj = activeObj;
      this.notify("toolbar", { prop: "editText", onPropertyChange: false });
    };
    ImageEditor2.prototype.canUndo = function() {
      var canUndo = false;
      var object = this.getUndoRedoColl();
      var undoRedoIndex = object["index"];
      if (undoRedoIndex > 0) {
        canUndo = true;
      }
      return canUndo;
    };
    ImageEditor2.prototype.canRedo = function() {
      var canRedo = false;
      var object = this.getUndoRedoColl();
      var undoRedoColl = object["undoRedoColl"];
      var undoRedoIndex = object["index"];
      if (undoRedoColl && undoRedoColl.length > 0 && undoRedoIndex < undoRedoColl.length - 1) {
        canRedo = true;
      }
      if (undoRedoIndex === undoRedoColl.length) {
        canRedo = false;
      } else if (undoRedoIndex === 0 && undoRedoColl.length > 0) {
        canRedo = true;
      } else if (undoRedoIndex > 0) {
        canRedo = true;
      }
      return canRedo;
    };
    ImageEditor2.prototype.apply = function() {
      if (this.isMaskImage) {
        this.discard();
      } else {
        this.updateColl("reset");
        this.closeOverlayTbar();
        this.okBtn(null, true);
      }
    };
    ImageEditor2.prototype.discard = function() {
      this.updateColl("reset");
      this.notify("draw", { prop: "performCancel", value: { isContextualToolbar: this.closeOverlayTbar(), isFinalCancel: true } });
    };
    ImageEditor2.prototype.enableShapeDrawing = function(shapeType, isEnabled) {
      if (isEnabled) {
        this.drawingShape = shapeType.toLowerCase();
        this.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      }
      if (shapeType && isEnabled) {
        this.currObjType.shape = shapeType.toLowerCase();
        this.activeObj.shape = this.currObjType.shape;
        this.currObjType.isDragging = this.currObjType.isCustomCrop = false;
        this.activeObj.shapeDegree = this.transform.degree;
        this.activeObj.shapeFlip = this.transform.currFlipState;
        this.activeObj.textFlip = this.transform.currFlipState;
        this.activeObj.flipObjColl = [];
        var orderObj = { order: null };
        this.notify("shape", { prop: "getNewOrder", onPropertyChange: false, value: { obj: orderObj } });
        this.activeObj.order = orderObj["order"];
        this.notify("selection", { prop: "annotate", value: { shape: this.currObjType.shape } });
        if (this.currObjType.shape === "text") {
          this.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
            type: "text",
            isApplyBtn: null,
            isCropping: null,
            isZooming: null,
            cType: null
          } });
        } else if (this.currObjType.shape === "redact") {
          this.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
            type: "redact",
            isApplyBtn: null,
            isCropping: null,
            isZooming: null,
            cType: null
          } });
        } else {
          this.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
            type: "shapes",
            isApplyBtn: null,
            isCropping: null,
            isZooming: null,
            cType: null
          } });
        }
        this.notify("toolbar", { prop: "update-toolbar-items", onPropertyChange: false });
      } else if (!isEnabled) {
        this.okBtn(null, true);
      }
    };
    ImageEditor2.prototype.bringToFront = function(shapeId) {
      this.noRedact = true;
      if (this.selectShape(shapeId)) {
        this.updateShapeOrder(shapeId, "bringToFront");
        this.apply();
      }
    };
    ImageEditor2.prototype.bringForward = function(shapeId) {
      this.noRedact = true;
      if (this.selectShape(shapeId)) {
        this.updateShapeOrder(shapeId, "bringForward");
        this.apply();
      }
    };
    ImageEditor2.prototype.sendToBack = function(shapeId) {
      this.noRedact = true;
      if (this.selectShape(shapeId)) {
        this.updateShapeOrder(shapeId, "sendToBack");
        this.apply();
      }
    };
    ImageEditor2.prototype.sendBackward = function(shapeId) {
      this.noRedact = true;
      if (this.selectShape(shapeId)) {
        this.updateShapeOrder(shapeId, "sendBackward");
        this.apply();
      }
    };
    ImageEditor2.prototype.clearImage = function() {
      this.reset();
      this.isImageLoaded = false;
      this.lowerContext.clearRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
      this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
      var btoolbar = (undefined).getElementById(this.element.id + "_bottomToolbar");
      if (Browser.isDevice && btoolbar) {
        (undefined).getElementById(this.element.id + "_bottomToolbar").style.display = "none";
      }
      this.notify("toolbar", { prop: "destroy-top-toolbar", onPropertyChange: false });
      this.notify("toolbar", { prop: "create-toolbar", onPropertyChange: false });
      this.notify("toolbar", { prop: "create-contextual-toolbar", onPropertyChange: false });
      var dropArea = (undefined).getElementById(this.element.id + "_dropArea");
      if (dropArea) {
        dropArea.style.display = "block";
      }
    };
    ImageEditor2.prototype.selectMaskImage = function(strokeWidth, color) {
      strokeWidth = strokeWidth ? strokeWidth : 10;
      color = color ? color : "#512da880";
      this.applyShapes();
      this.isMaskImage = true;
      this.updateColl("empty");
      this.enableDisableToolbar(true);
      this.update();
      this.activeObj.strokeSettings.strokeWidth = strokeWidth;
      this.notify("freehand-draw", { prop: "setPenStrokeWidth", onPropertyChange: false, value: { value: strokeWidth } });
      this.activeObj.strokeSettings.strokeColor = color;
      this.notify("freehand-draw", { prop: "freeHandDraw", onPropertyChange: false, value: { value: true } });
      this.maskCanvas.style.display = "block";
    };
    ImageEditor2.prototype.enableDisableToolbar = function(value) {
      var toolbar;
      var elem = (undefined).getElementById(this.element.id + "_toolbar");
      if (elem) {
        toolbar = getComponent(elem, "toolbar");
        if (toolbar) {
          toolbar.disable(value);
        }
      }
      elem = (undefined).getElementById(this.element.id + "_bottomToolbar");
      if (elem) {
        toolbar = getComponent(elem, "toolbar");
        if (toolbar) {
          toolbar.disable(value);
        }
      }
    };
    ImageEditor2.prototype.updateImage = function(data, imageBackgroundColor) {
      var _this = this;
      if (data || imageBackgroundColor || imageBackgroundColor === "") {
        var prevCropObj_1 = extend({}, this.cropObj, {}, true);
        var object = { currObj: {} };
        this.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
        var prevObj_1 = object["currObj"];
        prevObj_1.objColl = extend([], this.objColl, [], true);
        prevObj_1.pointColl = extend([], this.pointColl, [], true);
        prevObj_1.afterCropActions = extend([], this.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        this.notify("freehand-draw", { prop: "getSelPointColl", onPropertyChange: false, value: { obj: selPointCollObj } });
        prevObj_1.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
        if (data) {
          this.isImageUpdated = true;
          if (typeof data !== "string") {
            var canvas = this.createElement("canvas");
            canvas.width = data.width;
            canvas.height = data.height;
            canvas.getContext("2d").putImageData(data, 0, 0);
            data = canvas.toDataURL();
          }
          this.baseImg.src = data;
          setTimeout(function() {
            if (_this.cropObj.straighten !== 0) {
              _this.notify("toolbar", { prop: "performCropTransformClick", value: { shape: "crop-custom" } });
              _this.noPushUndo = true;
              _this.crop();
              _this.noPushUndo = false;
            } else {
              _this.notify("draw", { prop: "render-image", value: { isMouseWheel: false } });
            }
            _this.isImageUpdated = false;
            if (!imageBackgroundColor) {
              _this.notify("undo-redo", { prop: "updateUndoRedoColl", onPropertyChange: false, value: {
                operation: "updateImage",
                previousObj: prevObj_1,
                previousObjColl: prevObj_1.objColl,
                previousPointColl: prevObj_1.pointColl,
                previousSelPointColl: prevObj_1.selPointColl,
                previousCropObj: prevCropObj_1,
                previousText: null,
                currentText: null,
                previousFilter: null,
                isCircleCrop: null
              } });
              _this.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
            }
          }, 100);
        }
        if (imageBackgroundColor || imageBackgroundColor === "") {
          this.notify("draw", { prop: "imageBackgroundColor", onPropertyChange: false, value: { color: imageBackgroundColor } });
          this.notify("draw", { prop: "render-image", value: { isMouseWheel: false } });
          if (!data) {
            this.notify("undo-redo", { prop: "updateUndoRedoColl", onPropertyChange: false, value: {
              operation: "bgColor",
              previousObj: prevObj_1,
              previousObjColl: prevObj_1.objColl,
              previousPointColl: prevObj_1.pointColl,
              previousSelPointColl: prevObj_1.selPointColl,
              previousCropObj: prevCropObj_1,
              previousText: null,
              currentText: null,
              previousFilter: null,
              isCircleCrop: null
            } });
            this.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
          }
        }
        if (data && imageBackgroundColor) {
          this.notify("undo-redo", { prop: "updateUndoRedoColl", onPropertyChange: false, value: {
            operation: "updateImage",
            previousObj: prevObj_1,
            previousObjColl: prevObj_1.objColl,
            previousPointColl: prevObj_1.pointColl,
            previousSelPointColl: prevObj_1.selPointColl,
            previousCropObj: prevCropObj_1,
            previousText: null,
            currentText: null,
            previousFilter: null,
            isCircleCrop: null
          } });
          this.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
        }
      }
    };
    ImageEditor2.prototype.editCompleted = function(type) {
      this.notify("draw", { prop: "redrawDownScale" });
      var actionArgs = {
        action: type ? type : "shape-insert",
        actionEventArgs: this.editCompleteArgs
      };
      this.triggerEditCompleteEvent(actionArgs);
    };
    ImageEditor2.prototype.updateColl = function(type) {
      if (!this.isMaskImage) {
        return;
      }
      if (type === "empty") {
        this.tempToolbarHeight = this.toolbarHeight;
        this.tempToolbar = this.toolbar ? extend([], this.toolbar, [], true) : null;
        this.tempObjColl = extend([], this.objColl, [], true);
        this.tempPointColl = extend([], this.pointColl, [], true);
        this.tempShapeColl = extend([], this.shapeColl, [], true);
        this.objColl = [];
        this.pointColl = [];
        this.shapeColl = [];
        this.freehandCounter = 0;
        this.notify("freehand-draw", {
          prop: "setCurrentFreehandDrawIndex",
          value: { value: 0 }
        });
        this.notify("draw", { prop: "render-image", value: { isMouseWheel: false } });
      } else if (type === "reset") {
        this.objColl = this.tempObjColl;
        this.pointColl = this.tempPointColl;
        this.shapeColl = this.tempShapeColl;
        this.freehandCounter = this.pointColl.length;
        this.notify("freehand-draw", {
          prop: "setCurrentFreehandDrawIndex",
          value: { value: this.freehandCounter }
        });
        this.enableDisableToolbar(false);
        if (this.cropObj.straighten !== 0) {
          this.notify("toolbar", { prop: "performCropTransformClick", value: { shape: "crop-custom" } });
          this.noPushUndo = true;
          this.crop();
          this.noPushUndo = false;
        }
        this.notify("draw", { prop: "render-image", value: { isMouseWheel: false } });
        this.isMaskImage = false;
        this.upperContext.globalCompositeOperation = "source-over";
        this.maskCanvas.style.display = "none";
        this.activeObj.strokeSettings = {
          strokeColor: "#fff",
          fillColor: "",
          strokeWidth: null,
          radius: null,
          outlineColor: "",
          outlineWidth: null
        };
        this.notify("shape", { prop: "setStrokeSettings", value: {
          strokeSettings: this.activeObj.strokeSettings,
          strokeColor: "#fff",
          fillColor: "",
          strokeWidth: null,
          outlineWidth: null
        } });
        this.notify("freehand-draw", { prop: "setPenStrokeWidth", onPropertyChange: false, value: { value: 2 } });
        this.notify("freehand-draw", { prop: "setMasking", onPropertyChange: false, value: { value: false } });
      }
    };
    ImageEditor2.prototype.resetToolbar = function() {
      if (this.toolbarHeight !== this.tempToolbarHeight && !(isNullOrUndefined(this.toolbar) || this.toolbar && this.toolbar.length > 0 || !isNullOrUndefined(this.toolbarTemplate))) {
        this.toolbarHeight = this.tempToolbarHeight;
        this.notify("toolbar", { prop: "setToolbarHeight", value: { height: this.toolbarHeight } });
        this.toolbar = this.tempToolbar;
        if (!this.toolbarTemplate) {
          this.notify("toolbar", { prop: "create-toolbar", onPropertyChange: false });
          this.notify("toolbar", { prop: "create-contextual-toolbar", onPropertyChange: false });
        }
        this.update();
      }
    };
    ImageEditor2.prototype.getData = function(isMaskImage) {
      if (isMaskImage) {
        this.resetToolbar();
      }
      var objColl = extend([], this.objColl, null, true);
      var pointColl = extend([], this.pointColl, null, true);
      var shapeColl = extend([], this.shapeColl, null, true);
      if (isMaskImage) {
        this.notify("shape", { prop: "updateShapeColl", onPropertyChange: false });
        for (var i = 0; i < this.freehandCounter; i++) {
          this.pointColl[i].strokeColor = "#fff";
        }
      } else {
        this.objColl = [];
        this.pointColl = [];
        this.shapeColl = [];
        this.freehandCounter = 0;
      }
      var frameType = this.frameObj.type;
      this.frameObj.type = "none";
      var aspectWidth = this.aspectWidth;
      var aspectHeight = this.aspectHeight;
      this.aspectWidth = this.aspectHeight = null;
      var straighten = this.cropObj.straighten;
      this.togglePen = false;
      this.notify("toolbar", { prop: "performCropTransformClick", value: { shape: "crop-custom" } });
      var tempDestPoints = extend({}, this.img, {}, true);
      var tempCropObj = extend({}, this.cropObj, {}, true);
      var tempSel = extend({}, this.activeObj, {}, true);
      var tempTransform = extend({}, this.transform, {}, true);
      var panPoint = extend({}, this.panPoint, {}, true);
      if (straighten !== 0) {
        this.setStraighten(0);
      }
      var point = this.activeObj.activePoint;
      point.startX = this.img.destLeft;
      point.startY = this.img.destTop;
      point.width = this.img.destWidth;
      point.height = this.img.destHeight;
      point.endX = point.startX + point.width;
      point.endY = point.startY + point.height;
      this.notify("draw", { prop: "updateActiveObject", onPropertyChange: false, value: {
        actPoint: point,
        obj: this.activeObj,
        isMouseMove: null,
        x: null,
        y: null
      } });
      this.noPushUndo = true;
      this.crop();
      this.noPushUndo = false;
      this.isCropTab = false;
      this.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      this.notify("crop", { prop: "resetZoom", onPropertyChange: false });
      this.isCropTab = true;
      var afterCropActions = extend([], this.afterCropActions, [], true);
      var coll = extend([], this.rotateFlipColl, [], true);
      this.notify("crop", { prop: "revertTransform", value: { type: "initial", coll } });
      var imageData = this.getImageData();
      if (isMaskImage) {
        var canvas = this.createElement("canvas");
        var ctx = canvas.getContext("2d");
        canvas.width = imageData.width;
        canvas.height = imageData.height;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        if (this.pointColl.length > 0) {
          var obj = { width: 0, height: 0 };
          this.notify("crop", {
            prop: "calcRatio",
            onPropertyChange: false,
            value: { obj, dimension: { width: canvas.width, height: canvas.height } }
          });
          var ratio = obj;
          this.notify("export", { prop: "drawAnnotation", value: { context: ctx, ratio } });
        }
        this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
        imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      }
      this.notify("crop", { prop: "revertTransform", value: { type: "reverse", coll } });
      this.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      this.afterCropActions = afterCropActions;
      if (!isMaskImage) {
        this.objColl = objColl;
        this.pointColl = pointColl;
        this.shapeColl = shapeColl;
        this.freehandCounter = this.pointColl.length;
      }
      this.frameObj.type = frameType;
      this.aspectWidth = aspectWidth;
      this.aspectHeight = aspectHeight;
      this.notify("toolbar", { prop: "performCropTransformClick", value: { shape: "crop-custom" } });
      if (straighten !== 0) {
        this.setStraighten(straighten);
      }
      this.img = tempDestPoints;
      this.cropObj = tempCropObj;
      this.activeObj = tempSel;
      this.transform = tempTransform;
      this.notify("transform", {
        prop: "zoomAction",
        onPropertyChange: false,
        value: { zoomFactor: 0.1, zoomPoint: null, isResize: null }
      });
      this.notify("transform", {
        prop: "zoomAction",
        onPropertyChange: false,
        value: { zoomFactor: -0.1, zoomPoint: null, isResize: null }
      });
      if (this.transform.degree !== 0) {
        this.panPoint.currentPannedPoint = {
          x: panPoint.totalPannedClientPoint.x,
          y: panPoint.totalPannedClientPoint.y
        };
        this.notify("transform", { prop: "drawPannedImage", value: {
          xDiff: panPoint.totalPannedClientPoint.x,
          yDiff: panPoint.totalPannedClientPoint.y
        } });
        this.panPoint.currentPannedPoint = { x: 0, y: 0 };
        this.notify("transform", { prop: "setTempPanMove", value: { point: null } });
      }
      this.noPushUndo = true;
      this.crop();
      this.noPushUndo = false;
      this.transform.straighten = 0;
      this.notify("draw", { prop: "render-image", value: { isMouseWheel: false } });
      return imageData;
    };
    ImageEditor2.prototype.applyShapes = function() {
      if (this.isUndoRedoStack) {
        return;
      }
      var shapes = ["rectangle", "ellipse", "line", "arrow", "path", "text", "image"];
      var dummyObj = { bool: false };
      this.notify("selection", { prop: "getFreehandDrawEditing", onPropertyChange: false, value: { obj: dummyObj } });
      if (dummyObj["bool"] || this.togglePen || this.activeObj.shape && shapes.indexOf(this.activeObj.shape) !== -1 || this.drawingShape) {
        this.okBtn(null, true);
      }
    };
    ImageEditor2.prototype.closeOverlayTbar = function() {
      var isContextualToolbar = false;
      var frameObject = { bool: null };
      this.notify("toolbar", { prop: "getFrameToolbar", onPropertyChange: false, value: { obj: frameObject } });
      if (!frameObject["bool"] && this.element.querySelector(".e-contextual-toolbar-wrapper")) {
        if (!this.element.querySelector(".e-contextual-toolbar-wrapper").classList.contains("e-hide")) {
          isContextualToolbar = true;
        }
        var straightenObj = { bool: this.isStraightening };
        if (!Browser.isDevice || Browser.isDevice && !straightenObj["bool"]) {
          this.element.querySelector(".e-contextual-toolbar-wrapper").classList.add("e-hide");
        }
      }
      return isContextualToolbar;
    };
    ImageEditor2.prototype.toolbarTemplateFn = function() {
      var template;
      var templateID = this.element.id + "_toolbar";
      var toolbarArea = this.element.querySelector("#" + this.element.id + "_toolbarArea");
      if (this.toolbarTemplate) {
        this.toolbarFn = this.templateParser(this.toolbarTemplate);
        if (this.isReact) {
          template = this.toolbarFn({ type: "toolbar" }, this, "Template", templateID)[0];
        } else if (this.isAngular) {
          var templateColl = this.toolbarFn({ type: "toolbar" }, this, "Template", templateID);
          template = templateColl[0].nodeType === 3 ? templateColl[1] : templateColl[0];
        } else {
          template = this.toolbarFn({ type: "toolbar" }, this, "Template", templateID)[0];
        }
        toolbarArea.appendChild(template);
        this.toolbarHeight = toolbarArea.clientHeight;
        this.notify("toolbar", { prop: "setToolbarHeight", value: { height: this.toolbarHeight } });
        this["renderReactTemplates"]();
      }
    };
    ImageEditor2.prototype.quickAccessToolbarTemplateFn = function() {
      var template;
      var templateID = this.element.id + "_quickAccessToolbar";
      var toolbarArea = this.element.querySelector("#" + this.element.id + "_quickAccessToolbarArea");
      if (this.quickAccessToolbarTemplate) {
        this.qatFn = this.templateParser(this.quickAccessToolbarTemplate);
        if (this.isReact) {
          template = this.qatFn({ type: "toolbar" }, this, "Template", templateID)[0];
        } else if (this.isAngular) {
          var templateColl = this.qatFn({ type: "toolbar" }, this, "Template", templateID);
          template = templateColl[0].nodeType === 3 ? templateColl[1] : templateColl[0];
        } else {
          template = this.qatFn({ type: "toolbar" }, this, "Template", templateID)[0];
        }
        toolbarArea.appendChild(template);
        this["renderReactTemplates"]();
      }
    };
    ImageEditor2.prototype.templateParser = function(template) {
      if (template) {
        try {
          if (typeof template !== "function" && (void 0).querySelectorAll(template).length) {
            return compile$1((void 0).querySelector(template).innerHTML.trim());
          } else {
            return compile$1(template);
          }
        } catch (error) {
          return compile$1(template);
        }
      }
      return undefined;
    };
    ImageEditor2.prototype.getTextFromId = function(id) {
      var idToValue = {
        "1": "none",
        "2": "bar",
        "3": "arrow",
        "4": "arrowSolid",
        "5": "circle",
        "6": "circleSolid",
        "7": "square",
        "8": "squareSolid"
      };
      return idToValue["" + id];
    };
    ImageEditor2.prototype.getFinetuneOption = function(type) {
      var typeToOption = {
        "brightness": ImageFinetuneOption.Brightness,
        "contrast": ImageFinetuneOption.Contrast,
        "hue": ImageFinetuneOption.Hue,
        "saturation": ImageFinetuneOption.Saturation,
        "opacity": ImageFinetuneOption.Opacity,
        "blur": ImageFinetuneOption.Blur,
        "exposure": ImageFinetuneOption.Exposure
      };
      return typeToOption["" + type];
    };
    ImageEditor2.prototype.setPenStroke = function(args) {
      this.notify("freehand-draw", { prop: "setPenStrokeWidth", onPropertyChange: false, value: { value: parseInt(args, 10) } });
    };
    ImageEditor2.prototype.updateFreehandDrawColorChange = function() {
      var obj = { tempFreeHandDrawEditingStyles: null };
      this.notify("freehand-draw", { prop: "getTempFreeHandDrawEditingStyles", value: { obj } });
      this.notify("freehand-draw", { prop: "color-change", value: { color: obj["tempFreeHandDrawEditingStyles"].strokeColor } });
    };
    ImageEditor2.prototype.getUndoRedoColl = function() {
      var obj = { undoRedoColl: null, index: null };
      var undoRedoObj = { undoRedoStep: null };
      var object = { appliedUndoRedoColl: [] };
      this.notify("undo-redo", { prop: "getAppliedUndoRedoColl", value: { obj: object } });
      this.notify("undo-redo", { prop: "getUndoRedoStep", value: { obj: undoRedoObj } });
      obj["undoRedoColl"] = object["appliedUndoRedoColl"];
      obj["index"] = undoRedoObj["undoRedoStep"];
      return obj;
    };
    ImageEditor2.prototype.updateImageTransformColl = function(type) {
      var value;
      if (type === "rotateleft") {
        value = -90;
      } else if (type === "rotateright") {
        value = 90;
      } else if (type === "horizontalflip") {
        value = "horizontal";
      } else if (type === "verticalflip") {
        value = "vertical";
      }
      for (var i = 0; i < this.objColl.length; i++) {
        var shape = this.objColl[i].shape;
        if (shape === "image" || shape === "text") {
          if (isNullOrUndefined(this.objColl[i].rotateFlipColl)) {
            this.objColl[i].rotateFlipColl = [];
          }
          this.objColl[i].rotateFlipColl.push(value);
          var obj = { collection: this.objColl[i].rotateFlipColl };
          this.notify("shape", {
            prop: "alignRotateFlipColl",
            onPropertyChange: false,
            value: { collection: this.objColl[i].rotateFlipColl, isRotateFlipCollection: false, obj }
          });
          this.objColl[i].rotateFlipColl = obj["collection"];
        }
      }
    };
    ImageEditor2.prototype.setInitialZoomState = function() {
      this.objColl.push(this.activeObj);
      this.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      var isUndoRedo = this.isUndoRedo;
      this.isCropTab = false;
      this.isUndoRedo = true;
      if (this.transform.cropZoomFactor && this.transform.cropZoomFactor > 0) {
        this.notify("transform", {
          prop: "zoomAction",
          onPropertyChange: false,
          value: { zoomFactor: -this.transform.cropZoomFactor, zoomPoint: null, isResize: true }
        });
      } else {
        this.notify("transform", {
          prop: "zoomAction",
          onPropertyChange: false,
          value: { zoomFactor: Math.abs(this.transform.cropZoomFactor), zoomPoint: null, isResize: true }
        });
      }
      this.isUndoRedo = isUndoRedo;
      this.panPoint.totalPannedPoint = { x: 0, y: 0 };
      this.transform.cropZoomFactor = 0;
      this.notify("freehand-draw", { prop: "updateFHDColl", onPropertyChange: false });
      this.activeObj = extend({}, this.objColl[this.objColl.length - 1], {}, true);
      this.objColl.pop();
      this.isCropTab = true;
      this.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate", obj: this.activeObj } });
    };
    ImageEditor2.prototype.updateCropTransformItems = function() {
      this.prevCurrSelectionPoint = extend({}, this.currSelectionPoint, {}, true);
      this.notify("draw", { prop: "updateCropSelection", onPropertyChange: false });
    };
    ImageEditor2.prototype.toPascalCase = function(str, obj) {
      var strArr = [];
      if (!isNullOrUndefined(str)) {
        strArr = str.toLowerCase().split("-");
      }
      for (var i = 0; i < strArr.length; i++) {
        strArr[i] = strArr[i].charAt(0).toUpperCase() + strArr[i].slice(1);
      }
      if (obj) {
        obj["maxText"] = strArr.join("");
      }
      return strArr.join("");
    };
    ImageEditor2.prototype.getFontSizes = function() {
      var items = [];
      this.fontSizeColl = [];
      var fontSize;
      if (this.transform.degree === 0 || this.transform.degree % 180 === 0) {
        fontSize = this.img.destWidth / 25;
      } else {
        fontSize = this.img.destHeight / 25;
      }
      for (var i = 1; i <= 10; i++) {
        this.fontSizeColl.push({ text: (i * Math.round(fontSize / 2)).toString() });
        items.push({ text: i.toString() });
      }
      return items;
    };
    ImageEditor2.prototype.updateDropInfoContent = function(dropInfoElement) {
      if (!dropInfoElement) {
        return;
      }
      var supportObj = { key: "SupportText" };
      this.notify("toolbar", { prop: "getLocaleText", onPropertyChange: false, value: { obj: supportObj } });
      var words = this.getExtensionString();
      var fileSizeObj = { key: "MinMaxSize" };
      this.notify("toolbar", { prop: "getLocaleText", onPropertyChange: false, value: { obj: fileSizeObj } });
      var andObj = { key: "And" };
      this.notify("toolbar", { prop: "getLocaleText", onPropertyChange: false, value: { obj: andObj } });
      var size;
      if (this.uploadSettings.minFileSize && this.uploadSettings.maxFileSize) {
        size = " " + fileSizeObj["value"] + " " + this.formatSizeUnits(this.uploadSettings.minFileSize) + " " + andObj["value"] + " " + this.formatSizeUnits(this.uploadSettings.maxFileSize);
      } else if (this.uploadSettings.minFileSize) {
        fileSizeObj["key"] = "MinSize";
        this.notify("toolbar", { prop: "getLocaleText", onPropertyChange: false, value: { obj: fileSizeObj } });
        size = " " + fileSizeObj["value"] + " " + this.formatSizeUnits(this.uploadSettings.minFileSize);
      } else if (this.uploadSettings.maxFileSize) {
        fileSizeObj["key"] = "MaxSize";
        this.notify("toolbar", { prop: "getLocaleText", onPropertyChange: false, value: { obj: fileSizeObj } });
        size = " " + fileSizeObj["value"] + " " + this.formatSizeUnits(this.uploadSettings.maxFileSize);
      }
      if (size) {
        dropInfoElement.textContent = supportObj["value"] + words + size;
      } else {
        dropInfoElement.textContent = supportObj["value"] + words;
      }
    };
    ImageEditor2.prototype.okBtn = function(isMouseDown, isFinalApply, isResize) {
      if (isFinalApply) {
        this.noPushUndo = false;
        var tempActiveObj = {
          activePoint: { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 },
          flipObjColl: [],
          triangle: [],
          triangleRatio: [],
          order: null
        };
        this.notify("selection", { prop: "setTempActObj", onPropertyChange: false, value: { obj: tempActiveObj } });
      }
      var ctWrapper = this.element.querySelector(".e-contextual-toolbar-wrapper");
      if (ctWrapper) {
        ctWrapper.classList.remove("e-frame-wrapper");
      }
      var isCropSelection = false;
      var splitWords;
      this.isResizeOkBtn = true;
      var aspectIcon = this.element.querySelector("#" + this.element.id + "_aspectratio");
      var nonAspectIcon = this.element.querySelector("#" + this.element.id + "_nonaspectratio");
      var blrAspRatElem = this.element.querySelector(".e-ie-toolbar-aspect-ratio-btn");
      var blrNAspRatElem = this.element.querySelector(".e-ie-toolbar-nonaspect-ratio-btn");
      if (this.activeObj.shape !== undefined) {
        splitWords = this.activeObj.shape.split("-");
      }
      if (splitWords === undefined && this.currObjType.isCustomCrop) {
        isCropSelection = true;
      } else if (splitWords !== undefined && splitWords[0] === "crop") {
        isCropSelection = true;
      }
      this.allowDownScale = true;
      if ((this.activeObj.shape && this.activeObj.shape !== "image" || this.togglePen) && !isCropSelection) {
        var objt = { shapeSettingsObj: {} };
        this.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj: objt } });
        var shapeSettings = objt["shapeSettingsObj"];
        if (this.togglePen) {
          shapeSettings.type = ShapeType.FreehandDraw;
        }
        var shapeChangedArgs = { action: "apply", currentShapeSettings: extend({}, shapeSettings, {}, true) };
        if (!this.currObjType.isRedact && (isFinalApply || this.isShapeDrawing)) {
          if (this.isShapeDrawing) {
            shapeChangedArgs.action = "draw-end";
          }
          this.trigger("shapeChange", shapeChangedArgs);
        }
        this.editCompleteArgs = shapeChangedArgs;
        if (this.currObjType.isRedact) {
          this.currObjType.isRedact = false;
        }
      }
      if (aspectIcon || nonAspectIcon) {
        var obj_2 = { width: null, height: null };
        this.notify("selection", { prop: "getNumTextValue", onPropertyChange: false, value: { obj: obj_2 } });
        var point = { x: obj_2["width"], y: obj_2["height"] };
        var obj1 = { prevCropObj: this.prevCropObj };
        var obj2 = { prevObj: this.prevObj };
        if (point && point.x && point.y && obj1["prevCropObj"] && obj2["prevObj"]) {
          if (nonAspectIcon || blrNAspRatElem && !blrNAspRatElem.classList.contains("e-hidden")) {
            this.notify("transform", { prop: "resize", value: { width: point.x, height: point.y, isAspectRatio: false } });
          } else if (aspectIcon || blrAspRatElem && !blrAspRatElem.classList.contains("e-hidden")) {
            this.notify("transform", { prop: "resize", value: { width: point.x, height: null, isAspectRatio: true } });
          }
          this.isResize = false;
          this.aspectWidth = point.x;
          this.aspectHeight = point.y;
          this.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
            type: "main",
            isApplyBtn: false,
            isCropping: false,
            isZooming: null,
            cType: null
          } });
          this.notify("transform", {
            prop: "zoomAction",
            onPropertyChange: false,
            value: { zoomFactor: -this.transform.zoomFactor, zoomPoint: null, isResize: true }
          });
          this.notify("transform", {
            prop: "zoomAction",
            onPropertyChange: false,
            value: { zoomFactor: obj2["prevObj"]["defaultZoom"], zoomPoint: null, isResize: true }
          });
          if (obj2["prevObj"].zoomFactor) {
            this.setProperties({ zoomSettings: { zoomFactor: obj2["prevObj"].zoomFactor } }, true);
          }
          this.notify("transform", {
            prop: "setPreviousZoomValue",
            onPropertyChange: false,
            value: { previousZoomValue: this.zoomSettings.zoomFactor }
          });
          this.notify("undo-redo", { prop: "updateUndoRedoColl", onPropertyChange: false, value: {
            operation: "resize",
            previousObj: obj2["prevObj"],
            previousObjColl: obj2["prevObj"]["objColl"],
            previousPointColl: obj2["prevObj"]["pointColl"],
            previousSelPointColl: obj2["prevObj"]["selPointColl"],
            previousCropObj: obj1["prevCropObj"],
            previousText: null,
            currentText: null,
            previousFilter: null,
            isCircleCrop: null
          } });
          this.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
          var obj_3 = this.cancelCropSelection;
          if (obj_3 && (isNullOrUndefined(nonAspectIcon) || !nonAspectIcon)) {
            obj_3.previousObj.aspectWidth = obj_3.currentObj.aspectWidth = this.aspectWidth;
            obj_3.previousObj.aspectHeight = obj_3.currentObj.aspectHeight = this.aspectHeight;
            obj_3.previousCropObj = extend({}, this.cropObj, {}, true);
            obj_3.currentCropObj = extend({}, this.cropObj, {}, true);
            this.notify("draw", { prop: "updateCropSelObj" });
          }
          this.cancelCropSelection = null;
        } else if (point && (point.x === 0 || point.y === 0)) {
          this.notify("draw", { prop: "performCancel", value: { isContextualToolbar: null } });
        } else {
          this.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
            type: "main",
            isApplyBtn: false,
            isCropping: false,
            isZooming: null,
            cType: null
          } });
        }
        this.isAspectRatio = false;
      } else if (isResize) {
        var isAspectRatio = false;
        if (this.aspectWidth && this.aspectHeight) {
          this.notify("transform", { prop: "resize", value: { width: this.aspectWidth, height: this.aspectHeight, isAspectRatio: false } });
        } else if (this.aspectWidth) {
          this.notify("transform", { prop: "resize", value: { width: this.aspectWidth, height: null, isAspectRatio: true } });
          this.aspectHeight = this.aspectWidth / (this.img.destWidth / this.img.destHeight);
          isAspectRatio = true;
        }
        this.isResize = false;
        this.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
          type: "main",
          isApplyBtn: false,
          isCropping: false,
          isZooming: null,
          cType: null
        } });
        this.notify("transform", {
          prop: "zoomAction",
          onPropertyChange: false,
          value: { zoomFactor: -this.transform.zoomFactor, zoomPoint: null, isResize: true }
        });
        this.notify("transform", {
          prop: "zoomAction",
          onPropertyChange: false,
          value: { zoomFactor: this.prevObj["defaultZoom"], zoomPoint: null, isResize: true }
        });
        if (this.prevObj.zoomFactor) {
          this.setProperties({ zoomSettings: { zoomFactor: this.prevObj.zoomFactor } }, true);
        }
        this.notify("transform", {
          prop: "setPreviousZoomValue",
          onPropertyChange: false,
          value: { previousZoomValue: this.zoomSettings.zoomFactor }
        });
        this.notify("undo-redo", { prop: "updateUndoRedoColl", onPropertyChange: false, value: {
          operation: "resize",
          previousObj: this.prevObj,
          previousObjColl: this.prevObj["objColl"],
          previousPointColl: this.prevObj["pointColl"],
          previousSelPointColl: this.prevObj["selPointColl"],
          previousCropObj: this.prevCropObj,
          previousText: null,
          currentText: null,
          previousFilter: null,
          isCircleCrop: null
        } });
        this.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
        var obj_4 = this.cancelCropSelection;
        if (obj_4 && isAspectRatio) {
          obj_4.previousObj.aspectWidth = obj_4.currentObj.aspectWidth = this.aspectWidth;
          obj_4.previousObj.aspectHeight = obj_4.currentObj.aspectHeight = this.aspectHeight;
          obj_4.previousCropObj = extend({}, this.cropObj, {}, true);
          obj_4.currentCropObj = extend({}, this.cropObj, {}, true);
          this.notify("draw", { prop: "updateCropSelObj" });
        }
        this.cancelCropSelection = null;
        this.isAspectRatio = false;
      }
      var selElem = this.element.querySelector(".e-contextual-toolbar-wrapper .e-toolbar-item.e-selected");
      var obj = { bool: false };
      this.notify("selection", { prop: "getFreehandDrawEditing", onPropertyChange: false, value: { obj } });
      var frameObject = { bool: null };
      this.notify("toolbar", { prop: "getFrameToolbar", onPropertyChange: false, value: { obj: frameObject } });
      var sliderWrap = (undefined).querySelector("#" + this.element.id + "_sliderWrapper");
      if (selElem) {
        this.currentFilter = selElem.children[0].children[0].id.replace("Canvas", "");
      }
      if (isCropSelection) {
        if (this.transform.straighten !== 0 && (this.panPoint.totalPannedPoint.x !== 0 || this.panPoint.totalPannedPoint.y !== 0 || this.panPoint.totalPannedClientPoint.x !== 0 || this.panPoint.totalPannedClientPoint.y !== 0)) {
          var temp = this.prevStraightenedDegree;
          this.prevStraightenedDegree = this.transform.straighten;
          this.setStraighten(this.transform.straighten - 3);
          this.setStraighten(this.transform.straighten + 3);
          this.prevStraightenedDegree = temp;
        }
        this.isCroppedEvent = this.crop();
      } else if (this.togglePen) {
        this.freeHandDraw(false);
        if (!this.isMaskImage) {
          var widthObj = { penStrokeWidth: null };
          this.notify("freehand-draw", { prop: "getPenStrokeWidth", onPropertyChange: false, value: { obj: widthObj } });
          this.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
          this.notify("freehand-draw", { prop: "setPenStrokeWidth", onPropertyChange: false, value: { value: widthObj["penStrokeWidth"] } });
        }
        this.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
        this.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.upperContext } });
      } else if (this.textArea.style.display === "block" || this.textArea.style.display === "inline-block") {
        this.notify("shape", {
          prop: "redrawActObj",
          onPropertyChange: false,
          value: { x: null, y: null, isMouseDown: null }
        });
        this.lowerContext.clearRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
        this.notify("draw", { prop: "redrawImgWithObj", onPropertyChange: false });
        if (isNullOrUndefined(isMouseDown)) {
          this.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
        }
        this.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
        this.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.upperContext } });
      } else if ((sliderWrap || this.currObjType.isFiltered) && !this.drawingShape && this.activeObj.shape !== "redact") {
        this.initialAdjustmentValue = this.canvasFilter = this.lowerContext.filter;
        this.currObjType.isFiltered = false;
        var obj_5 = { value: null };
        this.notify("draw", { prop: "getTempAdjustmentValue", value: { obj: obj_5 } });
        if (!sliderWrap || sliderWrap.parentElement.previousElementSibling.textContent !== "Opacity") {
          this.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
        }
        if (this.activeObj.activePoint.width !== 0 && this.activeObj.activePoint.height !== 0 || this.activeObj.shape === "path" && this.activeObj.pointColl.length > 0) {
          this.notify("shape", { prop: "applyActObj", onPropertyChange: false, value: { isMouseDown: null } });
        }
      } else if (obj["bool"]) {
        this.notify("freehand-draw", { prop: "applyFhd", onPropertyChange: false });
        this.notify("selection", { prop: "setFreehandDrawCustomized", value: { isFreehandDrawCustomized: false } });
        this.notify("toolbar", { prop: "destroy-qa-toolbar" });
        this.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
        this.notify("freehand-draw", { prop: "resetFreehandDrawSelectedId", onPropertyChange: false });
      } else if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0 || this.activeObj.shape === "path" && this.activeObj.pointColl.length > 0) {
        if (this.activeObj.shape === "image") {
          this.notify("draw", { prop: "setImageApply", onPropertyChange: false, value: { bool: true } });
        }
        this.notify("shape", { prop: "applyActObj", onPropertyChange: false, value: { isMouseDown: null } });
      } else {
        if (JSON.stringify(this.frameObj) !== JSON.stringify(this.tempFrameObj)) {
          var object = { currObj: {} };
          this.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
          this.notify("undo-redo", { prop: "updateUndoRedoColl", onPropertyChange: false, value: {
            operation: "frame",
            previousObj: object["currObj"],
            previousObjColl: object["currObj"]["objColl"],
            previousPointColl: object["currObj"]["pointColl"],
            previousSelPointColl: object["currObj"]["selPointColl"],
            previousCropObj: extend({}, this.cropObj, {}, true),
            previousText: null,
            currentText: null,
            previousFilter: null,
            isCircleCrop: null
          } });
          this.notify("draw", { prop: "render-image", value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
          var currFrameSettings = {
            type: this.toPascalCase(this.frameObj.type),
            color: this.frameObj.color,
            gradientColor: this.frameObj.gradientColor,
            size: this.frameObj.size,
            inset: this.frameObj.inset,
            offset: this.frameObj.offset,
            borderRadius: this.frameObj.radius,
            frameLineStyle: this.toPascalCase(this.frameObj.border),
            lineCount: this.frameObj.amount
          };
          var prevFrameSettings = {
            type: this.toPascalCase(this.tempFrameObj.type),
            color: this.tempFrameObj.color,
            gradientColor: this.tempFrameObj.gradientColor,
            size: this.tempFrameObj.size,
            inset: this.tempFrameObj.inset,
            offset: this.tempFrameObj.offset,
            borderRadius: this.tempFrameObj.radius,
            frameLineStyle: this.toPascalCase(this.tempFrameObj.border),
            lineCount: this.tempFrameObj.amount
          };
          var frameChange = {
            cancel: false,
            previousFrameSetting: prevFrameSettings,
            currentFrameSetting: currFrameSettings
          };
          this.editCompleteArgs = frameChange;
          this.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
          this.tempFrameObj = extend({}, this.frameObj, {}, true);
        }
        this.notify("draw", { prop: "resetFrameZoom", onPropertyChange: false, value: { isOk: true } });
      }
      if (!obj["isCropToolbar"]) {
        this.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
          type: "main",
          isApplyBtn: false,
          isCropping: null,
          isZooming: null,
          cType: null
        } });
        this.currObjType.isRedact = false;
      }
      this.notify("draw", { prop: "setNewPath", value: { bool: false } });
      this.transform.zoomFactor = this.transform.defaultZoomFactor;
      this.notify("selection", { prop: "setCurrentDrawingShape", onPropertyChange: false, value: { value: "" } });
      this.isResizeOkBtn = false;
      this.notify("draw", { prop: "redrawDownScale" });
      this.isChangesSaved = this.isFinetuneBtnClick = false;
      if (isFinalApply) {
        this.drawingShape = null;
        this.notify("draw", { prop: "resetTempObjColl" });
        this.notify("draw", { prop: "resetTempPointColl" });
      }
    };
    ImageEditor2.prototype.triggerEditCompleteEvent = function(args) {
      if (args.action === "shape-insert" && args.actionEventArgs && args.actionEventArgs.currentShapeSettings && args.actionEventArgs.currentShapeSettings.type.toString() === "Redact") {
        args.action = "redact";
      }
      this.trigger("editComplete", args);
      this.editCompleteArgs = null;
    };
    ImageEditor2.prototype.getObjFromId = function(id) {
      var obj;
      if (this.activeObj.currIndex && this.activeObj.currIndex === id) {
        obj = extend({}, this.activeObj, {}, true);
      } else {
        for (var i = 0; i < this.shapeColl.length; i++) {
          var shapeId = this.shapeColl[i].id ? this.shapeColl[i].id : this.shapeColl[i].currIndex;
          if (shapeId === id) {
            obj = extend({}, this.shapeColl[i], {}, true);
            break;
          }
        }
      }
      return obj;
    };
    ImageEditor2.prototype.setTempFilterProperties = function() {
      this.upperCanvas.style.display = "block";
      this.cropSelectedState();
      var obj = { adjustmentLevel: null };
      this.notify("filter", {
        prop: "getAdjustmentLevel",
        onPropertyChange: false,
        value: { obj }
      });
      this.lowerContext.filter = this.initialAdjustmentValue;
      this.notify("draw", { prop: "setTempAdjustmentValue", value: { tempAdjustmentValue: this.lowerContext.filter } });
      this.notify("filter", {
        prop: "setTempAdjustmentLevel",
        onPropertyChange: false,
        value: { tempAdjustmentLevel: extend({}, obj["adjustmentLevel"], {}, true) }
      });
      this.notify("draw", { prop: "setTempFilter", value: { tempFilter: this.currentFilter } });
      var undoRedoObj = { undoRedoStep: null };
      this.notify("undo-redo", { prop: "getUndoRedoStep", value: { obj: undoRedoObj } });
      this.notify("draw", { prop: "setTempUndoRedoStep", value: { tempUndoRedoStep: undoRedoObj["undoRedoStep"] } });
    };
    ImageEditor2.prototype.cropSelectedState = function() {
      if (this.activeObj.shape && this.activeObj.shape.split("-")[0] === "crop") {
        this.okBtn();
      }
    };
    ImageEditor2.prototype.getCurrentCanvasData = function() {
      var tempFrame = extend({}, this.frameObj, {}, true);
      this.frameObj = { type: "none", color: "#fff", size: 20, inset: 20, offset: 20, radius: 0, amount: 1, border: "solid", gradientColor: "" };
      var tempFilter = this.lowerContext.filter;
      this.lowerContext.filter = this.canvasFilter = "none";
      var objColl = extend([], this.objColl, null, true);
      var pointColl = extend([], this.pointColl, null, true);
      this.objColl = [];
      this.pointColl = [];
      this.freehandCounter = 0;
      this.notify("draw", { prop: "render-image", value: { isMouseWheel: false } });
      var ctWrapper = this.element.querySelector(".e-contextual-toolbar-wrapper");
      if (ctWrapper) {
        ctWrapper.classList.add("e-hide");
      }
      var data = this.getImageData();
      if (ctWrapper) {
        ctWrapper.classList.remove("e-hide");
      }
      if (!Browser.isDevice) {
        this.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
          type: "main",
          isApplyBtn: true,
          isCropping: false
        } });
      }
      this.element.querySelector("#" + this.element.id + "_contextualToolbarArea").classList.remove("e-hide");
      this.objColl = objColl;
      this.pointColl = pointColl;
      this.freehandCounter = pointColl.length;
      this.notify("shape", {
        prop: "drawAnnotations",
        onPropertyChange: false,
        value: { ctx: this.lowerContext, shape: "iterate", pen: "iterate", isPreventApply: null }
      });
      this.lowerContext.filter = this.canvasFilter = tempFilter;
      this.frameObj = tempFrame;
      return data;
    };
    ImageEditor2.prototype.setCurrAdjustmentValue = function(type, value) {
      var finetuneValueChanging = { finetune: this.getFinetuneOption(type), value, cancel: false };
      this.trigger("finetuneValueChanging", finetuneValueChanging);
      this.editCompleteArgs = finetuneValueChanging;
      if (finetuneValueChanging.cancel) {
        return;
      }
      this.notify("filter", { prop: "setCurrAdjValue", value: { type: type.toLowerCase(), value } });
    };
    ImageEditor2.prototype.getSquarePointForPath = function(obj) {
      var point = { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 };
      if (obj.pointColl.length > 0) {
        point = { startX: obj.pointColl[0].x, startY: obj.pointColl[0].y, endX: obj.pointColl[0].x, endY: obj.pointColl[0].y };
        for (var i = 1; i < obj.pointColl.length; i++) {
          if (obj.pointColl[i].x < point.startX) {
            point.startX = obj.pointColl[i].x;
          }
          if (obj.pointColl[i].y < point.startY) {
            point.startY = obj.pointColl[i].y;
          }
          if (obj.pointColl[i].x > point.endX) {
            point.endX = obj.pointColl[i].x;
          }
          if (obj.pointColl[i].y > point.endY) {
            point.endY = obj.pointColl[i].y;
          }
        }
        point.width = point.endX - point.startX;
        point.height = point.endY - point.startY;
      }
      return point;
    };
    ImageEditor2.prototype.getSelectionType = function(type) {
      type = type === "crop-custom" ? "CropCustom" : type;
      var typeToSelectionType = {
        "CropCustom": "Custom",
        "CropSquare": "Square",
        "CropCircle": "Circle",
        "Crop3:2": "3:2",
        "Crop4:3": "4:3",
        "Crop5:4": "5:4",
        "Crop7:5": "7:5",
        "Crop16:9": "16:9",
        "Crop2:3": "2:3",
        "Crop3:4": "3:4",
        "Crop4:5": "4:5",
        "Crop5:7": "5:7",
        "Crop9:16": "9:16"
      };
      return typeToSelectionType["" + type] ? typeToSelectionType["" + type] : type.split("Crop")[1];
    };
    ImageEditor2.prototype.clearContext = function(ctx) {
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      ctx.clearRect(0, 0, ctx.canvas.height, ctx.canvas.width);
    };
    ImageEditor2.prototype.updateArrow = function(type, id) {
      var isObjPushed = false;
      var collLength = this.objColl.length;
      this.notify("shape", { prop: "pushActItemIntoObj" });
      if (collLength !== this.objColl.length) {
        isObjPushed = true;
      }
      var prevCropObj = extend({}, this.cropObj, {}, true);
      var object = { currObj: {} };
      var objt = { shapeSettingsObj: {} };
      this.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj: objt } });
      var shapeSettings = objt["shapeSettingsObj"];
      this.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
      var prevObj = object["currObj"];
      prevObj.objColl = extend([], this.objColl, [], true);
      prevObj.pointColl = extend([], this.pointColl, [], true);
      prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
      if (isObjPushed) {
        this.objColl.pop();
      }
      if (type === "startArrow") {
        this.activeObj.start = this.getTextFromId(id);
      } else if (type === "endArrow") {
        this.activeObj.end = this.getTextFromId(id);
      }
      this.notify("shape", { prop: "setStrokeSettings", value: {
        strokeSettings: null,
        strokeColor: null,
        fillColor: null,
        strokeWidth: this.activeObj.strokeSettings.strokeWidth
      } });
      this.objColl.push(this.activeObj);
      if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
        this.notify("undo-redo", {
          prop: "updateUndoRedoColl",
          onPropertyChange: false,
          value: {
            operation: "shapeTransform",
            previousObj: prevObj,
            previousObjColl: prevObj.objColl,
            previousPointColl: prevObj.pointColl,
            previousCropObj: prevCropObj,
            previousText: null,
            currentText: null,
            previousFilter: null,
            isCircleCrop: null
          }
        });
      }
      this.notify("selection", { prop: "redrawShape", value: { obj: this.objColl[this.objColl.length - 1] } });
      if (Browser.isDevice) {
        if ((undefined).getElementById(this.element.id + "_bottomToolbar")) {
          var toolbar_1 = getComponent(this.element.id + "_bottomToolbar", "toolbar");
          toolbar_1.refreshOverflow();
        }
      } else {
        if ((undefined).getElementById(this.element.id + "_toolbar")) {
          var toolbar_2 = getComponent(this.element.id + "_toolbar", "toolbar");
          toolbar_2.refreshOverflow();
        }
      }
      var shapeChangedArgs = { action: type, currentShapeSettings: extend({}, shapeSettings, {}, true) };
      this.trigger("shapeChange", shapeChangedArgs);
      this.editCompleteArgs = shapeChangedArgs;
    };
    ImageEditor2.prototype.updateFontFamily = function(id) {
      this.notify("selection", { prop: "setInitialTextEdit", value: { bool: false } });
      var isObjPushed = false;
      var collLength = this.objColl.length;
      this.notify("shape", { prop: "pushActItemIntoObj" });
      if (collLength !== this.objColl.length) {
        isObjPushed = true;
      }
      var objColl = extend([], this.objColl, [], true);
      var prevCropObj = extend({}, this.cropObj, {}, true);
      var objt = { shapeSettingsObj: {} };
      this.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj: objt } });
      var shapeSettings = objt["shapeSettingsObj"];
      var object = { currObj: {} };
      this.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
      var prevObj = object["currObj"];
      prevObj.objColl = extend([], this.objColl, [], true);
      prevObj.pointColl = extend([], this.pointColl, [], true);
      prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      this.notify("freehand-draw", {
        prop: "getSelPointColl",
        onPropertyChange: false,
        value: { obj: selPointCollObj }
      });
      prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
      if (isObjPushed) {
        this.objColl.pop();
      }
      if (this.textArea.style.display === "block" || this.textArea.style.display === "inline-block") {
        this.notify("shape", {
          prop: "updateFontRatio",
          onPropertyChange: false,
          value: { obj: this.activeObj, isTextArea: true }
        });
        var temp = this.activeObj.textSettings.fontFamily;
        this.activeObj.textSettings.fontFamily = this.toPascalCase(id);
        if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
          this.notify("shape", { prop: "redraw-text" });
        }
        this.objColl.push(this.activeObj);
        if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
          this.notify("undo-redo", {
            prop: "updateUndoRedoColl",
            onPropertyChange: false,
            value: {
              operation: "textAreaCustomization",
              previousObj: prevObj,
              previousObjColl: prevObj.objColl,
              previousPointColl: prevObj.pointColl,
              previousSelPointColl: prevObj.selPointColl,
              previousCropObj: prevCropObj,
              previousText: null,
              currentText: null,
              previousFilter: null,
              isCircleCrop: null
            }
          });
        }
        this.objColl.pop();
        this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
        var width = this.activeObj.activePoint.width + this.activeObj.textSettings.fontSize * 0.25;
        this.textArea.style.width = width + "px";
        this.textArea.style.fontFamily = this.toPascalCase(id);
        this.activeObj.textSettings.fontFamily = temp;
        this.notify("shape", {
          prop: "updateFontStyles",
          onPropertyChange: false,
          value: { isTextBox: null }
        });
      } else {
        this.notify("shape", {
          prop: "updateFontRatio",
          onPropertyChange: false,
          value: { obj: this.activeObj, isTextArea: null }
        });
        var fontFamily = this.activeObj.textSettings.fontFamily = this.toPascalCase(id);
        this.notify("shape", {
          prop: "setTextSettings",
          onPropertyChange: false,
          value: { textSettings: null, fontFamily, fontSize: null }
        });
        if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
          this.notify("shape", { prop: "redraw-text" });
        }
        this.objColl.push(this.activeObj);
        if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
          this.notify("undo-redo", {
            prop: "updateUndoRedoColl",
            onPropertyChange: false,
            value: {
              operation: "shapeTransform",
              previousObj: prevObj,
              previousObjColl: objColl,
              previousPointColl: extend([], this.pointColl, [], true),
              previousSelPointColl: prevObj.selPointColl,
              previousCropObj: prevCropObj,
              previousText: null,
              currentText: null,
              previousFilter: null,
              isCircleCrop: null
            }
          });
        }
        this.notify("selection", { prop: "redrawShape", value: { obj: this.objColl[this.objColl.length - 1] } });
      }
      var shapeChangedArgs = { action: "font-family", currentShapeSettings: extend({}, shapeSettings, {}, true) };
      shapeChangedArgs.currentShapeSettings.fontFamily = this.textArea.style.fontFamily;
      this.trigger("shapeChange", shapeChangedArgs);
      this.editCompleteArgs = shapeChangedArgs;
    };
    ImageEditor2.prototype.updateFontSize = function(text) {
      var itemText = text;
      this.notify("selection", { prop: "setInitialTextEdit", value: { bool: false } });
      var isObjPushed = false;
      var collLength = this.objColl.length;
      this.notify("shape", { prop: "pushActItemIntoObj" });
      if (collLength !== this.objColl.length) {
        isObjPushed = true;
      }
      var prevCropObj = extend({}, this.cropObj, {}, true);
      var objt = { shapeSettingsObj: {} };
      this.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj: objt } });
      var shapeSettings = objt["shapeSettingsObj"];
      var object = { currObj: {} };
      this.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
      var prevObj = object["currObj"];
      prevObj.objColl = extend([], this.objColl, [], true);
      prevObj.pointColl = extend([], this.pointColl, [], true);
      prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      this.notify("freehand-draw", {
        prop: "getSelPointColl",
        onPropertyChange: false,
        value: { obj: selPointCollObj }
      });
      prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
      if (isObjPushed) {
        this.objColl.pop();
      }
      if (this.textArea.style.display === "block" || this.textArea.style.display === "inline-block") {
        this.notify("shape", {
          prop: "updateFontRatio",
          onPropertyChange: false,
          value: { obj: this.activeObj, isTextArea: true }
        });
        var temp = this.activeObj.textSettings.fontSize;
        this.activeObj.textSettings.fontSize = parseInt(this.fontSizeColl[parseInt(itemText, 10) - 1].text, 10);
        this.objColl.push(this.activeObj);
        if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
          this.notify("undo-redo", {
            prop: "updateUndoRedoColl",
            onPropertyChange: false,
            value: {
              operation: "textAreaCustomization",
              previousObj: prevObj,
              previousObjColl: prevObj.objColl,
              previousPointColl: prevObj.pointColl,
              previousSelPointColl: prevObj.selPointColl,
              previousCropObj: prevCropObj,
              previousText: null,
              currentText: null,
              previousFilter: null,
              isCircleCrop: null
            }
          });
        }
        this.objColl.pop();
        var textStyle = "";
        if (this.textArea.style.fontWeight === "bold") {
          textStyle = "bold ";
        }
        if (this.textArea.style.fontStyle === "italic") {
          textStyle = "italic ";
        }
        if (this.textArea.style.fontWeight === "bold" && this.textArea.style.fontStyle === "italic") {
          textStyle = "italic bold ";
        }
        this.upperContext.font = textStyle + this.activeObj.textSettings.fontSize + "px " + this.textArea.style.fontFamily;
        var rows = this.textArea.value.split("\n");
        var obj = { maxText: "" };
        this.notify("shape", {
          prop: "getMaxText",
          onPropertyChange: false,
          value: { isTextBox: true, text: null, obj }
        });
        var text_1 = obj["maxText"];
        var width = this.upperContext.measureText(text_1).width + this.activeObj.textSettings.fontSize * 0.5;
        this.textArea.style.width = width + "px";
        this.textArea.style.height = rows.length * (this.activeObj.textSettings.fontSize + this.activeObj.textSettings.fontSize * 0.25) + "px";
        this.activeObj.textSettings.fontSize = temp;
        this.upperContext.font = this.activeObj.textSettings.fontSize + "px " + this.activeObj.textSettings.fontFamily;
        this.textArea.style.fontSize = parseInt(this.fontSizeColl[parseInt(itemText, 10) - 1].text, 10) + "px";
        if (this.textArea.style.fontFamily === "georgia") {
          this.textArea.style.width = parseFloat(this.textArea.style.width) + parseFloat(this.textArea.style.fontSize) + "px";
        }
      } else {
        this.notify("shape", {
          prop: "updateFontRatio",
          onPropertyChange: false,
          value: { obj: this.activeObj, isTextArea: null }
        });
        var fontSize = this.activeObj.textSettings.fontSize = parseInt(this.fontSizeColl[parseInt(itemText, 10) - 1].text, 10);
        this.notify("shape", {
          prop: "setTextSettings",
          onPropertyChange: false,
          value: { textSettings: null, fontFamily: null, fontSize }
        });
        this.upperContext.font = this.activeObj.textSettings.fontSize + "px " + this.activeObj.textSettings.fontFamily;
        var rows = this.activeObj.keyHistory.split("\n");
        var obj = { maxText: "" };
        this.notify("shape", {
          prop: "getMaxText",
          onPropertyChange: false,
          value: { isTextBox: null, text: null, obj }
        });
        var text_2 = obj["maxText"];
        var width = this.upperContext.measureText(text_2).width + this.activeObj.textSettings.fontSize * 0.5;
        var height = rows.length * (this.activeObj.textSettings.fontSize + this.activeObj.textSettings.fontSize * 0.25);
        if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
          this.notify("selection", {
            prop: "setTextSelection",
            onPropertyChange: false,
            value: { width, height }
          });
          this.notify("draw", { prop: "updateActiveObject", onPropertyChange: false, value: {
            actPoint: this.activeObj.activePoint,
            obj: this.activeObj,
            isMouseMove: null,
            x: null,
            y: null
          } });
          this.notify("shape", { prop: "redraw-text" });
        }
        this.objColl.push(this.activeObj);
        if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
          this.notify("undo-redo", {
            prop: "updateUndoRedoColl",
            onPropertyChange: false,
            value: {
              operation: "shapeTransform",
              previousObj: prevObj,
              previousObjColl: prevObj.objColl,
              previousPointColl: prevObj.pointColl,
              previousSelPointColl: prevObj.selPointColl,
              previousCropObj: prevCropObj,
              previousText: null,
              currentText: null,
              previousFilter: null,
              isCircleCrop: null
            }
          });
        }
        this.notify("selection", { prop: "redrawShape", value: { obj: this.objColl[this.objColl.length - 1] } });
      }
      var shapeChangedArgs = { action: "font-size", currentShapeSettings: extend({}, shapeSettings, {}, true) };
      shapeChangedArgs.currentShapeSettings.fontSize = this.activeObj.textSettings.fontSize;
      this.trigger("shapeChange", shapeChangedArgs);
      this.editCompleteArgs = shapeChangedArgs;
    };
    ImageEditor2.prototype.updateFontColor = function(value, color) {
      this.notify("selection", { prop: "setInitialTextEdit", value: { bool: false } });
      var isObjPushed = false;
      var collLength = this.objColl.length;
      this.notify("shape", { prop: "pushActItemIntoObj" });
      if (collLength !== this.objColl.length) {
        isObjPushed = true;
      }
      var prevCropObj = extend({}, this.cropObj, {}, true);
      var objt = { shapeSettingsObj: {} };
      this.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj: objt } });
      var shapeSettings = objt["shapeSettingsObj"];
      var object = { currObj: {} };
      this.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
      var prevObj = object["currObj"];
      prevObj.objColl = extend([], this.objColl, [], true);
      prevObj.pointColl = extend([], this.pointColl, [], true);
      prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      this.notify("freehand-draw", {
        prop: "getSelPointColl",
        onPropertyChange: false,
        value: { obj: selPointCollObj }
      });
      prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
      if (isObjPushed) {
        this.objColl.pop();
      }
      if (this.textArea.style.display === "none") {
        if (color === "Text") {
          this.activeObj.strokeSettings.strokeColor = value;
          this.notify("shape", { prop: "setStrokeSettings", value: {
            strokeSettings: null,
            strokeColor: this.activeObj.strokeSettings.strokeColor,
            fillColor: null,
            strokeWidth: null
          } });
        } else {
          this.activeObj.strokeSettings.fillColor = value;
          this.notify("shape", { prop: "setStrokeSettings", value: {
            strokeSettings: null,
            strokeColor: null,
            fillColor: this.activeObj.strokeSettings.fillColor,
            strokeWidth: null
          } });
        }
        if (!this.togglePen) {
          if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
            this.objColl.push(this.activeObj);
            this.notify("undo-redo", {
              prop: "updateUndoRedoColl",
              onPropertyChange: false,
              value: {
                operation: "shapeTransform",
                previousObj: prevObj,
                previousObjColl: prevObj.objColl,
                previousPointColl: prevObj.pointColl,
                previousSelPointColl: prevObj.selPointColl,
                previousCropObj: prevCropObj,
                previousText: null,
                currentText: null,
                previousFilter: null,
                isCircleCrop: null
              }
            });
            this.notify("selection", { prop: "redrawShape", value: { obj: this.objColl[this.objColl.length - 1] } });
          }
        }
      } else if (this.textArea.style.display === "block" || this.textArea.style.display === "inline-block") {
        this.textArea.style[color === "Text" ? "color" : "backgroundColor"] = value;
        var temp = color === "Text" ? this.activeObj.strokeSettings.strokeColor : this.activeObj.strokeSettings.fillColor;
        this.activeObj.strokeSettings[color === "Text" ? "strokeColor" : "fillColor"] = value;
        if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
          this.objColl.push(this.activeObj);
          this.notify("undo-redo", {
            prop: "updateUndoRedoColl",
            onPropertyChange: false,
            value: {
              operation: "textAreaCustomization",
              previousObj: prevObj,
              previousObjColl: prevObj.objColl,
              previousPointColl: prevObj.pointColl,
              previousSelPointColl: prevObj.selPointColl,
              previousCropObj: prevCropObj,
              previousText: null,
              currentText: null,
              previousFilter: null,
              isCircleCrop: null
            }
          });
          this.objColl.pop();
        }
        this.activeObj.strokeSettings[color === "Text" ? "strokeColor" : "fillColor"] = temp;
      } else if (!this.togglePen) {
        if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
          this.objColl.push(this.activeObj);
          this.notify("undo-redo", {
            prop: "updateUndoRedoColl",
            onPropertyChange: false,
            value: {
              operation: "shapeTransform",
              previousObj: prevObj,
              previousObjColl: prevObj.objColl,
              previousPointColl: prevObj.pointColl,
              previousSelPointColl: prevObj.selPointColl,
              previousCropObj: prevCropObj,
              previousText: null,
              currentText: null,
              previousFilter: null,
              isCircleCrop: null
            }
          });
          this.notify("selection", { prop: "redrawShape", value: { obj: this.objColl[this.objColl.length - 1] } });
        }
      }
      var shapeChangedArgs = { action: "font-color", currentShapeSettings: extend({}, shapeSettings, {}, true) };
      shapeChangedArgs.currentShapeSettings.fillColor = value;
      this.trigger("shapeChange", shapeChangedArgs);
      this.editCompleteArgs = shapeChangedArgs;
    };
    ImageEditor2.prototype.updateStrokeTextColor = function(value) {
      this.notify("selection", { prop: "setInitialTextEdit", value: { bool: false } });
      var isObjPushed = false;
      var collLength = this.objColl.length;
      this.notify("shape", { prop: "pushActItemIntoObj" });
      if (collLength !== this.objColl.length) {
        isObjPushed = true;
      }
      var prevCropObj = extend({}, this.cropObj, {}, true);
      var objt = { shapeSettingsObj: {} };
      this.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj: objt } });
      var shapeSettings = objt["shapeSettingsObj"];
      var object = { currObj: {} };
      this.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
      var prevObj = object["currObj"];
      prevObj.objColl = extend([], this.objColl, [], true);
      prevObj.pointColl = extend([], this.pointColl, [], true);
      prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      this.notify("freehand-draw", {
        prop: "getSelPointColl",
        onPropertyChange: false,
        value: { obj: selPointCollObj }
      });
      prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
      if (isObjPushed) {
        this.objColl.pop();
      }
      if (this.textArea.style.display === "none") {
        this.activeObj.strokeSettings.outlineColor = value;
        this.notify("shape", { prop: "setStrokeSettings", value: {
          strokeSettings: null,
          strokeColor: null,
          fillColor: null,
          strokeWidth: null,
          outlineColor: this.activeObj.strokeSettings.outlineColor
        } });
        if (!this.togglePen) {
          if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
            this.objColl.push(this.activeObj);
            this.notify("undo-redo", {
              prop: "updateUndoRedoColl",
              onPropertyChange: false,
              value: {
                operation: "shapeTransform",
                previousObj: prevObj,
                previousObjColl: prevObj.objColl,
                previousPointColl: prevObj.pointColl,
                previousSelPointColl: prevObj.selPointColl,
                previousCropObj: prevCropObj,
                previousText: null,
                currentText: null,
                previousFilter: null,
                isCircleCrop: null
              }
            });
            this.notify("selection", { prop: "redrawShape", value: { obj: this.objColl[this.objColl.length - 1] } });
          }
        }
      } else if (this.textArea.style.display === "block" || this.textArea.style.display === "inline-block") {
        this.textArea.style.textShadow = "-1px -1px 0 " + value + ", 1px -1px 0 " + value + ", -1px 1px 0 " + value + ", 1px 1px 0 " + value;
        var temp = this.activeObj.strokeSettings.outlineColor;
        this.activeObj.strokeSettings.outlineColor = value;
        if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
          this.objColl.push(this.activeObj);
          this.notify("undo-redo", {
            prop: "updateUndoRedoColl",
            onPropertyChange: false,
            value: {
              operation: "textAreaCustomization",
              previousObj: prevObj,
              previousObjColl: prevObj.objColl,
              previousPointColl: prevObj.pointColl,
              previousSelPointColl: prevObj.selPointColl,
              previousCropObj: prevCropObj,
              previousText: null,
              currentText: null,
              previousFilter: null,
              isCircleCrop: null
            }
          });
          this.objColl.pop();
        }
        this.activeObj.strokeSettings.outlineColor = temp;
      } else if (!this.togglePen) {
        if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
          this.objColl.push(this.activeObj);
          this.notify("undo-redo", {
            prop: "updateUndoRedoColl",
            onPropertyChange: false,
            value: {
              operation: "shapeTransform",
              previousObj: prevObj,
              previousObjColl: prevObj.objColl,
              previousPointColl: prevObj.pointColl,
              previousSelPointColl: prevObj.selPointColl,
              previousCropObj: prevCropObj,
              previousText: null,
              currentText: null,
              previousFilter: null,
              isCircleCrop: null
            }
          });
          this.notify("selection", { prop: "redrawShape", value: { obj: this.objColl[this.objColl.length - 1] } });
        }
      }
      var shapeChangedArgs = { action: "font-color", currentShapeSettings: extend({}, shapeSettings, {}, true) };
      shapeChangedArgs.currentShapeSettings.fillColor = value;
      this.trigger("shapeChange", shapeChangedArgs);
      this.editCompleteArgs = shapeChangedArgs;
    };
    ImageEditor2.prototype.updatePenStrokeWidth = function(id) {
      var temp = extend([], this.pointColl, [], true);
      this.updateFreehandDrawColorChange();
      var prevCropObj = extend({}, this.cropObj, {}, true);
      var objt = { shapeSettingsObj: {} };
      this.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj: objt } });
      var shapeSettings = objt["shapeSettingsObj"];
      var object = { currObj: {} };
      this.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
      var prevObj = object["currObj"];
      prevObj.objColl = extend([], this.objColl, [], true);
      prevObj.pointColl = extend([], this.pointColl, [], true);
      prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      this.notify("freehand-draw", {
        prop: "getSelPointColl",
        onPropertyChange: false,
        value: { obj: selPointCollObj }
      });
      prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
      this.pointColl = temp;
      this.notify("selection", { prop: "setFreehandDrawCustomized", value: { isFreehandDrawCustomized: true } });
      this.setPenStroke(id);
      var obj = { bool: false };
      this.notify("selection", { prop: "getFreehandDrawEditing", onPropertyChange: false, value: { obj } });
      if (obj["bool"]) {
        var obj_6 = { penStrokeWidth: null };
        this.notify("freehand-draw", { prop: "getPenStrokeWidth", onPropertyChange: false, value: { obj: obj_6 } });
        this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
        this.lowerContext.clearRect(0, 0, this.lowerCanvas.width, this.lowerCanvas.height);
        this.notify("freehand-draw", {
          prop: "hoverFhd",
          onPropertyChange: false,
          value: { strokeColor: null, strokeWidth: obj_6["penStrokeWidth"] }
        });
        var indexObj = { freehandSelectedIndex: null };
        this.notify("freehand-draw", { prop: "getFreehandSelectedIndex", onPropertyChange: false, value: { obj: indexObj } });
        this.pointColl[indexObj["freehandSelectedIndex"]].strokeWidth = obj_6["penStrokeWidth"];
        this.notify("draw", { prop: "render-image", value: { isMouseWheel: null } });
        this.notify("draw", { prop: "redrawDownScale" });
        this.notify("freehand-draw", {
          prop: "hoverFhd",
          onPropertyChange: false,
          value: { strokeColor: null, strokeWidth: obj_6["penStrokeWidth"] }
        });
        this.notify("undo-redo", {
          prop: "updateUndoRedoColl",
          onPropertyChange: false,
          value: {
            operation: "freehanddrawCustomized",
            previousObj: prevObj,
            previousObjColl: prevObj.objColl,
            previousPointColl: prevObj.pointColl,
            previousSelPointColl: prevObj.selPointColl,
            previousCropObj: prevCropObj,
            previousText: null,
            currentText: null,
            previousFilter: null,
            isCircleCrop: null
          }
        });
      }
      shapeSettings.type = ShapeType.FreehandDraw;
      var shapeChangedArgs = { action: "stroke-width", currentShapeSettings: extend({}, shapeSettings, {}, true) };
      shapeChangedArgs.currentShapeSettings.strokeWidth = this.activeObj.strokeSettings.strokeWidth;
      this.trigger("shapeChange", shapeChangedArgs);
      this.editCompleteArgs = shapeChangedArgs;
    };
    ImageEditor2.prototype.updatePenStrokeColor = function(value) {
      var temp = extend([], this.pointColl, [], true);
      this.updateFreehandDrawColorChange();
      var prevCropObj = extend({}, this.cropObj, {}, true);
      var objt = { shapeSettingsObj: {} };
      this.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj: objt } });
      var shapeSettings = objt["shapeSettingsObj"];
      var object = { currObj: {} };
      this.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
      var prevObj = object["currObj"];
      prevObj.objColl = extend([], this.objColl, [], true);
      prevObj.pointColl = extend([], this.pointColl, [], true);
      prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      this.notify("freehand-draw", {
        prop: "getSelPointColl",
        onPropertyChange: false,
        value: { obj: selPointCollObj }
      });
      prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
      this.pointColl = temp;
      this.notify("selection", { prop: "setFreehandDrawCustomized", value: { isFreehandDrawCustomized: true } });
      this.activeObj.strokeSettings.strokeColor = value;
      var indexObj = { freehandSelectedIndex: null };
      this.notify("freehand-draw", { prop: "getFreehandSelectedIndex", onPropertyChange: false, value: { obj: indexObj } });
      if (indexObj["freehandSelectedIndex"] !== null && indexObj["freehandSelectedIndex"] !== undefined) {
        this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
        this.notify("draw", { prop: "render-image", value: { isMouseWheel: null } });
        this.notify("draw", { prop: "redrawDownScale" });
        this.notify("freehand-draw", {
          prop: "hoverFhd",
          onPropertyChange: false,
          value: { strokeColor: null, strokeWidth: null }
        });
      }
      var obj = { bool: false };
      this.notify("selection", { prop: "getFreehandDrawEditing", onPropertyChange: false, value: { obj } });
      if (obj["bool"]) {
        var indexObj_1 = { freehandSelectedIndex: null };
        this.notify("freehand-draw", { prop: "getFreehandSelectedIndex", onPropertyChange: false, value: { obj: indexObj_1 } });
        this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
        this.pointColl[indexObj_1["freehandSelectedIndex"]].strokeColor = value;
        this.notify("freehand-draw", {
          prop: "hoverFhd",
          onPropertyChange: false,
          value: { strokeColor: value }
        });
        this.notify("undo-redo", {
          prop: "updateUndoRedoColl",
          onPropertyChange: false,
          value: {
            operation: "freehanddrawCustomized",
            previousObj: prevObj,
            previousObjColl: prevObj.objColl,
            previousPointColl: prevObj.pointColl,
            previousSelPointColl: prevObj.selPointColl,
            previousCropObj: prevCropObj,
            previousText: null,
            currentText: null,
            previousFilter: null,
            isCircleCrop: null
          }
        });
      } else if (!this.togglePen) {
        this.notify("selection", { prop: "redrawShape", value: { obj: this.activeObj } });
      }
      shapeSettings.type = ShapeType.FreehandDraw;
      var shapeChangedArgs = { action: "stroke-color", currentShapeSettings: extend({}, shapeSettings, {}, true) };
      shapeChangedArgs.currentShapeSettings.strokeColor = value;
      this.trigger("shapeChange", shapeChangedArgs);
      this.editCompleteArgs = shapeChangedArgs;
    };
    ImageEditor2.prototype.updateStrokeWidth = function(id, type, shapeType) {
      if (this.activeObj.shape && (this.activeObj.shape !== "path" || this.activeObj.shape === "path" && this.activeObj.pointColl.length > 0)) {
        var obj = { shapeSettingsObj: {} };
        this.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj } });
        var shapeSettings = obj["shapeSettingsObj"];
        var isObjPushed = false;
        var collLength = this.objColl.length;
        this.notify("shape", { prop: "pushActItemIntoObj" });
        if (collLength !== this.objColl.length) {
          isObjPushed = true;
        }
        var prevCropObj = extend({}, this.cropObj, {}, true);
        var object = { currObj: {} };
        this.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
        var prevObj = object["currObj"];
        prevObj.objColl = extend([], this.objColl, [], true);
        prevObj.pointColl = extend([], this.pointColl, [], true);
        prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        this.notify("freehand-draw", {
          prop: "getSelPointColl",
          onPropertyChange: false,
          value: { obj: selPointCollObj }
        });
        prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
        if (isObjPushed) {
          this.objColl.pop();
        }
        this.activeObj.strokeSettings[type === "width" ? shapeType === "text" ? "outlineWidth" : "strokeWidth" : "radius"] = parseInt(id, 10);
        if (this.activeObj.shape === "rectangle" || this.activeObj.shape === "ellipse") {
          this.activeObj.strokeSettings[type === "width" ? shapeType === "text" ? "outlineWidth" : "strokeWidth" : "radius"] = parseInt(id, 10) - 1;
        }
        this.activeObj.strokeSettings[type === "width" ? shapeType === "text" ? "outlineWidth" : "strokeWidth" : "radius"] *= 2;
        if (type === "width") {
          if (shapeType === "text") {
            this.notify("shape", { prop: "setStrokeSettings", value: {
              strokeSettings: null,
              strokeColor: null,
              fillColor: null,
              strokeWidth: null,
              radius: null,
              outlineWidth: this.activeObj.strokeSettings.outlineWidth
            } });
          } else {
            this.notify("shape", { prop: "setStrokeSettings", value: {
              strokeSettings: null,
              strokeColor: null,
              fillColor: null,
              strokeWidth: this.activeObj.strokeSettings.strokeWidth,
              radius: null,
              outlineWidth: null
            } });
          }
        } else {
          this.notify("shape", { prop: "setStrokeSettings", value: {
            strokeSettings: null,
            strokeColor: null,
            fillColor: null,
            strokeWidth: null,
            radius: this.activeObj.strokeSettings.radius
          } });
        }
        this.objColl.push(this.activeObj);
        if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
          this.notify("undo-redo", {
            prop: "updateUndoRedoColl",
            onPropertyChange: false,
            value: {
              operation: "shapeTransform",
              previousObj: prevObj,
              previousObjColl: prevObj.objColl,
              previousPointColl: prevObj.pointColl,
              previousSelPointColl: prevObj.selPointColl,
              previousCropObj: prevCropObj,
              previousText: null,
              currentText: null,
              previousFilter: null,
              isCircleCrop: null
            }
          });
        }
        this.notify("selection", { prop: "redrawShape", value: { obj: this.objColl[this.objColl.length - 1] } });
        var shapeChangedArgs = { action: "stroke-width", currentShapeSettings: extend({}, shapeSettings, {}, true) };
        shapeChangedArgs.currentShapeSettings[type === "width" ? shapeType === "text" ? "outlineWidth" : "strokeWidth" : "radius"] = this.activeObj.strokeSettings[type === "width" ? shapeType === "text" ? "outlineWidth" : "strokeWidth" : "radius"];
        this.trigger("shapeChange", shapeChangedArgs);
        this.editCompleteArgs = shapeChangedArgs;
      } else if (this.activeObj.shape && (this.activeObj.shape === "path" && this.activeObj.pointColl.length === 0)) {
        this.activeObj.strokeSettings.strokeWidth = parseInt(id, 10);
        this.activeObj.strokeSettings.strokeWidth *= 2;
        if (type === "width") {
          if (shapeType === "text") {
            this.notify("shape", { prop: "setStrokeSettings", value: {
              strokeSettings: null,
              strokeColor: null,
              fillColor: null,
              strokeWidth: null,
              radius: null,
              outlineWidth: this.activeObj.strokeSettings.outlineWidth
            } });
          } else {
            this.notify("shape", { prop: "setStrokeSettings", value: {
              strokeSettings: null,
              strokeColor: null,
              fillColor: null,
              strokeWidth: this.activeObj.strokeSettings.strokeWidth,
              radius: null,
              outlineWidth: null
            } });
          }
        } else {
          this.notify("shape", { prop: "setStrokeSettings", value: {
            strokeSettings: null,
            strokeColor: null,
            fillColor: null,
            strokeWidth: null,
            radius: this.activeObj.strokeSettings.radius
          } });
        }
      }
    };
    ImageEditor2.prototype.updateStrokeColor = function(value) {
      var objt = { shapeSettingsObj: {} };
      this.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj: objt } });
      var shapeSettings = objt["shapeSettingsObj"];
      if (this.activeObj.shape && (this.activeObj.shape !== "path" || this.activeObj.shape === "path" && this.activeObj.pointColl.length > 0)) {
        var isObjPushed = false;
        var collLength = this.objColl.length;
        this.notify("shape", { prop: "pushActItemIntoObj" });
        if (collLength !== this.objColl.length) {
          isObjPushed = true;
        }
        var prevCropObj = extend({}, this.cropObj, {}, true);
        var object = { currObj: {} };
        this.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
        var prevObj = object["currObj"];
        prevObj.objColl = extend([], this.objColl, [], true);
        prevObj.pointColl = extend([], this.pointColl, [], true);
        prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        this.notify("freehand-draw", {
          prop: "getSelPointColl",
          onPropertyChange: false,
          value: { obj: selPointCollObj }
        });
        prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
        if (isObjPushed) {
          this.objColl.pop();
        }
        this.activeObj.strokeSettings.strokeColor = value;
        this.notify("shape", { prop: "setStrokeSettings", value: { strokeSettings: null, strokeColor: this.activeObj.strokeSettings.strokeColor, fillColor: null, strokeWidth: null } });
        if (!this.togglePen) {
          this.objColl.push(this.activeObj);
          if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
            this.notify("undo-redo", {
              prop: "updateUndoRedoColl",
              onPropertyChange: false,
              value: {
                operation: "shapeTransform",
                previousObj: prevObj,
                previousObjColl: prevObj.objColl,
                previousPointColl: prevObj.pointColl,
                previousSelPointColl: prevObj.selPointColl,
                previousCropObj: prevCropObj,
                previousText: null,
                currentText: null,
                previousFilter: null,
                isCircleCrop: null
              }
            });
          }
          this.notify("selection", { prop: "redrawShape", value: { obj: this.objColl[this.objColl.length - 1] } });
        }
      } else if (this.activeObj.shape && (this.activeObj.shape === "path" && this.activeObj.pointColl.length === 0)) {
        this.activeObj.strokeSettings.strokeColor = value;
        this.notify("shape", { prop: "setStrokeSettings", value: { strokeSettings: null, strokeColor: this.activeObj.strokeSettings.strokeColor, fillColor: null, strokeWidth: null } });
      }
      var shapeChangedArgs = { action: "stroke-color", currentShapeSettings: extend({}, shapeSettings, {}, true) };
      shapeChangedArgs.currentShapeSettings.strokeColor = value;
      this.trigger("shapeChange", shapeChangedArgs);
      this.editCompleteArgs = shapeChangedArgs;
    };
    ImageEditor2.prototype.updateFillColor = function(value) {
      var obj = { shapeSettingsObj: {} };
      this.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj } });
      var shapeSettings = obj["shapeSettingsObj"];
      var isObjPushed = false;
      var collLength = this.objColl.length;
      this.notify("shape", { prop: "pushActItemIntoObj" });
      if (collLength !== this.objColl.length) {
        isObjPushed = true;
      }
      var prevCropObj = extend({}, this.cropObj, {}, true);
      var object = { currObj: {} };
      this.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
      var prevObj = object["currObj"];
      prevObj.objColl = extend([], this.objColl, [], true);
      prevObj.pointColl = extend([], this.pointColl, [], true);
      prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      this.notify("freehand-draw", {
        prop: "getSelPointColl",
        onPropertyChange: false,
        value: { obj: selPointCollObj }
      });
      prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
      if (isObjPushed) {
        this.objColl.pop();
      }
      this.activeObj.strokeSettings.fillColor = value;
      this.notify("shape", {
        prop: "setStrokeSettings",
        value: {
          strokeSettings: null,
          strokeColor: null,
          fillColor: this.activeObj.strokeSettings.fillColor,
          strokeWidth: null
        }
      });
      this.objColl.push(this.activeObj);
      if (this.activeObj.activePoint.width !== 0 || this.activeObj.activePoint.height !== 0) {
        this.notify("undo-redo", {
          prop: "updateUndoRedoColl",
          onPropertyChange: false,
          value: {
            operation: "shapeTransform",
            previousObj: prevObj,
            previousObjColl: prevObj.objColl,
            previousPointColl: prevObj.pointColl,
            previousSelPointColl: prevObj.selPointColl,
            previousCropObj: prevCropObj,
            previousText: null,
            currentText: null,
            previousFilter: null,
            isCircleCrop: null
          }
        });
      }
      this.notify("selection", { prop: "redrawShape", value: { obj: this.objColl[this.objColl.length - 1] } });
      var shapeChangedArgs = { action: "fill-color", currentShapeSettings: extend({}, shapeSettings, {}, true) };
      this.trigger("shapeChange", shapeChangedArgs);
      this.editCompleteArgs = shapeChangedArgs;
    };
    ImageEditor2.prototype.horizontalFlip = function(ctx, isPreventURC) {
      var prevCropObj;
      var prevObj;
      if (isNullOrUndefined(isPreventURC)) {
        if (isNullOrUndefined(this.activeObj.imageRatio)) {
          this.notify("shape", { prop: "updImgRatioForActObj", onPropertyChange: false });
        }
        this.notify("shape", { prop: "pushActItemIntoObj" });
        prevCropObj = extend({}, this.cropObj, {}, true);
        var object = { currObj: {} };
        this.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
        prevObj = object["currObj"];
        prevObj.objColl = extend([], this.objColl, [], true);
        prevObj.pointColl = extend([], this.pointColl, [], true);
        prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        this.notify("freehand-draw", {
          prop: "getSelPointColl",
          onPropertyChange: false,
          value: { obj: selPointCollObj }
        });
        prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
        this.objColl.pop();
      }
      this.notify("toolbar", { prop: "refreshSlider" });
      ctx.clearRect(0, 0, this.activeObj.imageCanvas.width, this.activeObj.imageCanvas.height);
      var activePoint = this.duplicateImage();
      this.notify("draw", {
        prop: "downScaleImgCanvas",
        onPropertyChange: false,
        value: { ctx: this.activeObj.imageCanvas.getContext("2d"), isImgAnnotation: true, isHFlip: true, isVFlip: null }
      });
      this.activeObj.activePoint = activePoint;
      this.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate" } });
      if (isNullOrUndefined(isPreventURC)) {
        this.objColl.push(this.activeObj);
        this.notify("undo-redo", {
          prop: "updateUndoRedoColl",
          onPropertyChange: false,
          value: {
            operation: "imageHFlip",
            previousObj: prevObj,
            previousObjColl: prevObj.objColl,
            previousPointColl: prevObj.pointColl,
            previousSelPointColl: prevObj.selPointColl,
            previousCropObj: prevCropObj,
            previousText: null,
            currentText: null,
            previousFilter: null,
            isCircleCrop: null
          }
        });
        this.notify("selection", { prop: "redrawShape", value: { obj: this.objColl[this.objColl.length - 1] } });
      }
    };
    ImageEditor2.prototype.verticalFlip = function(ctx, isPreventURC) {
      var prevCropObj;
      var prevObj;
      if (isNullOrUndefined(isPreventURC)) {
        if (isNullOrUndefined(this.activeObj.imageRatio)) {
          this.notify("shape", { prop: "updImgRatioForActObj", onPropertyChange: false });
        }
        this.notify("shape", { prop: "pushActItemIntoObj" });
        prevCropObj = extend({}, this.cropObj, {}, true);
        var object = { currObj: {} };
        this.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
        prevObj = object["currObj"];
        prevObj.objColl = extend([], this.objColl, [], true);
        prevObj.pointColl = extend([], this.pointColl, [], true);
        prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        this.notify("freehand-draw", {
          prop: "getSelPointColl",
          onPropertyChange: false,
          value: { obj: selPointCollObj }
        });
        prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
        this.objColl.pop();
      }
      this.notify("toolbar", { prop: "refreshSlider" });
      ctx.clearRect(0, 0, this.activeObj.imageCanvas.width, this.activeObj.imageCanvas.height);
      var activePoint = this.duplicateImage();
      this.notify("draw", {
        prop: "downScaleImgCanvas",
        onPropertyChange: false,
        value: { ctx: this.activeObj.imageCanvas.getContext("2d"), isImgAnnotation: true, isHFlip: null, isVFlip: true }
      });
      this.activeObj.activePoint = activePoint;
      this.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate" } });
      if (isNullOrUndefined(isPreventURC)) {
        this.objColl.push(this.activeObj);
        this.notify("undo-redo", {
          prop: "updateUndoRedoColl",
          onPropertyChange: false,
          value: {
            operation: "imageVFlip",
            previousObj: prevObj,
            previousObjColl: prevObj.objColl,
            previousPointColl: prevObj.pointColl,
            previousSelPointColl: prevObj.selPointColl,
            previousCropObj: prevCropObj,
            previousText: null,
            currentText: null,
            previousFilter: null,
            isCircleCrop: null
          }
        });
        this.notify("selection", { prop: "redrawShape", value: { obj: this.objColl[this.objColl.length - 1] } });
      }
    };
    ImageEditor2.prototype.rotateImage = function(rotate) {
      var prevCropObj;
      var prevObj;
      if (isNullOrUndefined(this.activeObj.imageRatio)) {
        this.notify("shape", { prop: "updImgRatioForActObj", onPropertyChange: false });
      }
      this.notify("shape", { prop: "pushActItemIntoObj" });
      prevCropObj = extend({}, this.cropObj, {}, true);
      var object = { currObj: {} };
      this.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
      prevObj = object["currObj"];
      prevObj.objColl = extend([], this.objColl, [], true);
      prevObj.pointColl = extend([], this.pointColl, [], true);
      prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      this.notify("freehand-draw", {
        prop: "getSelPointColl",
        onPropertyChange: false,
        value: { obj: selPointCollObj }
      });
      prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
      this.objColl.pop();
      this.notify("toolbar", { prop: "refreshSlider" });
      if (rotate === "rotleft") {
        this.activeObj.rotatedAngle -= 90 * (Math.PI / 180);
      } else {
        this.activeObj.rotatedAngle += 90 * (Math.PI / 180);
      }
      this.notify("selection", { prop: "updPtCollForShpRot", onPropertyChange: false, value: { obj: this.activeObj } });
      this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
      this.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate" } });
      this.objColl.push(this.activeObj);
      this.notify("undo-redo", {
        prop: "updateUndoRedoColl",
        onPropertyChange: false,
        value: {
          operation: "imageRotate",
          previousObj: prevObj,
          previousObjColl: prevObj.objColl,
          previousPointColl: prevObj.pointColl,
          previousSelPointColl: prevObj.selPointColl,
          previousCropObj: prevCropObj,
          previousText: null,
          currentText: null,
          previousFilter: null,
          isCircleCrop: null
        }
      });
      this.notify("selection", { prop: "redrawShape", value: { obj: this.objColl[this.objColl.length - 1] } });
      this.notify("toolbar", { prop: "destroy-qa-toolbar" });
      this.notify("toolbar", { prop: "renderQAT", onPropertyChange: false, value: { isPenEdit: null } });
    };
    ImageEditor2.prototype.pascalToSplitWords = function(str) {
      str = str.charAt(0).toUpperCase() + str.slice(1);
      var splitStr = str.match(/[A-Z][a-z]+/g);
      if (isNullOrUndefined(splitStr)) {
        return str;
      } else {
        return splitStr.map(function(word) {
          return word.charAt(0).toUpperCase() + word.slice(1);
        }).join(" ");
      }
    };
    ImageEditor2.prototype.getCurrAdjustmentValue = function(type) {
      var value = 100;
      var indexObj = { freehandSelectedIndex: null };
      this.notify("freehand-draw", { prop: "getFreehandSelectedIndex", onPropertyChange: false, value: { obj: indexObj } });
      if (type === "transparency" && this.togglePen) {
        var obj = { penOpacity: 1 };
        this.notify("freehand-draw", { prop: "getPenOpacity", onPropertyChange: false, value: { obj } });
        value = obj["penOpacity"] * 100;
      } else if (type === "transparency" && indexObj["freehandSelectedIndex"] !== null && indexObj["freehandSelectedIndex"] !== undefined) {
        value = this.pointColl[indexObj["freehandSelectedIndex"]].opacity * 100;
      } else {
        var obj = { adjustmentLevel: null };
        this.notify("filter", {
          prop: "getAdjustmentLevel",
          onPropertyChange: false,
          value: { obj }
        });
        var typeToAdjustmentLevel = {
          "brightness": obj["adjustmentLevel"].brightness,
          "contrast": obj["adjustmentLevel"].contrast,
          "hue": obj["adjustmentLevel"].hue,
          "saturation": obj["adjustmentLevel"].saturation,
          "opacity": obj["adjustmentLevel"].opacity,
          "blur": obj["adjustmentLevel"].blur,
          "exposure": obj["adjustmentLevel"].exposure,
          "transparency": obj["adjustmentLevel"].transparency,
          "straighten": this.transform.straighten
        };
        value = typeToAdjustmentLevel["" + type];
      }
      return value;
    };
    ImageEditor2.prototype.transformSelect = function(type) {
      if (this.transform.straighten === 0 && (type === "rotateleft" || type === "rotateright") && this.activeObj.shape && ([
        "crop-2:3",
        "crop-3:2",
        "crop-3:4",
        "crop-4:3",
        "crop-4:5",
        "crop-5:4",
        "crop-5:7",
        "crop-7:5",
        "crop-9:16",
        "crop-16:9"
      ].indexOf(this.activeObj.shape) !== -1 || this.activeObj.shape.indexOf("crop-") !== -1 && this.activeObj.shape !== "crop-custom" && this.activeObj.shape !== "crop-square" && this.activeObj.shape !== "crop-circle")) {
        this.activeObj.shape = "crop-" + this.activeObj.shape.split("-")[1].split(":")[1] + ":" + this.activeObj.shape.split("-")[1].split(":")[0];
        this.notify("toolbar", { prop: "performCropTransformClick", value: { shape: this.activeObj.shape, isTransform: true } });
      }
      this.isCropToolbar = true;
      this.allowDownScale = false;
      var straighten = this.transform.straighten;
      var straightenObj = extend({}, this.activeObj, {}, true);
      var zoomFactor = this.transform.zoomFactor;
      this.prevEventSelectionPoint = extend({}, this.activeObj, {}, true);
      var object = { currObj: {} };
      this.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
      this.prevEventObjPoint = object["currObj"];
      this.prevEventObjPoint.objColl = extend([], this.objColl, [], true);
      this.prevEventObjPoint.pointColl = extend([], this.pointColl, [], true);
      this.prevEventObjPoint.afterCropActions = extend([], this.afterCropActions, [], true);
      var selPointCollObj = { selPointColl: null };
      this.notify("freehand-draw", {
        prop: "getSelPointColl",
        onPropertyChange: false,
        value: { obj: selPointCollObj }
      });
      this.prevEventObjPoint.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
      if (this.transform.straighten !== 0) {
        this.transform.straighten = 0;
        this.straightenBaseImageCanvas();
        for (var i = 0, len = this.objColl.length; i < len; i++) {
          var shape = this.objColl[i].shape;
          if (shape !== "line" && shape !== "arrow" && shape !== "path") {
            this.objColl[i].rotatedAngle -= straighten * (Math.PI / 180);
            this.notify("selection", { prop: "updPtCollForShpRot", onPropertyChange: false, value: { obj: this.objColl[i] } });
          }
        }
        this.notify("draw", { prop: "render-image", value: { isMouseWheel: false } });
        this.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
        });
      }
      this.setInitialZoomState();
      var activeObj = extend({}, this.activeObj, {}, true);
      this.notify("crop", { prop: "setTransformCrop", onPropertyChange: false, value: { bool: true } });
      this.cropSelectedState();
      this.notify("crop", { prop: "setTransformCrop", onPropertyChange: false, value: { bool: false } });
      this.notify("draw", { prop: "resetCurrentSelectionPoint" });
      this.updateImageTransformColl(type);
      this.notify("transform", { prop: "performTransformation", value: { text: type } });
      this.isCropTab = true;
      this.notify("draw", { prop: "moveToSelectionRange", value: { type, activeObj } });
      if (this.isStraightening && (type === "horizontalflip" || type === "verticalflip")) {
        this.notify("draw", { prop: "resetStraightenDestPoints" });
        this.notify("draw", { prop: "setDestForStraighten" });
      }
      if (straighten !== 0) {
        this.transform.straighten = straighten;
        this.straightenBaseImageCanvas();
        for (var i = 0, len = this.objColl.length; i < len; i++) {
          var shape = this.objColl[i].shape;
          if (shape !== "line" && shape !== "arrow" && shape !== "path") {
            this.objColl[i].rotatedAngle += straighten * (Math.PI / 180);
            this.notify("selection", { prop: "updPtCollForShpRot", onPropertyChange: false, value: { obj: this.objColl[i] } });
          }
        }
        this.notify("shape", {
          prop: "drawAnnotations",
          onPropertyChange: false,
          value: { ctx: this.lowerContext, shape: "zoom", pen: "zoom", isPreventApply: null }
        });
        this.notify("draw", { prop: "render-image", value: { isMouseWheel: false } });
        this.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate", obj: straightenObj } });
        this.notify("draw", { prop: "setStraightenActObj", value: { activeObj: null } });
        this.notify("draw", { prop: "setStraightenInitZoom", value: { zoomFactor } });
        if (this.isStraightening && (type === "horizontalflip" || type === "verticalflip") && isNullOrUndefined(this.transform.zoomFactor) || this.transform.zoomFactor === 0) {
          if (this.transform.degree === 0) {
            this.transform.zoomFactor += 0.025;
          } else if (this.transform.zoomFactor === 0) {
            this.transform.zoomFactor = null;
          }
        }
        this.notify("draw", { prop: "zoomToSel", value: { activeObj: straightenObj, isToolbar: false } });
      }
      this.isCropToolbar = false;
      var stValPan = this.element.querySelector(".e-ie-straighten-value-span");
      if (stValPan) {
        stValPan.innerHTML = this.transform.straighten.toString() + "&#176";
      }
    };
    ImageEditor2.prototype.getDefaultFilter = function() {
      return "brightness(1) contrast(100%) hue-rotate(0deg) saturate(100%) opacity(1) blur(0px) sepia(0%) grayscale(0%) invert(0%)";
    };
    ImageEditor2.prototype.setStraighten = function(value) {
      var straightenEventArgs = { cancel: false, previousDegree: this.transform.straighten, currentDegree: value };
      this.trigger("rotating", straightenEventArgs);
      this.editCompleteArgs = straightenEventArgs;
      if (!straightenEventArgs.cancel) {
        this.performStraighten(straightenEventArgs);
        var actionArgs = { action: "straighten", actionEventArgs: this.editCompleteArgs };
        this.triggerEditCompleteEvent(actionArgs);
      }
    };
    ImageEditor2.prototype.duplicateImage = function() {
      var activePoint = extend({}, this.activeObj.activePoint, {}, true);
      var dimObj = { width: 0, height: 0 };
      this.notify("transform", {
        prop: "calcMaxDimension",
        onPropertyChange: false,
        value: { width: this.activeObj.imageElement.width, height: this.activeObj.imageElement.height, obj: dimObj, isImgShape: null }
      });
      this.activeObj.activePoint.width = dimObj["width"];
      this.activeObj.activePoint.height = dimObj["height"];
      return activePoint;
    };
    ImageEditor2.prototype.performStraighten = function(straightenEventArgs) {
      var value = straightenEventArgs.currentDegree;
      var stValPan = this.element.querySelector(".e-ie-straighten-value-span");
      if (stValPan) {
        stValPan.innerHTML = value.toString() + "&#176";
      }
      var obj = extend({}, this.activeObj, null, true);
      this.notify("freehand-draw", { prop: "setCenterSelPoints" });
      this.transform.straighten = value;
      this.straightenPoint = {
        x: this.activeObj.activePoint.startX + this.activeObj.activePoint.width / 2,
        y: this.activeObj.activePoint.startY + this.activeObj.activePoint.height / 2
      };
      this.straightenBaseImageCanvas();
      for (var i = 0, len = this.objColl.length; i < len; i++) {
        var shape = this.objColl[i].shape;
        if (shape !== "line" && shape !== "arrow" && shape !== "path") {
          this.objColl[i].rotatedAngle += (this.transform.straighten - this.prevStraightenedDegree) * (Math.PI / 180);
          this.notify("selection", { prop: "updPtCollForShpRot", onPropertyChange: false, value: { obj: this.objColl[i] } });
        }
      }
      if (this.transform.degree % 90 === 0 && this.transform.degree % 180 !== 0) {
        if (this.transform.straighten === 0) {
          this.transform.straighten = 360;
        }
        this.notify("draw", {
          prop: "performPointZoom",
          onPropertyChange: false,
          value: {
            x: this.activeObj.activePoint.startX + this.activeObj.activePoint.width / 2,
            y: this.activeObj.activePoint.startY + this.activeObj.activePoint.height / 2,
            type: "zoomIn",
            isResize: true
          }
        });
        this.notify("draw", {
          prop: "performPointZoom",
          onPropertyChange: false,
          value: {
            x: this.activeObj.activePoint.startX + this.activeObj.activePoint.width / 2,
            y: this.activeObj.activePoint.startY + this.activeObj.activePoint.height / 2,
            type: "zoomOut",
            isResize: true
          }
        });
        if (this.transform.straighten === 360) {
          this.transform.straighten = 0;
        }
      } else {
        this.notify("draw", { prop: "render-image", value: { isMouseWheel: true, isPreventClearRect: null, isFrame: null, isStraighten: true } });
      }
      this.notify("draw", {
        prop: "drawObject",
        onPropertyChange: false,
        value: { canvas: "duplicate", obj }
      });
      this.notify("draw", { prop: "zoomToSel", value: { activeObj: obj, isToolbar: true } });
      this.notify("transform", { prop: "disableZoomOutBtn", value: { isZoomOut: true } });
      this.prevStraightenedDegree = this.transform.straighten;
    };
    ImageEditor2.prototype.straightenBaseImageCanvas = function() {
      if (this.isImageLoaded) {
        var flipState = this.getStraightenFlipState();
        var straighten = flipState === "horizontal" || flipState === "vertical" ? -this.transform.straighten : this.transform.straighten;
        var ctx = this.baseImgCanvas.getContext("2d");
        if (ctx.canvas.width !== this.lowerContext.canvas.width && ctx.canvas.height !== this.lowerContext.canvas.height) {
          var obj_7 = { width: 0, height: 0 };
          this.notify("crop", {
            prop: "calcRatio",
            onPropertyChange: false,
            value: { obj: obj_7, dimension: { width: ctx.canvas.width, height: ctx.canvas.height } }
          });
        }
        var dimension = undefined;
        dimension = this.getRotatedCanvasDim(this.baseImg.width, this.baseImg.height, this.transform.straighten);
        this.img.srcWidth = ctx.canvas.width = dimension.width;
        this.img.srcHeight = ctx.canvas.height = dimension.height;
        var x = ctx.canvas.width / 2;
        var y = ctx.canvas.height / 2;
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        ctx.translate(x, y);
        ctx.rotate(straighten * Math.PI / 180);
        ctx.drawImage(this.baseImg, -this.baseImg.width / 2, -this.baseImg.height / 2, this.baseImg.width, this.baseImg.height);
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        var obj = { width: 0, height: 0 };
        this.notify("crop", { prop: "calcRatio", onPropertyChange: false, value: { obj, dimension: { width: ctx.canvas.width, height: ctx.canvas.height } } });
      }
    };
    ImageEditor2.prototype.getRotatedCanvasDim = function(width, height, angle) {
      var angleRad = angle * Math.PI / 180;
      var cosAngle = Math.cos(angleRad);
      var sinAngle = Math.sin(angleRad);
      var minX = Math.min(0, width * cosAngle, height * Math.cos(Math.PI / 2 - angleRad), width * cosAngle + height * Math.cos(Math.PI / 2 - angleRad));
      var maxX = Math.max(0, width * cosAngle, height * Math.cos(Math.PI / 2 - angleRad), width * cosAngle + height * Math.cos(Math.PI / 2 - angleRad));
      var minY = Math.min(0, width * sinAngle, height * Math.sin(Math.PI / 2 - angleRad), width * sinAngle + height * Math.sin(Math.PI / 2 - angleRad));
      var maxY = Math.max(0, width * sinAngle, height * Math.sin(Math.PI / 2 - angleRad), width * sinAngle + height * Math.sin(Math.PI / 2 - angleRad));
      return { width: Math.ceil(maxX - minX), height: Math.ceil(maxY - minY) };
    };
    ImageEditor2.prototype.updateShapeOrder = function(id, value) {
      var shapeObj = this.getObjFromId(id);
      if (shapeObj.shape && (shapeObj.shape !== "path" || shapeObj.shape === "path" && shapeObj.pointColl.length > 0) || shapeObj && shapeObj["id"] && shapeObj["id"].indexOf("pen") > -1) {
        var obj = { shapeSettingsObj: {} };
        this.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj } });
        var shapeSettings = obj["shapeSettingsObj"];
        if (shapeObj.shape) {
          this.notify("shape", { prop: "pushActItemIntoObj" });
        }
        var prevCropObj = extend({}, this.cropObj, {}, true);
        var object = { currObj: {} };
        this.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
        var prevObj = object["currObj"];
        prevObj.objColl = extend([], this.objColl, [], true);
        prevObj.pointColl = extend([], this.pointColl, [], true);
        prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
        var selPointCollObj = { selPointColl: null };
        this.notify("freehand-draw", {
          prop: "getSelPointColl",
          onPropertyChange: false,
          value: { obj: selPointCollObj }
        });
        prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
        if (shapeObj.shape) {
          this.objColl.pop();
        }
        this.notify("shape", { prop: "z-order", onPropertyChange: false, value: { obj: shapeObj, value } });
        if (shapeObj.shape) {
          this.notify("shape", { prop: "setStrokeSettings", value: {
            strokeSettings: null,
            strokeColor: null,
            fillColor: null,
            strokeWidth: shapeObj.strokeSettings.strokeWidth
          } });
          this.objColl.push(shapeObj);
        }
        this.notify("undo-redo", {
          prop: "updateUndoRedoColl",
          onPropertyChange: false,
          value: {
            operation: "shapeTransform",
            previousObj: prevObj,
            previousObjColl: prevObj.objColl,
            previousPointColl: prevObj.pointColl,
            previousSelPointColl: prevObj.selPointColl,
            previousCropObj: prevCropObj,
            previousText: null,
            currentText: null,
            previousFilter: null,
            isCircleCrop: null
          }
        });
        if (shapeObj.shape) {
          this.notify("selection", { prop: "redrawShape", value: { obj: this.objColl[this.objColl.length - 1] } });
          this.activeObj.order = shapeObj.order;
        }
        var shapeChangedArgs = {
          action: "stroke-width",
          previousShapeSettings: extend({}, shapeSettings, {}, true),
          currentShapeSettings: extend({}, shapeSettings, {}, true)
        };
        shapeChangedArgs.currentShapeSettings.strokeWidth = this.activeObj.strokeSettings.strokeWidth;
      } else if (this.activeObj.shape && (this.activeObj.shape === "path" && this.activeObj.pointColl.length === 0)) {
        this.notify("shape", { prop: "setStrokeSettings", value: {
          strokeSettings: null,
          strokeColor: null,
          fillColor: null,
          strokeWidth: this.activeObj.strokeSettings.strokeWidth
        } });
      }
    };
    ImageEditor2.prototype.getStraightenFlipState = function() {
      var flipState = "";
      if (this.rotateFlipColl.length > 0) {
        for (var i = 0, len = this.rotateFlipColl.length; i < len; i++) {
          var curFlip = this.rotateFlipColl[i];
          if (curFlip === "horizontal") {
            flipState += "horizontal";
          } else if (curFlip === "vertical") {
            flipState += "vertical";
          }
          if (flipState === "horizontalvertical" || flipState === "verticalhorizontal") {
            flipState = "";
          }
        }
      }
      return flipState;
    };
    ImageEditor2.prototype.initializeZoomSettings = function() {
      this.theme = isNullOrUndefined(this.theme) ? "Bootstrap5" : this.theme;
      if (isNullOrUndefined(this.zoomSettings.zoomTrigger) || this.zoomSettings.zoomTrigger === 0) {
        this.zoomSettings.zoomTrigger = ZoomTrigger.MouseWheel | ZoomTrigger.Pinch | ZoomTrigger.Toolbar | ZoomTrigger.Commands;
      }
      if (isNullOrUndefined(this.selectionSettings.strokeColor)) {
        this.selectionSettings.strokeColor = this.themeColl[this.theme]["primaryColor"];
      }
      if (isNullOrUndefined(this.selectionSettings.fillColor)) {
        this.selectionSettings.fillColor = this.themeColl[this.theme]["secondaryColor"];
      }
    };
    ImageEditor2.prototype.initializeThemeColl = function() {
      this.themeColl = {
        Bootstrap5: { primaryColor: "#0d6efd", secondaryColor: "#fff" },
        Bootstrap5Dark: { primaryColor: "#0d6efd", secondaryColor: "#fff" },
        Tailwind: { primaryColor: "#4f46e5", secondaryColor: "#fff" },
        TailwindDark: { primaryColor: "#22d3ee", secondaryColor: "#fff" },
        Fluent: { primaryColor: "#0078d4", secondaryColor: "#fff" },
        FluentDark: { primaryColor: "#0078d4", secondaryColor: "#fff" },
        Bootstrap4: { primaryColor: "#007bff", secondaryColor: "#fff" },
        Bootstrap: { primaryColor: "#317ab9", secondaryColor: "#fff" },
        BootstrapDark: { primaryColor: "#317ab9", secondaryColor: "#fff" },
        Material: { primaryColor: "#e3165b", secondaryColor: "#fff" },
        MaterialDark: { primaryColor: "#00b0ff", secondaryColor: "#fff" },
        Fabric: { primaryColor: "#0078d6", secondaryColor: "#fff" },
        FabricDark: { primaryColor: "#0074cc", secondaryColor: "#fff" },
        Highcontrast: { primaryColor: "#000000", secondaryColor: "#fff" },
        Material3: { primaryColor: "#6750a4", secondaryColor: "#fff" },
        Material3Dark: { primaryColor: "#d0bcff", secondaryColor: "#fff" },
        Fluent2: { primaryColor: "#0f6cbd", secondaryColor: "#fff" },
        Fluent2Dark: { primaryColor: "#115ea3", secondaryColor: "#fff" },
        Fluent2Highcontrast: { primaryColor: "#1aebff", secondaryColor: "#fff" },
        "Bootstrap5.3": { primaryColor: "#0d6efd", secondaryColor: "#fff" },
        "Bootstrap5.3Dark": { primaryColor: "#0d6efd", secondaryColor: "#fff" },
        Tailwind3: { primaryColor: "#4f46e5", secondaryColor: "#ffffff" },
        Tailwind3Dark: { primaryColor: "#6366f1", secondaryColor: "#ffffff03" }
      };
    };
    ImageEditor2.prototype.drawRedact = function(type, x, y, width, height, value) {
      var isRedact = false;
      var isPointsInRange = this.allowShape(x, y);
      if (!this.disabled && this.isImageLoaded && (isPointsInRange || isNullOrUndefined(x) && isNullOrUndefined(y))) {
        isRedact = true;
        this.manageActiveAction();
        this.notify("shape", {
          prop: "drawRedact",
          onPropertyChange: false,
          value: {
            x,
            y,
            width,
            height,
            type,
            value
          }
        });
        this.notify("draw", { prop: "redrawDownScale" });
      }
      return isRedact;
    };
    var ImageEditor_1;
    __decorate$3([
      Property("")
    ], ImageEditor2.prototype, "cssClass", undefined);
    __decorate$3([
      Property(false)
    ], ImageEditor2.prototype, "disabled", undefined);
    __decorate$3([
      Property("100%")
    ], ImageEditor2.prototype, "height", undefined);
    __decorate$3([
      Property("Bootstrap5")
    ], ImageEditor2.prototype, "theme", undefined);
    __decorate$3([
      Property()
    ], ImageEditor2.prototype, "toolbar", undefined);
    __decorate$3([
      Property()
    ], ImageEditor2.prototype, "toolbarTemplate", undefined);
    __decorate$3([
      Property("100%")
    ], ImageEditor2.prototype, "width", undefined);
    __decorate$3([
      Property(true)
    ], ImageEditor2.prototype, "allowUndoRedo", undefined);
    __decorate$3([
      Property(true)
    ], ImageEditor2.prototype, "showQuickAccessToolbar", undefined);
    __decorate$3([
      Property()
    ], ImageEditor2.prototype, "quickAccessToolbarTemplate", undefined);
    __decorate$3([
      Property(false)
    ], ImageEditor2.prototype, "isReadOnly", undefined);
    __decorate$3([
      Property(false)
    ], ImageEditor2.prototype, "enableRtl", undefined);
    __decorate$3([
      Property(false)
    ], ImageEditor2.prototype, "enablePersistence", undefined);
    __decorate$3([
      Complex({}, FinetuneSettings)
    ], ImageEditor2.prototype, "finetuneSettings", undefined);
    __decorate$3([
      Complex({}, ZoomSettings)
    ], ImageEditor2.prototype, "zoomSettings", undefined);
    __decorate$3([
      Complex({}, SelectionSettings)
    ], ImageEditor2.prototype, "selectionSettings", undefined);
    __decorate$3([
      Complex({}, FontFamily)
    ], ImageEditor2.prototype, "fontFamily", undefined);
    __decorate$3([
      Complex({}, UploadSettings)
    ], ImageEditor2.prototype, "uploadSettings", undefined);
    __decorate$3([
      Event()
    ], ImageEditor2.prototype, "beforeSave", undefined);
    __decorate$3([
      Event()
    ], ImageEditor2.prototype, "created", undefined);
    __decorate$3([
      Event()
    ], ImageEditor2.prototype, "destroyed", undefined);
    __decorate$3([
      Event()
    ], ImageEditor2.prototype, "zooming", undefined);
    __decorate$3([
      Event()
    ], ImageEditor2.prototype, "panning", undefined);
    __decorate$3([
      Event()
    ], ImageEditor2.prototype, "cropping", undefined);
    __decorate$3([
      Event()
    ], ImageEditor2.prototype, "rotating", undefined);
    __decorate$3([
      Event()
    ], ImageEditor2.prototype, "flipping", undefined);
    __decorate$3([
      Event()
    ], ImageEditor2.prototype, "shapeChanging", undefined);
    __decorate$3([
      Event()
    ], ImageEditor2.prototype, "selectionChanging", undefined);
    __decorate$3([
      Event()
    ], ImageEditor2.prototype, "fileOpened", undefined);
    __decorate$3([
      Event()
    ], ImageEditor2.prototype, "saved", undefined);
    __decorate$3([
      Event()
    ], ImageEditor2.prototype, "toolbarCreated", undefined);
    __decorate$3([
      Event()
    ], ImageEditor2.prototype, "toolbarUpdating", undefined);
    __decorate$3([
      Event()
    ], ImageEditor2.prototype, "toolbarItemClicked", undefined);
    __decorate$3([
      Event()
    ], ImageEditor2.prototype, "imageFiltering", undefined);
    __decorate$3([
      Event()
    ], ImageEditor2.prototype, "finetuneValueChanging", undefined);
    __decorate$3([
      Event()
    ], ImageEditor2.prototype, "click", undefined);
    __decorate$3([
      Event()
    ], ImageEditor2.prototype, "shapeChange", undefined);
    __decorate$3([
      Event()
    ], ImageEditor2.prototype, "quickAccessToolbarOpen", undefined);
    __decorate$3([
      Event()
    ], ImageEditor2.prototype, "resizing", undefined);
    __decorate$3([
      Event()
    ], ImageEditor2.prototype, "quickAccessToolbarItemClick", undefined);
    __decorate$3([
      Event()
    ], ImageEditor2.prototype, "frameChange", undefined);
    __decorate$3([
      Event()
    ], ImageEditor2.prototype, "editComplete", undefined);
    ImageEditor2 = ImageEditor_1 = __decorate$3([
      NotifyPropertyChanges
    ], ImageEditor2);
    return ImageEditor2;
  }(Component)
);
var FileType;
(function(FileType2) {
  FileType2["Png"] = "Png";
  FileType2["Jpeg"] = "Jpeg";
  FileType2["Svg"] = "Svg";
  FileType2["WebP"] = "WebP";
})(FileType || (FileType = {}));
var Direction;
(function(Direction2) {
  Direction2["Horizontal"] = "Horizontal";
  Direction2["Vertical"] = "Vertical";
})(Direction || (Direction = {}));
var ShapeType;
(function(ShapeType2) {
  ShapeType2["Rectangle"] = "Rectangle";
  ShapeType2["Ellipse"] = "Ellipse";
  ShapeType2["Line"] = "Line";
  ShapeType2["Arrow"] = "Arrow";
  ShapeType2["Path"] = "Path";
  ShapeType2["Text"] = "Text";
  ShapeType2["FreehandDraw"] = "FreehandDraw";
  ShapeType2["Image"] = "Image";
})(ShapeType || (ShapeType = {}));
var ZoomTrigger;
(function(ZoomTrigger2) {
  ZoomTrigger2[ZoomTrigger2["MouseWheel"] = 1] = "MouseWheel";
  ZoomTrigger2[ZoomTrigger2["Pinch"] = 2] = "Pinch";
  ZoomTrigger2[ZoomTrigger2["Commands"] = 4] = "Commands";
  ZoomTrigger2[ZoomTrigger2["Toolbar"] = 8] = "Toolbar";
})(ZoomTrigger || (ZoomTrigger = {}));
var Theme;
(function(Theme2) {
  Theme2["Bootstrap5"] = "Bootstrap5";
  Theme2["Bootstrap5Dark"] = "Bootstrap5Dark";
  Theme2["Tailwind"] = "Tailwind";
  Theme2["TailwindDark"] = "TailwindDark";
  Theme2["Fluent"] = "Fluent";
  Theme2["FluentDark"] = "FluentDark";
  Theme2["Bootstrap4"] = "Bootstrap4";
  Theme2["Bootstrap"] = "Bootstrap";
  Theme2["BootstrapDark"] = "BootstrapDark";
  Theme2["Material"] = "Material";
  Theme2["MaterialDark"] = "MaterialDark";
  Theme2["Fabric"] = "Fabric";
  Theme2["FabricDark"] = "FabricDark";
  Theme2["Highcontrast"] = "Highcontrast";
  Theme2["Fluent2"] = "Fluent2";
  Theme2["Fluent2Dark"] = "Fluent2Dark";
  Theme2["Tailwind3"] = "Tailwind3";
  Theme2["Tailwind3Dark"] = "Tailwind3Dark";
})(Theme || (Theme = {}));
var ImageEditorCommand;
(function(ImageEditorCommand2) {
  ImageEditorCommand2["Crop"] = "Crop";
  ImageEditorCommand2["Transform"] = "Transform";
  ImageEditorCommand2["Annotate"] = "Annotate";
  ImageEditorCommand2["ZoomIn"] = "ZoomIn";
  ImageEditorCommand2["ZoomOut"] = "ZoomOut";
  ImageEditorCommand2["Open"] = "Open";
  ImageEditorCommand2["Reset"] = "Reset";
  ImageEditorCommand2["Save"] = "Save";
  ImageEditorCommand2["Pan"] = "Pan";
  ImageEditorCommand2["Move"] = "Move";
  ImageEditorCommand2["Pen"] = "Pen";
  ImageEditorCommand2["Line"] = "Line";
  ImageEditorCommand2["Arrow"] = "Arrow";
  ImageEditorCommand2["Path"] = "Path";
  ImageEditorCommand2["Rectangle"] = "Rectangle";
  ImageEditorCommand2["Image"] = "Image";
  ImageEditorCommand2["Ellipse"] = "Ellipse";
  ImageEditorCommand2["Text"] = "Text";
  ImageEditorCommand2["CustomSelection"] = "CustomSelection";
  ImageEditorCommand2["CircleSelection"] = "CircleSelection";
  ImageEditorCommand2["SquareSelection"] = "SquareSelection";
  ImageEditorCommand2["RatioSelection"] = "RatioSelection";
  ImageEditorCommand2["RotateLeft"] = "RotateLeft";
  ImageEditorCommand2["RotateRight"] = "RotateRight";
  ImageEditorCommand2["FlipHorizontal"] = "FlipHorizontal";
  ImageEditorCommand2["FlipVertical"] = "FlipVertical";
  ImageEditorCommand2["Undo"] = "Undo";
  ImageEditorCommand2["Redo"] = "Redo";
  ImageEditorCommand2["None"] = "None";
  ImageEditorCommand2["Mat"] = "Mat";
  ImageEditorCommand2["Bevel"] = "Bevel";
  ImageEditorCommand2["Inset"] = "Inset";
  ImageEditorCommand2["Hook"] = "Hook";
  ImageEditorCommand2["Finetune"] = "Finetune";
  ImageEditorCommand2["Filter"] = "Filter";
  ImageEditorCommand2["Frame"] = "Frame";
  ImageEditorCommand2["Resize"] = "Resize";
  ImageEditorCommand2["HorizontalFlip"] = "HorizontalFlip";
  ImageEditorCommand2["VerticalFlip"] = "VerticalFlip";
  ImageEditorCommand2["Brightness"] = "Brightness";
  ImageEditorCommand2["Contrast"] = "Contrast";
  ImageEditorCommand2["Hue"] = "Hue";
  ImageEditorCommand2["Saturation"] = "Saturation";
  ImageEditorCommand2["Opacity"] = "Opacity";
  ImageEditorCommand2["Blur"] = "Blur";
  ImageEditorCommand2["Exposure"] = "Exposure";
  ImageEditorCommand2["Default"] = "Default";
  ImageEditorCommand2["Chrome"] = "Chrome";
  ImageEditorCommand2["Cold"] = "Cold";
  ImageEditorCommand2["Warm"] = "Warm";
  ImageEditorCommand2["Grayscale"] = "Grayscale";
  ImageEditorCommand2["Sepia"] = "Sepia";
  ImageEditorCommand2["Invert"] = "Invert";
  ImageEditorCommand2["Straightening"] = "Straightening";
})(ImageEditorCommand || (ImageEditorCommand = {}));
var ImageFilterOption;
(function(ImageFilterOption2) {
  ImageFilterOption2["Default"] = "Default";
  ImageFilterOption2["Chrome"] = "Chrome";
  ImageFilterOption2["Cold"] = "Cold";
  ImageFilterOption2["Warm"] = "Warm";
  ImageFilterOption2["Grayscale"] = "Grayscale";
  ImageFilterOption2["Sepia"] = "Sepia";
  ImageFilterOption2["Invert"] = "Invert";
})(ImageFilterOption || (ImageFilterOption = {}));
var ImageFinetuneOption;
(function(ImageFinetuneOption2) {
  ImageFinetuneOption2["Brightness"] = "Brightness";
  ImageFinetuneOption2["Contrast"] = "Contrast";
  ImageFinetuneOption2["Hue"] = "Hue";
  ImageFinetuneOption2["Saturation"] = "Saturation";
  ImageFinetuneOption2["Exposure"] = "Exposure";
  ImageFinetuneOption2["Opacity"] = "Opacity";
  ImageFinetuneOption2["Blur"] = "Blur";
})(ImageFinetuneOption || (ImageFinetuneOption = {}));
var ArrowheadType;
(function(ArrowheadType2) {
  ArrowheadType2["None"] = "None";
  ArrowheadType2["Arrow"] = "Arrow";
  ArrowheadType2["SolidArrow"] = "SolidArrow";
  ArrowheadType2["Circle"] = "Circle";
  ArrowheadType2["SolidCircle"] = "SolidCircle";
  ArrowheadType2["Square"] = "Square";
  ArrowheadType2["SolidSquare"] = "SolidSquare";
  ArrowheadType2["Bar"] = "Bar";
})(ArrowheadType || (ArrowheadType = {}));
var FrameType;
(function(FrameType2) {
  FrameType2["None"] = "None";
  FrameType2["Mat"] = "Mat";
  FrameType2["Bevel"] = "Bevel";
  FrameType2["Line"] = "Line";
  FrameType2["Inset"] = "Inset";
  FrameType2["Hook"] = "Hook";
})(FrameType || (FrameType = {}));
var FrameLineStyle;
(function(FrameLineStyle2) {
  FrameLineStyle2["Solid"] = "Solid";
  FrameLineStyle2["Dashed"] = "Dashed";
  FrameLineStyle2["Dotted"] = "Dotted";
})(FrameLineStyle || (FrameLineStyle = {}));
var RedactType;
(function(RedactType2) {
  RedactType2["Blur"] = "Blur";
  RedactType2["Pixelate"] = "Pixelate";
})(RedactType || (RedactType = {}));
var __extends$2 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate$2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CLS_ROOT$1 = "e-hscroll";
var CLS_RTL$2 = "e-rtl";
var CLS_DISABLE$2 = "e-overlay";
var CLS_HSCROLLBAR$1 = "e-hscroll-bar";
var CLS_HSCROLLCON = "e-hscroll-content";
var CLS_NAVARROW$1 = "e-nav-arrow";
var CLS_NAVRIGHTARROW = "e-nav-right-arrow";
var CLS_NAVLEFTARROW = "e-nav-left-arrow";
var CLS_HSCROLLNAV = "e-scroll-nav";
var CLS_HSCROLLNAVRIGHT = "e-scroll-right-nav";
var CLS_HSCROLLNAVLEFT = "e-scroll-left-nav";
var CLS_DEVICE$1 = "e-scroll-device";
var CLS_OVERLAY$1 = "e-scroll-overlay";
var CLS_RIGHTOVERLAY = "e-scroll-right-overlay";
var CLS_LEFTOVERLAY = "e-scroll-left-overlay";
var OVERLAY_MAXWID$1 = 40;
var HScroll = (
  /** @class */
  function(_super) {
    __extends$2(HScroll2, _super);
    function HScroll2(options, element2) {
      return _super.call(this, options, element2) || this;
    }
    HScroll2.prototype.preRender = function() {
      this.browser = Browser.info.name;
      this.browserCheck = this.browser === "mozilla";
      this.isDevice = Browser.isDevice;
      this.customStep = true;
      var element2 = this.element;
      this.ieCheck = this.browser === "edge" || this.browser === "msie";
      this.initialize();
      if (element2.id === "") {
        element2.id = getUniqueID("hscroll");
        this.uniqueId = true;
      }
      element2.style.display = "block";
      if (this.enableRtl) {
        element2.classList.add(CLS_RTL$2);
      }
    };
    HScroll2.prototype.render = function() {
      this.touchModule = new Touch(this.element, { scroll: this.touchHandler.bind(this), swipe: this.swipeHandler.bind(this) });
      EventHandler.add(this.scrollEle, "scroll", this.scrollHandler, this);
      if (!this.isDevice) {
        this.createNavIcon(this.element);
      } else {
        this.element.classList.add(CLS_DEVICE$1);
        this.createOverlay(this.element);
      }
      this.setScrollState();
    };
    HScroll2.prototype.setScrollState = function() {
      if (isNullOrUndefined(this.scrollStep) || this.scrollStep < 0) {
        this.scrollStep = this.scrollEle.offsetWidth;
        this.customStep = false;
      } else {
        this.customStep = true;
      }
    };
    HScroll2.prototype.initialize = function() {
      var scrollEle = this.createElement("div", { className: CLS_HSCROLLCON });
      var scrollDiv = this.createElement("div", { className: CLS_HSCROLLBAR$1 });
      scrollDiv.setAttribute("tabindex", "-1");
      var ele = this.element;
      var innerEle = [].slice.call(ele.children);
      for (var _i = 0, innerEle_1 = innerEle; _i < innerEle_1.length; _i++) {
        var ele_1 = innerEle_1[_i];
        scrollEle.appendChild(ele_1);
      }
      scrollDiv.appendChild(scrollEle);
      ele.appendChild(scrollDiv);
      scrollDiv.style.overflowX = "hidden";
      this.scrollEle = scrollDiv;
      this.scrollItems = scrollEle;
    };
    HScroll2.prototype.getPersistData = function() {
      var keyEntity = ["scrollStep"];
      return this.addOnPersist(keyEntity);
    };
    HScroll2.prototype.getModuleName = function() {
      return "hScroll";
    };
    HScroll2.prototype.destroy = function() {
      var ele = this.element;
      ele.style.display = "";
      ele.classList.remove(CLS_ROOT$1);
      ele.classList.remove(CLS_DEVICE$1);
      ele.classList.remove(CLS_RTL$2);
      var nav = selectAll(".e-" + ele.id + "_nav." + CLS_HSCROLLNAV, ele);
      var overlay = selectAll("." + CLS_OVERLAY$1, ele);
      [].slice.call(overlay).forEach(function(ele2) {
        detach(ele2);
      });
      for (var _i = 0, _a = [].slice.call(this.scrollItems.children); _i < _a.length; _i++) {
        var elem = _a[_i];
        ele.appendChild(elem);
      }
      if (this.uniqueId) {
        this.element.removeAttribute("id");
      }
      detach(this.scrollEle);
      if (nav.length > 0) {
        detach(nav[0]);
        if (!isNullOrUndefined(nav[1])) {
          detach(nav[1]);
        }
      }
      EventHandler.remove(this.scrollEle, "scroll", this.scrollHandler);
      this.touchModule.destroy();
      this.touchModule = null;
      _super.prototype.destroy.call(this);
    };
    HScroll2.prototype.disable = function(value) {
      var navEles = selectAll(".e-scroll-nav:not(." + CLS_DISABLE$2 + ")", this.element);
      if (value) {
        this.element.classList.add(CLS_DISABLE$2);
      } else {
        this.element.classList.remove(CLS_DISABLE$2);
      }
      [].slice.call(navEles).forEach(function(el) {
        el.setAttribute("tabindex", !value ? "0" : "-1");
      });
    };
    HScroll2.prototype.createOverlay = function(element2) {
      var id = element2.id.concat("_nav");
      var rightOverlayEle = this.createElement("div", { className: CLS_OVERLAY$1 + " " + CLS_RIGHTOVERLAY });
      var clsRight = "e-" + element2.id.concat("_nav " + CLS_HSCROLLNAV + " " + CLS_HSCROLLNAVRIGHT);
      var rightEle = this.createElement("div", { id: id.concat("_right"), className: clsRight });
      var navItem = this.createElement("div", { className: CLS_NAVRIGHTARROW + " " + CLS_NAVARROW$1 + " e-icons" });
      rightEle.appendChild(navItem);
      var leftEle = this.createElement("div", { className: CLS_OVERLAY$1 + " " + CLS_LEFTOVERLAY });
      if (this.ieCheck) {
        rightEle.classList.add("e-ie-align");
      }
      element2.appendChild(rightOverlayEle);
      element2.appendChild(rightEle);
      element2.insertBefore(leftEle, element2.firstChild);
      this.eventBinding([rightEle]);
    };
    HScroll2.prototype.createNavIcon = function(element2) {
      var id = element2.id.concat("_nav");
      var clsRight = "e-" + element2.id.concat("_nav " + CLS_HSCROLLNAV + " " + CLS_HSCROLLNAVRIGHT);
      var rightAttributes = { "role": "button", "id": id.concat("_right"), "aria-label": "Scroll right" };
      var nav = this.createElement("div", { className: clsRight, attrs: rightAttributes });
      nav.setAttribute("aria-disabled", "false");
      var navItem = this.createElement("div", { className: CLS_NAVRIGHTARROW + " " + CLS_NAVARROW$1 + " e-icons" });
      var clsLeft = "e-" + element2.id.concat("_nav " + CLS_HSCROLLNAV + " " + CLS_HSCROLLNAVLEFT);
      var leftAttributes = { "role": "button", "id": id.concat("_left"), "aria-label": "Scroll left" };
      var navEle = this.createElement("div", { className: clsLeft + " " + CLS_DISABLE$2, attrs: leftAttributes });
      navEle.setAttribute("aria-disabled", "true");
      var navLeftItem = this.createElement("div", { className: CLS_NAVLEFTARROW + " " + CLS_NAVARROW$1 + " e-icons" });
      navEle.appendChild(navLeftItem);
      nav.appendChild(navItem);
      element2.appendChild(nav);
      element2.insertBefore(navEle, element2.firstChild);
      if (this.ieCheck) {
        nav.classList.add("e-ie-align");
        navEle.classList.add("e-ie-align");
      }
      this.eventBinding([nav, navEle]);
    };
    HScroll2.prototype.onKeyPress = function(e) {
      var _this = this;
      if (e.key === "Enter") {
        var timeoutFun_1 = function() {
          _this.keyTimeout = true;
          _this.eleScrolling(10, e.target, true);
        };
        this.keyTimer = (undefined).setTimeout(function() {
          timeoutFun_1();
        }, 100);
      }
    };
    HScroll2.prototype.onKeyUp = function(e) {
      if (e.key !== "Enter") {
        return;
      }
      if (this.keyTimeout) {
        this.keyTimeout = false;
      } else {
        e.target.click();
      }
      clearTimeout(this.keyTimer);
    };
    HScroll2.prototype.eventBinding = function(ele) {
      var _this = this;
      [].slice.call(ele).forEach(function(el) {
        new Touch(el, { tapHold: _this.tabHoldHandler.bind(_this), tapHoldThreshold: 500 });
        el.addEventListener("keydown", _this.onKeyPress.bind(_this));
        el.addEventListener("keyup", _this.onKeyUp.bind(_this));
        el.addEventListener("mouseup", _this.repeatScroll.bind(_this));
        el.addEventListener("touchend", _this.repeatScroll.bind(_this));
        el.addEventListener("contextmenu", function(e) {
          e.preventDefault();
        });
        EventHandler.add(el, "click", _this.clickEventHandler, _this);
      });
    };
    HScroll2.prototype.repeatScroll = function() {
      clearInterval(this.timeout);
    };
    HScroll2.prototype.tabHoldHandler = function(e) {
      var _this = this;
      var trgt = e.originalEvent.target;
      trgt = this.contains(trgt, CLS_HSCROLLNAV) ? trgt.firstElementChild : trgt;
      var scrollDis = 10;
      var timeoutFun = function() {
        _this.eleScrolling(scrollDis, trgt, true);
      };
      this.timeout = (undefined).setInterval(function() {
        timeoutFun();
      }, 50);
    };
    HScroll2.prototype.contains = function(ele, className) {
      return ele.classList.contains(className);
    };
    HScroll2.prototype.eleScrolling = function(scrollDis, trgt, isContinuous) {
      var rootEle = this.element;
      var classList2 = trgt.classList;
      if (classList2.contains(CLS_HSCROLLNAV)) {
        classList2 = trgt.querySelector("." + CLS_NAVARROW$1).classList;
      }
      if (this.contains(rootEle, CLS_RTL$2) && this.browserCheck) {
        scrollDis = -scrollDis;
      }
      if (!this.contains(rootEle, CLS_RTL$2) || this.browserCheck || this.ieCheck) {
        if (classList2.contains(CLS_NAVRIGHTARROW)) {
          this.frameScrollRequest(scrollDis, "add", isContinuous);
        } else {
          this.frameScrollRequest(scrollDis, "", isContinuous);
        }
      } else {
        if (classList2.contains(CLS_NAVLEFTARROW)) {
          this.frameScrollRequest(scrollDis, "add", isContinuous);
        } else {
          this.frameScrollRequest(scrollDis, "", isContinuous);
        }
      }
    };
    HScroll2.prototype.clickEventHandler = function(e) {
      this.eleScrolling(this.scrollStep, e.target, false);
    };
    HScroll2.prototype.swipeHandler = function(e) {
      var swipeEle = this.scrollEle;
      var distance;
      if (e.velocity <= 1) {
        distance = e.distanceX / (e.velocity * 10);
      } else {
        distance = e.distanceX / e.velocity;
      }
      var start = 0.5;
      var animate = function() {
        var step = Math.sin(start);
        if (step <= 0) {
          (undefined).cancelAnimationFrame(step);
        } else {
          if (e.swipeDirection === "Left") {
            swipeEle.scrollLeft += distance * step;
          } else if (e.swipeDirection === "Right") {
            swipeEle.scrollLeft -= distance * step;
          }
          start -= 0.5;
          (undefined).requestAnimationFrame(animate);
        }
      };
      animate();
    };
    HScroll2.prototype.scrollUpdating = function(scrollVal, action) {
      if (action === "add") {
        this.scrollEle.scrollLeft += scrollVal;
      } else {
        this.scrollEle.scrollLeft -= scrollVal;
      }
      if (this.enableRtl && this.scrollEle.scrollLeft > 0) {
        this.scrollEle.scrollLeft = 0;
      }
    };
    HScroll2.prototype.frameScrollRequest = function(scrollVal, action, isContinuous) {
      var _this = this;
      var step = 10;
      if (isContinuous) {
        this.scrollUpdating(scrollVal, action);
        return;
      }
      if (!this.customStep) {
        [].slice.call(selectAll("." + CLS_OVERLAY$1, this.element)).forEach(function(el) {
          scrollVal -= el.offsetWidth;
        });
      }
      var animate = function() {
        var scrollValue;
        var scrollStep;
        if (_this.contains(_this.element, CLS_RTL$2) && _this.browserCheck) {
          scrollValue = -scrollVal;
          scrollStep = -10;
        } else {
          scrollValue = scrollVal;
          scrollStep = step;
        }
        if (scrollValue < step) {
          (undefined).cancelAnimationFrame(scrollStep);
        } else {
          _this.scrollUpdating(scrollStep, action);
          scrollVal -= scrollStep;
          (undefined).requestAnimationFrame(animate);
        }
      };
      animate();
    };
    HScroll2.prototype.touchHandler = function(e) {
      var ele = this.scrollEle;
      var distance = e.distanceX;
      if (this.ieCheck && this.contains(this.element, CLS_RTL$2)) {
        distance = -distance;
      }
      if (e.scrollDirection === "Left") {
        ele.scrollLeft = ele.scrollLeft + distance;
      } else if (e.scrollDirection === "Right") {
        ele.scrollLeft = ele.scrollLeft - distance;
      }
    };
    HScroll2.prototype.arrowDisabling = function(addDisable, removeDisable) {
      if (this.isDevice) {
        var arrowEle = isNullOrUndefined(addDisable) ? removeDisable : addDisable;
        var arrowIcon = arrowEle.querySelector("." + CLS_NAVARROW$1);
        if (isNullOrUndefined(addDisable)) {
          classList(arrowIcon, [CLS_NAVRIGHTARROW], [CLS_NAVLEFTARROW]);
        } else {
          classList(arrowIcon, [CLS_NAVLEFTARROW], [CLS_NAVRIGHTARROW]);
        }
      } else if (addDisable && removeDisable) {
        addDisable.classList.add(CLS_DISABLE$2);
        addDisable.setAttribute("aria-disabled", "true");
        addDisable.removeAttribute("tabindex");
        removeDisable.classList.remove(CLS_DISABLE$2);
        removeDisable.setAttribute("aria-disabled", "false");
        removeDisable.setAttribute("tabindex", "0");
      }
      this.repeatScroll();
    };
    HScroll2.prototype.scrollHandler = function(e) {
      var target = e.target;
      var width = target.offsetWidth;
      this.element;
      var navLeftEle = this.element.querySelector("." + CLS_HSCROLLNAVLEFT);
      var navRightEle = this.element.querySelector("." + CLS_HSCROLLNAVRIGHT);
      var leftOverlay = this.element.querySelector("." + CLS_LEFTOVERLAY);
      var rightOverlay = this.element.querySelector("." + CLS_RIGHTOVERLAY);
      var scrollLeft = target.scrollLeft;
      if (scrollLeft <= 0) {
        scrollLeft = -scrollLeft;
      }
      if (this.isDevice) {
        if (this.enableRtl && !(this.browserCheck || this.ieCheck)) {
          leftOverlay = this.element.querySelector("." + CLS_RIGHTOVERLAY);
          rightOverlay = this.element.querySelector("." + CLS_LEFTOVERLAY);
        }
        if (scrollLeft < OVERLAY_MAXWID$1) {
          leftOverlay.style.width = scrollLeft + "px";
        } else {
          leftOverlay.style.width = "40px";
        }
        if (target.scrollWidth - Math.ceil(width + scrollLeft) < OVERLAY_MAXWID$1) {
          rightOverlay.style.width = target.scrollWidth - Math.ceil(width + scrollLeft) + "px";
        } else {
          rightOverlay.style.width = "40px";
        }
      }
      if (scrollLeft === 0) {
        this.arrowDisabling(navLeftEle, navRightEle);
      } else if (Math.ceil(width + scrollLeft + 0.1) >= target.scrollWidth) {
        this.arrowDisabling(navRightEle, navLeftEle);
      } else {
        var disEle = this.element.querySelector("." + CLS_HSCROLLNAV + "." + CLS_DISABLE$2);
        if (disEle) {
          disEle.classList.remove(CLS_DISABLE$2);
          disEle.setAttribute("aria-disabled", "false");
          disEle.setAttribute("tabindex", "0");
        }
      }
    };
    HScroll2.prototype.onPropertyChanged = function(newProp, oldProp) {
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "scrollStep":
            this.setScrollState();
            break;
          case "enableRtl":
            newProp.enableRtl ? this.element.classList.add(CLS_RTL$2) : this.element.classList.remove(CLS_RTL$2);
            break;
        }
      }
    };
    __decorate$2([
      Property(null)
    ], HScroll2.prototype, "scrollStep", undefined);
    HScroll2 = __decorate$2([
      NotifyPropertyChanges
    ], HScroll2);
    return HScroll2;
  }(Component)
);
var __extends$1 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate$1 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CLS_ROOT = "e-vscroll";
var CLS_RTL$1 = "e-rtl";
var CLS_DISABLE$1 = "e-overlay";
var CLS_VSCROLLBAR = "e-vscroll-bar";
var CLS_VSCROLLCON = "e-vscroll-content";
var CLS_NAVARROW = "e-nav-arrow";
var CLS_NAVUPARROW = "e-nav-up-arrow";
var CLS_NAVDOWNARROW = "e-nav-down-arrow";
var CLS_VSCROLLNAV = "e-scroll-nav";
var CLS_VSCROLLNAVUP = "e-scroll-up-nav";
var CLS_VSCROLLNAVDOWN = "e-scroll-down-nav";
var CLS_DEVICE = "e-scroll-device";
var CLS_OVERLAY = "e-scroll-overlay";
var CLS_UPOVERLAY = "e-scroll-up-overlay";
var CLS_DOWNOVERLAY = "e-scroll-down-overlay";
var OVERLAY_MAXWID = 40;
var VScroll = (
  /** @class */
  function(_super) {
    __extends$1(VScroll2, _super);
    function VScroll2(options, element2) {
      return _super.call(this, options, element2) || this;
    }
    VScroll2.prototype.preRender = function() {
      this.browser = Browser.info.name;
      this.browserCheck = this.browser === "mozilla";
      this.isDevice = Browser.isDevice;
      this.customStep = true;
      var ele = this.element;
      this.ieCheck = this.browser === "edge" || this.browser === "msie";
      this.initialize();
      if (ele.id === "") {
        ele.id = getUniqueID("vscroll");
        this.uniqueId = true;
      }
      ele.style.display = "block";
      if (this.enableRtl) {
        ele.classList.add(CLS_RTL$1);
      }
    };
    VScroll2.prototype.render = function() {
      this.touchModule = new Touch(this.element, { scroll: this.touchHandler.bind(this), swipe: this.swipeHandler.bind(this) });
      EventHandler.add(this.scrollEle, "scroll", this.scrollEventHandler, this);
      if (!this.isDevice) {
        this.createNavIcon(this.element);
      } else {
        this.element.classList.add(CLS_DEVICE);
        this.createOverlayElement(this.element);
      }
      this.setScrollState();
      EventHandler.add(this.element, "wheel", this.wheelEventHandler, this);
    };
    VScroll2.prototype.setScrollState = function() {
      if (isNullOrUndefined(this.scrollStep) || this.scrollStep < 0) {
        this.scrollStep = this.scrollEle.offsetHeight;
        this.customStep = false;
      } else {
        this.customStep = true;
      }
    };
    VScroll2.prototype.initialize = function() {
      var scrollCnt = createElement("div", { className: CLS_VSCROLLCON });
      var scrollBar = createElement("div", { className: CLS_VSCROLLBAR });
      scrollBar.setAttribute("tabindex", "-1");
      var ele = this.element;
      var innerEle = [].slice.call(ele.children);
      for (var _i = 0, innerEle_1 = innerEle; _i < innerEle_1.length; _i++) {
        var ele_1 = innerEle_1[_i];
        scrollCnt.appendChild(ele_1);
      }
      scrollBar.appendChild(scrollCnt);
      ele.appendChild(scrollBar);
      scrollBar.style.overflow = "hidden";
      this.scrollEle = scrollBar;
      this.scrollItems = scrollCnt;
    };
    VScroll2.prototype.getPersistData = function() {
      var keyEntity = ["scrollStep"];
      return this.addOnPersist(keyEntity);
    };
    VScroll2.prototype.getModuleName = function() {
      return "vScroll";
    };
    VScroll2.prototype.destroy = function() {
      var el = this.element;
      el.style.display = "";
      removeClass([this.element], [CLS_ROOT, CLS_DEVICE, CLS_RTL$1]);
      var navs = selectAll(".e-" + el.id + "_nav." + CLS_VSCROLLNAV, el);
      var overlays = selectAll("." + CLS_OVERLAY, el);
      [].slice.call(overlays).forEach(function(ele) {
        detach(ele);
      });
      for (var _i = 0, _a = [].slice.call(this.scrollItems.children); _i < _a.length; _i++) {
        var elem = _a[_i];
        el.appendChild(elem);
      }
      if (this.uniqueId) {
        this.element.removeAttribute("id");
      }
      detach(this.scrollEle);
      if (navs.length > 0) {
        detach(navs[0]);
        if (!isNullOrUndefined(navs[1])) {
          detach(navs[1]);
        }
      }
      EventHandler.remove(this.scrollEle, "scroll", this.scrollEventHandler);
      this.touchModule.destroy();
      this.touchModule = null;
      _super.prototype.destroy.call(this);
    };
    VScroll2.prototype.disable = function(value) {
      var navEle = selectAll(".e-scroll-nav:not(." + CLS_DISABLE$1 + ")", this.element);
      if (value) {
        this.element.classList.add(CLS_DISABLE$1);
      } else {
        this.element.classList.remove(CLS_DISABLE$1);
      }
      [].slice.call(navEle).forEach(function(el) {
        el.setAttribute("tabindex", !value ? "0" : "-1");
      });
    };
    VScroll2.prototype.createOverlayElement = function(element2) {
      var id = element2.id.concat("_nav");
      var downOverlayEle = createElement("div", { className: CLS_OVERLAY + " " + CLS_DOWNOVERLAY });
      var clsDown = "e-" + element2.id.concat("_nav " + CLS_VSCROLLNAV + " " + CLS_VSCROLLNAVDOWN);
      var downEle = createElement("div", { id: id.concat("down"), className: clsDown });
      var navItem = createElement("div", { className: CLS_NAVDOWNARROW + " " + CLS_NAVARROW + " e-icons" });
      downEle.appendChild(navItem);
      var upEle = createElement("div", { className: CLS_OVERLAY + " " + CLS_UPOVERLAY });
      if (this.ieCheck) {
        downEle.classList.add("e-ie-align");
      }
      element2.appendChild(downOverlayEle);
      element2.appendChild(downEle);
      element2.insertBefore(upEle, element2.firstChild);
      this.eventBinding([downEle]);
    };
    VScroll2.prototype.createNavIcon = function(element2) {
      var id = element2.id.concat("_nav");
      var clsDown = "e-" + element2.id.concat("_nav " + CLS_VSCROLLNAV + " " + CLS_VSCROLLNAVDOWN);
      var nav = createElement("div", { id: id.concat("_down"), className: clsDown });
      nav.setAttribute("aria-disabled", "false");
      var navItem = createElement("div", { className: CLS_NAVDOWNARROW + " " + CLS_NAVARROW + " e-icons" });
      var clsUp = "e-" + element2.id.concat("_nav " + CLS_VSCROLLNAV + " " + CLS_VSCROLLNAVUP);
      var navElement = createElement("div", { id: id.concat("_up"), className: clsUp + " " + CLS_DISABLE$1 });
      navElement.setAttribute("aria-disabled", "true");
      var navUpItem = createElement("div", { className: CLS_NAVUPARROW + " " + CLS_NAVARROW + " e-icons" });
      navElement.appendChild(navUpItem);
      nav.appendChild(navItem);
      nav.setAttribute("tabindex", "0");
      element2.appendChild(nav);
      element2.insertBefore(navElement, element2.firstChild);
      if (this.ieCheck) {
        nav.classList.add("e-ie-align");
        navElement.classList.add("e-ie-align");
      }
      this.eventBinding([nav, navElement]);
    };
    VScroll2.prototype.onKeyPress = function(ev) {
      var _this = this;
      if (ev.key === "Enter") {
        var timeoutFun_1 = function() {
          _this.keyTimeout = true;
          _this.eleScrolling(10, ev.target, true);
        };
        this.keyTimer = (undefined).setTimeout(function() {
          timeoutFun_1();
        }, 100);
      }
    };
    VScroll2.prototype.onKeyUp = function(ev) {
      if (ev.key !== "Enter") {
        return;
      }
      if (this.keyTimeout) {
        this.keyTimeout = false;
      } else {
        ev.target.click();
      }
      clearTimeout(this.keyTimer);
    };
    VScroll2.prototype.eventBinding = function(element2) {
      var _this = this;
      [].slice.call(element2).forEach(function(ele) {
        new Touch(ele, { tapHold: _this.tabHoldHandler.bind(_this), tapHoldThreshold: 500 });
        ele.addEventListener("keydown", _this.onKeyPress.bind(_this));
        ele.addEventListener("keyup", _this.onKeyUp.bind(_this));
        ele.addEventListener("mouseup", _this.repeatScroll.bind(_this));
        ele.addEventListener("touchend", _this.repeatScroll.bind(_this));
        ele.addEventListener("contextmenu", function(e) {
          e.preventDefault();
        });
        EventHandler.add(ele, "click", _this.clickEventHandler, _this);
      });
    };
    VScroll2.prototype.repeatScroll = function() {
      clearInterval(this.timeout);
    };
    VScroll2.prototype.tabHoldHandler = function(ev) {
      var _this = this;
      var trgt = ev.originalEvent.target;
      trgt = this.contains(trgt, CLS_VSCROLLNAV) ? trgt.firstElementChild : trgt;
      var scrollDistance = 10;
      var timeoutFun = function() {
        _this.eleScrolling(scrollDistance, trgt, true);
      };
      this.timeout = (undefined).setInterval(function() {
        timeoutFun();
      }, 50);
    };
    VScroll2.prototype.contains = function(element2, className) {
      return element2.classList.contains(className);
    };
    VScroll2.prototype.eleScrolling = function(scrollDis, trgt, isContinuous) {
      var classList2 = trgt.classList;
      if (classList2.contains(CLS_VSCROLLNAV)) {
        classList2 = trgt.querySelector("." + CLS_NAVARROW).classList;
      }
      if (classList2.contains(CLS_NAVDOWNARROW)) {
        this.frameScrollRequest(scrollDis, "add", isContinuous);
      } else if (classList2.contains(CLS_NAVUPARROW)) {
        this.frameScrollRequest(scrollDis, "", isContinuous);
      }
    };
    VScroll2.prototype.clickEventHandler = function(event) {
      this.eleScrolling(this.scrollStep, event.target, false);
    };
    VScroll2.prototype.wheelEventHandler = function(e) {
      e.preventDefault();
      this.frameScrollRequest(this.scrollStep, e.deltaY > 0 ? "add" : "", false);
    };
    VScroll2.prototype.swipeHandler = function(e) {
      var swipeElement = this.scrollEle;
      var distance;
      if (e.velocity <= 1) {
        distance = e.distanceY / (e.velocity * 10);
      } else {
        distance = e.distanceY / e.velocity;
      }
      var start = 0.5;
      var animate = function() {
        var step = Math.sin(start);
        if (step <= 0) {
          (undefined).cancelAnimationFrame(step);
        } else {
          if (e.swipeDirection === "Up") {
            swipeElement.scrollTop += distance * step;
          } else if (e.swipeDirection === "Down") {
            swipeElement.scrollTop -= distance * step;
          }
          start -= 0.02;
          (undefined).requestAnimationFrame(animate);
        }
      };
      animate();
    };
    VScroll2.prototype.scrollUpdating = function(scrollVal, action) {
      if (action === "add") {
        this.scrollEle.scrollTop += scrollVal;
      } else {
        this.scrollEle.scrollTop -= scrollVal;
      }
    };
    VScroll2.prototype.frameScrollRequest = function(scrollValue, action, isContinuous) {
      var _this = this;
      var step = 10;
      if (isContinuous) {
        this.scrollUpdating(scrollValue, action);
        return;
      }
      if (!this.customStep) {
        [].slice.call(selectAll("." + CLS_OVERLAY, this.element)).forEach(function(el) {
          scrollValue -= el.offsetHeight;
        });
      }
      var animate = function() {
        if (scrollValue < step) {
          (undefined).cancelAnimationFrame(step);
        } else {
          _this.scrollUpdating(step, action);
          scrollValue -= step;
          (undefined).requestAnimationFrame(animate);
        }
      };
      animate();
    };
    VScroll2.prototype.touchHandler = function(e) {
      var el = this.scrollEle;
      var distance = e.distanceY;
      if (e.scrollDirection === "Up") {
        el.scrollTop = el.scrollTop + distance;
      } else if (e.scrollDirection === "Down") {
        el.scrollTop = el.scrollTop - distance;
      }
    };
    VScroll2.prototype.arrowDisabling = function(addDisableCls, removeDisableCls) {
      if (this.isDevice) {
        var arrowEle = isNullOrUndefined(addDisableCls) ? removeDisableCls : addDisableCls;
        var arrowIcon = arrowEle.querySelector("." + CLS_NAVARROW);
        if (isNullOrUndefined(addDisableCls)) {
          classList(arrowIcon, [CLS_NAVDOWNARROW], [CLS_NAVUPARROW]);
        } else {
          classList(arrowIcon, [CLS_NAVUPARROW], [CLS_NAVDOWNARROW]);
        }
      } else {
        addDisableCls.classList.add(CLS_DISABLE$1);
        addDisableCls.setAttribute("aria-disabled", "true");
        addDisableCls.removeAttribute("tabindex");
        removeDisableCls.classList.remove(CLS_DISABLE$1);
        removeDisableCls.setAttribute("aria-disabled", "false");
        removeDisableCls.setAttribute("tabindex", "0");
      }
      this.repeatScroll();
    };
    VScroll2.prototype.scrollEventHandler = function(e) {
      var target = e.target;
      var height = target.offsetHeight;
      var navUpEle = this.element.querySelector("." + CLS_VSCROLLNAVUP);
      var navDownEle = this.element.querySelector("." + CLS_VSCROLLNAVDOWN);
      var upOverlay = this.element.querySelector("." + CLS_UPOVERLAY);
      var downOverlay = this.element.querySelector("." + CLS_DOWNOVERLAY);
      var scrollTop = target.scrollTop;
      if (scrollTop <= 0) {
        scrollTop = -scrollTop;
      }
      if (this.isDevice) {
        if (scrollTop < OVERLAY_MAXWID) {
          upOverlay.style.height = scrollTop + "px";
        } else {
          upOverlay.style.height = "40px";
        }
        if (target.scrollHeight - Math.ceil(height + scrollTop) < OVERLAY_MAXWID) {
          downOverlay.style.height = target.scrollHeight - Math.ceil(height + scrollTop) + "px";
        } else {
          downOverlay.style.height = "40px";
        }
      }
      if (scrollTop === 0) {
        this.arrowDisabling(navUpEle, navDownEle);
      } else if (Math.ceil(height + scrollTop + 0.1) >= target.scrollHeight) {
        this.arrowDisabling(navDownEle, navUpEle);
      } else {
        var disEle = this.element.querySelector("." + CLS_VSCROLLNAV + "." + CLS_DISABLE$1);
        if (disEle) {
          disEle.classList.remove(CLS_DISABLE$1);
          disEle.setAttribute("aria-disabled", "false");
          disEle.setAttribute("tabindex", "0");
        }
      }
    };
    VScroll2.prototype.onPropertyChanged = function(newProp, oldProp) {
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "scrollStep":
            this.setScrollState();
            break;
          case "enableRtl":
            if (newProp.enableRtl) {
              this.element.classList.add(CLS_RTL$1);
            } else {
              this.element.classList.remove(CLS_RTL$1);
            }
            break;
        }
      }
    };
    __decorate$1([
      Property(null)
    ], VScroll2.prototype, "scrollStep", undefined);
    VScroll2 = __decorate$1([
      NotifyPropertyChanges
    ], VScroll2);
    return VScroll2;
  }(Component)
);
var __extends = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CLS_VERTICAL = "e-vertical";
var CLS_ITEMS = "e-toolbar-items";
var CLS_ITEM = "e-toolbar-item";
var CLS_RTL = "e-rtl";
var CLS_SEPARATOR = "e-separator";
var CLS_POPUPICON = "e-popup-up-icon";
var CLS_POPUPDOWN = "e-popup-down-icon";
var CLS_POPUPOPEN = "e-popup-open";
var CLS_TEMPLATE = "e-template";
var CLS_DISABLE = "e-overlay";
var CLS_POPUPTEXT = "e-toolbar-text";
var CLS_TBARTEXT = "e-popup-text";
var CLS_TBAROVERFLOW = "e-overflow-show";
var CLS_POPOVERFLOW = "e-overflow-hide";
var CLS_TBARBTN = "e-tbar-btn";
var CLS_TBARNAV = "e-hor-nav";
var CLS_TBARSCRLNAV = "e-scroll-nav";
var CLS_TBARRIGHT = "e-toolbar-right";
var CLS_TBARLEFT = "e-toolbar-left";
var CLS_TBARCENTER = "e-toolbar-center";
var CLS_TBARPOS = "e-tbar-pos";
var CLS_HSCROLLCNT = "e-hscroll-content";
var CLS_VSCROLLCNT = "e-vscroll-content";
var CLS_HSCROLLBAR = "e-hscroll-bar";
var CLS_POPUPNAV = "e-hor-nav";
var CLS_POPUPCLASS = "e-toolbar-pop";
var CLS_POPUP = "e-toolbar-popup";
var CLS_TBARBTNTEXT = "e-tbar-btn-text";
var CLS_TBARNAVACT = "e-nav-active";
var CLS_TBARIGNORE = "e-ignore";
var CLS_POPPRI = "e-popup-alone";
var CLS_HIDDEN = "e-hidden";
var CLS_MULTIROW = "e-toolbar-multirow";
var CLS_MULTIROWPOS = "e-multirow-pos";
var CLS_MULTIROW_SEPARATOR = "e-multirow-separator";
var CLS_EXTENDABLE_SEPARATOR = "e-extended-separator";
var CLS_EXTEANDABLE_TOOLBAR = "e-extended-toolbar";
var CLS_EXTENDABLECLASS = "e-toolbar-extended";
var CLS_EXTENDPOPUP = "e-expended-nav";
var CLS_EXTENDEDPOPOPEN = "e-tbar-extended";
var Item = (
  /** @class */
  function(_super) {
    __extends(Item2, _super);
    function Item2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
      Property("")
    ], Item2.prototype, "id", undefined);
    __decorate([
      Property("")
    ], Item2.prototype, "text", undefined);
    __decorate([
      Property("auto")
    ], Item2.prototype, "width", undefined);
    __decorate([
      Property("")
    ], Item2.prototype, "cssClass", undefined);
    __decorate([
      Property(false)
    ], Item2.prototype, "showAlwaysInPopup", undefined);
    __decorate([
      Property(false)
    ], Item2.prototype, "disabled", undefined);
    __decorate([
      Property("")
    ], Item2.prototype, "prefixIcon", undefined);
    __decorate([
      Property("")
    ], Item2.prototype, "suffixIcon", undefined);
    __decorate([
      Property(true)
    ], Item2.prototype, "visible", undefined);
    __decorate([
      Property("None")
    ], Item2.prototype, "overflow", undefined);
    __decorate([
      Property("")
    ], Item2.prototype, "template", undefined);
    __decorate([
      Property("Button")
    ], Item2.prototype, "type", undefined);
    __decorate([
      Property("Both")
    ], Item2.prototype, "showTextOn", undefined);
    __decorate([
      Property(null)
    ], Item2.prototype, "htmlAttributes", undefined);
    __decorate([
      Property("")
    ], Item2.prototype, "tooltipText", undefined);
    __decorate([
      Property("Left")
    ], Item2.prototype, "align", undefined);
    __decorate([
      Event()
    ], Item2.prototype, "click", undefined);
    __decorate([
      Property(-1)
    ], Item2.prototype, "tabIndex", undefined);
    return Item2;
  }(ChildProperty)
);
var Toolbar = (
  /** @class */
  function(_super) {
    __extends(Toolbar2, _super);
    function Toolbar2(options, element2) {
      var _this = _super.call(this, options, element2) || this;
      _this.resizeContext = _this.resize.bind(_this);
      _this.orientationChangeContext = _this.orientationChange.bind(_this);
      _this.keyConfigs = {
        moveLeft: "leftarrow",
        moveRight: "rightarrow",
        moveUp: "uparrow",
        moveDown: "downarrow",
        popupOpen: "enter",
        popupClose: "escape",
        tab: "tab",
        home: "home",
        end: "end"
      };
      return _this;
    }
    Toolbar2.prototype.destroy = function() {
      var _this = this;
      if (this.isReact || this.isAngular) {
        this.clearTemplate();
      }
      var btnItems = this.element.querySelectorAll(".e-control.e-btn");
      [].slice.call(btnItems).forEach(function(el) {
        if (!isNullOrUndefined(el) && !isNullOrUndefined(el.ej2_instances) && !isNullOrUndefined(el.ej2_instances[0]) && !el.ej2_instances[0].isDestroyed) {
          el.ej2_instances[0].destroy();
        }
      });
      this.unwireEvents();
      this.tempId.forEach(function(ele) {
        if (!isNullOrUndefined(_this.element.querySelector(ele))) {
          (undefined).body.appendChild(_this.element.querySelector(ele)).style.display = "none";
        }
      });
      this.destroyItems();
      while (this.element.lastElementChild) {
        this.element.removeChild(this.element.lastElementChild);
      }
      if (this.trgtEle) {
        this.element.appendChild(this.ctrlTem);
        this.trgtEle = null;
        this.ctrlTem = null;
      }
      if (this.popObj) {
        this.popObj.destroy();
        detach(this.popObj.element);
      }
      if (this.activeEle) {
        this.activeEle = null;
      }
      this.popObj = null;
      this.tbarAlign = null;
      this.tbarItemsCol = [];
      this.remove(this.element, "e-toolpop");
      if (this.cssClass) {
        removeClass([this.element], this.cssClass.split(" "));
      }
      this.element.removeAttribute("style");
      ["aria-disabled", "aria-orientation", "role"].forEach(function(attrb) {
        return _this.element.removeAttribute(attrb);
      });
      _super.prototype.destroy.call(this);
    };
    Toolbar2.prototype.preRender = function() {
      var eventArgs = { enableCollision: this.enableCollision, scrollStep: this.scrollStep };
      this.trigger("beforeCreate", eventArgs);
      this.enableCollision = eventArgs.enableCollision;
      this.scrollStep = eventArgs.scrollStep;
      this.scrollModule = null;
      this.popObj = null;
      this.tempId = [];
      this.tbarItemsCol = this.items;
      this.isVertical = this.element.classList.contains(CLS_VERTICAL) ? true : false;
      this.isExtendedOpen = false;
      this.popupPriCount = 0;
      if (this.enableRtl) {
        this.add(this.element, CLS_RTL);
      }
    };
    Toolbar2.prototype.wireEvents = function() {
      EventHandler.add(this.element, "click", this.clickHandler, this);
      (undefined).addEventListener("resize", this.resizeContext);
      (undefined).addEventListener("orientationchange", this.orientationChangeContext);
      if (this.allowKeyboard) {
        this.wireKeyboardEvent();
      }
    };
    Toolbar2.prototype.wireKeyboardEvent = function() {
      this.keyModule = new KeyboardEvents(this.element, {
        keyAction: this.keyActionHandler.bind(this),
        keyConfigs: this.keyConfigs
      });
      EventHandler.add(this.element, "keydown", this.docKeyDown, this);
      this.updateTabIndex("0");
    };
    Toolbar2.prototype.updateTabIndex = function(tabIndex) {
      var ele = this.element.querySelector("." + CLS_ITEM + ":not(." + CLS_DISABLE + " ):not(." + CLS_SEPARATOR + " ):not(." + CLS_HIDDEN + " )");
      if (!isNullOrUndefined(ele) && !isNullOrUndefined(ele.firstElementChild)) {
        var dataTabIndex = ele.firstElementChild.getAttribute("data-tabindex");
        if (dataTabIndex && dataTabIndex === "-1" && ele.firstElementChild.tagName !== "INPUT") {
          ele.firstElementChild.setAttribute("tabindex", tabIndex);
        }
      }
    };
    Toolbar2.prototype.unwireKeyboardEvent = function() {
      if (this.keyModule) {
        EventHandler.remove(this.element, "keydown", this.docKeyDown);
        this.keyModule.destroy();
        this.keyModule = null;
      }
    };
    Toolbar2.prototype.docKeyDown = function(e) {
      if (e.target.tagName === "INPUT") {
        return;
      }
      var popCheck = !isNullOrUndefined(this.popObj) && isVisible(this.popObj.element) && this.overflowMode !== "Extended";
      if (e.keyCode === 9 && e.target.classList.contains("e-hor-nav") === true && popCheck) {
        this.popObj.hide({ name: "FadeOut", duration: 100 });
      }
      var keyCheck = e.keyCode === 40 || e.keyCode === 38 || e.keyCode === 35 || e.keyCode === 36;
      if (keyCheck) {
        e.preventDefault();
      }
    };
    Toolbar2.prototype.unwireEvents = function() {
      EventHandler.remove(this.element, "click", this.clickHandler);
      this.destroyScroll();
      this.unwireKeyboardEvent();
      (undefined).removeEventListener("resize", this.resizeContext);
      (undefined).removeEventListener("orientationchange", this.orientationChangeContext);
      (undefined).removeEventListener("scroll", this.clickEvent);
      (undefined).removeEventListener("click", this.scrollEvent);
      this.scrollEvent = null;
      this.clickEvent = null;
    };
    Toolbar2.prototype.clearProperty = function() {
      this.tbarEle = [];
      this.tbarAlgEle = { lefts: [], centers: [], rights: [] };
    };
    Toolbar2.prototype.docEvent = function(e) {
      var popEle = closest(e.target, ".e-popup");
      if (this.popObj && isVisible(this.popObj.element) && !popEle && this.overflowMode === "Popup") {
        this.popObj.hide({ name: "FadeOut", duration: 100 });
      }
    };
    Toolbar2.prototype.destroyScroll = function() {
      if (this.scrollModule) {
        if (this.tbarAlign) {
          this.add(this.scrollModule.element, CLS_TBARPOS);
        }
        this.scrollModule.destroy();
        this.scrollModule = null;
      }
    };
    Toolbar2.prototype.destroyItems = function() {
      if (this.element) {
        [].slice.call(this.element.querySelectorAll("." + CLS_ITEM)).forEach(function(el) {
          detach(el);
        });
      }
      if (this.tbarAlign) {
        var tbarItems = this.element.querySelector("." + CLS_ITEMS);
        [].slice.call(tbarItems.children).forEach(function(el) {
          detach(el);
        });
        this.tbarAlign = false;
        this.remove(tbarItems, CLS_TBARPOS);
      }
      this.clearProperty();
    };
    Toolbar2.prototype.destroyMode = function() {
      if (this.scrollModule) {
        this.remove(this.scrollModule.element, CLS_RTL);
        this.destroyScroll();
      }
      this.remove(this.element, CLS_EXTENDEDPOPOPEN);
      this.remove(this.element, CLS_EXTEANDABLE_TOOLBAR);
      var tempEle = this.element.querySelector(".e-toolbar-multirow");
      if (tempEle) {
        this.remove(tempEle, CLS_MULTIROW);
      }
      if (this.popObj) {
        this.popupRefresh(this.popObj.element, true);
      }
    };
    Toolbar2.prototype.add = function(ele, val) {
      ele.classList.add(val);
    };
    Toolbar2.prototype.remove = function(ele, val) {
      ele.classList.remove(val);
    };
    Toolbar2.prototype.elementFocus = function(ele) {
      var fChild = ele.firstElementChild;
      if (fChild) {
        fChild.focus();
        this.activeEleSwitch(ele);
      } else {
        ele.focus();
      }
    };
    Toolbar2.prototype.clstElement = function(tbrNavChk, trgt) {
      var clst;
      if (tbrNavChk && this.popObj && isVisible(this.popObj.element)) {
        clst = this.popObj.element.querySelector("." + CLS_ITEM);
      } else if (this.element === trgt || tbrNavChk) {
        clst = this.element.querySelector("." + CLS_ITEM + ":not(." + CLS_DISABLE + " ):not(." + CLS_SEPARATOR + " ):not(." + CLS_HIDDEN + " )");
      } else {
        clst = closest(trgt, "." + CLS_ITEM);
      }
      return clst;
    };
    Toolbar2.prototype.keyHandling = function(clst, e, trgt, navChk, scrollChk) {
      var popObj = this.popObj;
      var rootEle = this.element;
      var popAnimate = { name: "FadeOut", duration: 100 };
      var value = e.action === "moveUp" ? "previous" : "next";
      var ele;
      var nodes;
      switch (e.action) {
        case "moveRight":
          if (this.isVertical) {
            return;
          }
          if (rootEle === trgt) {
            this.elementFocus(clst);
          } else if (!navChk) {
            this.eleFocus(clst, "next");
          }
          break;
        case "moveLeft":
          if (this.isVertical) {
            return;
          }
          if (!navChk) {
            this.eleFocus(clst, "previous");
          }
          break;
        case "home":
        case "end":
          if (clst) {
            var popupCheck = closest(clst, ".e-popup");
            var extendedPopup = this.element.querySelector("." + CLS_EXTENDABLECLASS);
            if (this.overflowMode === "Extended" && extendedPopup && extendedPopup.classList.contains("e-popup-open")) {
              popupCheck = e.action === "end" ? extendedPopup : null;
            }
            if (popupCheck) {
              if (isVisible(this.popObj.element)) {
                nodes = [].slice.call(popupCheck.children);
                if (e.action === "home") {
                  ele = this.focusFirstVisibleEle(nodes);
                } else {
                  ele = this.focusLastVisibleEle(nodes);
                }
              }
            } else {
              nodes = this.element.querySelectorAll("." + CLS_ITEMS + " ." + CLS_ITEM + ":not(." + CLS_SEPARATOR + ")");
              if (e.action === "home") {
                ele = this.focusFirstVisibleEle(nodes);
              } else {
                ele = this.focusLastVisibleEle(nodes);
              }
            }
            if (ele) {
              this.elementFocus(ele);
            }
          }
          break;
        case "moveUp":
        case "moveDown":
          if (!this.isVertical) {
            if (popObj && closest(trgt, ".e-popup")) {
              var popEle = popObj.element;
              var popFrstEle = popEle.firstElementChild;
              if (value === "previous" && popFrstEle === clst) {
                popEle.lastElementChild.firstChild.focus();
              } else if (value === "next" && popEle.lastElementChild === clst) {
                popFrstEle.firstChild.focus();
              } else {
                this.eleFocus(clst, value);
              }
            } else if (e.action === "moveDown" && popObj && isVisible(popObj.element)) {
              this.elementFocus(clst);
            }
          } else {
            if (e.action === "moveUp") {
              this.eleFocus(clst, "previous");
            } else {
              this.eleFocus(clst, "next");
            }
          }
          break;
        case "tab":
          if (!scrollChk && !navChk) {
            var ele_1 = clst.firstElementChild;
            if (rootEle === trgt) {
              if (this.activeEle) {
                this.activeEle.focus();
              } else {
                this.activeEleRemove(ele_1);
                ele_1.focus();
              }
            }
          }
          break;
        case "popupClose":
          if (popObj && this.overflowMode !== "Extended") {
            popObj.hide(popAnimate);
          }
          break;
        case "popupOpen":
          if (!navChk) {
            return;
          }
          if (popObj && !isVisible(popObj.element)) {
            popObj.element.style.top = rootEle.offsetHeight + "px";
            popObj.show({ name: "FadeIn", duration: 100 });
          } else {
            popObj.hide(popAnimate);
          }
          break;
      }
    };
    Toolbar2.prototype.keyActionHandler = function(e) {
      var trgt = e.target;
      if (trgt.tagName === "INPUT" || trgt.tagName === "TEXTAREA" || this.element.classList.contains(CLS_DISABLE)) {
        return;
      }
      e.preventDefault();
      var tbrNavChk = trgt.classList.contains(CLS_TBARNAV);
      var tbarScrollChk = trgt.classList.contains(CLS_TBARSCRLNAV);
      var clst = this.clstElement(tbrNavChk, trgt);
      if (clst || tbarScrollChk) {
        this.keyHandling(clst, e, trgt, tbrNavChk, tbarScrollChk);
      }
    };
    Toolbar2.prototype.disable = function(value) {
      var rootEle = this.element;
      if (value) {
        rootEle.classList.add(CLS_DISABLE);
      } else {
        rootEle.classList.remove(CLS_DISABLE);
      }
      if (this.activeEle) {
        this.activeEle.setAttribute("tabindex", this.activeEle.getAttribute("data-tabindex"));
      }
      if (this.scrollModule) {
        this.scrollModule.disable(value);
      }
      if (this.popObj) {
        if (isVisible(this.popObj.element) && this.overflowMode !== "Extended") {
          this.popObj.hide();
        }
        rootEle.querySelector("#" + rootEle.id + "_nav").setAttribute("tabindex", !value ? "0" : "-1");
      }
    };
    Toolbar2.prototype.eleContains = function(el) {
      return el.classList.contains(CLS_SEPARATOR) || el.classList.contains(CLS_DISABLE) || el.getAttribute("disabled") || el.classList.contains(CLS_HIDDEN) || !isVisible(el) || !el.classList.contains(CLS_ITEM);
    };
    Toolbar2.prototype.focusFirstVisibleEle = function(nodes) {
      var element2;
      var index = 0;
      while (index < nodes.length) {
        var ele = nodes[parseInt(index.toString(), 10)];
        if (!ele.classList.contains(CLS_HIDDEN) && !ele.classList.contains(CLS_DISABLE)) {
          return ele;
        }
        index++;
      }
      return element2;
    };
    Toolbar2.prototype.focusLastVisibleEle = function(nodes) {
      var element2;
      var index = nodes.length - 1;
      while (index >= 0) {
        var ele = nodes[parseInt(index.toString(), 10)];
        if (!ele.classList.contains(CLS_HIDDEN) && !ele.classList.contains(CLS_DISABLE)) {
          return ele;
        }
        index--;
      }
      return element2;
    };
    Toolbar2.prototype.eleFocus = function(closest2, pos) {
      var sib = Object(closest2)[pos + "ElementSibling"];
      if (sib) {
        var skipEle = this.eleContains(sib);
        if (skipEle) {
          this.eleFocus(sib, pos);
          return;
        }
        this.elementFocus(sib);
      } else if (this.tbarAlign) {
        var elem = Object(closest2.parentElement)[pos + "ElementSibling"];
        if (!isNullOrUndefined(elem) && elem.children.length === 0) {
          elem = Object(elem)[pos + "ElementSibling"];
        }
        if (!isNullOrUndefined(elem) && elem.children.length > 0) {
          if (pos === "next") {
            var el = elem.querySelector("." + CLS_ITEM);
            if (this.eleContains(el)) {
              this.eleFocus(el, pos);
            } else {
              el.firstElementChild.focus();
              this.activeEleSwitch(el);
            }
          } else {
            var el = elem.lastElementChild;
            if (this.eleContains(el)) {
              this.eleFocus(el, pos);
            } else {
              this.elementFocus(el);
            }
          }
        }
      } else if (!isNullOrUndefined(closest2)) {
        var tbrItems = this.element.querySelectorAll("." + CLS_ITEMS + " ." + CLS_ITEM + ":not(." + CLS_SEPARATOR + "):not(." + CLS_DISABLE + "):not(." + CLS_HIDDEN + ")");
        if (pos === "next" && tbrItems) {
          this.elementFocus(tbrItems[0]);
        } else if (pos === "previous" && tbrItems) {
          this.elementFocus(tbrItems[tbrItems.length - 1]);
        }
      }
    };
    Toolbar2.prototype.clickHandler = function(e) {
      var _this = this;
      var trgt = e.target;
      var ele = this.element;
      var isPopupElement = !isNullOrUndefined(closest(trgt, "." + CLS_POPUPCLASS));
      var clsList = trgt.classList;
      var popupNav = closest(trgt, "." + CLS_TBARNAV);
      if (!popupNav) {
        popupNav = trgt;
      }
      if (!ele.children[0].classList.contains("e-hscroll") && !ele.children[0].classList.contains("e-vscroll") && clsList.contains(CLS_TBARNAV)) {
        clsList = trgt.querySelector(".e-icons").classList;
      }
      if (clsList.contains(CLS_POPUPICON) || clsList.contains(CLS_POPUPDOWN)) {
        this.popupClickHandler(ele, popupNav, CLS_RTL);
      }
      var itemObj;
      var clst = closest(e.target, "." + CLS_ITEM);
      if ((isNullOrUndefined(clst) || clst.classList.contains(CLS_DISABLE)) && !popupNav.classList.contains(CLS_TBARNAV)) {
        return;
      }
      if (clst) {
        var tempItem = this.items[this.tbarEle.indexOf(clst)];
        itemObj = tempItem;
      }
      var eventArgs = { originalEvent: e, item: itemObj };
      var isClickBinded = itemObj && !isNullOrUndefined(itemObj.click) && typeof itemObj.click == "object" ? !isNullOrUndefined(itemObj.click.observers) && itemObj.click.observers.length > 0 : !isNullOrUndefined(itemObj) && !isNullOrUndefined(itemObj.click);
      if (isClickBinded) {
        this.trigger("items[" + this.tbarEle.indexOf(clst) + "].click", eventArgs);
      }
      if (!eventArgs.cancel) {
        this.trigger("clicked", eventArgs, function(clickedArgs) {
          if (!isNullOrUndefined(_this.popObj) && isPopupElement && !clickedArgs.cancel && _this.overflowMode === "Popup" && clickedArgs.item && clickedArgs.item.type !== "Input") {
            _this.popObj.hide({ name: "FadeOut", duration: 100 });
          }
        });
      }
    };
    Toolbar2.prototype.popupClickHandler = function(ele, popupNav, CLS_RTL2) {
      var popObj = this.popObj;
      if (isVisible(popObj.element)) {
        popupNav.classList.remove(CLS_TBARNAVACT);
        popObj.hide({ name: "FadeOut", duration: 100 });
      } else {
        if (ele.classList.contains(CLS_RTL2)) {
          popObj.enableRtl = true;
          popObj.position = { X: "left", Y: "top" };
        }
        if (popObj.offsetX === 0 && !ele.classList.contains(CLS_RTL2)) {
          popObj.enableRtl = false;
          popObj.position = { X: "right", Y: "top" };
        }
        if (this.overflowMode === "Extended") {
          popObj.element.style.minHeight = "0px";
          popObj.width = this.getToolbarPopupWidth(this.element);
        }
        popObj.dataBind();
        popObj.refreshPosition();
        popObj.element.style.top = this.getElementOffsetY() + "px";
        popupNav.classList.add(CLS_TBARNAVACT);
        popObj.show({ name: "FadeIn", duration: 100 });
      }
    };
    Toolbar2.prototype.getToolbarPopupWidth = function(ele) {
      var eleStyles = (undefined).getComputedStyle(ele);
      return parseFloat(eleStyles.width) + parseFloat(eleStyles.borderRightWidth) * 2;
    };
    Toolbar2.prototype.render = function() {
      var _this = this;
      this.initialize();
      this.renderControl();
      this.wireEvents();
      this.clickEvent = this.docEvent.bind(this);
      this.scrollEvent = this.docEvent.bind(this);
      this.renderComplete();
      if (this.isReact && this.portals && this.portals.length > 0) {
        this.renderReactTemplates(function() {
          _this.refreshOverflow();
        });
      }
    };
    Toolbar2.prototype.initialize = function() {
      var width = formatUnit(this.width);
      var height = formatUnit(this.height);
      if (Browser.info.name !== "msie" || this.height !== "auto" || this.overflowMode === "MultiRow") {
        setStyleAttribute(this.element, { "height": height });
      }
      setStyleAttribute(this.element, { "width": width });
      var ariaAttr = {
        "role": "toolbar",
        "aria-disabled": "false",
        "aria-orientation": !this.isVertical ? "horizontal" : "vertical"
      };
      attributes(this.element, ariaAttr);
      if (this.cssClass) {
        addClass([this.element], this.cssClass.split(" "));
      }
    };
    Toolbar2.prototype.renderControl = function() {
      var ele = this.element;
      this.trgtEle = ele.children.length > 0 ? ele.querySelector("div") : null;
      this.tbarAlgEle = { lefts: [], centers: [], rights: [] };
      this.renderItems();
      this.renderLayout();
    };
    Toolbar2.prototype.renderLayout = function() {
      this.renderOverflowMode();
      if (this.tbarAlign) {
        this.itemPositioning();
      }
      if (this.popObj && this.popObj.element.childElementCount > 1 && this.checkPopupRefresh(this.element, this.popObj.element)) {
        this.popupRefresh(this.popObj.element, false);
      }
      this.separator();
    };
    Toolbar2.prototype.itemsAlign = function(items, itemEleDom) {
      var innerItem;
      var innerPos;
      if (!this.tbarEle) {
        this.tbarEle = [];
      }
      for (var i = 0; i < items.length; i++) {
        innerItem = this.renderSubComponent(items[parseInt(i.toString(), 10)], i);
        if (this.tbarEle.indexOf(innerItem) === -1) {
          this.tbarEle.push(innerItem);
        }
        if (!this.tbarAlign) {
          this.tbarItemAlign(items[parseInt(i.toString(), 10)], itemEleDom, i);
        }
        innerPos = itemEleDom.querySelector(".e-toolbar-" + items[parseInt(i.toString(), 10)].align.toLowerCase());
        if (innerPos) {
          if (!(items[parseInt(i.toString(), 10)].showAlwaysInPopup && items[parseInt(i.toString(), 10)].overflow !== "Show")) {
            this.tbarAlgEle[(items[parseInt(i.toString(), 10)].align + "s").toLowerCase()].push(innerItem);
          }
          innerPos.appendChild(innerItem);
        } else {
          itemEleDom.appendChild(innerItem);
        }
      }
      if (this.isReact) {
        var portals = "portals";
        this.notify("render-react-toolbar-template", this["" + portals]);
        this.renderReactTemplates();
      }
    };
    Toolbar2.prototype.changeOrientation = function() {
      var ele = this.element;
      if (this.isVertical) {
        ele.classList.remove(CLS_VERTICAL);
        this.isVertical = false;
        if (this.height === "auto" || this.height === "100%") {
          ele.style.height = this.height;
        }
        ele.setAttribute("aria-orientation", "horizontal");
      } else {
        ele.classList.add(CLS_VERTICAL);
        this.isVertical = true;
        ele.setAttribute("aria-orientation", "vertical");
        setStyleAttribute(this.element, { "height": formatUnit(this.height), "width": formatUnit(this.width) });
      }
      this.destroyMode();
      this.refreshOverflow();
    };
    Toolbar2.prototype.initScroll = function(element2, innerItems) {
      if (!this.scrollModule && this.checkOverflow(element2, innerItems[0])) {
        if (this.tbarAlign) {
          this.element.querySelector("." + CLS_ITEMS + " ." + CLS_TBARCENTER).removeAttribute("style");
        }
        if (this.isVertical) {
          this.scrollModule = new VScroll({ scrollStep: this.scrollStep, enableRtl: this.enableRtl }, innerItems[0]);
        } else {
          this.scrollModule = new HScroll({ scrollStep: this.scrollStep, enableRtl: this.enableRtl }, innerItems[0]);
        }
        if (this.cssClass) {
          addClass([innerItems[0]], this.cssClass.split(" "));
        }
        var scrollEle = this.scrollModule.element.querySelector("." + CLS_HSCROLLBAR + ", .e-vscroll-bar");
        if (scrollEle) {
          scrollEle.removeAttribute("tabindex");
        }
        this.remove(this.scrollModule.element, CLS_TBARPOS);
        setStyleAttribute(this.element, { overflow: "hidden" });
      }
    };
    Toolbar2.prototype.itemWidthCal = function(items) {
      var _this = this;
      var width = 0;
      var style;
      [].slice.call(selectAll("." + CLS_ITEM, items)).forEach(function(el) {
        if (isVisible(el)) {
          style = (undefined).getComputedStyle(el);
          width += _this.isVertical ? el.offsetHeight : el.offsetWidth;
          width += parseFloat(_this.isVertical ? style.marginTop : style.marginRight);
          width += parseFloat(_this.isVertical ? style.marginBottom : style.marginLeft);
        }
      });
      return width;
    };
    Toolbar2.prototype.getScrollCntEle = function(innerItem) {
      var trgClass = this.isVertical ? ".e-vscroll-content" : ".e-hscroll-content";
      return innerItem.querySelector(trgClass);
    };
    Toolbar2.prototype.checkOverflow = function(element2, innerItem) {
      if (isNullOrUndefined(element2) || isNullOrUndefined(innerItem) || !isVisible(element2)) {
        return false;
      }
      var eleWidth = this.isVertical ? element2.offsetHeight : element2.offsetWidth;
      var itemWidth = this.isVertical ? innerItem.offsetHeight : innerItem.offsetWidth;
      if (this.tbarAlign || this.scrollModule || eleWidth === itemWidth) {
        itemWidth = this.itemWidthCal(this.scrollModule ? this.getScrollCntEle(innerItem) : innerItem);
      }
      var popNav = element2.querySelector("." + CLS_TBARNAV);
      var scrollNav = element2.querySelector("." + CLS_TBARSCRLNAV);
      var navEleWidth = 0;
      if (popNav) {
        navEleWidth = this.isVertical ? popNav.offsetHeight : popNav.offsetWidth;
      } else if (scrollNav) {
        navEleWidth = this.isVertical ? scrollNav.offsetHeight * 2 : scrollNav.offsetWidth * 2;
      }
      if (eleWidth >= itemWidth && scrollNav) {
        return false;
      } else if (itemWidth > eleWidth - navEleWidth) {
        return true;
      } else {
        return false;
      }
    };
    Toolbar2.prototype.refreshOverflow = function() {
      this.resize();
    };
    Toolbar2.prototype.toolbarAlign = function(innerItems) {
      if (this.tbarAlign) {
        this.add(innerItems, CLS_TBARPOS);
        this.itemPositioning();
      }
    };
    Toolbar2.prototype.renderOverflowMode = function() {
      var ele = this.element;
      var innerItems = ele.querySelector("." + CLS_ITEMS);
      var priorityCheck = this.popupPriCount > 0;
      if (ele && ele.children.length > 0) {
        this.offsetWid = ele.offsetWidth;
        this.remove(this.element, "e-toolpop");
        if (Browser.info.name === "msie" && this.height === "auto") {
          ele.style.height = "";
        }
        switch (this.overflowMode) {
          case "Scrollable":
            if (isNullOrUndefined(this.scrollModule)) {
              this.initScroll(ele, [].slice.call(ele.getElementsByClassName(CLS_ITEMS)));
            }
            break;
          case "Popup":
            this.add(this.element, "e-toolpop");
            if (this.tbarAlign) {
              this.removePositioning();
            }
            if (this.checkOverflow(ele, innerItems) || priorityCheck) {
              this.setOverflowAttributes(ele);
            }
            this.toolbarAlign(innerItems);
            break;
          case "MultiRow":
            this.add(innerItems, CLS_MULTIROW);
            if (this.checkOverflow(ele, innerItems) && this.tbarAlign) {
              this.removePositioning();
              this.add(innerItems, CLS_MULTIROWPOS);
            }
            if (ele.style.overflow === "hidden") {
              ele.style.overflow = "";
            }
            if (Browser.info.name === "msie" || ele.style.height !== "auto") {
              ele.style.height = "auto";
            }
            break;
          case "Extended":
            this.add(this.element, CLS_EXTEANDABLE_TOOLBAR);
            if (this.checkOverflow(ele, innerItems) || priorityCheck) {
              if (this.tbarAlign) {
                this.removePositioning();
              }
              this.setOverflowAttributes(ele);
            }
            this.toolbarAlign(innerItems);
        }
      }
    };
    Toolbar2.prototype.setOverflowAttributes = function(ele) {
      this.createPopupEle(ele, [].slice.call(selectAll("." + CLS_ITEMS + " ." + CLS_ITEM, ele)));
      var ariaAttr = {
        "tabindex": "0",
        "role": "button",
        "aria-haspopup": "true",
        "aria-label": "overflow"
      };
      attributes(this.element.querySelector("." + CLS_TBARNAV), ariaAttr);
    };
    Toolbar2.prototype.separator = function() {
      var element2 = this.element;
      var eleItem = [].slice.call(element2.querySelectorAll("." + CLS_SEPARATOR));
      var multiVar = element2.querySelector("." + CLS_MULTIROW_SEPARATOR);
      var extendVar = element2.querySelector("." + CLS_EXTENDABLE_SEPARATOR);
      var eleInlineItem = this.overflowMode === "MultiRow" ? multiVar : extendVar;
      if (eleInlineItem !== null) {
        if (this.overflowMode === "MultiRow") {
          eleInlineItem.classList.remove(CLS_MULTIROW_SEPARATOR);
        } else if (this.overflowMode === "Extended") {
          eleInlineItem.classList.remove(CLS_EXTENDABLE_SEPARATOR);
        }
      }
      for (var i = 0; i <= eleItem.length - 1; i++) {
        if (eleItem[parseInt(i.toString(), 10)].offsetLeft < 30 && eleItem[parseInt(i.toString(), 10)].offsetLeft !== 0) {
          if (this.overflowMode === "MultiRow") {
            eleItem[parseInt(i.toString(), 10)].classList.add(CLS_MULTIROW_SEPARATOR);
          } else if (this.overflowMode === "Extended") {
            eleItem[parseInt(i.toString(), 10)].classList.add(CLS_EXTENDABLE_SEPARATOR);
          }
        }
      }
    };
    Toolbar2.prototype.createPopupEle = function(ele, innerEle) {
      var innerNav = ele.querySelector("." + CLS_TBARNAV);
      var vertical = this.isVertical;
      if (!innerNav) {
        this.createPopupIcon(ele);
      }
      innerNav = ele.querySelector("." + CLS_TBARNAV);
      var innerNavDom = vertical ? innerNav.offsetHeight : innerNav.offsetWidth;
      var eleWidth = (vertical ? ele.offsetHeight : ele.offsetWidth) - innerNavDom;
      this.element.classList.remove("e-rtl");
      setStyleAttribute(this.element, { direction: "initial" });
      this.checkPriority(ele, innerEle, eleWidth, true);
      if (this.enableRtl) {
        this.element.classList.add("e-rtl");
      }
      this.element.style.removeProperty("direction");
      this.createPopup();
    };
    Toolbar2.prototype.pushingPoppedEle = function(tbarObj, popupPri, ele, eleHeight, sepHeight) {
      var element2 = tbarObj.element;
      var poppedEle = [].slice.call(selectAll("." + CLS_POPUP, element2.querySelector("." + CLS_ITEMS)));
      var nodes = selectAll("." + CLS_TBAROVERFLOW, ele);
      var nodeIndex = 0;
      var nodePri = 0;
      poppedEle.forEach(function(el, index) {
        nodes = selectAll("." + CLS_TBAROVERFLOW, ele);
        if (el.classList.contains(CLS_TBAROVERFLOW) && nodes.length > 0) {
          if (tbarObj.tbResize && nodes.length > index) {
            ele.insertBefore(el, nodes[parseInt(index.toString(), 10)]);
            ++nodePri;
          } else {
            ele.insertBefore(el, ele.children[nodes.length]);
            ++nodePri;
          }
        } else if (el.classList.contains(CLS_TBAROVERFLOW)) {
          ele.insertBefore(el, ele.firstChild);
          ++nodePri;
        } else if (tbarObj.tbResize && el.classList.contains(CLS_POPOVERFLOW) && ele.children.length > 0 && nodes.length === 0) {
          ele.insertBefore(el, ele.firstChild);
          ++nodePri;
        } else if (el.classList.contains(CLS_POPOVERFLOW)) {
          popupPri.push(el);
        } else if (tbarObj.tbResize) {
          ele.insertBefore(el, ele.childNodes[nodeIndex + nodePri]);
          ++nodeIndex;
        } else {
          ele.appendChild(el);
        }
        if (el.classList.contains(CLS_SEPARATOR)) {
          setStyleAttribute(el, { display: "", height: sepHeight + "px" });
        } else {
          setStyleAttribute(el, { display: "", height: eleHeight + "px" });
        }
      });
      popupPri.forEach(function(el) {
        ele.appendChild(el);
      });
      var tbarEle = selectAll("." + CLS_ITEM, element2.querySelector("." + CLS_ITEMS));
      for (var i = tbarEle.length - 1; i >= 0; i--) {
        var tbarElement = tbarEle[parseInt(i.toString(), 10)];
        if (tbarElement.classList.contains(CLS_SEPARATOR) && this.overflowMode !== "Extended") {
          setStyleAttribute(tbarElement, { display: "none" });
        } else {
          break;
        }
      }
    };
    Toolbar2.prototype.createPopup = function() {
      var element2 = this.element;
      var sepHeight;
      var sepItem;
      if (this.overflowMode === "Extended") {
        sepItem = element2.querySelector("." + CLS_SEPARATOR);
        sepHeight = element2.style.height === "auto" || element2.style.height === "" ? null : sepItem && sepItem.offsetHeight;
      }
      var eleItem = element2.querySelector("." + CLS_ITEM + ":not(." + CLS_SEPARATOR + "):not(." + CLS_POPUP + ")");
      var eleHeight = element2.style.height === "auto" || element2.style.height === "" ? null : eleItem && eleItem.offsetHeight;
      var ele;
      var popupPri = [];
      if (select("#" + element2.id + "_popup." + CLS_POPUPCLASS, element2)) {
        ele = select("#" + element2.id + "_popup." + CLS_POPUPCLASS, element2);
      } else {
        var extendEle = this.createElement("div", {
          id: element2.id + "_popup",
          className: CLS_POPUPCLASS + " " + CLS_EXTENDABLECLASS
        });
        var popupEle = this.createElement("div", { id: element2.id + "_popup", className: CLS_POPUPCLASS });
        ele = this.overflowMode === "Extended" ? extendEle : popupEle;
      }
      this.pushingPoppedEle(this, popupPri, ele, eleHeight, sepHeight);
      this.popupInit(element2, ele);
    };
    Toolbar2.prototype.getElementOffsetY = function() {
      return this.overflowMode === "Extended" && (undefined).getComputedStyle(this.element).getPropertyValue("box-sizing") === "border-box" ? this.element.clientHeight : this.element.offsetHeight;
    };
    Toolbar2.prototype.popupInit = function(element2, ele) {
      if (!this.popObj) {
        element2.appendChild(ele);
        if (this.cssClass) {
          addClass([ele], this.cssClass.split(" "));
        }
        setStyleAttribute(this.element, { overflow: "" });
        var popup = new Popup(null, {
          relateTo: this.element,
          offsetY: this.isVertical ? 0 : this.getElementOffsetY(),
          enableRtl: this.enableRtl,
          open: this.popupOpen.bind(this),
          close: this.popupClose.bind(this),
          collision: { Y: this.enableCollision ? "flip" : "none" },
          position: this.enableRtl ? { X: "left", Y: "top" } : { X: "right", Y: "top" }
        });
        if (this.overflowMode === "Extended") {
          popup.width = this.getToolbarPopupWidth(this.element);
          popup.offsetX = 0;
        }
        popup.appendTo(ele);
        (undefined).addEventListener("scroll", this.clickEvent);
        (undefined).addEventListener("click", this.scrollEvent);
        if (this.overflowMode !== "Extended") {
          popup.element.style.maxHeight = popup.element.offsetHeight + "px";
        }
        if (this.isVertical) {
          popup.element.style.visibility = "hidden";
        }
        if (this.isExtendedOpen) {
          var popupNav = this.element.querySelector("." + CLS_TBARNAV);
          popupNav.classList.add(CLS_TBARNAVACT);
          classList(popupNav.firstElementChild, [CLS_POPUPICON], [CLS_POPUPDOWN]);
          this.element.querySelector("." + CLS_EXTENDABLECLASS).classList.add(CLS_POPUPOPEN);
        } else {
          popup.hide();
        }
        this.popObj = popup;
      } else if (this.overflowMode !== "Extended") {
        var popupEle = this.popObj.element;
        setStyleAttribute(popupEle, { maxHeight: "", display: "block" });
        setStyleAttribute(popupEle, { maxHeight: popupEle.offsetHeight + "px", display: "" });
      }
    };
    Toolbar2.prototype.tbarPopupHandler = function(isOpen) {
      if (this.overflowMode === "Extended") {
        if (isOpen) {
          this.add(this.element, CLS_EXTENDEDPOPOPEN);
        } else {
          this.remove(this.element, CLS_EXTENDEDPOPOPEN);
        }
      }
    };
    Toolbar2.prototype.popupOpen = function(e) {
      var popObj = this.popObj;
      if (!this.isVertical) {
        popObj.offsetY = this.getElementOffsetY();
        popObj.dataBind();
      }
      var popupEle = this.popObj.element;
      var toolEle = this.popObj.element.parentElement;
      var popupNav = toolEle.querySelector("." + CLS_TBARNAV);
      popupNav.setAttribute("aria-expanded", "true");
      if (this.overflowMode === "Extended") {
        popObj.element.style.minHeight = "";
      } else {
        setStyleAttribute(popObj.element, { height: "auto", maxHeight: "" });
        popObj.element.style.maxHeight = popObj.element.offsetHeight + "px";
      }
      var popupElePos = popupEle.offsetTop + popupEle.offsetHeight + calculatePosition(toolEle).top;
      var popIcon = popupNav.firstElementChild;
      popupNav.classList.add(CLS_TBARNAVACT);
      classList(popIcon, [CLS_POPUPICON], [CLS_POPUPDOWN]);
      this.tbarPopupHandler(true);
      var scrollVal = isNullOrUndefined((undefined).scrollY) ? 0 : (undefined).scrollY;
      if (!this.isVertical && (undefined).innerHeight + scrollVal < popupElePos && this.element.offsetTop < popupEle.offsetHeight) {
        var overflowHeight = popupEle.offsetHeight - (popupElePos - (undefined).innerHeight - scrollVal + 5);
        popObj.height = overflowHeight + "px";
        for (var i = 0; i <= popupEle.childElementCount; i++) {
          var ele = popupEle.children[parseInt(i.toString(), 10)];
          if (ele.offsetTop + ele.offsetHeight > overflowHeight) {
            overflowHeight = ele.offsetTop;
            break;
          }
        }
        if (this.overflowMode !== "Extended") {
          setStyleAttribute(popObj.element, { maxHeight: overflowHeight + "px" });
        }
      } else if (this.isVertical && this.overflowMode !== "Extended") {
        var tbEleData = this.element.getBoundingClientRect();
        setStyleAttribute(popObj.element, { maxHeight: tbEleData.top + this.element.offsetHeight + "px", bottom: 0, visibility: "" });
      }
      if (popObj) {
        var popupOffset = popupEle.getBoundingClientRect();
        if (popupOffset.right > (undefined).documentElement.clientWidth && popupOffset.width > toolEle.getBoundingClientRect().width) {
          popObj.collision = { Y: "none" };
          popObj.dataBind();
        }
        popObj.refreshPosition();
      }
    };
    Toolbar2.prototype.popupClose = function(e) {
      var element2 = this.element;
      var popupNav = element2.querySelector("." + CLS_TBARNAV);
      popupNav.setAttribute("aria-expanded", "false");
      var popIcon = popupNav.firstElementChild;
      popupNav.classList.remove(CLS_TBARNAVACT);
      classList(popIcon, [CLS_POPUPDOWN], [CLS_POPUPICON]);
      this.tbarPopupHandler(false);
    };
    Toolbar2.prototype.checkPriority = function(ele, inEle, eleWidth, pre) {
      var popPriority = this.popupPriCount > 0;
      var len = inEle.length;
      var eleWid = eleWidth;
      var eleOffset;
      var checkoffset;
      var sepCheck = 0;
      var itemCount = 0;
      var itemPopCount = 0;
      var checkClass = function(ele2, val) {
        var rVal = false;
        val.forEach(function(cls) {
          if (ele2.classList.contains(cls)) {
            rVal = true;
          }
        });
        return rVal;
      };
      for (var i = len - 1; i >= 0; i--) {
        var mrgn = undefined;
        var compuStyle = (undefined).getComputedStyle(inEle[parseInt(i.toString(), 10)]);
        if (this.isVertical) {
          mrgn = parseFloat(compuStyle.marginTop);
          mrgn += parseFloat(compuStyle.marginBottom);
        } else {
          mrgn = parseFloat(compuStyle.marginRight);
          mrgn += parseFloat(compuStyle.marginLeft);
        }
        var fstEleCheck = inEle[parseInt(i.toString(), 10)] === this.tbarEle[0];
        if (fstEleCheck) {
          this.tbarEleMrgn = mrgn;
        }
        eleOffset = this.isVertical ? inEle[parseInt(i.toString(), 10)].offsetHeight : inEle[parseInt(i.toString(), 10)].offsetWidth;
        var eleWid_1 = fstEleCheck ? eleOffset + mrgn : eleOffset;
        if (checkClass(inEle[parseInt(i.toString(), 10)], [CLS_POPPRI]) && popPriority) {
          inEle[parseInt(i.toString(), 10)].classList.add(CLS_POPUP);
          if (this.isVertical) {
            setStyleAttribute(inEle[parseInt(i.toString(), 10)], { display: "none", minHeight: eleWid_1 + "px" });
          } else {
            setStyleAttribute(inEle[parseInt(i.toString(), 10)], { display: "none", minWidth: eleWid_1 + "px" });
          }
          itemPopCount++;
        }
        if (this.isVertical) {
          checkoffset = inEle[parseInt(i.toString(), 10)].offsetTop + inEle[parseInt(i.toString(), 10)].offsetHeight + mrgn > eleWidth;
        } else {
          checkoffset = inEle[parseInt(i.toString(), 10)].offsetLeft + inEle[parseInt(i.toString(), 10)].offsetWidth + mrgn > eleWidth;
        }
        if (checkoffset) {
          if (inEle[parseInt(i.toString(), 10)].classList.contains(CLS_SEPARATOR)) {
            if (this.overflowMode === "Extended") {
              var sepEle = inEle[parseInt(i.toString(), 10)];
              if (checkClass(sepEle, [CLS_SEPARATOR, CLS_TBARIGNORE])) {
                inEle[parseInt(i.toString(), 10)].classList.add(CLS_POPUP);
                itemPopCount++;
              }
              itemCount++;
            } else if (this.overflowMode === "Popup") {
              if (sepCheck > 0 && itemCount === itemPopCount) {
                var sepEle = inEle[i + itemCount + (sepCheck - 1)];
                if (checkClass(sepEle, [CLS_SEPARATOR, CLS_TBARIGNORE])) {
                  setStyleAttribute(sepEle, { display: "none" });
                }
              }
              sepCheck++;
              itemCount = 0;
              itemPopCount = 0;
            }
          } else {
            itemCount++;
          }
          if (inEle[parseInt(i.toString(), 10)].classList.contains(CLS_TBAROVERFLOW) && pre) {
            eleWidth -= (this.isVertical ? inEle[parseInt(i.toString(), 10)].offsetHeight : inEle[parseInt(i.toString(), 10)].offsetWidth) + mrgn;
          } else if (!checkClass(inEle[parseInt(i.toString(), 10)], [CLS_SEPARATOR, CLS_TBARIGNORE])) {
            inEle[parseInt(i.toString(), 10)].classList.add(CLS_POPUP);
            if (this.isVertical) {
              setStyleAttribute(inEle[parseInt(i.toString(), 10)], { display: "none", minHeight: eleWid_1 + "px" });
            } else {
              setStyleAttribute(inEle[parseInt(i.toString(), 10)], { display: "none", minWidth: eleWid_1 + "px" });
            }
            itemPopCount++;
          } else {
            eleWidth -= (this.isVertical ? inEle[parseInt(i.toString(), 10)].offsetHeight : inEle[parseInt(i.toString(), 10)].offsetWidth) + mrgn;
          }
        }
      }
      if (pre) {
        var popedEle = selectAll("." + CLS_ITEM + ":not(." + CLS_POPUP + ")", this.element);
        this.checkPriority(ele, popedEle, eleWid, false);
      }
    };
    Toolbar2.prototype.createPopupIcon = function(element2) {
      var id = element2.id.concat("_nav");
      var className = "e-" + element2.id.concat("_nav " + CLS_POPUPNAV);
      className = this.overflowMode === "Extended" ? className + " " + CLS_EXTENDPOPUP : className;
      var nav = this.createElement("div", { id, className });
      if (Browser.info.name === "msie" || Browser.info.name === "edge") {
        nav.classList.add("e-ie-align");
      }
      var navItem = this.createElement("div", { className: CLS_POPUPDOWN + " e-icons" });
      nav.appendChild(navItem);
      nav.setAttribute("tabindex", "0");
      nav.setAttribute("role", "button");
      element2.appendChild(nav);
    };
    Toolbar2.prototype.tbarPriRef = function(inEle, indx, sepPri, el, des, elWid, wid, ig, eleStyles) {
      var ignoreCount = ig;
      var popEle = this.popObj.element;
      var query = "." + CLS_ITEM + ":not(." + CLS_SEPARATOR + "):not(." + CLS_TBAROVERFLOW + ")";
      var priEleCnt = selectAll("." + CLS_POPUP + ":not(." + CLS_TBAROVERFLOW + ")", popEle).length;
      var checkClass = function(ele, val) {
        return ele.classList.contains(val);
      };
      if (selectAll(query, inEle).length === 0) {
        var eleSep = inEle.children[indx - (indx - sepPri) - 1];
        var ignoreCheck = !isNullOrUndefined(eleSep) && checkClass(eleSep, CLS_TBARIGNORE);
        if (!isNullOrUndefined(eleSep) && checkClass(eleSep, CLS_SEPARATOR) && !isVisible(eleSep) || ignoreCheck) {
          eleSep.style.display = "unset";
          var eleSepWidth = eleSep.offsetWidth + parseFloat((undefined).getComputedStyle(eleSep).marginRight) * 2;
          var prevSep = eleSep.previousElementSibling;
          if (elWid + eleSepWidth < wid || des) {
            inEle.insertBefore(el, inEle.children[indx + ignoreCount - (indx - sepPri)]);
            if (!isNullOrUndefined(prevSep)) {
              prevSep.style.display = "";
            }
          } else {
            setStyleAttribute(el, eleStyles);
            if (prevSep.classList.contains(CLS_SEPARATOR)) {
              prevSep.style.display = "none";
            }
          }
          eleSep.style.display = "";
        } else {
          inEle.insertBefore(el, inEle.children[indx + ignoreCount - (indx - sepPri)]);
        }
      } else {
        inEle.insertBefore(el, inEle.children[indx + ignoreCount - priEleCnt]);
      }
    };
    Toolbar2.prototype.popupRefresh = function(popupEle, destroy2) {
      var _this = this;
      var ele = this.element;
      var isVer = this.isVertical;
      var innerEle = ele.querySelector("." + CLS_ITEMS);
      var popNav = ele.querySelector("." + CLS_TBARNAV);
      if (isNullOrUndefined(popNav)) {
        return;
      }
      innerEle.removeAttribute("style");
      popupEle.style.display = "block";
      var dimension;
      if (isVer) {
        dimension = ele.offsetHeight - (popNav.offsetHeight + innerEle.offsetHeight);
      } else {
        dimension = ele.offsetWidth - (popNav.offsetWidth + innerEle.offsetWidth);
      }
      var popupEleWidth = 0;
      [].slice.call(popupEle.children).forEach(function(el) {
        popupEleWidth += _this.popupEleWidth(el);
        setStyleAttribute(el, { "position": "" });
      });
      if (dimension + (isVer ? popNav.offsetHeight : popNav.offsetWidth) > popupEleWidth && this.popupPriCount === 0) {
        destroy2 = true;
      }
      this.popupEleRefresh(dimension, popupEle, destroy2);
      popupEle.style.display = "";
      if (popupEle.children.length === 0 && popNav && this.popObj) {
        detach(popNav);
        popNav = null;
        this.popObj.destroy();
        detach(this.popObj.element);
        this.popObj = null;
      }
    };
    Toolbar2.prototype.ignoreEleFetch = function(index, innerEle) {
      var ignoreEle = [].slice.call(innerEle.querySelectorAll("." + CLS_TBARIGNORE));
      var ignoreInx = [];
      var count = 0;
      if (ignoreEle.length > 0) {
        ignoreEle.forEach(function(ele) {
          ignoreInx.push([].slice.call(innerEle.children).indexOf(ele));
        });
      } else {
        return 0;
      }
      ignoreInx.forEach(function(val) {
        if (val <= index) {
          count++;
        }
      });
      return count;
    };
    Toolbar2.prototype.checkPopupRefresh = function(root, popEle) {
      popEle.style.display = "block";
      var elWid = this.popupEleWidth(popEle.firstElementChild);
      popEle.firstElementChild.style.removeProperty("Position");
      var tbarWidth = root.offsetWidth - root.querySelector("." + CLS_TBARNAV).offsetWidth;
      var tbarItemsWid = root.querySelector("." + CLS_ITEMS).offsetWidth;
      popEle.style.removeProperty("display");
      if (tbarWidth > elWid + tbarItemsWid) {
        return true;
      }
      return false;
    };
    Toolbar2.prototype.popupEleWidth = function(el) {
      el.style.position = "absolute";
      var elWidth = this.isVertical ? el.offsetHeight : el.offsetWidth;
      var btnText = el.querySelector("." + CLS_TBARBTNTEXT);
      if (el.classList.contains("e-tbtn-align") || el.classList.contains(CLS_TBARTEXT)) {
        var btn = el.children[0];
        if (!isNullOrUndefined(btnText) && el.classList.contains(CLS_TBARTEXT)) {
          btnText.style.display = "none";
        } else if (!isNullOrUndefined(btnText) && el.classList.contains(CLS_POPUPTEXT)) {
          btnText.style.display = "block";
        }
        btn.style.minWidth = "0%";
        elWidth = parseFloat(!this.isVertical ? el.style.minWidth : el.style.minHeight);
        btn.style.minWidth = "";
        btn.style.minHeight = "";
        if (!isNullOrUndefined(btnText)) {
          btnText.style.display = "";
        }
      }
      return elWidth;
    };
    Toolbar2.prototype.popupEleRefresh = function(width, popupEle, destroy2) {
      var popPriority = this.popupPriCount > 0;
      var eleSplice = this.tbarEle;
      var priEleCnt;
      var index;
      var innerEle = this.element.querySelector("." + CLS_ITEMS);
      var ignoreCount = 0;
      var _loop_1 = function(el2) {
        if (el2.classList.contains(CLS_POPPRI) && popPriority && !destroy2) {
          return "continue";
        }
        var elWidth = this_1.popupEleWidth(el2);
        if (el2 === this_1.tbarEle[0]) {
          elWidth += this_1.tbarEleMrgn;
        }
        el2.style.position = "";
        if (elWidth < width || destroy2) {
          var inlineStyles = {
            minWidth: el2.style.minWidth,
            height: el2.style.height,
            minHeight: el2.style.minHeight
          };
          setStyleAttribute(el2, { minWidth: "", height: "", minHeight: "" });
          if (!el2.classList.contains(CLS_POPOVERFLOW)) {
            el2.classList.remove(CLS_POPUP);
          }
          index = this_1.tbarEle.indexOf(el2);
          if (this_1.tbarAlign) {
            var pos = this_1.items[parseInt(index.toString(), 10)].align;
            index = this_1.tbarAlgEle[(pos + "s").toLowerCase()].indexOf(el2);
            eleSplice = this_1.tbarAlgEle[(pos + "s").toLowerCase()];
            innerEle = this_1.element.querySelector("." + CLS_ITEMS + " .e-toolbar-" + pos.toLowerCase());
          }
          var sepBeforePri_1 = 0;
          if (this_1.overflowMode !== "Extended") {
            eleSplice.slice(0, index).forEach(function(el3) {
              if (el3.classList.contains(CLS_TBAROVERFLOW) || el3.classList.contains(CLS_SEPARATOR)) {
                if (el3.classList.contains(CLS_SEPARATOR)) {
                  el3.style.display = "";
                  width -= el3.offsetWidth;
                }
                sepBeforePri_1++;
              }
            });
          }
          ignoreCount = this_1.ignoreEleFetch(index, innerEle);
          if (el2.classList.contains(CLS_TBAROVERFLOW)) {
            this_1.tbarPriRef(innerEle, index, sepBeforePri_1, el2, destroy2, elWidth, width, ignoreCount, inlineStyles);
            width -= el2.offsetWidth;
          } else if (index === 0) {
            innerEle.insertBefore(el2, innerEle.firstChild);
            width -= el2.offsetWidth;
          } else {
            priEleCnt = selectAll("." + CLS_TBAROVERFLOW, this_1.popObj.element).length;
            innerEle.insertBefore(el2, innerEle.children[index + ignoreCount - priEleCnt]);
            width -= el2.offsetWidth;
          }
          el2.style.height = "";
        } else {
          return "break";
        }
      };
      var this_1 = this;
      for (var _i = 0, _a = [].slice.call(popupEle.children); _i < _a.length; _i++) {
        var el = _a[_i];
        var state_1 = _loop_1(el);
        if (state_1 === "break")
          break;
      }
      var checkOverflow = this.checkOverflow(this.element, this.element.getElementsByClassName(CLS_ITEMS)[0]);
      if (checkOverflow && !destroy2) {
        this.renderOverflowMode();
      }
    };
    Toolbar2.prototype.removePositioning = function() {
      var item = this.element.querySelector("." + CLS_ITEMS);
      if (isNullOrUndefined(item) || !item.classList.contains(CLS_TBARPOS)) {
        return;
      }
      this.remove(item, CLS_TBARPOS);
      var innerItem = [].slice.call(item.childNodes);
      innerItem[1].removeAttribute("style");
      innerItem[2].removeAttribute("style");
    };
    Toolbar2.prototype.refreshPositioning = function() {
      var item = this.element.querySelector("." + CLS_ITEMS);
      this.add(item, CLS_TBARPOS);
      this.itemPositioning();
    };
    Toolbar2.prototype.itemPositioning = function() {
      var item = this.element.querySelector("." + CLS_ITEMS);
      var margin;
      if (isNullOrUndefined(item) || !item.classList.contains(CLS_TBARPOS)) {
        return;
      }
      var popupNav = this.element.querySelector("." + CLS_TBARNAV);
      var innerItem;
      if (this.scrollModule) {
        var trgClass = this.isVertical ? CLS_VSCROLLCNT : CLS_HSCROLLCNT;
        innerItem = [].slice.call(item.querySelector("." + trgClass).children);
      } else {
        innerItem = [].slice.call(item.childNodes);
      }
      if (this.isVertical) {
        margin = innerItem[0].offsetHeight + innerItem[2].offsetHeight;
      } else {
        margin = innerItem[0].offsetWidth + innerItem[2].offsetWidth;
      }
      var tbarWid = this.isVertical ? this.element.offsetHeight : this.element.offsetWidth;
      if (popupNav) {
        tbarWid -= this.isVertical ? popupNav.offsetHeight : popupNav.offsetWidth;
        var popWid = (this.isVertical ? popupNav.offsetHeight : popupNav.offsetWidth) + "px";
        innerItem[2].removeAttribute("style");
        if (this.isVertical) {
          if (this.enableRtl) {
            innerItem[2].style.top = popWid;
          } else {
            innerItem[2].style.bottom = popWid;
          }
        } else {
          if (this.enableRtl) {
            innerItem[2].style.left = popWid;
          } else {
            innerItem[2].style.right = popWid;
          }
        }
      }
      if (tbarWid <= margin) {
        return;
      }
      var value = (tbarWid - margin - (!this.isVertical ? innerItem[1].offsetWidth : innerItem[1].offsetHeight)) / 2;
      innerItem[1].removeAttribute("style");
      var mrgn = (!this.isVertical ? innerItem[0].offsetWidth : innerItem[0].offsetHeight) + value + "px";
      if (this.isVertical) {
        if (this.enableRtl) {
          innerItem[1].style.marginBottom = mrgn;
        } else {
          innerItem[1].style.marginTop = mrgn;
        }
      } else {
        if (this.enableRtl) {
          innerItem[1].style.marginRight = mrgn;
        } else {
          innerItem[1].style.marginLeft = mrgn;
        }
      }
    };
    Toolbar2.prototype.tbarItemAlign = function(item, itemEle, pos) {
      var _this = this;
      if (item.showAlwaysInPopup && item.overflow !== "Show") {
        return;
      }
      var alignDiv = [];
      alignDiv.push(this.createElement("div", { className: CLS_TBARLEFT, attrs: { role: "group" } }));
      alignDiv.push(this.createElement("div", { className: CLS_TBARCENTER, attrs: { role: "group" } }));
      alignDiv.push(this.createElement("div", { className: CLS_TBARRIGHT, attrs: { role: "group" } }));
      if (pos === 0 && item.align !== "Left") {
        alignDiv.forEach(function(ele) {
          itemEle.appendChild(ele);
        });
        this.tbarAlign = true;
        this.add(itemEle, CLS_TBARPOS);
      } else if (item.align !== "Left") {
        var alignEle = itemEle.childNodes;
        var leftAlign_1 = alignDiv[0];
        [].slice.call(alignEle).forEach(function(el) {
          _this.tbarAlgEle.lefts.push(el);
          leftAlign_1.appendChild(el);
        });
        itemEle.appendChild(leftAlign_1);
        itemEle.appendChild(alignDiv[1]);
        itemEle.appendChild(alignDiv[2]);
        this.tbarAlign = true;
        this.add(itemEle, CLS_TBARPOS);
      }
    };
    Toolbar2.prototype.ctrlTemplate = function() {
      var _this = this;
      this.ctrlTem = this.trgtEle.cloneNode(true);
      this.add(this.trgtEle, CLS_ITEMS);
      this.tbarEle = [];
      var innerEle = [].slice.call(this.trgtEle.children);
      innerEle.forEach(function(ele) {
        if (ele.tagName === "DIV") {
          _this.tbarEle.push(ele);
          if (!isNullOrUndefined(ele.firstElementChild)) {
            ele.firstElementChild.setAttribute("aria-disabled", "false");
          }
          _this.add(ele, CLS_ITEM);
        }
      });
    };
    Toolbar2.prototype.renderItems = function() {
      var ele = this.element;
      var items = this.items;
      if (this.trgtEle != null) {
        this.ctrlTemplate();
      } else if (ele && items.length > 0) {
        var itemEleDom = undefined;
        if (ele && ele.children.length > 0) {
          itemEleDom = ele.querySelector("." + CLS_ITEMS);
        }
        if (!itemEleDom) {
          itemEleDom = this.createElement("div", { className: CLS_ITEMS });
        }
        this.itemsAlign(items, itemEleDom);
        ele.appendChild(itemEleDom);
      }
    };
    Toolbar2.prototype.setAttr = function(attr, element2) {
      var key = Object.keys(attr);
      var keyVal;
      for (var i = 0; i < key.length; i++) {
        keyVal = key[parseInt(i.toString(), 10)];
        if (keyVal === "class") {
          this.add(element2, attr["" + keyVal]);
        } else {
          element2.setAttribute(keyVal, attr["" + keyVal]);
        }
      }
    };
    Toolbar2.prototype.enableItems = function(items, isEnable) {
      var _this = this;
      var elements = items;
      var len = elements.length;
      var ele;
      if (isNullOrUndefined(isEnable)) {
        isEnable = true;
      }
      var enable = function(isEnable2, ele2) {
        if (isEnable2) {
          ele2.classList.remove(CLS_DISABLE);
          if (!isNullOrUndefined(ele2.firstElementChild)) {
            ele2.firstElementChild.setAttribute("aria-disabled", "false");
            _this.updateTabIndex("0");
          }
        } else {
          ele2.classList.add(CLS_DISABLE);
          if (!isNullOrUndefined(ele2.firstElementChild)) {
            ele2.firstElementChild.setAttribute("aria-disabled", "true");
            ele2.firstElementChild.setAttribute("tabindex", "-1");
            _this.updateTabIndex("0");
          }
        }
      };
      if (!isNullOrUndefined(len) && len >= 1) {
        for (var a = 0, element2 = [].slice.call(elements); a < len; a++) {
          var itemElement = element2[parseInt(a.toString(), 10)];
          if (typeof itemElement === "number") {
            ele = this.getElementByIndex(itemElement);
            if (isNullOrUndefined(ele)) {
              return;
            } else {
              elements[parseInt(a.toString(), 10)] = ele;
            }
          } else {
            ele = itemElement;
          }
          enable(isEnable, ele);
        }
        if (isEnable) {
          removeClass(elements, CLS_DISABLE);
        } else {
          addClass(elements, CLS_DISABLE);
        }
      } else {
        if (typeof elements === "number") {
          ele = this.getElementByIndex(elements);
          if (isNullOrUndefined(ele)) {
            return;
          }
        } else {
          ele = items;
        }
        enable(isEnable, ele);
      }
    };
    Toolbar2.prototype.getElementByIndex = function(index) {
      if (this.tbarEle[parseInt(index.toString(), 10)]) {
        return this.tbarEle[parseInt(index.toString(), 10)];
      }
      return null;
    };
    Toolbar2.prototype.addItems = function(items, index) {
      var innerItems;
      this.extendedOpen();
      var itemsDiv = this.element.querySelector("." + CLS_ITEMS);
      if (isNullOrUndefined(itemsDiv)) {
        this.itemsRerender(items);
        return;
      }
      var innerEle;
      var itemAgn = "Left";
      if (isNullOrUndefined(index)) {
        index = 0;
      }
      items.forEach(function(e) {
        if (!isNullOrUndefined(e.align) && e.align !== "Left" && itemAgn === "Left") {
          itemAgn = e.align;
        }
      });
      for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
        var item = items_1[_i];
        if (isNullOrUndefined(item.type)) {
          item.type = "Button";
        }
        innerItems = selectAll("." + CLS_ITEM, this.element);
        item.align = itemAgn;
        innerEle = this.renderSubComponent(item, index);
        if (this.tbarEle.length >= index && innerItems.length >= 0) {
          if (isNullOrUndefined(this.scrollModule)) {
            this.destroyMode();
          }
          var algIndex = item.align[0] === "L" ? 0 : item.align[0] === "C" ? 1 : 2;
          var ele = undefined;
          if (!this.tbarAlign && itemAgn !== "Left") {
            this.tbarItemAlign(item, itemsDiv, 1);
            this.tbarAlign = true;
            ele = closest(innerItems[0], "." + CLS_ITEMS).children[parseInt(algIndex.toString(), 10)];
            ele.appendChild(innerEle);
            this.tbarAlgEle[(item.align + "s").toLowerCase()].push(innerEle);
            this.refreshPositioning();
          } else if (this.tbarAlign) {
            ele = closest(innerItems[0], "." + CLS_ITEMS).children[parseInt(algIndex.toString(), 10)];
            ele.insertBefore(innerEle, ele.children[parseInt(index.toString(), 10)]);
            this.tbarAlgEle[(item.align + "s").toLowerCase()].splice(index, 0, innerEle);
            this.refreshPositioning();
          } else if (innerItems.length === 0) {
            innerItems = selectAll("." + CLS_ITEMS, this.element);
            innerItems[0].appendChild(innerEle);
          } else {
            innerItems[0].parentNode.insertBefore(innerEle, innerItems[parseInt(index.toString(), 10)]);
          }
          this.items.splice(index, 0, item);
          if (item.template) {
            this.tbarEle.splice(this.tbarEle.length - 1, 1);
          }
          this.tbarEle.splice(index, 0, innerEle);
          index++;
          this.offsetWid = itemsDiv.offsetWidth;
        }
      }
      itemsDiv.style.width = "";
      this.renderOverflowMode();
      if (this.isReact) {
        this.renderReactTemplates();
      }
    };
    Toolbar2.prototype.removeItems = function(args) {
      var elements = args;
      var index;
      var innerItems = [].slice.call(selectAll("." + CLS_ITEM, this.element));
      if (typeof elements === "number") {
        index = parseInt(args.toString(), 10);
        this.removeItemByIndex(index, innerItems);
      } else {
        if (elements && elements.length > 1) {
          for (var _i = 0, _a = [].slice.call(elements); _i < _a.length; _i++) {
            var ele = _a[_i];
            index = this.tbarEle.indexOf(ele);
            this.removeItemByIndex(index, innerItems);
            innerItems = selectAll("." + CLS_ITEM, this.element);
          }
        } else {
          var ele = elements && elements.length && elements.length === 1 ? elements[0] : args;
          index = innerItems.indexOf(ele);
          this.removeItemByIndex(index, innerItems);
        }
      }
      this.resize();
    };
    Toolbar2.prototype.removeItemByIndex = function(index, innerItems) {
      if (this.tbarEle[parseInt(index.toString(), 10)] && innerItems[parseInt(index.toString(), 10)]) {
        var eleIdx = this.tbarEle.indexOf(innerItems[parseInt(index.toString(), 10)]);
        if (this.tbarAlign) {
          var indexAgn = this.tbarAlgEle[(this.items[parseInt(eleIdx.toString(), 10)].align + "s").toLowerCase()].indexOf(this.tbarEle[parseInt(eleIdx.toString(), 10)]);
          this.tbarAlgEle[(this.items[parseInt(eleIdx.toString(), 10)].align + "s").toLowerCase()].splice(parseInt(indexAgn.toString(), 10), 1);
        }
        if (this.isReact) {
          this.clearToolbarTemplate(innerItems[parseInt(index.toString(), 10)]);
        }
        var btnItem = innerItems[parseInt(index.toString(), 10)].querySelector(".e-control.e-btn");
        if (!isNullOrUndefined(btnItem) && !isNullOrUndefined(btnItem.ej2_instances[0]) && !btnItem.ej2_instances[0].isDestroyed) {
          btnItem.ej2_instances[0].destroy();
        }
        detach(innerItems[parseInt(index.toString(), 10)]);
        this.items.splice(eleIdx, 1);
        this.tbarEle.splice(eleIdx, 1);
      }
    };
    Toolbar2.prototype.templateRender = function(templateProp, innerEle, item, index) {
      var itemType = item.type;
      var eleObj = templateProp;
      var isComponent;
      if (typeof templateProp === "object") {
        isComponent = typeof eleObj.appendTo === "function";
      }
      if (typeof templateProp === "string" || !isComponent) {
        var templateFn = undefined;
        var val = templateProp;
        var regEx = new RegExp(/<(?=.*? .*?\/ ?>|br|hr|input|!--|wbr)[a-z]+.*?>|<([a-z]+).*?<\/\1>/i);
        val = typeof templateProp === "string" ? templateProp.trim() : templateProp;
        try {
          if (typeof templateProp === "object" && !isNullOrUndefined(templateProp.tagName)) {
            innerEle.appendChild(templateProp);
          } else if (typeof templateProp === "string" && regEx.test(val)) {
            innerEle.innerHTML = val;
          } else if ((void 0).querySelectorAll(val).length) {
            var ele = (void 0).querySelector(val);
            var tempStr = ele.outerHTML.trim();
            innerEle.appendChild(ele);
            ele.style.display = "";
            if (!isNullOrUndefined(tempStr)) {
              this.tempId.push(val);
            }
          } else {
            templateFn = compile$1(val);
          }
        } catch (e) {
          templateFn = compile$1(val);
        }
        var tempArray = undefined;
        if (!isNullOrUndefined(templateFn)) {
          var toolbarTemplateID = this.element.id + index + "_template";
          tempArray = templateFn({}, this, "template", toolbarTemplateID, this.isStringTemplate, undefined, undefined, this.root);
        }
        if (!isNullOrUndefined(tempArray) && tempArray.length > 0) {
          [].slice.call(tempArray).forEach(function(ele2) {
            if (!isNullOrUndefined(ele2.tagName)) {
              ele2.style.display = "";
            }
            innerEle.appendChild(ele2);
          });
        }
      } else if (itemType === "Input") {
        var ele = this.createElement("input");
        if (item.id) {
          ele.id = item.id;
        } else {
          ele.id = getUniqueID("tbr-ipt");
        }
        innerEle.appendChild(ele);
        eleObj.appendTo(ele);
      }
      this.add(innerEle, CLS_TEMPLATE);
      var firstChild = innerEle.firstElementChild;
      if (!isNullOrUndefined(firstChild)) {
        firstChild.setAttribute("tabindex", isNullOrUndefined(firstChild.getAttribute("tabIndex")) ? "-1" : this.getDataTabindex(firstChild));
        firstChild.setAttribute("data-tabindex", isNullOrUndefined(firstChild.getAttribute("tabIndex")) ? "-1" : this.getDataTabindex(firstChild));
      }
      this.tbarEle.push(innerEle);
    };
    Toolbar2.prototype.buttonRendering = function(item, innerEle) {
      var dom = this.createElement("button", { className: CLS_TBARBTN });
      dom.setAttribute("type", "button");
      var textStr = item.text;
      var iconCss;
      var iconPos;
      if (item.id) {
        dom.id = item.id;
      } else {
        dom.id = getUniqueID("e-tbr-btn");
      }
      var btnTxt = this.createElement("span", { className: "e-tbar-btn-text" });
      if (textStr) {
        btnTxt.innerHTML = this.enableHtmlSanitizer ? SanitizeHtmlHelper.sanitize(textStr) : textStr;
        dom.appendChild(btnTxt);
        dom.classList.add("e-tbtn-txt");
      } else {
        this.add(innerEle, "e-tbtn-align");
      }
      if (item.prefixIcon || item.suffixIcon) {
        if (item.prefixIcon && item.suffixIcon || item.prefixIcon) {
          iconCss = item.prefixIcon + " e-icons";
          iconPos = "Left";
        } else {
          iconCss = item.suffixIcon + " e-icons";
          iconPos = "Right";
        }
      }
      var btnObj = new Button({ iconCss, iconPosition: iconPos });
      btnObj.createElement = this.createElement;
      btnObj.appendTo(dom);
      if (item.width) {
        setStyleAttribute(dom, { "width": formatUnit(item.width) });
      }
      return dom;
    };
    Toolbar2.prototype.renderSubComponent = function(item, index) {
      var dom;
      var innerEle = this.createElement("div", { className: CLS_ITEM });
      var tempDom = this.createElement("div", {
        innerHTML: this.enableHtmlSanitizer && !isNullOrUndefined(item.tooltipText) ? SanitizeHtmlHelper.sanitize(item.tooltipText) : item.tooltipText
      });
      if (!this.tbarEle) {
        this.tbarEle = [];
      }
      if (item.htmlAttributes) {
        this.setAttr(item.htmlAttributes, innerEle);
      }
      if (item.tooltipText) {
        innerEle.setAttribute("title", tempDom.textContent);
      }
      if (item.cssClass) {
        innerEle.className = innerEle.className + " " + item.cssClass;
      }
      if (item.template) {
        this.templateRender(item.template, innerEle, item, index);
      } else {
        switch (item.type) {
          case "Button":
            dom = this.buttonRendering(item, innerEle);
            dom.setAttribute("tabindex", isNullOrUndefined(item.tabIndex) ? "-1" : item.tabIndex.toString());
            dom.setAttribute("data-tabindex", isNullOrUndefined(item.tabIndex) ? "-1" : item.tabIndex.toString());
            dom.setAttribute("aria-label", item.text || item.tooltipText);
            dom.setAttribute("aria-disabled", "false");
            innerEle.appendChild(dom);
            innerEle.addEventListener("click", this.itemClick.bind(this));
            break;
          case "Separator":
            this.add(innerEle, CLS_SEPARATOR);
            break;
        }
      }
      if (item.showTextOn) {
        var sTxt = item.showTextOn;
        if (sTxt === "Toolbar") {
          this.add(innerEle, CLS_POPUPTEXT);
          this.add(innerEle, "e-tbtn-align");
        } else if (sTxt === "Overflow") {
          this.add(innerEle, CLS_TBARTEXT);
        }
      }
      if (item.overflow) {
        var overflow = item.overflow;
        if (overflow === "Show") {
          this.add(innerEle, CLS_TBAROVERFLOW);
        } else if (overflow === "Hide") {
          if (!innerEle.classList.contains(CLS_SEPARATOR)) {
            this.add(innerEle, CLS_POPOVERFLOW);
          }
        }
      }
      if (item.overflow !== "Show" && item.showAlwaysInPopup && !innerEle.classList.contains(CLS_SEPARATOR)) {
        this.add(innerEle, CLS_POPPRI);
        this.popupPriCount++;
      }
      if (item.disabled) {
        this.add(innerEle, CLS_DISABLE);
      }
      if (item.visible === false) {
        this.add(innerEle, CLS_HIDDEN);
      }
      return innerEle;
    };
    Toolbar2.prototype.getDataTabindex = function(ele) {
      return isNullOrUndefined(ele.getAttribute("data-tabindex")) ? "-1" : ele.getAttribute("data-tabindex");
    };
    Toolbar2.prototype.itemClick = function(e) {
      this.activeEleSwitch(e.currentTarget);
    };
    Toolbar2.prototype.activeEleSwitch = function(ele) {
      this.activeEleRemove(ele.firstElementChild);
      this.activeEle.focus();
    };
    Toolbar2.prototype.activeEleRemove = function(curEle) {
      var previousEle = this.element.querySelector("." + CLS_ITEM + ":not(." + CLS_DISABLE + " ):not(." + CLS_SEPARATOR + " ):not(." + CLS_HIDDEN + " )");
      if (!isNullOrUndefined(this.activeEle)) {
        this.activeEle.setAttribute("tabindex", this.getDataTabindex(this.activeEle));
        if (previousEle) {
          previousEle.removeAttribute("tabindex");
        }
        previousEle = this.activeEle;
      }
      this.activeEle = curEle;
      if (this.getDataTabindex(this.activeEle) === "-1") {
        if (isNullOrUndefined(this.trgtEle) && !curEle.parentElement.classList.contains(CLS_TEMPLATE)) {
          if (!isNullOrUndefined(this.element.querySelector(".e-hor-nav")) && this.element.querySelector(".e-hor-nav").classList.contains("e-nav-active")) {
            this.updateTabIndex("0");
            var tabindexValue = this.getDataTabindex(previousEle) === "-1" ? "0" : this.getDataTabindex(previousEle);
            previousEle.setAttribute("tabindex", tabindexValue);
          } else {
            this.updateTabIndex("-1");
          }
          curEle.removeAttribute("tabindex");
        } else {
          var tabIndex = parseInt(this.getDataTabindex(this.activeEle), 10) + 1;
          this.activeEle.setAttribute("tabindex", tabIndex.toString());
        }
      }
    };
    Toolbar2.prototype.getPersistData = function() {
      return this.addOnPersist([]);
    };
    Toolbar2.prototype.getModuleName = function() {
      return "toolbar";
    };
    Toolbar2.prototype.itemsRerender = function(newProp) {
      this.items = this.tbarItemsCol;
      if (this.isReact || this.isAngular) {
        this.clearTemplate();
      }
      this.destroyMode();
      this.destroyItems();
      this.items = newProp;
      this.tbarItemsCol = this.items;
      this.renderItems();
      this.renderOverflowMode();
      if (this.isReact) {
        this.renderReactTemplates();
      }
    };
    Toolbar2.prototype.resize = function() {
      var ele = this.element;
      this.tbResize = true;
      if (this.tbarAlign) {
        this.itemPositioning();
      }
      if (this.popObj && this.overflowMode === "Popup") {
        this.popObj.hide();
      }
      var checkOverflow = this.checkOverflow(ele, ele.getElementsByClassName(CLS_ITEMS)[0]);
      if (!checkOverflow) {
        this.destroyScroll();
        var multirowele = ele.querySelector("." + CLS_ITEMS);
        if (!isNullOrUndefined(multirowele)) {
          this.remove(multirowele, CLS_MULTIROWPOS);
          if (this.tbarAlign) {
            this.add(multirowele, CLS_TBARPOS);
          }
        }
      }
      if (checkOverflow && this.scrollModule && this.offsetWid === ele.offsetWidth) {
        return;
      }
      if (this.offsetWid > ele.offsetWidth || checkOverflow) {
        this.renderOverflowMode();
      }
      if (this.popObj) {
        if (this.overflowMode === "Extended") {
          this.popObj.width = this.getToolbarPopupWidth(this.element);
        }
        if (this.tbarAlign) {
          this.removePositioning();
        }
        this.popupRefresh(this.popObj.element, false);
        if (this.tbarAlign) {
          this.refreshPositioning();
        }
      }
      if (this.element.querySelector("." + CLS_HSCROLLBAR)) {
        this.scrollStep = this.element.querySelector("." + CLS_HSCROLLBAR).offsetWidth;
      }
      this.offsetWid = ele.offsetWidth;
      this.tbResize = false;
      this.separator();
    };
    Toolbar2.prototype.orientationChange = function() {
      var _this = this;
      setTimeout(function() {
        _this.resize();
      }, 500);
    };
    Toolbar2.prototype.extendedOpen = function() {
      var sib = this.element.querySelector("." + CLS_EXTENDABLECLASS);
      if (this.overflowMode === "Extended" && sib) {
        this.isExtendedOpen = sib.classList.contains(CLS_POPUPOPEN);
      }
    };
    Toolbar2.prototype.updateHideEleTabIndex = function(ele, isHidden, isElement, eleIndex, innerItems) {
      if (isElement) {
        eleIndex = innerItems.indexOf(ele);
      }
      var nextEle = innerItems[++eleIndex];
      while (nextEle) {
        var skipEle = this.eleContains(nextEle);
        if (!skipEle) {
          var dataTabIndex = nextEle.firstElementChild.getAttribute("data-tabindex");
          if (isHidden && dataTabIndex === "-1") {
            nextEle.firstElementChild.setAttribute("tabindex", "0");
          } else if (dataTabIndex !== nextEle.firstElementChild.getAttribute("tabindex")) {
            nextEle.firstElementChild.setAttribute("tabindex", dataTabIndex);
          }
          break;
        }
        nextEle = innerItems[++eleIndex];
      }
    };
    Toolbar2.prototype.clearToolbarTemplate = function(templateEle) {
      if (this.registeredTemplate && this.registeredTemplate["template"]) {
        var registeredTemplates = this.registeredTemplate;
        for (var index = 0; index < registeredTemplates["template"].length; index++) {
          var registeredItem = registeredTemplates["template"][parseInt(index.toString(), 10)].rootNodes[0];
          var closestItem = closest(registeredItem, "." + CLS_ITEM);
          if (!isNullOrUndefined(closestItem) && closestItem === templateEle) {
            this.clearTemplate(["template"], [registeredTemplates["template"][parseInt(index.toString(), 10)]]);
            break;
          }
        }
      } else if (this.portals && this.portals.length > 0) {
        var portals = this.portals;
        for (var index = 0; index < portals.length; index++) {
          var portalItem = portals[parseInt(index.toString(), 10)];
          var closestItem = closest(portalItem.containerInfo, "." + CLS_ITEM);
          if (!isNullOrUndefined(closestItem) && closestItem === templateEle) {
            this.clearTemplate(["template"], index);
            break;
          }
        }
      }
    };
    Toolbar2.prototype.onPropertyChanged = function(newProp, oldProp) {
      var tEle = this.element;
      this.extendedOpen();
      for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
        var prop = _a[_i];
        switch (prop) {
          case "items":
            if (!(newProp.items instanceof Array && oldProp.items instanceof Array)) {
              var changedProb = Object.keys(newProp.items);
              for (var i = 0; i < changedProb.length; i++) {
                var index = parseInt(Object.keys(newProp.items)[parseInt(i.toString(), 10)], 10);
                var property = Object.keys(newProp.items[parseInt(index.toString(), 10)])[0];
                var newProperty = Object(newProp.items[parseInt(index.toString(), 10)])["" + property];
                if (this.tbarAlign || property === "align") {
                  this.refresh();
                  this.trigger("created");
                  break;
                }
                var popupPriCheck = property === "showAlwaysInPopup" && !newProperty;
                var booleanCheck = property === "overflow" && this.popupPriCount !== 0;
                if (popupPriCheck || this.items[parseInt(index.toString(), 10)].showAlwaysInPopup && booleanCheck) {
                  --this.popupPriCount;
                }
                if (isNullOrUndefined(this.scrollModule)) {
                  this.destroyMode();
                }
                var itemCol = [].slice.call(selectAll("." + CLS_ITEMS + " ." + CLS_ITEM, tEle));
                if (this.isReact && this.items[parseInt(index.toString(), 10)].template) {
                  this.clearToolbarTemplate(itemCol[parseInt(index.toString(), 10)]);
                }
                detach(itemCol[parseInt(index.toString(), 10)]);
                this.tbarEle.splice(index, 1);
                this.addItems([this.items[parseInt(index.toString(), 10)]], index);
                this.items.splice(index, 1);
                if (this.items[parseInt(index.toString(), 10)].template) {
                  this.tbarEle.splice(this.items.length, 1);
                }
              }
            } else {
              this.itemsRerender(newProp.items);
            }
            break;
          case "width":
            setStyleAttribute(tEle, { "width": formatUnit(newProp.width) });
            this.refreshOverflow();
            break;
          case "height":
            setStyleAttribute(this.element, { "height": formatUnit(newProp.height) });
            break;
          case "overflowMode":
            this.destroyMode();
            this.renderOverflowMode();
            if (this.enableRtl) {
              this.add(tEle, CLS_RTL);
            }
            this.refreshOverflow();
            break;
          case "enableRtl":
            if (newProp.enableRtl) {
              this.add(tEle, CLS_RTL);
            } else {
              this.remove(tEle, CLS_RTL);
            }
            if (!isNullOrUndefined(this.scrollModule)) {
              if (newProp.enableRtl) {
                this.add(this.scrollModule.element, CLS_RTL);
              } else {
                this.remove(this.scrollModule.element, CLS_RTL);
              }
            }
            if (!isNullOrUndefined(this.popObj)) {
              if (newProp.enableRtl) {
                this.add(this.popObj.element, CLS_RTL);
              } else {
                this.remove(this.popObj.element, CLS_RTL);
              }
            }
            if (this.tbarAlign) {
              this.itemPositioning();
            }
            break;
          case "scrollStep":
            if (this.scrollModule) {
              this.scrollModule.scrollStep = this.scrollStep;
            }
            break;
          case "enableCollision":
            if (this.popObj) {
              this.popObj.collision = { Y: this.enableCollision ? "flip" : "none" };
            }
            break;
          case "cssClass":
            if (oldProp.cssClass) {
              removeClass([this.element], oldProp.cssClass.split(" "));
            }
            if (newProp.cssClass) {
              addClass([this.element], newProp.cssClass.split(" "));
            }
            break;
          case "allowKeyboard":
            this.unwireKeyboardEvent();
            if (newProp.allowKeyboard) {
              this.wireKeyboardEvent();
            }
            break;
        }
      }
    };
    Toolbar2.prototype.hideItem = function(index, value) {
      var isElement = typeof index === "object" ? true : false;
      var eleIndex = index;
      var ele;
      if (!isElement && isNullOrUndefined(eleIndex)) {
        return;
      }
      var innerItems = [].slice.call(selectAll("." + CLS_ITEM, this.element));
      if (isElement) {
        ele = index;
      } else if (this.tbarEle[parseInt(eleIndex.toString(), 10)]) {
        var innerItems_1 = [].slice.call(selectAll("." + CLS_ITEM, this.element));
        ele = innerItems_1[parseInt(eleIndex.toString(), 10)];
      }
      if (ele) {
        if (value) {
          ele.classList.add(CLS_HIDDEN);
          if (!ele.classList.contains(CLS_SEPARATOR)) {
            if (isNullOrUndefined(ele.firstElementChild.getAttribute("tabindex")) || ele.firstElementChild.getAttribute("tabindex") !== "-1") {
              this.updateHideEleTabIndex(ele, value, isElement, eleIndex, innerItems);
            }
          }
        } else {
          ele.classList.remove(CLS_HIDDEN);
          if (!ele.classList.contains(CLS_SEPARATOR)) {
            this.updateHideEleTabIndex(ele, value, isElement, eleIndex, innerItems);
          }
        }
        this.refreshOverflow();
      }
    };
    __decorate([
      Collection([], Item)
    ], Toolbar2.prototype, "items", undefined);
    __decorate([
      Property("auto")
    ], Toolbar2.prototype, "width", undefined);
    __decorate([
      Property("auto")
    ], Toolbar2.prototype, "height", undefined);
    __decorate([
      Property("")
    ], Toolbar2.prototype, "cssClass", undefined);
    __decorate([
      Property("Scrollable")
    ], Toolbar2.prototype, "overflowMode", undefined);
    __decorate([
      Property()
    ], Toolbar2.prototype, "scrollStep", undefined);
    __decorate([
      Property(true)
    ], Toolbar2.prototype, "enableCollision", undefined);
    __decorate([
      Property(true)
    ], Toolbar2.prototype, "enableHtmlSanitizer", undefined);
    __decorate([
      Property(true)
    ], Toolbar2.prototype, "allowKeyboard", undefined);
    __decorate([
      Event()
    ], Toolbar2.prototype, "clicked", undefined);
    __decorate([
      Event()
    ], Toolbar2.prototype, "created", undefined);
    __decorate([
      Event()
    ], Toolbar2.prototype, "destroyed", undefined);
    __decorate([
      Event()
    ], Toolbar2.prototype, "beforeCreate", undefined);
    Toolbar2 = __decorate([
      NotifyPropertyChanges
    ], Toolbar2);
    return Toolbar2;
  }(Component)
);
var ToolbarModule = (
  /** @class */
  function() {
    function ToolbarModule2(parent) {
      this.defToolbarItems = [];
      this.toolbarHeight = 46;
      this.currToolbar = "";
      this.preventZoomBtn = false;
      this.currentToolbar = "main";
      this.selFhdColor = "#42a5f5";
      this.preventEnableDisableUr = false;
      this.isAspectRatio = true;
      this.isFrameToolbar = false;
      this.presetColors = {
        "custom": [
          "#000000",
          "#f44336",
          "#e91e63",
          "#9c27b0",
          "#673ab7",
          "#2196f3",
          "#03a9f4",
          "#00bcd4",
          "#009688",
          "#ffeb3b",
          "#ffffff",
          "#ffebee",
          "#fce4ec",
          "#f3e5f5",
          "#ede7f6",
          "#e3f2fd",
          "#e1f5fe",
          "#e0f7fa",
          "#e0f2f1",
          "#fffde7",
          "#f2f2f2",
          "#ffcdd2",
          "#f8bbd0",
          "#e1bee7",
          "#d1c4e9",
          "#bbdefb",
          "#b3e5fc",
          "#b2ebf2",
          "#b2dfdb",
          "#fff9c4",
          "#e6e6e6",
          "#ef9a9a",
          "#f48fb1",
          "#ce93d8",
          "#b39ddb",
          "#90caf9",
          "#81d4fa",
          "#80deea",
          "#80cbc4",
          "#fff59d",
          "#cccccc",
          "#e57373",
          "#f06292",
          "#ba68c8",
          "#9575cd",
          "#64b5f6",
          "#4fc3f7",
          "#4dd0e1",
          "#4db6ac",
          "#fff176",
          "#b3b3b3",
          "#ef5350",
          "#ec407a",
          "#ab47bc",
          "#7e57c2",
          "#42a5f5",
          "#29b6f6",
          "#26c6da",
          "#26a69a",
          "#ffee58",
          "#999999",
          "#e53935",
          "#d81b60",
          "#8e24aa",
          "#5e35b1",
          "#1e88e5",
          "#039be5",
          "#00acc1",
          "#00897b",
          "#fdd835",
          "#808080",
          "#d32f2f",
          "#c2185b",
          "#7b1fa2",
          "#512da8",
          "#1976d2",
          "#0288d1",
          "#0097a7",
          "#00796b",
          "#fbc02d",
          "#666666",
          "#c62828",
          "#ad1457",
          "#6a1b9a",
          "#4527a0",
          "#1565c0",
          "#0277bd",
          "#00838f",
          "#00695c",
          "#f9a825",
          "#4d4d4d",
          "#b71c1c",
          "#880e4f",
          "#4a148c",
          "#311b92",
          "#0d47a1",
          "#01579b",
          "#006064",
          "#004d40",
          "#f57f17"
        ]
      };
      this.isSlider = false;
      this.currentQuality = 1;
      this.imageQuality = "highest";
      this.parent = parent;
      this.addEventListener();
      this.initLocale();
    }
    ToolbarModule2.prototype.destroy = function() {
      if (this.parent.isDestroyed) {
        return;
      }
      this.removeEventListener();
    };
    ToolbarModule2.prototype.addEventListener = function() {
      this.parent.on("toolbar", this.toolbar, this);
      this.parent.on("destroyed", this.destroy, this);
    };
    ToolbarModule2.prototype.removeEventListener = function() {
      this.parent.off("toolbar", this.toolbar);
      this.parent.off("destroyed", this.destroy);
    };
    ToolbarModule2.prototype.initLocale = function() {
      this.defaultLocale = {
        Crop: "Crop",
        ZoomIn: "Zoom In",
        ZoomOut: "Zoom Out",
        Undo: "Undo",
        Redo: "Redo",
        Transform: "Transform",
        Annotation: "Annotation",
        Finetune: "Finetune",
        Brightness: "Brightness",
        Contrast: "Contrast",
        Hue: "Hue",
        Saturation: "Saturation",
        Opacity: "Opacity",
        Blur: "Blur",
        Sharpen: "Sharpen",
        Exposure: "Exposure",
        Filter: "Filter",
        Default: "Default",
        Chrome: "Chrome",
        Cold: "Cold",
        Warm: "Warm",
        Grayscale: "Grayscale",
        BlackAndWhite: "Black and White",
        Sepia: "Sepia",
        Invert: "Invert",
        Text: "Add Text",
        Pen: "Pen",
        Reset: "Reset",
        Save: "Save",
        Select: "Select",
        RotateLeft: "Rotate Left",
        RotateRight: "Rotate Right",
        HorizontalFlip: "Horizontal Flip",
        VerticalFlip: "Vertical Flip",
        OK: "Apply",
        Cancel: "Discard",
        FillColor: "Fill Color",
        StrokeColor: "Stroke Color",
        StrokeWidth: "Stroke Width",
        FontFamily: "Font Family",
        FontStyle: "Font Style",
        FontSize: "Font Size",
        FontColor: "Font Color",
        Pan: "Pan",
        Move: "Move",
        Load: "Load",
        Custom: "Custom",
        Square: "Square",
        Circle: "Circle",
        Ellipse: "Ellipse",
        Rectangle: "Rectangle",
        Line: "Line",
        Arrow: "Arrow",
        Path: "Path",
        Bold: "Bold",
        Italic: "Italic",
        BoldItalic: "Bold Italic",
        XSmall: "X-Small",
        Small: "Small",
        Medium: "Medium",
        Large: "Large",
        XLarge: "X-Large",
        ABC: "ABC",
        Browse: "Browse",
        Duplicate: "Duplicate",
        Remove: "Remove",
        EditText: "Edit Text",
        Start: "Start",
        End: "End",
        Bar: "Bar",
        ArrowSolid: "Arrow Solid",
        CircleSolid: "Circle Solid",
        SquareSolid: "Square Solid",
        None: "None",
        CropAndTransform: "Crop and Transform",
        CropSelection: "Crop Selection",
        Image: "Add Image",
        Transparency: "Transparency",
        Height: "Height",
        Width: "Width",
        AspectRatio: "Maintain aspect ratio",
        W: "W",
        H: "H",
        DragText: "Drag and drop your image here or",
        DropText: "Drop your image here or",
        BrowseText: "Browse here...",
        SupportText: "Supports:",
        Frame: "Frame",
        Mat: "Mat",
        Bevel: "Bevel",
        Inset: "Inset",
        Hook: "Hook",
        Color: "Color",
        Size: "Size",
        Offset: "Offset",
        Radius: "Radius",
        Amount: "Amount",
        Resize: "Resize",
        0: "0%",
        20: "20%",
        40: "40%",
        60: "60%",
        80: "80%",
        100: "100%",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        Border: "Border",
        Solid: "Solid",
        Dashed: "Dashed",
        Dotted: "Dotted",
        GradientColor: "Gradient Color",
        ConfirmDialogHeader: "Confirm Save Changes",
        ConfirmDialogContent: "Do you want to save the changes you made to the image?",
        AlertDialogHeader: "Unsupported file",
        AlertDialogContent: "The selected file is unsupported.",
        MinMaxSize: "with file size between",
        MinMaxSizeAlert: "File size between",
        MinSize: "with minimum file size of",
        MinSizeAlert: "A minimum file size of",
        MaxSize: "with maximum file size of",
        MaxSizeAlert: "A maximum file size of",
        To: "to",
        Bytes: "bytes",
        Yes: "Yes",
        No: "No",
        ImageErrorDialogHeader: "Image Selection Error",
        ImageErrorDialogContent: "Please select only one image to open.",
        Straighten: "Straighten",
        NoOutline: "No outline",
        DlgOK: "OK",
        SaveAs: "Save As",
        ImageName: "Image name",
        Format: "Format",
        Quality: "Quality",
        Download: "Download",
        Close: "Close",
        ImageSize: "Image Size",
        QualityInfo: "The image quality option is only available for JPEG format",
        Good: "Good",
        Great: "Great",
        Highest: "Highest",
        BringForward: "Bring Forward",
        SendBackward: "Send Backward",
        SendToBack: "Send to Back",
        BringToFront: "Bring to Front",
        ZOrder: "Z-Order",
        Redact: "Redact",
        Pixelate: "Pixelate",
        BorderRadius: "Border Radius",
        TextOutlineColor: "Outline Color",
        TextOutlineWidth: "Outline Width",
        PixelSize: "Pixel Size",
        And: "and"
      };
      this.l10n = new L10n("image-editor", this.defaultLocale, this.parent.locale);
    };
    ToolbarModule2.prototype.toolbar = function(args) {
      var parent = this.parent;
      this.updatePrivateVariables();
      switch (args.prop) {
        case "create-toolbar":
          this.createToolbar();
          break;
        case "create-contextual-toolbar":
          this.createContextualToolbar();
          break;
        case "update-toolbar-items":
          this.updateToolbarItems();
          break;
        case "refresh-toolbar":
          this.refreshToolbar(args.value["type"], args.value["isApplyBtn"], args.value["isCropping"], args.value["isZooming"], args.value["cType"]);
          break;
        case "renderQAT":
          this.renderQAT(args.value["isPenEdit"]);
          break;
        case "enable-disable-btns":
          this.enableDisableTbrBtn();
          break;
        case "init-main-toolbar":
          this.initMainToolbar(args.value["isApplyBtn"], args.value["isDevice"], args.value["isOkBtn"], args.value["isResize"], args.value["isFrame"], args.value["isMainToolbar"]);
          break;
        case "create-bottom-toolbar":
          this.createBottomToolbar();
          break;
        case "refresh-main-toolbar":
          this.refreshMainToolbar();
          break;
        case "create-qa-toolbar":
          this.createQuickAccessToolbar();
          break;
        case "destroy-qa-toolbar":
          this.destroyQuickAccessToolbar();
          break;
        case "zoom-up-handler":
          this.zoomBtnMouseUpHandler();
          break;
        case "refresh-dropdown-btn":
          this.refreshDropDownBtn(args.value["isDisabled"]);
          break;
        case "close-contextual-toolbar":
          this.closeContextualToolbar();
          break;
        case "destroy-bottom-toolbar":
          this.destroyBottomToolbar();
          break;
        case "destroy-top-toolbar":
          this.destroyTopToolbar();
          break;
        case "destroySubComponents":
          this.destroySubComponents();
          break;
        case "setLocale":
          this.l10n.setLocale(args.value["locale"]);
          break;
        case "setPreventZoomBtn":
          this.preventZoomBtn = args.value["isPrevent"];
          break;
        case "getToolbarHeight":
          args.value["obj"]["toolbarHeight"] = this.toolbarHeight;
          break;
        case "setToolbarHeight":
          if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.length > 0 && parent.toolbar.indexOf("Open") > -1) {
            this.toolbarHeight = args.value["height"];
          }
          break;
        case "setCurrentToolbar":
          this.currentToolbar = args.value["type"];
          break;
        case "setSelectedFreehandColor":
          this.selFhdColor = args.value["color"];
          break;
        case "setInitialAdjustmentValue":
          parent.initialAdjustmentValue = args.value["value"];
          break;
        case "getCanvasFilter":
          args.value["obj"]["canvasFilter"] = parent.canvasFilter;
          break;
        case "getDefToolbarItems":
          args.value["obj"]["defToolbarItems"] = this.defToolbarItems;
          break;
        case "getPenStroke":
          this.getPenStroke(args.value["value"]);
          break;
        case "performDefToolbarClickAction":
          this.performDefTbrClick(args.value["type"], args.value["isContextualToolbar"], args.value["isDisabledAdjustment"], args.value["isDisabledFilter"], args.value["isFilterFinetune"]);
          break;
        case "setTempFilterProperties":
          parent.setTempFilterProperties();
          break;
        case "refreshSlider":
          this.refreshSlider();
          break;
        case "getCurrAdjustmentValue":
          parent.getCurrAdjustmentValue(args.value["type"]);
          break;
        case "setCurrAdjustmentValue":
          parent.setCurrAdjustmentValue(args.value["type"], args.value["value"]);
          break;
        case "refreshShapeDrawing":
          this.refreshShapeDrawing();
          break;
        case "setEnableDisableUndoRedo":
          this.preventEnableDisableUr = args.value["isPrevent"];
          break;
        case "reset":
          this.reset();
          break;
        case "getLocaleText":
          args.value["obj"]["value"] = this.l10n.getConstant(args.value["obj"]["key"]);
          break;
        case "initResizeToolbar":
          this.initResizeToolbar();
          break;
        case "getFrameToolbar":
          args.value["obj"]["bool"] = this.isFrameToolbar;
          break;
        case "resizeClick":
          this.resizeClick();
          break;
        case "frameToolbarClick":
          this.frameToolbarClick();
          break;
        case "performCropTransformClick":
          this.performCropTransformClick(args.value["shape"], args.value["isTransform"]);
          break;
        case "duplicateShape":
          this.duplicateShape(args.value["isPreventUndoRedo"], true);
          break;
        case "editText":
          this.editText();
          break;
        case "setInitialSize":
          this.initialSize = Number(args.value["value"]);
          break;
        case "widthPress":
          this.widthPress(args.value["e"]);
          break;
        case "heightPress":
          this.heightPress(args.value["e"]);
          break;
        case "widthAspectRatio":
          this.widthAspectRatio(args.value["e"]);
          break;
        case "heightAspectRatio":
          this.heightAspectRatio(args.value["e"]);
          break;
        case "cancelPan":
          this.cancelPan();
          break;
        case "zoomInBtnMouseDownHandler":
          this.zoomInBtnMouseDownHandler(args.value["event"]);
          break;
        case "zoomOutBtnMouseDownHandler":
          this.zoomOutBtnMouseDownHandler(args.value["event"]);
          break;
        case "drawDashedLine":
          this.drawDashedLine(args.value["context"]);
          break;
        case "saveDialogClosed":
          this.saveDialogClosed(args.value["id"]);
          break;
        case "getIndex":
          this.getIndex(args.value["item"]);
          break;
        case "getRectRadius":
          this.getRectRadius(args.value["text"]);
          break;
        case "applyPreviewFilter":
          this.applyPreviewFilter();
          break;
        case "renderSlider":
          this.renderSlider(args.value["type"], args.value["isSelect"]);
          break;
        case "zoomInBtnClickHandler":
          this.zoomInBtnClickHandler(args.value["e"]);
          break;
        case "zoomOutBtnClickHandler":
          this.zoomOutBtnClickHandler(args.value["e"]);
          break;
        case "getAdjustmentToolbarItem":
          this.getAdjustmentToolbarItem();
          break;
        case "getFilterToolbarItem":
          this.getFilterToolbarItem();
          break;
        case "renderCropBtn":
          this.renderCropBtn();
          break;
      }
    };
    ToolbarModule2.prototype.updatePrivateVariables = function() {
      var parent = this.parent;
      this.inMemoryCanvas = parent.inMemoryCanvas;
      if (parent.lowerCanvas) {
        this.lowerContext = parent.lowerCanvas.getContext("2d");
      }
      if (parent.upperCanvas) {
        this.upperContext = parent.upperCanvas.getContext("2d");
      }
      if (this.inMemoryCanvas) {
        this.inMemoryContext = this.inMemoryCanvas.getContext("2d");
      }
    };
    ToolbarModule2.prototype.reset = function() {
      var parent = this.parent;
      this.toolbarHeight = 46;
      parent.prevCurrSelectionPoint = null;
      this.zoomBtnHold = null;
      this.currToolbar = "";
      parent.cxtTbarHeight = null;
      this.currentToolbar = "main";
      this.selFhdColor = "#42a5f5";
      parent.currentFilter = "";
      this.preventZoomBtn = parent.isCropToolbar = this.preventEnableDisableUr = this.isFrameToolbar = false;
      parent.initialAdjustmentValue = parent.canvasFilter = "brightness(1) contrast(100%) hue-rotate(0deg) saturate(100%) opacity(1) blur(0px) sepia(0%) grayscale(0%) invert(0%)";
      parent.tempStraighten = 0;
      parent.isStraightening = false;
    };
    ToolbarModule2.prototype.destroyTopToolbar = function() {
      var parent = this.parent;
      var toolbar = (undefined).getElementById(parent.element.id + "_toolbar");
      if (this.isToolbar() && toolbar && toolbar.classList.contains("e-control")) {
        getComponent(toolbar, "toolbar").destroy();
      }
    };
    ToolbarModule2.prototype.destroyBottomToolbar = function() {
      var parent = this.parent;
      var toolbar = (undefined).getElementById(parent.element.id + "_bottomToolbar");
      if (toolbar && toolbar.classList.contains("e-control")) {
        getComponent(toolbar, "toolbar").destroy();
      }
    };
    ToolbarModule2.prototype.isToolbar = function() {
      var parent = this.parent;
      return isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.length > 0 || !isNullOrUndefined(parent.toolbarTemplate);
    };
    ToolbarModule2.prototype.createToolbar = function() {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.length > 0) {
        parent.element.appendChild(parent.createElement("div", {
          id: id + "_toolbarArea",
          className: "e-toolbar-area"
        }));
        var toolbarItems = {
          cssClass: "e-image-upload",
          align: "Left",
          type: "Input",
          tooltipText: this.l10n.getConstant("Browse"),
          template: new Uploader({ allowedExtensions: parent.uploadSettings.allowedExtensions, multiple: false })
        };
        if (isNullOrUndefined(this.defToolbarItems)) {
          this.defToolbarItems = [];
        }
        this.defToolbarItems.push(toolbarItems);
        var toolbarArea = (undefined).getElementById(id + "_toolbarArea");
        var toolbar_1 = parent.createElement("div", { id: id + "_toolbar" });
        toolbarArea.appendChild(toolbar_1);
        var uploadItems = [
          {
            cssClass: "e-image-upload",
            align: "Left",
            type: "Input",
            tooltipText: this.l10n.getConstant("Browse"),
            template: new Uploader({
              allowedExtensions: parent.uploadSettings.allowedExtensions,
              multiple: false,
              selected: function() {
                var toolbar = (undefined).getElementById(id + "_toolbar");
                var bToolbar = (undefined).getElementById(id + "_bottomToolbar");
                if (!parent.disabled) {
                  if (Browser.isDevice) {
                    if (_this.defToolbarItems.length > 0 && toolbar) {
                      getComponent(toolbar, "toolbar").destroy();
                    }
                    if (bToolbar) {
                      getComponent(bToolbar, "toolbar").destroy();
                    }
                    _this.initMainToolbar(false, Browser.isDevice, null);
                    _this.createBottomToolbar();
                  } else {
                    if (_this.defToolbarItems.length > 0 && toolbar) {
                      getComponent(toolbar, "toolbar").destroy();
                    }
                    _this.initMainToolbar(false, false, null);
                  }
                }
              }
            })
          }
        ];
        var toolbarObj = new Toolbar({
          items: uploadItems,
          width: "100%",
          created: function() {
            parent.trigger("toolbarCreated", { toolbarType: "main" });
          },
          clicked: this.defToolbarClicked.bind(this)
        });
        toolbarObj.appendTo("#" + id + "_toolbar");
        this.createLeftToolbarControls();
        var mToolbar = (undefined).getElementById(id + "_toolbar");
        if (toolbar_1) {
          this.toolbarHeight = mToolbar.clientHeight;
          if (parent.toolbar && parent.toolbar.length > 0 && parent.toolbar.indexOf("Open") === -1) {
            var toolabr = getComponent((undefined).getElementById(parent.element.id + "_toolbar"), "toolbar");
            if (toolabr) {
              toolabr.destroy();
              (undefined).getElementById(parent.element.id + "_toolbar").innerHTML = "";
            }
          }
        }
      } else {
        this.toolbarHeight = 0;
      }
    };
    ToolbarModule2.prototype.createContextualToolbar = function() {
      var parent = this.parent;
      var id = parent.element.id;
      if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.length > 0) {
        var contextualToolbarArea = parent.createElement("div", { id: id + "_contextualToolbarArea", className: "e-contextual-toolbar-wrapper e-hide" });
        contextualToolbarArea.style.position = "absolute";
        parent.element.appendChild(contextualToolbarArea);
        var toolbarArea = (undefined).getElementById(id + "_contextualToolbarArea");
        var toolbar_2 = parent.createElement("div", { id: id + "_contextualToolbar" });
        toolbarArea.appendChild(toolbar_2);
      }
    };
    ToolbarModule2.prototype.createBottomToolbar = function() {
      var parent = this.parent;
      var id = parent.element.id;
      if (parent.element.querySelector("#" + id + "_bottomToolbarArea")) {
        parent.element.querySelector("#" + id + "_bottomToolbarArea").remove();
      }
      if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.length > 0) {
        parent.element.appendChild(parent.createElement("div", {
          id: id + "_bottomToolbarArea",
          className: "e-bottom-toolbar"
        }));
        if (!parent.toolbarTemplate) {
          var toolbarArea = (undefined).getElementById(id + "_bottomToolbarArea");
          var toolbarElem = parent.createElement("div", {
            id: id + "_bottomToolbar"
          });
          toolbarArea.appendChild(toolbarElem);
        }
        this.initBottomToolbar();
      }
    };
    ToolbarModule2.prototype.createQuickAccessToolbar = function() {
      var parent = this.parent;
      var id = parent.element.id;
      if (parent.showQuickAccessToolbar) {
        var toolbarItems = {
          cssClass: "e-image-upload",
          align: "Left",
          type: "Input",
          tooltipText: this.l10n.getConstant("Browse"),
          template: new Uploader({ allowedExtensions: parent.uploadSettings.allowedExtensions, multiple: false })
        };
        if (isNullOrUndefined(this.defToolbarItems)) {
          this.defToolbarItems = [];
        }
        this.defToolbarItems.push(toolbarItems);
        var toolbarArea = (undefined).getElementById(id + "_quickAccessToolbarArea");
        var toolbar_3 = parent.createElement("div", {
          id: id + "_quickAccessToolbar"
        });
        toolbarArea.appendChild(toolbar_3);
        var toolbarObj = new Toolbar({ clicked: this.defToolbarClicked.bind(this) });
        toolbarObj.appendTo("#" + id + "_quickAccessToolbar");
      }
    };
    ToolbarModule2.prototype.initMainToolbar = function(isApplyOption, isDevice, isOkBtn, isResize, isFrame, isMainToolbar, isRedact) {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      if (this.isToolbar()) {
        var leftItem = this.getLeftToolbarItem(isOkBtn, isResize);
        var rightItem = this.getRightToolbarItem(isOkBtn, isMainToolbar, isRedact);
        var mainItem = this.getMainToolbarItem(isApplyOption, isFrame, isRedact);
        var zoomItem = this.getZoomToolbarItem();
        if (isDevice) {
          if (isFrame || isRedact) {
            this.defToolbarItems = mainItem;
          } else {
            this.defToolbarItems = leftItem.concat(rightItem);
          }
        } else {
          this.defToolbarItems = leftItem.concat(mainItem, rightItem, zoomItem);
        }
        var args = { toolbarType: "main", toolbarItems: this.defToolbarItems };
        parent.trigger("toolbarUpdating", args);
        this.defToolbarItems = args.toolbarItems;
        if (this.defToolbarItems.length > 0) {
          var toolbarObj = new Toolbar({
            width: "100%",
            items: this.defToolbarItems,
            clicked: this.defToolbarClicked.bind(this),
            created: function() {
              if (!isDevice) {
                _this.renderAnnotationBtn();
              }
              _this.wireZoomBtnEvents();
              parent.trigger("toolbarCreated", { toolbarType: "main" });
            }
          });
          if (isDevice && isFrame || isDevice && isRedact) {
            toolbarObj.appendTo("#" + id + "_bottomToolbar");
          } else {
            toolbarObj.appendTo("#" + id + "_toolbar");
          }
          this.createLeftToolbarControls();
          this.enableDisableTbrBtn();
          if (this.isToolbar() && (undefined).getElementById(id + "_toolbar")) {
            var toolbar_4 = getComponent(id + "_toolbar", "toolbar");
            toolbar_4.refreshOverflow();
          }
        }
      }
    };
    ToolbarModule2.prototype.initBottomToolbar = function() {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.length > 0) {
        var items = this.getMainToolbarItem();
        var args = { toolbarType: "bottom-toolbar", toolbarItems: items };
        parent.trigger("toolbarUpdating", args);
        items = args.toolbarItems;
        var toolbarObj = new Toolbar({
          items,
          width: "100%",
          created: function() {
            _this.renderAnnotationBtn();
            _this.renderCropBtn();
            _this.renderTransformBtn();
            parent.trigger("toolbarCreated", { toolbarType: "main" });
          },
          clicked: this.defToolbarClicked.bind(this)
        });
        toolbarObj.appendTo("#" + id + "_bottomToolbar");
        if (this.defToolbarItems.length > 0 && (undefined).getElementById(id + "_bottomToolbar")) {
          var toolbar_5 = getComponent(id + "_bottomToolbar", "toolbar");
          toolbar_5.refreshOverflow();
        }
      }
    };
    ToolbarModule2.prototype.getLeftToolbarItem = function(isOkBtn, isResize) {
      var parent = this.parent;
      var id = parent.element.id;
      var toolbarItems = [];
      if (!isOkBtn || isResize) {
        if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.indexOf("Open") > -1) {
          toolbarItems.push({ id: id + "_upload", cssClass: "e-image-upload", align: "Left", type: "Input", template: new Uploader({ allowedExtensions: parent.uploadSettings.allowedExtensions, multiple: false }) });
          toolbarItems.push({ visible: false, cssClass: "e-image-position e-btn e-flat", tooltipText: this.l10n.getConstant("Browse"), align: "Left" });
        } else if (Browser.isDevice && (parent.toolbar && parent.toolbar.indexOf("Open") === -1)) {
          toolbarItems.push({ visible: false, id: id + "_upload", cssClass: "e-image-upload", align: "Left", type: "Input", template: new Uploader({ allowedExtensions: parent.uploadSettings.allowedExtensions, multiple: false }) });
          toolbarItems.push({ visible: false, cssClass: "e-image-position e-btn e-flat", tooltipText: this.l10n.getConstant("Browse"), align: "Left" });
        }
      }
      if (parent.allowUndoRedo && !isResize) {
        if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.indexOf("Undo") > -1) {
          toolbarItems.push({
            id: id + "_undo",
            prefixIcon: "e-icons e-undo",
            cssClass: "top-icon e-undo",
            tooltipText: this.l10n.getConstant("Undo"),
            align: "Left"
          });
        }
        if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.indexOf("Redo") > -1) {
          toolbarItems.push({
            id: id + "_redo",
            prefixIcon: "e-icons e-redo",
            cssClass: "top-icon e-redo",
            tooltipText: this.l10n.getConstant("Redo"),
            align: "Left"
          });
        }
      }
      if (!this.preventZoomBtn && (parent.zoomSettings.zoomTrigger & ZoomTrigger.Toolbar) === ZoomTrigger.Toolbar && !isResize) {
        if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.indexOf("ZoomOut") > -1) {
          toolbarItems.push({
            id: id + "_zoomOut",
            prefixIcon: "e-icons e-zoom-out",
            cssClass: "top-icon e-dec-zoom",
            tooltipText: this.l10n.getConstant("ZoomOut"),
            align: "Left"
          });
        }
        if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.indexOf("ZoomIn") > -1) {
          toolbarItems.push({
            id: id + "_zoomIn",
            prefixIcon: "e-icons e-zoom-in",
            cssClass: "top-icon e-inc-zoom",
            tooltipText: this.l10n.getConstant("ZoomIn"),
            align: "Left"
          });
        }
      }
      var tempToolbarItems = this.processToolbar("left");
      for (var i = 0, len = tempToolbarItems.length; i < len; i++) {
        toolbarItems.push(tempToolbarItems[i]);
      }
      return toolbarItems;
    };
    ToolbarModule2.prototype.getRightToolbarItem = function(isOkBtn, isMainToolbar, isRedact) {
      var parent = this.parent;
      var id = parent.element.id;
      var toolbarItems = [];
      if (isOkBtn || isRedact) {
        toolbarItems.push({
          id: id + "_ok",
          prefixIcon: "e-icons e-check",
          cssClass: "top-icon e-tick",
          tooltipText: this.l10n.getConstant("OK"),
          align: "Right",
          tabIndex: 0
        });
        toolbarItems.push({
          id: id + "_cancel",
          prefixIcon: "e-icons e-close",
          cssClass: "top-icon e-save",
          tooltipText: this.l10n.getConstant("Cancel"),
          align: "Right"
        });
      }
      if ((isMainToolbar || !Browser.isDevice) && (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.indexOf("Reset") > -1)) {
        toolbarItems.push({
          id: id + "_reset",
          prefixIcon: "e-icons e-btn-reset",
          cssClass: "top-icon e-img-reset",
          tooltipText: this.l10n.getConstant("Reset"),
          align: "Right"
        });
      }
      if (!isOkBtn) {
        if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.indexOf("Save") > -1) {
          toolbarItems.push({
            id: id + "_save",
            prefixIcon: "e-icons e-btn-save",
            cssClass: "e-caret-hide top-icon e-save",
            tooltipText: this.l10n.getConstant("Save"),
            align: "Right"
          });
        }
      }
      var tempToolbarItems = this.processToolbar("right");
      for (var i = 0, len = tempToolbarItems.length; i < len; i++) {
        toolbarItems.push(tempToolbarItems[i]);
      }
      return toolbarItems;
    };
    ToolbarModule2.prototype.getMainToolbarItem = function(isApplyOption, isFrame, isRedact) {
      var parent = this.parent;
      var id = parent.element.id;
      var toolbarItems = [];
      if (isFrame) {
        if (isNullOrUndefined(parent.toolbar) || !isNullOrUndefined(parent.toolbar) && parent.toolbar.indexOf("None") > -1 || parent.toolbar.indexOf("Frame") > -1) {
          toolbarItems.push({
            id: id + "_none",
            prefixIcon: "e-icons e-frame-none",
            cssClass: "top-icon e-frame-none",
            tooltipText: this.l10n.getConstant("None"),
            align: "Center"
          });
        }
        if (isNullOrUndefined(parent.toolbar) || !isNullOrUndefined(parent.toolbar) && parent.toolbar.indexOf("Mat") > -1 || parent.toolbar.indexOf("Frame") > -1) {
          toolbarItems.push({
            id: id + "_mat",
            prefixIcon: "e-icons e-frame-mat",
            cssClass: "top-icon e-frame-mat",
            tooltipText: this.l10n.getConstant("Mat"),
            align: "Center"
          });
        }
        if (isNullOrUndefined(parent.toolbar) || !isNullOrUndefined(parent.toolbar) && parent.toolbar.indexOf("Bevel") > -1 || parent.toolbar.indexOf("Frame") > -1) {
          toolbarItems.push({
            id: id + "_bevel",
            prefixIcon: "e-icons e-frame-bevel",
            cssClass: "top-icon e-frame-bevel",
            tooltipText: this.l10n.getConstant("Bevel"),
            align: "Center"
          });
        }
        if (isNullOrUndefined(parent.toolbar) || !isNullOrUndefined(parent.toolbar) && parent.toolbar.indexOf("Line") > -1 || parent.toolbar.indexOf("Frame") > -1) {
          toolbarItems.push({
            id: id + "_line",
            prefixIcon: "e-icons e-frame-line",
            cssClass: "top-icon e-frame-line",
            tooltipText: this.l10n.getConstant("Line"),
            align: "Center"
          });
        }
        if (isNullOrUndefined(parent.toolbar) || !isNullOrUndefined(parent.toolbar) && parent.toolbar.indexOf("Inset") > -1 || parent.toolbar.indexOf("Frame") > -1) {
          toolbarItems.push({
            id: id + "_inset",
            prefixIcon: "e-icons e-frame-inset",
            cssClass: "top-icon e-frame-inset",
            tooltipText: this.l10n.getConstant("Inset"),
            align: "Center"
          });
        }
        if (isNullOrUndefined(parent.toolbar) || !isNullOrUndefined(parent.toolbar) && parent.toolbar.indexOf("Hook") > -1 || parent.toolbar.indexOf("Frame") > -1) {
          toolbarItems.push({
            id: id + "_hook",
            prefixIcon: "e-icons e-frame-hook",
            cssClass: "top-icon e-frame-hook",
            tooltipText: this.l10n.getConstant("Hook"),
            align: "Center"
          });
        }
      } else if (isRedact) {
        toolbarItems.push({
          id: id + "_redactBlur",
          prefixIcon: "e-icons e-tint",
          cssClass: "top-icon e-opacity",
          tooltipText: this.l10n.getConstant("Blur"),
          align: "Center"
        });
        toolbarItems.push({
          id: id + "_pixelate",
          prefixIcon: "e-icons e-opacity",
          cssClass: "top-icon e-opacity",
          tooltipText: this.l10n.getConstant("Pixelate"),
          align: "Center"
        });
        toolbarItems.push({
          id: id + "_duplicate",
          prefixIcon: "e-icons e-order",
          cssClass: "top-icon e-order",
          tooltipText: this.l10n.getConstant("Duplicate"),
          align: "Center"
        });
        toolbarItems.push({
          id: id + "_remove",
          prefixIcon: "e-icons e-trash",
          cssClass: "top-icon e-trash",
          tooltipText: this.l10n.getConstant("Remove"),
          align: "Center"
        });
      } else {
        if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.indexOf("Crop") > -1) {
          toolbarItems.push({
            id: id + "_cropTransform",
            prefixIcon: "e-icons e-crop",
            cssClass: "top-icon e-crop",
            tooltipText: this.l10n.getConstant("CropAndTransform"),
            align: "Center"
          });
        }
        if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.indexOf("Annotate") > -1) {
          toolbarItems.push({
            id: id + "_annotation",
            tooltipText: this.l10n.getConstant("Annotation"),
            align: "Center",
            template: '<button id="' + id + '_annotationBtn"></button>'
          });
        }
        if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.indexOf("Finetune") > -1) {
          toolbarItems.push({
            id: id + "_adjustment",
            prefixIcon: "e-icons e-adjustment",
            cssClass: "top-icon e-adjustment",
            tooltipText: this.l10n.getConstant("Finetune"),
            align: "Center"
          });
        }
        if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.indexOf("Filter") > -1) {
          toolbarItems.push({
            id: id + "_filter",
            prefixIcon: "e-icons e-filters",
            cssClass: "top-icon e-filters",
            tooltipText: this.l10n.getConstant("Filter"),
            align: "Center"
          });
        }
        if (isNullOrUndefined(parent.toolbar) || !isNullOrUndefined(parent.toolbar) && parent.toolbar.indexOf("Frame") > -1) {
          toolbarItems.push({
            id: id + "_frame",
            prefixIcon: "e-icons e-border-frame",
            cssClass: "top-icon e-border-frame",
            tooltipText: this.l10n.getConstant("Frame"),
            align: "Center"
          });
        }
        if (isNullOrUndefined(parent.toolbar) || !isNullOrUndefined(parent.toolbar) && parent.toolbar.indexOf("Resize") > -1) {
          toolbarItems.push({
            id: id + "_resize",
            prefixIcon: "e-icons e-resize",
            cssClass: "top-icon e-resize",
            tooltipText: this.l10n.getConstant("Resize"),
            align: "Center"
          });
        }
        if (isNullOrUndefined(parent.toolbar) || !isNullOrUndefined(parent.toolbar) && parent.toolbar.indexOf("Redact") > -1) {
          toolbarItems.push({
            id: id + "_redact",
            prefixIcon: "e-icons e-redact",
            cssClass: "top-icon e-opacity",
            tooltipText: this.l10n.getConstant("Redact"),
            align: "Center"
          });
        }
      }
      var tempToolbarItems = this.processToolbar("center");
      for (var i = 0, len = tempToolbarItems.length; i < len; i++) {
        toolbarItems.push(tempToolbarItems[i]);
      }
      if (isApplyOption) {
        toolbarItems.push({
          id: id + "_ok",
          prefixIcon: "e-icons e-check",
          cssClass: "top-icon e-tick",
          tooltipText: this.l10n.getConstant("OK"),
          align: "Right",
          tabIndex: 0
        });
        toolbarItems.push({
          id: id + "_cancel",
          prefixIcon: "e-icons e-close",
          cssClass: "top-icon e-save",
          tooltipText: this.l10n.getConstant("Cancel"),
          align: "Right"
        });
      }
      return toolbarItems;
    };
    ToolbarModule2.prototype.getZoomToolbarItem = function() {
      var toolbarItems = [];
      return toolbarItems;
    };
    ToolbarModule2.prototype.updateContextualToolbar = function(type, cType, isSelect) {
      var parent = this.parent;
      var id = parent.element.id;
      var toolbarArea = parent.element.querySelector("#" + id + "_toolbarArea");
      var contextualToolbarArea = parent.element.querySelector("#" + id + "_contextualToolbarArea");
      if (!contextualToolbarArea) {
        return;
      }
      contextualToolbarArea.classList.remove("e-hide");
      contextualToolbarArea.style.left = toolbarArea.offsetLeft + "px";
      if (type === "filter") {
        var toolbar_6 = (undefined).getElementById(id + "_toolbar");
        if (toolbar_6 && this.defToolbarItems.length > 0) {
          getComponent(toolbar_6, "toolbar").destroy();
        }
        if (Browser.isDevice) {
          this.initMainToolbar(false, true, true);
        } else {
          this.initMainToolbar(true, null, null);
        }
        this.refreshSlider();
        this.initFilterToolbarItem();
      } else {
        var ctxToolbar = (undefined).querySelector("#" + id + "_contextualToolbar");
        if (ctxToolbar.classList.contains("e-control")) {
          getComponent(ctxToolbar, "toolbar").destroy();
        }
        this.refreshSlider();
        if (type === "frame") {
          this.initFrameToolbarItem();
        } else {
          this.renderSlider(cType, isSelect);
        }
      }
      if (parent.toolbarTemplate) {
        this.toolbarHeight = parent.element.querySelector("#" + id + "_toolbarArea").clientHeight;
      } else if (parent.element.querySelector("#" + id + "_toolbar")) {
        this.toolbarHeight = parent.element.querySelector("#" + id + "_toolbar").clientHeight;
      }
      parent.toolbarHeight = this.toolbarHeight;
      if (Browser.isDevice) {
        var cHt = contextualToolbarArea.offsetHeight + 1;
        var cusWrapper = parent.element.querySelector("#" + id + "_customizeWrapper");
        if (this.isFrameToolbar && cusWrapper) {
          cHt = cusWrapper.offsetHeight + 2;
        }
        var ht = parent.element.querySelector("#" + id + "_canvasWrapper").offsetHeight;
        contextualToolbarArea.style.top = this.toolbarHeight + 1 + ht - cHt + "px";
        if (cType === "straighten") {
          parent.isStraightening = true;
          var ctxToolbar = parent.element.querySelector("#" + id + "_contextualToolbarArea");
          if (ctxToolbar.style.position === "absolute") {
            ctxToolbar.style.position = "";
            parent.element.insertBefore(ctxToolbar, parent.element.querySelector("#" + id + "_bottomToolbarArea"));
            parent.update();
            if (isSelect) {
              parent.notify("draw", {
                prop: "select",
                onPropertyChange: false,
                value: {
                  type: this.getCropTextContent((undefined).getElementById(id + "_cropBtn")).toLowerCase(),
                  startX: null,
                  startY: null,
                  width: null,
                  height: null
                }
              });
            }
          }
        }
      } else {
        contextualToolbarArea.style.top = this.toolbarHeight + 1 + "px";
      }
    };
    ToolbarModule2.prototype.processToolbar = function(position) {
      var parent = this.parent;
      var toolbarItems = [];
      if (parent.toolbar) {
        for (var i = 0, len = parent.toolbar.length; i < len; i++) {
          if (typeof parent.toolbar[i] === "object") {
            if (isNullOrUndefined(parent.toolbar[i].align)) {
              if (position === "left") {
                toolbarItems.push(parent.toolbar[i]);
              }
            } else if (parent.toolbar[i].align.toLowerCase() === position) {
              toolbarItems.push(parent.toolbar[i]);
            }
          }
        }
      }
      return toolbarItems;
    };
    ToolbarModule2.prototype.processSubToolbar = function(items) {
      var toolbarItems = [];
      if (items) {
        for (var i = 0, len = items.length; i < len; i++) {
          if (typeof items[i] === "object") {
            items[i].align = "Center";
            toolbarItems.push(items[i]);
          }
        }
      }
      return toolbarItems;
    };
    ToolbarModule2.prototype.wireZoomBtnEvents = function() {
      var zoomIn = (undefined).querySelector("#" + this.parent.element.id + "_zoomIn");
      var zoomOut = (undefined).querySelector("#" + this.parent.element.id + "_zoomOut");
      if (zoomIn) {
        zoomIn.addEventListener("mousedown", this.zoomInBtnMouseDownHandler.bind(this));
        zoomIn.addEventListener("mouseup", this.zoomBtnMouseUpHandler.bind(this));
        zoomIn.addEventListener("click", this.zoomInBtnClickHandler.bind(this));
      }
      if (zoomOut) {
        zoomOut.addEventListener("mousedown", this.zoomOutBtnMouseDownHandler.bind(this));
        zoomOut.addEventListener("mouseup", this.zoomBtnMouseUpHandler.bind(this));
        zoomOut.addEventListener("click", this.zoomOutBtnClickHandler.bind(this));
      }
    };
    ToolbarModule2.prototype.widthPress = function(e) {
      if (e.keyCode === 109) {
        e.preventDefault();
        return;
      }
    };
    ToolbarModule2.prototype.heightPress = function(e) {
      if (e.keyCode === 109) {
        e.preventDefault();
        return;
      }
    };
    ToolbarModule2.prototype.widthAspectRatio = function(e) {
      if (e.keyCode === 109 || e.keyCode === 9) {
        return;
      }
      var parent = this.parent;
      var id = parent.element.id;
      var aspectRatioHeight = parent.element.querySelector("#" + id + "_resizeHeight");
      var aspectRatioWidth = parent.element.querySelector("#" + id + "_resizeWidth");
      var icon = parent.element.querySelector("#" + id + "_aspectratio");
      var originalWidth2 = parent.img.destWidth;
      var originalHeight2 = parent.img.destHeight;
      var aspectRatioHeightValue = parseFloat(aspectRatioHeight.value);
      var val = aspectRatioHeightValue / (originalHeight2 / originalWidth2);
      var width = val % 1 >= 0.5 || val % 1 <= -0.5 ? Math.round(val) : val < 0 ? Math.ceil(val) : Math.floor(val);
      var widthNumeric = getComponent(aspectRatioWidth, "numerictextbox");
      var heightNumeric = getComponent(aspectRatioWidth, "numerictextbox");
      if (icon) {
        if (width != null && !isNaN(width)) {
          if (isNullOrUndefined(widthNumeric.value)) {
            widthNumeric.placeholder = width + " px";
            aspectRatioWidth.placeholder = width.toString() + " px";
          } else {
            widthNumeric.value = width;
            aspectRatioWidth.value = width.toString() + " px";
          }
        } else {
          if (isNullOrUndefined(widthNumeric.value)) {
            widthNumeric.placeholder = "0 px";
            aspectRatioWidth.placeholder = "0 px";
            if (isNullOrUndefined(heightNumeric.value) && !isNullOrUndefined(heightNumeric.placeholder)) {
              widthNumeric.placeholder = "" + parent.img.srcWidth;
              aspectRatioWidth.placeholder = "" + parent.img.srcWidth;
            }
          } else {
            widthNumeric.value = 0;
            aspectRatioWidth.value = "0 px";
          }
        }
      }
    };
    ToolbarModule2.prototype.heightAspectRatio = function(e) {
      if (e.keyCode === 109 || e.keyCode === 9) {
        return;
      }
      var parent = this.parent;
      var id = parent.element.id;
      var aspectRatioHeight = parent.element.querySelector("#" + id + "_resizeHeight");
      var aspectRatioWidth = parent.element.querySelector("#" + id + "_resizeWidth");
      var icon = parent.element.querySelector("#" + id + "_aspectratio");
      var originalWidth2 = parent.img.destWidth;
      var originalHeight2 = parent.img.destHeight;
      var aspectRatioWidthValue = parseFloat(aspectRatioWidth.value);
      var value = aspectRatioWidthValue / (originalWidth2 / originalHeight2);
      var ht = value % 1 >= 0.5 || value % 1 <= -0.5 ? Math.round(value) : value < 0 ? Math.ceil(value) : Math.floor(value);
      var heightNumeric = getComponent(aspectRatioHeight, "numerictextbox");
      var widthNumeric = getComponent(aspectRatioWidth, "numerictextbox");
      if (icon) {
        if (!isNaN(ht)) {
          if (isNullOrUndefined(heightNumeric.value)) {
            heightNumeric.placeholder = ht + " px";
            aspectRatioHeight.placeholder = ht.toString() + " px";
          } else {
            heightNumeric.value = ht;
            aspectRatioHeight.value = ht.toString() + " px";
          }
        } else {
          if (isNullOrUndefined(heightNumeric.value)) {
            heightNumeric.placeholder = "0 px";
            aspectRatioHeight.placeholder = "0 px";
            if (isNullOrUndefined(widthNumeric.value) && !isNullOrUndefined(widthNumeric.placeholder)) {
              heightNumeric.placeholder = "" + parent.img.srcHeight;
              aspectRatioHeight.placeholder = "" + parent.img.srcHeight;
            }
          } else {
            heightNumeric.value = 0;
            aspectRatioHeight.value = "0 px";
          }
        }
      }
    };
    ToolbarModule2.prototype.getResizeToolbarItem = function() {
      var parent = this.parent;
      var id = parent.element.id;
      var isResize = parent.aspectWidth && parent.aspectHeight ? true : false;
      var width = this.parent.transform.degree % 90 === 0 && this.parent.transform.degree % 180 !== 0 ? Math.ceil(this.parent.img.srcHeight).toString() : Math.ceil(this.parent.img.srcWidth).toString();
      var height = this.parent.transform.degree % 90 === 0 && this.parent.transform.degree % 180 !== 0 ? Math.ceil(this.parent.img.srcWidth).toString() : Math.ceil(this.parent.img.srcHeight).toString();
      var toolbarItems = [];
      var spanWidth = (undefined).createElement("span");
      spanWidth.innerHTML = this.l10n.getConstant("W");
      toolbarItems.push({ id: id + "_width", cssClass: "e-ie-resize-width", template: spanWidth, align: "Center" });
      toolbarItems.push({
        id: id + "_resizeWidth",
        prefixIcon: "e-icons e-anti-clock-wise",
        tooltipText: this.l10n.getConstant("Width"),
        align: "Center",
        type: "Input",
        template: new NumericTextBox({
          width: 75,
          htmlAttributes: { maxLength: "4" },
          showSpinButton: false,
          value: isResize ? parent.aspectWidth : null,
          placeholder: isResize ? null : width,
          format: "###.## px"
        })
      });
      var spanHeight = (undefined).createElement("span");
      spanHeight.innerHTML = this.l10n.getConstant("H");
      toolbarItems.push({ id: id + "_height", cssClass: "e-ie-resize-height", template: spanHeight, align: "Center" });
      toolbarItems.push({
        id: id + "_resizeHeight",
        prefixIcon: "e-icons e-clock-wise",
        tooltipText: this.l10n.getConstant("Height"),
        align: "Center",
        type: "Input",
        template: new NumericTextBox({
          width: 75,
          htmlAttributes: { maxLength: "4" },
          showSpinButton: false,
          value: isResize ? parent.aspectHeight : null,
          placeholder: isResize ? null : height,
          format: "###.## px"
        })
      });
      if (!this.isAspectRatio) {
        toolbarItems.push({
          id: id + "_aspectratio",
          prefixIcon: "e-icons e-lock",
          align: "Center",
          tooltipText: this.l10n.getConstant("AspectRatio"),
          type: "Button",
          tabIndex: 0
        });
        this.isAspectRatio = true;
      } else {
        toolbarItems.push({ id: id + "_nonaspectratio", prefixIcon: "e-icons e-unlock", align: "Center", tooltipText: this.l10n.getConstant("AspectRatio"), type: "Button" });
        this.isAspectRatio = false;
      }
      if (!Browser.isDevice) {
        toolbarItems.push({
          id: id + "_ok",
          prefixIcon: "e-icons e-check",
          cssClass: "top-icon e-tick",
          tooltipText: this.l10n.getConstant("OK"),
          align: "Right",
          tabIndex: 0
        });
        toolbarItems.push({
          id: id + "_cancel",
          prefixIcon: "e-icons e-close",
          cssClass: "top-icon e-save",
          tooltipText: this.l10n.getConstant("Cancel"),
          align: "Right"
        });
      }
      return toolbarItems;
    };
    ToolbarModule2.prototype.initResizeToolbar = function() {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      var leftItem = this.getLeftToolbarItem(false, true);
      var rightItem = this.getRightToolbarItem();
      var mainItem = this.getResizeToolbarItem();
      var zoomItem = this.getZoomToolbarItem();
      if (Browser.isDevice) {
        this.defToolbarItems = mainItem;
      } else {
        this.defToolbarItems = leftItem.concat(zoomItem, mainItem, rightItem);
      }
      var args = { toolbarType: "resize", toolbarItems: this.defToolbarItems };
      parent.trigger("toolbarUpdating", args);
      this.defToolbarItems = args.toolbarItems;
      var toolbar = new Toolbar({
        width: "100%",
        items: this.defToolbarItems,
        clicked: this.defToolbarClicked.bind(this),
        created: function() {
          _this.wireResizeBtnEvents();
          parent.trigger("toolbarCreated", { toolbarType: "shapes" });
          if (Browser.isDevice) {
            if (_this.defToolbarItems.length > 0 && !isNullOrUndefined((undefined).getElementById(id + "_bottomToolbar"))) {
              toolbar.refreshOverflow();
            }
          } else {
            _this.createLeftToolbarControls();
            if (_this.defToolbarItems.length > 0 && !isNullOrUndefined((undefined).getElementById(id + "_toolbar"))) {
              toolbar.refreshOverflow();
            }
          }
        }
      });
      if (Browser.isDevice) {
        toolbar.appendTo("#" + id + "_bottomToolbar");
      } else {
        toolbar.appendTo("#" + id + "_toolbar");
      }
      parent.isResize = false;
      this.enableDisableTbrBtn();
      parent.isResize = true;
      parent.notify("transform", { prop: "disableZoomOutBtn", value: { isZoomOut: true } });
    };
    ToolbarModule2.prototype.wireResizeBtnEvents = function() {
      var parent = this.parent;
      var id = parent.element.id;
      var aspectRatioHeight = parent.element.querySelector("#" + id + "_resizeHeight");
      var aspectRatioWidth = parent.element.querySelector("#" + id + "_resizeWidth");
      if (!isNullOrUndefined(aspectRatioHeight)) {
        aspectRatioHeight.addEventListener("keydown", this.widthPress.bind(this));
        aspectRatioWidth.addEventListener("keyup", this.heightAspectRatio.bind(this));
      }
      if (!isNullOrUndefined(aspectRatioWidth)) {
        aspectRatioWidth.addEventListener("keydown", this.heightPress.bind(this));
        aspectRatioHeight.addEventListener("keyup", this.widthAspectRatio.bind(this));
      }
    };
    ToolbarModule2.prototype.enableDisableTbrBtn = function() {
      var parent = this.parent;
      var id = parent.element.id;
      if (!this.preventEnableDisableUr) {
        var object = { appliedUndoRedoColl: [] };
        parent.notify("undo-redo", { prop: "getAppliedUndoRedoColl", value: { obj: object } });
        var undoRedoObj = { undoRedoStep: null };
        parent.notify("undo-redo", { prop: "getUndoRedoStep", value: { obj: undoRedoObj } });
        var undo = parent.element.querySelector("#" + id + "_undo");
        if (undo && undoRedoObj["undoRedoStep"] === 0) {
          undo.classList.add("e-disabled");
          undo.parentElement.classList.add("e-overlay");
        } else if (undo && undoRedoObj["undoRedoStep"] > 0) {
          undo.classList.remove("e-disabled");
          undo.parentElement.classList.remove("e-overlay");
        }
        var redo = parent.element.querySelector("#" + id + "_redo");
        if (redo && undoRedoObj["undoRedoStep"] === object["appliedUndoRedoColl"].length) {
          redo.classList.add("e-disabled");
          redo.parentElement.classList.add("e-overlay");
        } else if (redo && (undoRedoObj["undoRedoStep"] === 0 && object["appliedUndoRedoColl"].length > 0)) {
          redo.classList.remove("e-disabled");
          redo.parentElement.classList.remove("e-overlay");
        } else if (redo && undoRedoObj["undoRedoStep"] > 0) {
          redo.classList.remove("e-disabled");
          redo.parentElement.classList.remove("e-overlay");
        }
      }
      var zoomIn = (undefined).querySelector("#" + id + "_zoomIn");
      if (zoomIn && parent.zoomSettings.zoomFactor >= parent.zoomSettings.maxZoomFactor) {
        zoomIn.classList.add("e-disabled");
        zoomIn.parentElement.classList.add("e-overlay");
      } else if (zoomIn) {
        zoomIn.classList.remove("e-disabled");
        zoomIn.parentElement.classList.remove("e-overlay");
      }
      var zoomOut = (undefined).querySelector("#" + id + "_zoomOut");
      if (zoomOut && parent.zoomSettings.zoomFactor <= parent.zoomSettings.minZoomFactor) {
        zoomOut.classList.add("e-disabled");
        zoomOut.parentElement.classList.add("e-overlay");
      } else if (zoomOut) {
        zoomOut.classList.remove("e-disabled");
        zoomOut.parentElement.classList.remove("e-overlay");
      }
      var frame = (undefined).querySelector("#" + id + "_frame");
      if (frame && (parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle" || parent.isCircleCrop)) {
        frame.classList.add("e-overlay");
      } else if (frame) {
        frame.classList.remove("e-overlay");
      }
      var ratio = (undefined).querySelector("#" + id + "_aspectratio");
      if (ratio && (parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle" || parent.isCircleCrop)) {
        ratio.classList.add("e-overlay");
      } else if (ratio) {
        ratio.classList.remove("e-overlay");
      }
    };
    ToolbarModule2.prototype.createLeftToolbarControls = function() {
      var parent = this.parent;
      var id = parent.element.id;
      if (this.defToolbarItems !== undefined && this.defToolbarItems.length > 0 && (undefined).getElementById(id + "_toolbar")) {
        var uploadDiv = (undefined).getElementById(id + "_toolbar").querySelector(".e-image-upload");
        if (uploadDiv) {
          var uploadElem = uploadDiv.getElementsByTagName("input")[0];
          var uploadBtnElem = uploadDiv.getElementsByTagName("button")[0];
          uploadBtnElem.className = "e-tbar-btn e-tbtn-txt top-icon";
          uploadBtnElem.innerHTML = "";
          uploadBtnElem.title = this.l10n.getConstant("Browse");
          uploadBtnElem.appendChild(parent.createElement("span", {
            className: "e-btn-icon e-icons e-upload-icon e-icon-left"
          }));
          uploadElem.onchange = this.fileSelect.bind(this, uploadElem);
        }
      }
    };
    ToolbarModule2.prototype.fileSelect = function(inputElement, args) {
      var parent = this.parent;
      var type = inputElement.files[0].type.split("/")[1];
      var filesTypes = this.parent.getExtensionArray();
      var isJPG = (type === "jpg" || type === "jpeg") && (parent.uploadSettings.allowedExtensions.indexOf("jpg") > -1 || parent.uploadSettings.allowedExtensions.indexOf("jpeg") > -1);
      this.fileName = inputElement.files[0].name.split(".")[0];
      var size = inputElement.files[0].size;
      this.parent.notify("toolbar", { prop: "setInitialSize", value: { value: inputElement.files[0].size } });
      if ((filesTypes.indexOf(type) > -1 || isJPG || type.indexOf("svg") > -1 && filesTypes.indexOf("svg") > -1) && (!this.parent.uploadSettings.minFileSize || size > this.parent.uploadSettings.minFileSize) && (!this.parent.uploadSettings.maxFileSize || size < this.parent.uploadSettings.maxFileSize)) {
        this.parent.notify("draw", { prop: "fileSelect", value: { inputElement, args } });
      } else {
        if (!this.parent.isImageLoaded) {
          this.destroyTopToolbar();
          this.createToolbar();
          if (Browser.isDevice) {
            this.destroyBottomToolbar();
          }
        }
        this.parent.showDialogPopup("unsupported", !(filesTypes.indexOf(type) > -1 || isJPG || type.indexOf("svg") > -1 && filesTypes.indexOf("svg") > -1));
      }
    };
    ToolbarModule2.prototype.triggerTbarClickEvent = function(args) {
      var clickEvent = { item: args.item, originalEvent: args.event };
      this.parent.trigger("toolbarItemClicked", clickEvent);
    };
    ToolbarModule2.prototype.renderAnnotationBtn = function(isContextualToolbar) {
      var _this = this;
      var parent = this.parent;
      var isCustomized = false;
      var items = [];
      var id = parent.element.id;
      var defItems = ["Ellipse", "Arrow", "Line", "Rectangle", "Pen", "Path", "Text", "Image"];
      if (parent.toolbar) {
        for (var i = 0; i < defItems.length; i++) {
          if (parent.toolbar.indexOf(defItems[i]) !== -1) {
            isCustomized = true;
            break;
          }
        }
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Pen") > -1) {
        items.push({ text: this.l10n.getConstant("Pen"), id: "pen", iconCss: "e-icons e-free-pen" });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Line") > -1) {
        items.push({ text: this.l10n.getConstant("Line"), id: "line", iconCss: "e-icons e-line" });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Rectangle") > -1) {
        items.push({ text: this.l10n.getConstant("Rectangle"), id: "rectangle", iconCss: "e-icons e-rectangle" });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Ellipse") > -1) {
        items.push({ text: this.l10n.getConstant("Ellipse"), id: "ellipse", iconCss: "e-icons e-circle" });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Arrow") > -1) {
        items.push({ text: this.l10n.getConstant("Arrow"), id: "arrow", iconCss: "e-icons e-arrow-right-up" });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Path") > -1) {
        items.push({ text: this.l10n.getConstant("Path"), id: "path", iconCss: "e-icons e-critical-path" });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Text") > -1) {
        items.push({ text: this.l10n.getConstant("Text"), id: "text", iconCss: "e-icons e-add-text" });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Image") > -1) {
        items.push({ text: this.l10n.getConstant("Image"), id: "image", iconCss: "e-icons e-image" });
      }
      var obj = { freehandDrawSelectedId: null };
      parent.notify("freehand-draw", { prop: "getFreehandDrawSelectedId", onPropertyChange: false, value: { obj } });
      var toolbarId = Browser.isDevice ? "#" + id + "_bottomToolbar #" + id : "#" + id;
      this.enableDisableCloneBtn(toolbarId, obj);
      var iconCss = isContextualToolbar ? this.getCurrentShapeIcon(parent.activeObj.shape) : "e-annotation";
      var drpDownBtn = new DropDownButton({
        items,
        iconCss: "e-icons " + iconCss,
        cssClass: "e-image-popup",
        open: function(args) {
          if (parent.currObjType.isFiltered || parent.currObjType.isRedact) {
            parent.okBtn();
            parent.element.querySelector("#" + id + "_annotationBtn").click();
          }
          if (Browser.isDevice) {
            args.element.parentElement.style.top = drpDownBtn.element.getBoundingClientRect().top - args.element.parentElement.offsetHeight + "px";
          }
          if (parent.activeObj.shape) {
            (undefined).getElementById(parent.activeObj.shape).classList.add("e-selected");
          } else if (parent.togglePen) {
            (undefined).getElementById("pen").classList.add("e-selected");
          }
        },
        select: function(args) {
          parent.noPushUndo = false;
          _this.triggerTbarClickEvent(args);
          parent.okBtn();
          var isCropSelection = false;
          var splitWords;
          if (parent.activeObj.shape !== undefined) {
            splitWords = parent.activeObj.shape.split("-");
          }
          if (splitWords === undefined && parent.currObjType.isCustomCrop) {
            isCropSelection = true;
          } else if (splitWords !== undefined && splitWords[0] === "crop") {
            isCropSelection = true;
          }
          parent.currObjType.isCustomCrop = false;
          if (isCropSelection || parent.togglePan) {
            parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
            _this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            _this.refreshToolbar("main");
          }
          var obj2 = { currentFreehandDrawIndex: null };
          parent.notify("freehand-draw", { prop: "getCurrentFreehandDrawIndex", value: { obj: obj2 } });
          var prevObj = { shapeSettingsObj: {} };
          var shapeSettings;
          var shapeChangingArgs;
          var shapes = ["ellipse", "rectangle", "text", "image"];
          var allowOutofBound;
          drpDownBtn.iconCss = "e-icons " + _this.getCurrentShapeIcon(args.item.id);
          parent.notify("draw", { prop: "updateTempObjColl" });
          parent.notify("draw", { prop: "updateTempPointColl" });
          var penStrokeWidthObj = { penStrokeWidth: 2 };
          switch (args.item.id) {
            case "pen":
              parent.notify("freehand-draw", { prop: "getPenStrokeWidth", onPropertyChange: false, value: { obj: penStrokeWidthObj } });
              parent.notify("draw", { prop: "setTempStrokeWidth", value: { strokeWidth: penStrokeWidthObj["penStrokeWidth"] } });
              parent.drawingShape = null;
              parent.notify("draw", { prop: "setTempFreehandCounter", value: { tempFreehandCounter: parent.freehandCounter } });
              parent.notify("draw", { prop: "setTempCurrentFreehandDrawIndex", value: { tempCurrentFreehandDrawIndex: obj2["currentFreehandDrawIndex"] } });
              _this.currentToolbar = "pen";
              parent.freeHandDraw(true);
              parent.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj: prevObj } });
              shapeSettings = prevObj["shapeSettingsObj"];
              parent.notify("freehand-draw", { prop: "getPenStrokeWidth", onPropertyChange: false, value: { obj: penStrokeWidthObj } });
              shapeSettings.strokeWidth = penStrokeWidthObj["penStrokeWidth"];
              shapeSettings.type = ShapeType.FreehandDraw;
              shapeChangingArgs = {
                cancel: false,
                action: "insert",
                previousShapeSettings: shapeSettings,
                currentShapeSettings: shapeSettings
              };
              parent.notify("freehand-draw", { prop: "triggerShapeChanging", value: { shapeChangingArgs } });
              break;
            case "text":
              _this.currentToolbar = "text";
              parent.drawingShape = args.item.id;
              _this.currentToolbar = "text";
              _this.setInitialShapeSettings(args);
              parent.notify("selection", { prop: "annotate", value: { shape: args.item.id } });
              parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
                type: "text",
                isApplyBtn: null,
                isCropping: null,
                isZooming: null,
                cType: null
              } });
              break;
            case "image":
              parent.drawingShape = null;
              _this.currentToolbar = "shapes";
              parent.element.querySelector("#" + id + "_fileUpload").click();
              break;
            case "ellipse":
            case "arrow":
            case "line":
            case "rectangle":
            case "path":
              parent.drawingShape = args.item.id;
              _this.currentToolbar = "shapes";
              _this.setInitialShapeSettings(args);
              parent.notify("selection", { prop: "annotate", value: { shape: args.item.id } });
              parent.notify("toolbar", { prop: "refresh-toolbar", onPropertyChange: false, value: {
                type: "shapes",
                isApplyBtn: null,
                isCropping: null,
                isZooming: null,
                cType: null
              } });
              parent.notify("selection", { prop: "updatePrevShapeSettings", onPropertyChange: false, value: { obj: prevObj } });
              shapeSettings = prevObj["shapeSettingsObj"];
              allowOutofBound = shapes.indexOf(_this.parent.activeObj.shape) !== -1 ? false : true;
              shapeChangingArgs = {
                cancel: false,
                action: "insert",
                previousShapeSettings: shapeSettings,
                currentShapeSettings: shapeSettings,
                allowShapeOverflow: allowOutofBound
              };
              parent.trigger("shapeChanging", shapeChangingArgs);
              parent.editCompleteArgs = shapeChangingArgs;
              parent.notify("shape", { prop: "updateShapeChangeEventArgs", value: { shapeSettings: shapeChangingArgs.currentShapeSettings } });
              break;
          }
          _this.updateToolbarItems();
          var tempTogglePen = parent.togglePen;
          if (args.item.id === "pen") {
            parent.togglePen = false;
          }
          parent.notify("draw", { prop: "redrawDownScale" });
          parent.togglePen = tempTogglePen;
        }
      });
      drpDownBtn.appendTo("#" + id + "_annotationBtn");
    };
    ToolbarModule2.prototype.enableDisableCloneBtn = function(toolbarId, obj) {
      var parent = this.parent;
      var isDummyTextClick = false;
      var width = Math.floor(parent.activeObj.activePoint.width);
      if (parent.activeObj.shape && parent.activeObj.shape === "text" && parent.activeObj.textSettings.fontSize === 11 && (width === 55 || parent.activeObj.textSettings.bold && width === 58) && Math.floor(parent.activeObj.activePoint.height) === 11) {
        isDummyTextClick = true;
      }
      var duplicateElement = (undefined).querySelector(toolbarId + "_duplicate");
      var removeElement = (undefined).querySelector(toolbarId + "_remove");
      var editTextElement = (undefined).querySelector(toolbarId + "_editText");
      var zOrderElement = (undefined).querySelector(toolbarId + "_zOrderBtn");
      if (isDummyTextClick || parent.activeObj.activePoint.width === 0 && parent.activeObj.activePoint.height === 0 && (isNullOrUndefined(parent.activeObj.pointColl) || parent.activeObj.pointColl && parent.activeObj.pointColl.length === 0) && isNullOrUndefined(obj["freehandDrawSelectedId"])) {
        if (duplicateElement) {
          duplicateElement.classList.add("e-overlay");
        }
        if (removeElement) {
          removeElement.classList.add("e-overlay");
        }
        if (editTextElement) {
          editTextElement.classList.add("e-overlay");
        }
        if (zOrderElement) {
          zOrderElement.classList.add("e-overlay");
        }
      } else {
        if (duplicateElement) {
          duplicateElement.classList.remove("e-overlay");
        }
        if (removeElement) {
          removeElement.classList.remove("e-overlay");
        }
        if (editTextElement) {
          editTextElement.classList.remove("e-overlay");
        }
        if (zOrderElement) {
          zOrderElement.classList.remove("e-overlay");
        }
      }
      if (zOrderElement && (parent.shapeColl.length === 0 || obj["freehandDrawSelectedId"] && parent.shapeColl.length === 1)) {
        zOrderElement.classList.add("e-overlay");
      }
    };
    ToolbarModule2.prototype.renderStraightenSlider = function() {
      var parent = this.parent;
      var id = parent.element.id;
      if ((isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.indexOf("Straightening") > -1) && parent.element.querySelector("#" + id + "_straightenSlider")) {
        var slider = this.createSlider(-45, 45, parent.cropObj.straighten, "straighten");
        slider.appendTo("#" + id + "_straightenSlider");
        var sliderHandle = slider.element.querySelector(".e-handle");
        if (sliderHandle && !Browser.isDevice) {
          sliderHandle.addEventListener("mousedown", function(e) {
            e.preventDefault();
            e.stopPropagation();
          });
          sliderHandle.addEventListener("touchstart", function(e) {
            e.preventDefault();
            e.stopPropagation();
          });
        }
      }
    };
    ToolbarModule2.prototype.renderCropBtn = function(shapeString) {
      var _this = this;
      var parent = this.parent;
      var items = [];
      var isCustomized = false;
      var defItems = ["CustomSelection", "CircleSelection", "SquareSelection", "RatioSelection"];
      if (parent.toolbar) {
        for (var i = 0; i < defItems.length; i++) {
          if (parent.toolbar.indexOf(defItems[i]) !== -1) {
            isCustomized = true;
            break;
          }
        }
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("CustomSelection") > -1) {
        items.push({ text: this.l10n.getConstant("Custom"), id: "custom", iconCss: "e-icons e-custom" });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("CircleSelection") > -1) {
        items.push({ text: this.l10n.getConstant("Circle"), id: "circle", iconCss: "e-icons e-circle" });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("SquareSelection") > -1) {
        items.push({ text: this.l10n.getConstant("Square"), id: "square", iconCss: "e-icons e-square" });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("RatioSelection") > -1) {
        items.push({ text: "2:3", id: "2:3", iconCss: "e-icons e-custom-f" });
        items.push({ text: "3:2", id: "3:2", iconCss: "e-icons e-custom-a" });
        items.push({ text: "3:4", id: "3:4", iconCss: "e-icons e-custom-g" });
        items.push({ text: "4:3", id: "4:3", iconCss: "e-icons e-custom-b" });
        items.push({ text: "4:5", id: "4:5", iconCss: "e-icons e-custom-h" });
        items.push({ text: "5:4", id: "5:4", iconCss: "e-icons e-custom-c" });
        items.push({ text: "5:7", id: "5:7", iconCss: "e-icons e-custom-i" });
        items.push({ text: "7:5", id: "7:5", iconCss: "e-icons e-custom-d" });
        items.push({ text: "9:16", id: "9:16", iconCss: "e-icons e-custom-j" });
        items.push({ text: "16:9", id: "16:9", iconCss: "e-icons e-custom-e" });
      }
      var iconCss;
      var shape;
      if (shapeString) {
        iconCss = this.getCurrentShapeIcon(shapeString);
        shape = shapeString;
      } else if (parent.activeObj.shape && (parent.activeObj.activePoint.width !== 0 || parent.activeObj.activePoint.height !== 0) || parent.activeObj.shape === "path" && parent.activeObj.pointColl.length > 0) {
        iconCss = this.getCurrentShapeIcon(parent.activeObj.shape);
        shape = parent.activeObj.shape;
      } else if (parent.currSelectionPoint) {
        iconCss = this.getCurrentShapeIcon(parent.currSelectionPoint.shape);
        shape = parent.currSelectionPoint.shape;
      } else {
        iconCss = items[0].iconCss;
        shape = items[0].id;
      }
      var drpDownBtn = new DropDownButton({
        open: function(args) {
          if (parent.togglePan) {
            _this.cancelPan();
          }
          if (Browser.isDevice) {
            args.element.parentElement.style.top = drpDownBtn.element.getBoundingClientRect().top - args.element.parentElement.offsetHeight + "px";
          }
          if (parent.activeObj.shape && parent.activeObj.shape.split("-").length > 1) {
            var elem = (undefined).getElementById(parent.activeObj.shape.split("-")[1]);
            if (elem) {
              elem.classList.add("e-selected");
              elem.focus();
            }
          }
          parent.notify("transform", { prop: "disableZoomOutBtn", value: { isZoomOut: true } });
        },
        items,
        select: function(args) {
          _this.triggerTbarClickEvent(args);
          _this.cropSelect(args);
          drpDownBtn.iconCss = "e-icons " + _this.getCurrentShapeIcon("crop-" + args.item.id);
          drpDownBtn.content = Browser.isDevice ? null : parent.toPascalCase(args.item.id);
        },
        iconCss: "e-icons " + iconCss,
        cssClass: "e-image-popup e-ie-crop-ddb-popup",
        content: Browser.isDevice ? null : parent.toPascalCase(shape.replace("crop-", ""))
      });
      drpDownBtn.appendTo("#" + parent.element.id + "_cropBtn");
    };
    ToolbarModule2.prototype.renderTransformBtn = function() {
      var _this = this;
      var parent = this.parent;
      var items = [];
      if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.indexOf("RotateLeft") > -1) {
        items.push({ text: this.l10n.getConstant("RotateLeft"), id: "rotateleft", iconCss: "e-icons e-anti-clock-wise" });
      }
      if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.indexOf("RotateRight") > -1) {
        items.push({ text: this.l10n.getConstant("RotateRight"), id: "rotateright", iconCss: "e-icons e-clock-wise" });
      }
      if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.indexOf("FlipHorizontal") > -1) {
        items.push({ text: this.l10n.getConstant("HorizontalFlip"), id: "horizontalflip", iconCss: "e-icons e-horizontal-flip" });
      }
      if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.indexOf("FlipVertical") > -1) {
        items.push({ text: this.l10n.getConstant("VerticalFlip"), id: "verticalflip", iconCss: "e-icons e-vertical-flip" });
      }
      var drpDownBtn = new DropDownButton({
        open: function(args) {
          if (Browser.isDevice) {
            var elem = args.element.parentElement;
            var ht = elem.offsetHeight;
            elem.style.display = "none";
            elem.style.top = drpDownBtn.element.getBoundingClientRect().top - ht + "px";
            elem.style.display = "block";
          }
        },
        items,
        select: function(args) {
          _this.triggerTbarClickEvent(args);
          parent.transformSelect.bind(_this);
        },
        iconCss: "e-icons e-transform",
        cssClass: "e-image-popup"
      });
      drpDownBtn.appendTo("#" + parent.element.id + "_transformBtn");
    };
    ToolbarModule2.prototype.saveDialogPopup = function() {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      var quality = ["Good", "Great", "Highest"];
      parent.element.appendChild(parent.createElement("div", { id: id + "_saveDialog" }));
      var dialogContent = parent.createElement("div", {
        id: id + "_dialogContent"
      });
      dialogContent.style.display = "flex";
      var dialogImgContent = dialogContent.appendChild(parent.createElement("div", {
        id: id + "_dialogImgContent",
        className: "e-ie-dlg-img-content"
      }));
      dialogImgContent.appendChild(parent.createElement("canvas", {
        id: id + "_imgPic",
        className: "e-ie-img-dlg-canvas"
      }));
      var imageNameContainer = dialogImgContent.appendChild(parent.createElement("div", {
        id: id + "_imageNameContainer",
        className: "e-ie-img-size"
      }));
      imageNameContainer.appendChild(parent.createElement("span", {
        id: id + "_imageNameLabel",
        className: "e-ie-quality-info"
      }));
      var dialogRightContent = dialogContent.appendChild(parent.createElement("div", {
        id: id + "_dialogRightContent",
        className: "e-ie-dlg-right-content"
      }));
      var imageNameDiv = dialogRightContent.appendChild(parent.createElement("div", {
        id: id + "_namediv",
        className: "e-ie-img-save-name"
      }));
      imageNameDiv.appendChild(parent.createElement("span", {
        id: id + "_labelImgname",
        className: "e-ie-img-label-name",
        innerHTML: this.l10n.getConstant("ImageName")
      }));
      imageNameDiv.appendChild(parent.createElement("input", {
        id: id + "_imgNametext",
        className: "e-ie-img-input",
        attrs: { type: "text" }
      }));
      var formatNameDiv = dialogRightContent.appendChild(parent.createElement("div", {
        id: id + "_imgNamediv",
        className: "e-ie-img-save-dlg"
      }));
      formatNameDiv.appendChild(parent.createElement("span", {
        id: id + "_labelname",
        className: "e-ie-img-label-name",
        innerHTML: this.l10n.getConstant("Format")
      }));
      formatNameDiv.appendChild(parent.createElement("button", {
        id: id + "_saveDropdownbtn",
        attrs: { tabindex: "1" }
      }));
      var qualityNameDiv = dialogRightContent.appendChild(parent.createElement("div", {
        id: id + "_imgQualitydiv",
        className: "e-ie-img-quality-name"
      }));
      var qualityDiv = parent.createElement("div", {
        id: id + "_qualityContainer"
      });
      qualityDiv.appendChild(parent.createElement("span", {
        id: id + "_qualityLabel",
        className: "e-ie-img-quality-label",
        innerHTML: this.l10n.getConstant("Quality")
      }));
      qualityDiv.appendChild(parent.createElement("span", {
        id: id + "_qualityInfo",
        className: "e-circle-info e-icons e-ie-quality-span",
        attrs: { title: this.l10n.getConstant("QualityInfo") }
      }));
      var qualityValueElem = qualityDiv.appendChild(parent.createElement("div", {
        id: id + "_imgsizeSpan",
        className: "e-ie-img-size-value-span"
      }));
      qualityValueElem.appendChild(parent.createElement("span", {
        id: id + "_imgsizeValueSpan",
        className: ""
      }));
      qualityNameDiv.appendChild(qualityDiv);
      var qualityOptionDiv = parent.createElement("div", {
        id: id + "_qualityOptionContainer",
        className: "e-ie-quality-option-container"
      });
      var buttonGroup = qualityNameDiv.appendChild(parent.createElement("div", {
        id: id + "_qualityButtonGroup",
        className: "e-btn-group"
      }));
      quality.forEach(function(option) {
        var input = (undefined).createElement("input");
        input.type = "radio";
        input.id = id + "_" + option.toLowerCase();
        input.name = "quality";
        input.value = option.toLowerCase();
        var label = (undefined).createElement("label");
        label.className = "e-btn";
        label.htmlFor = option.toLowerCase();
        label.textContent = _this.l10n.getConstant(option);
        buttonGroup.appendChild(input);
        buttonGroup.appendChild(label);
      });
      qualityOptionDiv.appendChild(buttonGroup);
      qualityOptionDiv.appendChild(parent.createElement("div", {
        id: id + "_qualitySlider",
        className: "e-ie-img-quality-slider"
      }));
      qualityOptionDiv.appendChild(parent.createElement("button", { id: id + "_qualitybuttonIcon", className: "e-ie-img-icon-button", attrs: { type: "button" } }));
      qualityNameDiv.appendChild(qualityOptionDiv);
      if (Browser.isDevice) {
        dialogRightContent.appendChild(parent.createElement("span", {
          id: id + "_qualitySize",
          className: "e-ie-img-quality-size"
        }));
      }
      parent.element.querySelector("#" + id + "_saveDialog").style.display = "block";
      parent.element.appendChild(dialogContent);
      var dialog = new Dialog({
        target: parent.element,
        header: this.l10n.getConstant("SaveAs"),
        closeOnEscape: true,
        content: (undefined).getElementById(id + "_dialogContent"),
        width: Browser.isDevice ? "345px" : "570px",
        isModal: true,
        animationSettings: { effect: "Zoom" },
        beforeOpen: this.onBeforeopen(),
        close: this.saveDialogClosed.bind(this, id),
        cssClass: "e-ie-save-dialog",
        buttons: [
          {
            "click": function() {
              dialog.hide();
            },
            buttonModel: {
              content: this.l10n.getConstant("Close"),
              cssClass: "e-save-cancel-btn"
            }
          },
          {
            "click": function() {
              _this.download();
              dialog.hide();
              _this.isSlider = false;
            },
            buttonModel: {
              isPrimary: true,
              content: this.l10n.getConstant("Download"),
              cssClass: "e-flat e-save-download-btn"
            }
          }
        ]
      });
      dialog.appendTo("#" + id + "_saveDialog");
    };
    ToolbarModule2.prototype.saveDialogClosed = function(id) {
      if (getComponent((undefined).getElementById(id + "_saveDropdownbtn"), "dropdownbutton")) {
        getComponent((undefined).getElementById(id + "_saveDropdownbtn"), "dropdownbutton").destroy();
      }
      this.isSlider = false;
      if ((undefined).querySelector("#" + id + "_qualityButtonGroup") && (undefined).querySelector("#" + id + "_qualitySlider")) {
        (undefined).querySelector("#" + id + "_qualityButtonGroup").remove();
        (undefined).querySelector("#" + id + "_qualitySlider").remove();
        (undefined).querySelector("#" + id + "_imgsizeValueSpan").remove();
        (undefined).querySelector("#" + id + "_imageNameLabel").remove();
        (undefined).querySelector("#" + id + "_imgsizeSpan").remove();
      }
      (undefined).getElementById(id + "_dialogContent").remove();
      getComponent((undefined).getElementById(id + "_saveDialog"), "dialog").destroy();
      (undefined).getElementById(id + "_saveDialog").remove();
    };
    ToolbarModule2.prototype.onBeforeopen = function() {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      var obj = { canvas: null };
      var items = [
        { id: "jpeg", text: "JPEG" },
        { id: "png", text: "PNG" },
        { id: "svg", text: "SVG" },
        { id: "webp", text: "WebP" }
      ];
      var inputObj = new TextBox({
        placeholder: this.l10n.getConstant("ImageName")
      });
      inputObj.appendTo("#" + id + "_imgNametext");
      var qualityContainer = (undefined).getElementById(id + "_imgQualitydiv");
      var slider = (undefined).getElementById(id + "_qualitySlider");
      var qualityBtnGrp = (undefined).querySelector("#" + id + "_qualityButtonGroup");
      var qualityBtnIcon = (undefined).querySelector("#" + id + "_qualitybuttonIcon");
      var qualitySliderValue = (undefined).querySelector("#" + id + "_imgsizeSpan");
      var imageNameLabel;
      if (Browser.isDevice) {
        imageNameLabel = (undefined).getElementById(id + "_qualitySize");
      } else {
        imageNameLabel = (undefined).getElementById(id + "_imageNameLabel");
      }
      var fileObj = { fileName: "", fileType: "" };
      parent.notify("draw", { prop: "getFileName", onPropertyChange: false, value: { obj: fileObj } });
      this.fileType = fileObj["fileType"] ? fileObj["fileType"] : "JPEG";
      parent.notify("export", { prop: "exportToCanvas", value: { object: obj } });
      var tempCanvas = obj["canvas"];
      var canvas = (undefined).getElementById(id + "_imgPic");
      canvas.width = tempCanvas.width;
      canvas.height = tempCanvas.height;
      var buttonIcon = new Button({ iconCss: "e-icons e-settings" });
      buttonIcon.appendTo("#" + id + "_qualitybuttonIcon");
      var ddbElem = (undefined).getElementById(id + "_saveDropdownbtn");
      if (ddbElem) {
        var spanElem_1 = (undefined).createElement("span");
        spanElem_1.innerHTML = this.fileType === "Webp" ? "Webp" : this.fileType.toUpperCase();
        if (ddbElem) {
          ddbElem.appendChild(spanElem_1);
        }
        var drpDownBtn_1 = new DropDownButton({
          items,
          open: function(args) {
            if (Browser.isDevice) {
              args.element.parentElement.style.top = drpDownBtn_1.element.getBoundingClientRect().top - args.element.parentElement.offsetHeight + "px";
            }
            var activeBtn = spanElem_1.innerHTML;
            if (activeBtn !== "") {
              args.element.querySelector('[aria-label = "' + activeBtn + '"]').classList.add("e-selected-btn");
            }
          },
          select: function(args) {
            qualitySliderValue.style.display = "none";
            _this.fileType = spanElem_1.innerHTML = args.item.text;
            if (args.item.id !== "jpeg") {
              qualityContainer.style.display = "none";
              imageNameLabel.style.display = "block";
              _this.updateImageSize(1, obj["canvas"], _this.fileType);
              if (slider) {
                if (_this.isSlider) {
                  getComponent(slider, "slider").destroy();
                }
                slider.style.display = "none";
              }
              _this.isSlider = false;
            } else {
              qualityContainer.style.display = "block";
              removeClass([qualityBtnGrp], "e-hide");
              slider.style.display = "none";
              imageNameLabel.style.display = "block";
              _this.updateImageSize(isNullOrUndefined(_this.currentQuality) ? 1 : _this.currentQuality, obj["canvas"], _this.fileType);
              (undefined).getElementById(id + "_" + _this.imageQuality).checked = true;
            }
          }
        });
        drpDownBtn_1.appendTo("#" + id + "_saveDropdownbtn");
        var imgName = (undefined).getElementById(id + "_imgNametext");
        imgName.value = this.fileName ? this.fileName : fileObj["fileName"];
        if (fileObj["fileType"] && fileObj["fileType"].toUpperCase() !== "JPEG") {
          qualityContainer.style.display = "none";
          qualitySliderValue.style.display = "none";
        }
        if (Browser.isDevice) {
          (undefined).getElementById(id + "_dialogImgContent").style.display = "none";
          (undefined).getElementById(id + "_dialogRightContent").style.width = "100%";
          this.updateImageSize(1, obj["canvas"], this.fileType);
        } else {
          this.updateImageSize(1, obj["canvas"], this.fileType);
        }
      }
      (undefined).getElementById(id + "_" + this.imageQuality).checked = true;
      qualityBtnGrp.addEventListener("click", this.qualityBtnClickHandler.bind(this));
      qualityBtnIcon.addEventListener("click", this.qualityBtnClickHandler.bind(this));
    };
    ToolbarModule2.prototype.qualityBtnClickHandler = function(event) {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      var target = event.target;
      var fileObj = { fileName: "" };
      var obj = { canvas: null };
      var compressionValues = {
        "Good": 0.8,
        "Great": 0.9,
        "Highest": 1
      };
      var qualityBtnGrp = (undefined).querySelector("#" + id + "_qualityButtonGroup");
      var qualitySlider = (undefined).querySelector("#" + id + "_qualitySlider");
      var qualityOption = (undefined).querySelector("#" + id + "_qualityOptionContainer");
      var qualitySliderValueDiv = (undefined).querySelector("#" + id + "_imgsizeSpan");
      var qualitySliderValueSpan = (undefined).querySelector("#" + id + "_imgsizeValueSpan");
      parent.notify("draw", { prop: "getFileName", onPropertyChange: false, value: { obj: fileObj } });
      parent.notify("export", { prop: "exportToCanvas", value: { object: obj } });
      if (event.currentTarget.id === id + "_qualitybuttonIcon" && !this.isSlider) {
        addClass([qualityBtnGrp], "e-hide");
        qualitySlider.style.display = "block";
        qualitySliderValueDiv.style.display = "inline-block";
        qualityOption.style.display = "flex";
        var sliderObj = new Slider({
          tooltip: { placement: "Before", isVisible: true, format: "P0", showOn: "Focus" },
          min: 0.01,
          max: 1,
          step: 0.01,
          value: this.currentQuality,
          type: "MinRange",
          width: Browser.isDevice ? "80%" : "190px",
          created: function() {
            _this.updateImageSize(_this.currentQuality, obj["canvas"], "jpeg");
            qualitySliderValueSpan.innerHTML = Math.round(_this.currentQuality * 100).toString();
          },
          changed: function(args) {
            _this.currentQuality = args.value;
            qualitySliderValueSpan.innerHTML = Math.round(_this.currentQuality * 100).toString();
            parent.notify("export", { prop: "setImageQuality", value: { value: args.value } });
            _this.updateImageSize(args.value, obj["canvas"], "jpeg");
          }
        });
        sliderObj.appendTo("#" + id + "_qualitySlider");
        sliderObj.element.parentElement.classList.add("e-ie-quality-slider");
        this.isSlider = true;
      } else if (event.currentTarget.id === id + "_qualitybuttonIcon" && this.isSlider) {
        getComponent(qualitySlider, "slider").destroy();
        qualitySlider.style.display = "none";
        qualitySliderValueDiv.style.display = "none";
        removeClass([qualityBtnGrp], "e-hide");
        qualityOption.style.display = "block";
        this.isSlider = false;
      } else if (compressionValues.hasOwnProperty(target.textContent) && !this.isSlider) {
        event.target.previousElementSibling.checked = true;
        this.currentQuality = compressionValues[target.textContent];
        this.imageQuality = target.textContent.toLowerCase();
        this.updateImageSize(compressionValues[target.textContent], obj["canvas"], "jpeg");
      }
    };
    ToolbarModule2.prototype.updateImageSize = function(quality, tempCanvas, fileType) {
      var fileSize;
      var parent = this.parent;
      var id = parent.element.id;
      var canvas = (undefined).getElementById(id + "_imgPic");
      var ctx = canvas.getContext("2d");
      var imageNameLabel;
      if (Browser.isDevice) {
        imageNameLabel = (undefined).getElementById(id + "_qualitySize");
      } else {
        imageNameLabel = (undefined).getElementById(id + "_imageNameLabel");
      }
      if (fileType.toLowerCase() === "jpeg") {
        tempCanvas.toBlob(function(blob) {
          fileSize = Math.floor(blob.size / 1024);
          if (fileSize > 1e3) {
            var megabytes2 = fileSize / 1024;
            imageNameLabel.innerHTML = this.l10n.getConstant("ImageSize") + ": " + megabytes2.toFixed(2) + " MB";
            fileSize = +megabytes2.toFixed(2);
          } else {
            imageNameLabel.innerHTML = this.l10n.getConstant("ImageSize") + ": " + fileSize.toFixed(2) + " KB";
            fileSize = +fileSize.toFixed(2);
          }
          if (Browser.isDevice) {
            canvas.style.display = "none";
          } else {
            var compressedImage_1 = new Image();
            compressedImage_1.src = URL.createObjectURL(blob);
            compressedImage_1.onload = function() {
              ctx.drawImage(compressedImage_1, 0, 0);
              URL.revokeObjectURL(compressedImage_1.src);
            };
          }
          this.fileSize = fileSize;
        }.bind(this), "image/jpeg", quality);
      } else if (!isNullOrUndefined(fileType) && (fileType.toLowerCase() === "png" || fileType.toLowerCase() === "webp")) {
        var type = "image/" + fileType.toLowerCase();
        ctx.drawImage(tempCanvas, 0, 0);
        tempCanvas.toBlob(function(blob) {
          fileSize = Math.floor(blob.size / 1024);
          if (fileSize > 1e3) {
            var megabytes2 = fileSize / 1024;
            imageNameLabel.innerHTML = this.l10n.getConstant("ImageSize") + ": " + megabytes2.toFixed(2) + " MB";
            fileSize = +megabytes2.toFixed(2);
          } else {
            imageNameLabel.innerHTML = this.l10n.getConstant("ImageSize") + ": " + fileSize.toFixed(2) + " KB";
            fileSize = +fileSize.toFixed(2);
          }
          if (Browser.isDevice) {
            canvas.style.display = "none";
          }
          this.fileSize = fileSize;
        }.bind(this), type, 1);
      } else if (!isNullOrUndefined(fileType) && fileType.toLowerCase() === "svg") {
        ctx.drawImage(tempCanvas, 0, 0);
        var svgDataUrl = tempCanvas.toDataURL("image/svg+xml");
        var base64Data = svgDataUrl.split(",")[1];
        var binaryStringLength = base64Data.length;
        var rawByteSize = binaryStringLength;
        var fileSize_1 = Math.floor(rawByteSize / 1024);
        if (fileSize_1 > 1e3) {
          var megabytes = fileSize_1 / 1024;
          imageNameLabel.innerHTML = this.l10n.getConstant("ImageSize") + ": " + megabytes.toFixed(2) + " MB";
          fileSize_1 = +megabytes.toFixed(2);
        } else {
          imageNameLabel.innerHTML = this.l10n.getConstant("ImageSize") + ": " + fileSize_1.toFixed(2) + " KB";
          fileSize_1 = +fileSize_1.toFixed(2);
        }
        if (Browser.isDevice) {
          canvas.style.display = "none";
        }
        this.fileSize = fileSize_1;
      } else {
        if (Browser.isDevice) {
          canvas.style.display = "none";
        } else {
          ctx.drawImage(tempCanvas, 0, 0);
          if (this.initialSize > 1e3) {
            var megabytes = this.initialSize / 1048576;
            imageNameLabel.innerHTML = this.l10n.getConstant("ImageSize") + ": " + megabytes.toFixed(2) + " MB";
          } else {
            imageNameLabel.innerHTML = this.l10n.getConstant("ImageSize") + ": " + this.initialSize.toFixed(2) + " KB";
          }
        }
      }
    };
    ToolbarModule2.prototype.download = function() {
      var parent = this.parent;
      var id = parent.element.id;
      if (this.fileType === "JPEG" && this.isSlider) {
        var value = getComponent((undefined).getElementById(id + "_qualitySlider"), "slider").value;
        parent.notify("export", { prop: "setImageQuality", value: { value } });
      } else {
        parent.notify("export", { prop: "setImageQuality", value: { value: this.currentQuality } });
      }
      var fileName = (undefined).getElementById(id + "_imgNametext").value;
      parent.export(this.fileType, fileName);
    };
    ToolbarModule2.prototype.getCropTransformToolbarItem = function() {
      var parent = this.parent;
      var id = parent.element.id;
      var toolbarItems = [];
      toolbarItems.push({
        id: id + "_crop",
        tooltipText: this.l10n.getConstant("CropSelection"),
        align: "Center",
        template: '<button id="' + id + '_cropBtn"></button>'
      });
      toolbarItems.push({ align: "Center", type: "Separator" });
      if (isNullOrUndefined(parent.toolbar) || parent.toolbar && (parent.toolbar.indexOf("Transform") > -1 || parent.toolbar.indexOf("RotateLeft") > -1)) {
        toolbarItems.push({ id: id + "_rotateLeft", prefixIcon: "e-icons e-anti-clock-wise", tooltipText: this.l10n.getConstant("RotateLeft"), align: "Center" });
      }
      if (isNullOrUndefined(parent.toolbar) || parent.toolbar && (parent.toolbar.indexOf("Transform") > -1 || parent.toolbar.indexOf("RotateRight") > -1)) {
        toolbarItems.push({ id: id + "_rotateRight", prefixIcon: "e-icons e-clock-wise", tooltipText: this.l10n.getConstant("RotateRight"), align: "Center" });
      }
      if (toolbarItems.length > 2) {
        toolbarItems.push({ align: "Center", type: "Separator" });
      }
      if (isNullOrUndefined(parent.toolbar) || parent.toolbar && (parent.toolbar.indexOf("Transform") > -1 || parent.toolbar.indexOf("HorizontalFlip") > -1)) {
        toolbarItems.push({ id: id + "_horizontalFlip", prefixIcon: "e-icons e-horizontal-flip", tooltipText: this.l10n.getConstant("HorizontalFlip"), align: "Center" });
      }
      if (isNullOrUndefined(parent.toolbar) || parent.toolbar && (parent.toolbar.indexOf("Transform") > -1 || parent.toolbar.indexOf("VerticalFlip") > -1)) {
        toolbarItems.push({ id: id + "_verticalFlip", prefixIcon: "e-icons e-vertical-flip", tooltipText: this.l10n.getConstant("VerticalFlip"), align: "Center" });
      }
      if ((isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.indexOf("Straightening") > -1) && !Browser.isDevice) {
        toolbarItems.push({ align: "Center", type: "Separator" });
        if (isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.indexOf("Straightening") > -1) {
          var spanWidth = (undefined).createElement("span");
          spanWidth.innerHTML = this.l10n.getConstant("Straighten");
          toolbarItems.push({ id: id + "_straightenSpan", cssClass: "e-ie-straighten-span", template: spanWidth, align: "Center" });
          toolbarItems.push({
            id: id + "_straighten",
            cssClass: "top-icon e-straighten",
            tooltipText: this.l10n.getConstant("Straighten"),
            align: "Center",
            type: "Input",
            template: '<div id="' + id + '_straightenSlider"></div>'
          });
          var straightenSpan = (undefined).createElement("span");
          straightenSpan.innerHTML = parent.transform.straighten.toString() + "&#176";
          toolbarItems.push({
            id: id + "_straightenSpan",
            cssClass: "e-ie-straighten-value-span",
            template: straightenSpan,
            align: "Center"
          });
        }
      }
      if (!Browser.isDevice) {
        toolbarItems.push({
          id: id + "_ok",
          prefixIcon: "e-icons e-check",
          cssClass: "top-icon e-tick",
          tooltipText: this.l10n.getConstant("OK"),
          align: "Right",
          tabIndex: 0
        });
        toolbarItems.push({
          id: id + "_cancel",
          prefixIcon: "e-icons e-close",
          cssClass: "top-icon e-save",
          tooltipText: this.l10n.getConstant("Cancel"),
          align: "Right"
        });
      }
      return toolbarItems;
    };
    ToolbarModule2.prototype.getShapesToolbarItem = function(items) {
      var parent = this.parent;
      var id = parent.element.id;
      var toolbarItems = [];
      if (isNullOrUndefined(parent.toolbar) || parent.toolbar) {
        toolbarItems.push({
          id: id + "_annotation",
          tooltipText: this.l10n.getConstant("Annotation"),
          align: "Center",
          template: '<button id="' + id + '_annotationBtn"></button>'
        });
      }
      if (items.indexOf("fillColor") > -1) {
        toolbarItems.push({
          prefixIcon: "e-icons e-copy",
          id: id + "_fillcolor",
          cssClass: "top-icon e-fill",
          tooltipText: this.l10n.getConstant("FillColor"),
          align: "Center",
          type: "Input",
          template: '<button id="' + id + '_fillColorBtn"></button>'
        });
      }
      if (items.indexOf("strokeColor") > -1) {
        toolbarItems.push({
          prefixIcon: "e-icons e-copy",
          id: id + "_strokecolor",
          cssClass: "top-icon e-stroke",
          tooltipText: this.l10n.getConstant("StrokeColor"),
          align: "Center",
          type: "Input",
          template: '<button id="' + id + '_borderColorBtn"></button>'
        });
      }
      if (items.indexOf("strokeWidth") > -1) {
        toolbarItems.push({
          id: id + "_strokeWidth",
          cssClass: "top-icon e-size",
          tooltipText: this.l10n.getConstant("StrokeWidth"),
          align: "Center",
          type: "Input",
          template: '<button id="' + id + '_borderWidthBtn"></button>'
        });
      }
      if (items.indexOf("start") > -1) {
        toolbarItems.push({
          id: id + "_start",
          cssClass: "top-icon e-size",
          tooltipText: this.l10n.getConstant("Start"),
          align: "Center",
          type: "Input",
          template: '<button id="' + id + '_startBtn"></button>'
        });
      }
      if (items.indexOf("borderRadius") > -1) {
        toolbarItems.push({
          id: id + "_rectangleRadius",
          cssClass: "top-icon e-size",
          tooltipText: this.l10n.getConstant("BorderRadius"),
          align: "Center",
          type: "Input",
          template: '<button id="' + id + '_rectangleRadiusBtn"></button>'
        });
      }
      if (items.indexOf("end") > -1) {
        toolbarItems.push({
          id: id + "_end",
          cssClass: "top-icon e-size",
          tooltipText: this.l10n.getConstant("End"),
          align: "Center",
          type: "Input",
          template: '<button id="' + id + '_endBtn"></button>'
        });
      }
      if (items.indexOf("flip") > -1) {
        toolbarItems.push({
          id: id + "_rotLeft",
          prefixIcon: "e-anti-clock-wise",
          tooltipText: this.l10n.getConstant("RotateLeft"),
          align: "Center"
        });
        toolbarItems.push({
          id: id + "_rotRight",
          prefixIcon: "e-clock-wise",
          tooltipText: this.l10n.getConstant("RotateRight"),
          align: "Center"
        });
        toolbarItems.push({
          id: id + "_hFlip",
          prefixIcon: "e-horizontal-flip",
          tooltipText: this.l10n.getConstant("HorizontalFlip"),
          align: "Center"
        });
        toolbarItems.push({
          id: id + "_vFlip",
          prefixIcon: "e-vertical-flip",
          tooltipText: this.l10n.getConstant("VerticalFlip"),
          align: "Center"
        });
      }
      if (items.indexOf("transparency") > -1) {
        toolbarItems.push({ align: "Center", type: "Separator" });
        toolbarItems.push({
          id: id + "_transparency",
          prefixIcon: "e-opacity",
          tooltipText: this.l10n.getConstant("Opacity"),
          align: "Center"
        });
      }
      toolbarItems.push({ align: "Center", type: "Separator" });
      if (items.indexOf("z-order") > -1) {
        toolbarItems.push({
          id: id + "_zOrder",
          cssClass: "top-icon e-list-unordered-3",
          tooltipText: this.l10n.getConstant("ZOrder"),
          align: "Center",
          type: "Input",
          template: '<button id="' + id + '_zOrderBtn"></button>'
        });
      }
      if (items.indexOf("duplicate") > -1) {
        toolbarItems.push({
          id: id + "_duplicate",
          prefixIcon: "e-icons e-order",
          cssClass: "top-icon e-order",
          tooltipText: this.l10n.getConstant("Duplicate"),
          align: "Center"
        });
      }
      if (items.indexOf("remove") > -1) {
        toolbarItems.push({
          id: id + "_remove",
          prefixIcon: "e-icons e-trash",
          cssClass: "top-icon e-trash",
          tooltipText: this.l10n.getConstant("Remove"),
          align: "Center"
        });
      }
      if (items.indexOf("text") > -1) {
        toolbarItems.push({
          id: id + "_editText",
          prefixIcon: "e-icons e-annotation-edit",
          cssClass: "top-icon e-annotation-edit",
          tooltipText: this.l10n.getConstant("EditText"),
          align: "Center"
        });
      }
      var tempToolbarItems = this.processSubToolbar(items);
      for (var i = 0, len = tempToolbarItems.length; i < len; i++) {
        toolbarItems.push(tempToolbarItems[i]);
      }
      if (!Browser.isDevice) {
        var obj = { shape: null };
        parent.notify("selection", { prop: "getCurrentDrawingShape", value: { obj } });
        if (obj["shape"] !== "path") {
          toolbarItems.push({
            id: id + "_ok",
            prefixIcon: "e-icons e-check",
            cssClass: "top-icon e-tick",
            tooltipText: this.l10n.getConstant("OK"),
            align: "Right",
            tabIndex: 0
          });
          toolbarItems.push({
            id: id + "_cancel",
            prefixIcon: "e-icons e-close",
            cssClass: "top-icon e-save",
            tooltipText: this.l10n.getConstant("Cancel"),
            align: "Right"
          });
        }
      }
      return toolbarItems;
    };
    ToolbarModule2.prototype.initCropTransformToolbar = function(shape, isTransform) {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      var leftItem = this.getLeftToolbarItem();
      var rightItem = this.getRightToolbarItem();
      var mainItem = this.getCropTransformToolbarItem();
      var zoomItem = this.getZoomToolbarItem();
      if (Browser.isDevice) {
        this.defToolbarItems = mainItem;
      } else {
        this.defToolbarItems = leftItem.concat(zoomItem, mainItem, rightItem);
      }
      var args = { toolbarType: "crop-transform", toolbarItems: this.defToolbarItems };
      parent.trigger("toolbarUpdating", args);
      this.defToolbarItems = args.toolbarItems;
      var toolbar = new Toolbar({
        width: "100%",
        items: this.defToolbarItems,
        clicked: this.defToolbarClicked.bind(this),
        created: function() {
          _this.renderCropBtn(shape);
          _this.renderStraightenSlider();
          _this.wireZoomBtnEvents();
          parent.trigger("toolbarCreated", { toolbarType: "shapes" });
          if (Browser.isDevice) {
            if (_this.defToolbarItems.length > 0 && (undefined).getElementById(id + "_bottomToolbar")) {
              toolbar.refreshOverflow();
              toolbar.refreshOverflow();
              toolbar.refreshOverflow();
            }
          } else {
            _this.createLeftToolbarControls();
            if (_this.defToolbarItems.length > 0 && (undefined).getElementById(id + "_toolbar")) {
              toolbar.refreshOverflow();
            }
          }
          if ((undefined).getElementById(id + "_cropBtn") && isNullOrUndefined(isTransform)) {
            if (!Browser.isDevice) {
              parent.notify("draw", {
                prop: "select",
                onPropertyChange: false,
                value: {
                  type: _this.getCropTextContent((undefined).getElementById(id + "_cropBtn")).toLowerCase(),
                  startX: null,
                  startY: null,
                  width: null,
                  height: null
                }
              });
            }
          }
        }
      });
      if (Browser.isDevice) {
        toolbar.appendTo("#" + id + "_bottomToolbar");
      } else {
        toolbar.appendTo("#" + id + "_toolbar");
      }
      var slider = parent.element.querySelector("#" + id + "_straightenSlider");
      if ((isNullOrUndefined(parent.toolbar) || parent.toolbar && parent.toolbar.indexOf("Straightening") > -1) && slider && slider.parentElement.clientHeight > this.toolbarHeight) {
        this.toolbarHeight = parent.toolbarHeight = slider.parentElement.clientHeight;
      }
      this.enableDisableTbrBtn();
      parent.notify("transform", { prop: "disableZoomOutBtn", value: { isZoomOut: true } });
    };
    ToolbarModule2.prototype.getCropTextContent = function(elem) {
      if (elem) {
        var classToContentMap = {
          "e-custom": "Custom",
          "e-circle": "Circle",
          "e-square": "Square",
          "e-custom-a": "3:2",
          "e-custom-b": "4:3",
          "e-custom-c": "5:4",
          "e-custom-d": "7:5",
          "e-custom-e": "16:9",
          "e-custom-f": "2:3",
          "e-custom-g": "3:4",
          "e-custom-h": "4:5",
          "e-custom-i": "5:7",
          "e-custom-j": "9:16"
        };
        var classList2 = elem.children[0].classList;
        for (var className in classToContentMap) {
          if (classList2.contains(className)) {
            return classToContentMap[className];
          }
        }
      }
      return "";
    };
    ToolbarModule2.prototype.getCurrentShapeIcon = function(shape) {
      var shapeIcons = {
        rectangle: "e-rectangle",
        ellipse: "e-circle",
        line: "e-line",
        arrow: "e-arrow-right-up",
        path: "e-critical-path",
        text: "e-add-text",
        image: "e-image",
        pen: "e-free-pen",
        "crop-custom": "e-custom",
        "crop-circle": "e-circle",
        "crop-square": "e-square",
        "crop-3:2": "e-custom-a",
        "crop-4:3": "e-custom-b",
        "crop-5:4": "e-custom-c",
        "crop-7:5": "e-custom-d",
        "crop-16:9": "e-custom-e",
        "crop-2:3": "e-custom-f",
        "crop-3:4": "e-custom-g",
        "crop-4:5": "e-custom-h",
        "crop-5:7": "e-custom-i",
        "crop-9:16": "e-custom-j"
      };
      return shapeIcons[shape] ? shapeIcons[shape] : shape && shape.indexOf("crop-") !== -1 ? "e-custom" : "e-free-pen";
    };
    ToolbarModule2.prototype.initShapesToolbarItem = function(items) {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      var leftItem = this.getLeftToolbarItem();
      var rightItem = this.getRightToolbarItem();
      var mainItem = this.getShapesToolbarItem(items);
      var zoomItem = this.getZoomToolbarItem();
      if (Browser.isDevice) {
        this.defToolbarItems = mainItem;
      } else {
        this.defToolbarItems = leftItem.concat(zoomItem, mainItem, rightItem);
      }
      var args = {
        toolbarType: parent.activeObj.shape ? parent.activeObj.shape : "shapes",
        toolbarItems: this.defToolbarItems
      };
      parent.trigger("toolbarUpdating", args);
      if (this.isToolbarString(args.toolbarItems)) {
        items = args.toolbarItems;
        this.excludeItems(args.toolbarItems);
      } else {
        this.defToolbarItems = args.toolbarItems;
      }
      var toolbar = new Toolbar({
        width: "100%",
        items: this.defToolbarItems,
        clicked: this.defToolbarClicked.bind(this),
        created: function() {
          _this.renderAnnotationBtn(true);
          _this.createRectangleRadius(items);
          _this.createShapeColor(items);
          _this.createShapeBtn(items);
          _this.createZOrderBtn(items);
          if (parent.activeObj.shape === "arrow") {
            if (items.some(function(item) {
              return item.toLowerCase().indexOf("start") > -1;
            })) {
              _this.createStartBtn();
            }
            if (items.some(function(item) {
              return item.toLowerCase().indexOf("end") > -1;
            })) {
              _this.createEndBtn();
            }
          }
          _this.wireZoomBtnEvents();
          parent.trigger("toolbarCreated", { toolbarType: "shapes" });
          if (Browser.isDevice) {
            if (_this.defToolbarItems.length > 0 && (undefined).getElementById(id + "_bottomToolbar")) {
              toolbar.refreshOverflow();
              toolbar.refreshOverflow();
              toolbar.refreshOverflow();
            }
          } else {
            _this.createLeftToolbarControls();
            if (_this.defToolbarItems.length > 0 && (undefined).getElementById(id + "_toolbar")) {
              toolbar.refreshOverflow();
            }
          }
        }
      });
      if (Browser.isDevice) {
        toolbar.appendTo("#" + id + "_bottomToolbar");
      } else {
        toolbar.appendTo("#" + id + "_toolbar");
      }
      this.enableDisableTbrBtn();
    };
    ToolbarModule2.prototype.createRectangleRadius = function(items) {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      if (items.indexOf("borderRadius") > -1) {
        var strokeWidthItems = [
          { id: "1", text: this.l10n.getConstant("0") },
          { id: "2", text: this.l10n.getConstant("20") },
          { id: "3", text: this.l10n.getConstant("40") },
          { id: "4", text: this.l10n.getConstant("60") },
          { id: "5", text: this.l10n.getConstant("80") },
          { id: "6", text: this.l10n.getConstant("100") }
        ];
        var strokeWidthBtn = (undefined).getElementById(id + "_rectangleRadiusBtn");
        var spanElem_2 = (undefined).createElement("span");
        spanElem_2.innerHTML = this.l10n.getConstant(parent.frameObj.radius.toString());
        spanElem_2.className = "e-shape-rectangle-radius";
        strokeWidthBtn.appendChild(spanElem_2);
        var drpDownBtn_2 = new DropDownButton({
          items: strokeWidthItems,
          open: function(args) {
            if (Browser.isDevice) {
              var parentElem = args.element.parentElement;
              parentElem.style.top = drpDownBtn_2.element.getBoundingClientRect().top - parentElem.offsetHeight + "px";
            }
            var activeBtn = drpDownBtn_2.element.childNodes[0].textContent;
            if (activeBtn !== "") {
              args.element.querySelector('[aria-label = "' + activeBtn + '"]').classList.add("e-selected-btn");
            }
          },
          select: function(args) {
            _this.triggerTbarClickEvent(args);
            spanElem_2.textContent = args.item.text;
            parent.updateStrokeWidth(args.item.id, "radius");
            if (Browser.isDevice) {
              if ((undefined).getElementById(id + "_bottomToolbar")) {
                var toolbar_7 = getComponent(id + "_bottomToolbar", "toolbar");
                toolbar_7.refreshOverflow();
              }
            } else {
              if ((undefined).getElementById(id + "_toolbar")) {
                var toolbar_8 = getComponent(id + "_toolbar", "toolbar");
                toolbar_8.refreshOverflow();
              }
            }
            parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
          }
        });
        drpDownBtn_2.appendTo("#" + id + "_rectangleRadiusBtn");
      }
    };
    ToolbarModule2.prototype.beforeModeSwitch = function(args, inst) {
      this.popupLeft = args.element.offsetParent.style.left;
      if (args.mode === "Picker") {
        inst.showButtons = true;
        inst.dataBind();
        args.element.querySelector(".e-apply").title = this.l10n.getConstant("Apply");
        args.element.querySelector(".e-cancel").title = this.l10n.getConstant("Cancel");
        args.element.querySelector(".e-mode-switch-btn").title = this.l10n.getConstant("StandardColors");
      } else {
        inst.showButtons = false;
        inst.dataBind();
        args.element.querySelector(".e-mode-switch-btn").title = this.l10n.getConstant("MoreColors");
      }
    };
    ToolbarModule2.prototype.createShapeColor = function(items) {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      if (items.indexOf("fillColor") > -1) {
        parent.element.querySelector(".e-template.e-fill").appendChild(parent.createElement("input", {
          id: id + "_shape_fill"
        }));
        var fillColor_1 = new ColorPicker({
          modeSwitcher: true,
          noColor: true,
          value: "",
          inline: true,
          showButtons: false,
          mode: "Palette",
          cssClass: "e-shape-fill-color",
          beforeModeSwitch: function(args) {
            return _this.beforeModeSwitch(args, fillColor_1);
          },
          presetColors: {
            "custom": [
              "",
              "#f44336",
              "#e91e63",
              "#9c27b0",
              "#673ab7",
              "#2196f3",
              "#03a9f4",
              "#00bcd4",
              "#009688",
              "#ffeb3b",
              "#ffffff",
              "#ffebee",
              "#fce4ec",
              "#f3e5f5",
              "#ede7f6",
              "#e3f2fd",
              "#e1f5fe",
              "#e0f7fa",
              "#e0f2f1",
              "#fffde7",
              "#f2f2f2",
              "#ffcdd2",
              "#f8bbd0",
              "#e1bee7",
              "#d1c4e9",
              "#bbdefb",
              "#b3e5fc",
              "#b2ebf2",
              "#b2dfdb",
              "#fff9c4",
              "#e6e6e6",
              "#ef9a9a",
              "#f48fb1",
              "#ce93d8",
              "#b39ddb",
              "#90caf9",
              "#81d4fa",
              "#80deea",
              "#80cbc4",
              "#fff59d",
              "#cccccc",
              "#e57373",
              "#f06292",
              "#ba68c8",
              "#9575cd",
              "#64b5f6",
              "#4fc3f7",
              "#4dd0e1",
              "#4db6ac",
              "#fff176",
              "#b3b3b3",
              "#ef5350",
              "#ec407a",
              "#ab47bc",
              "#7e57c2",
              "#42a5f5",
              "#29b6f6",
              "#26c6da",
              "#26a69a",
              "#ffee58",
              "#999999",
              "#e53935",
              "#d81b60",
              "#8e24aa",
              "#5e35b1",
              "#1e88e5",
              "#039be5",
              "#00acc1",
              "#00897b",
              "#fdd835",
              "#808080",
              "#d32f2f",
              "#c2185b",
              "#7b1fa2",
              "#512da8",
              "#1976d2",
              "#0288d1",
              "#0097a7",
              "#00796b",
              "#fbc02d",
              "#666666",
              "#c62828",
              "#ad1457",
              "#6a1b9a",
              "#4527a0",
              "#1565c0",
              "#0277bd",
              "#00838f",
              "#00695c",
              "#f9a825",
              "#4d4d4d",
              "#b71c1c",
              "#880e4f",
              "#4a148c",
              "#311b92",
              "#0d47a1",
              "#01579b",
              "#006064",
              "#004d40",
              "#f57f17"
            ]
          },
          beforeTileRender: function(args) {
            if (args.value === "") {
              args.element.classList.add("e-nocolor-item");
            }
          },
          change: function(args) {
            parent.updateFillColor(args.value);
            if (args.currentValue.rgba === "") {
              fillDDB_1.element.children[0].classList.add("e-nocolor-item");
            } else {
              fillDDB_1.element.children[0].classList.remove("e-nocolor-item");
              fillDDB_1.element.children[0].style.backgroundColor = args.currentValue.rgba;
            }
            fillDDB_1.toggle();
            parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
          },
          onModeSwitch: function(args) {
            if (Browser.isDevice) {
              args.element.parentElement.parentElement.style.left = _this.popupLeft;
              args.element.parentElement.parentElement.style.top = fillDDB_1.element.getBoundingClientRect().top - args.element.parentElement.parentElement.offsetHeight + "px";
            }
          },
          beforeClose: function() {
            fillDDB_1.toggle();
          }
        }, "#" + id + "_shape_fill");
        var fillDDB_1 = new DropDownButton({
          open: function(args) {
            var parenElem = args.element.parentElement;
            if (Browser.isDevice) {
              parenElem.style.top = fillDDB_1.element.getBoundingClientRect().top - parenElem.offsetHeight + "px";
              if ((undefined).innerWidth <= 520) {
                parenElem.style.left = parent.element.offsetLeft + "px";
              }
            }
          },
          target: ".e-shape-fill-color",
          iconCss: "e-dropdownbtn-preview",
          cssClass: "e-ie-ddb-popup"
        }, "#" + id + "_fillColorBtn");
        fillColor_1.inline = true;
        fillColor_1.value = fillColor_1.getValue(fillColor_1.value, "rgba");
        parent.element.querySelector(".e-fill.e-template .e-dropdownbtn-preview").classList.add("e-nocolor-item");
      }
      if (items.indexOf("strokeColor") > -1) {
        parent.element.querySelector(".e-template.e-stroke").appendChild(parent.createElement("input", {
          id: id + "_shape_stroke"
        }));
        var strokeColor_1 = new ColorPicker({
          modeSwitcher: true,
          noColor: false,
          value: "#fff",
          inline: true,
          showButtons: false,
          mode: "Palette",
          cssClass: "e-shape-stroke-color",
          beforeModeSwitch: function(args) {
            _this.popupLeft = args.element.offsetParent.style.left;
            strokeColor_1.value = parent.activeObj.strokeSettings.strokeColor !== "#fff" ? parent.activeObj.strokeSettings.strokeColor : "#008000ff";
            _this.beforeModeSwitch(args, strokeColor_1);
          },
          presetColors: this.presetColors,
          change: function(args) {
            parent.updateStrokeColor(args.value);
            strokeDDB_1.element.children[0].style.backgroundColor = args.currentValue.rgba;
            strokeDDB_1.toggle();
            parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
          },
          onModeSwitch: function(args) {
            if (Browser.isDevice) {
              args.element.parentElement.parentElement.style.left = _this.popupLeft;
              args.element.parentElement.parentElement.style.top = strokeDDB_1.element.getBoundingClientRect().top - args.element.parentElement.parentElement.offsetHeight + "px";
            }
          },
          beforeClose: function() {
            strokeDDB_1.toggle();
          }
        }, "#" + id + "_shape_stroke");
        var strokeDDB_1 = new DropDownButton({
          open: function(args) {
            var parenElem = args.element.parentElement;
            if (Browser.isDevice) {
              parenElem.style.top = strokeDDB_1.element.getBoundingClientRect().top - parenElem.offsetHeight + "px";
              if ((undefined).innerWidth <= 520) {
                parenElem.style.left = parent.element.offsetLeft + "px";
              }
            }
          },
          target: ".e-shape-stroke-color",
          iconCss: "e-dropdownbtn-preview",
          cssClass: "e-ie-ddb-popup"
        }, "#" + id + "_borderColorBtn");
        strokeColor_1.inline = true;
        strokeColor_1.value = strokeColor_1.getValue(strokeColor_1.value, "rgba");
        parent.element.querySelector(".e-stroke.e-template .e-dropdownbtn-preview").style.background = "#fff";
      }
    };
    ToolbarModule2.prototype.createShapeBtn = function(items) {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      if (items.indexOf("strokeWidth") > -1) {
        var strokeWidthItems = [
          { id: "1", text: this.l10n.getConstant("XSmall") },
          { id: "2", text: this.l10n.getConstant("Small") },
          { id: "3", text: this.l10n.getConstant("Medium") },
          { id: "4", text: this.l10n.getConstant("Large") },
          { id: "5", text: this.l10n.getConstant("XLarge") }
        ];
        if (parent.activeObj.shape && (parent.activeObj.shape === "rectangle" || parent.activeObj.shape === "ellipse")) {
          strokeWidthItems = [
            { id: "1", text: this.l10n.getConstant("NoOutline") },
            { id: "2", text: this.l10n.getConstant("XSmall") },
            { id: "3", text: this.l10n.getConstant("Small") },
            { id: "4", text: this.l10n.getConstant("Medium") },
            { id: "5", text: this.l10n.getConstant("Large") },
            { id: "6", text: this.l10n.getConstant("XLarge") }
          ];
        }
        var strokeWidthBtn = (undefined).getElementById(id + "_borderWidthBtn");
        var spanElem_3 = (undefined).createElement("span");
        spanElem_3.innerHTML = this.l10n.getConstant("XSmall");
        spanElem_3.className = "e-shape-stroke-width";
        strokeWidthBtn.appendChild(spanElem_3);
        var drpDownBtn_3 = new DropDownButton({
          items: strokeWidthItems,
          open: function(args) {
            if (Browser.isDevice) {
              args.element.parentElement.style.top = drpDownBtn_3.element.getBoundingClientRect().top - args.element.parentElement.offsetHeight + "px";
            }
            var activeBtn = spanElem_3.innerHTML;
            if (activeBtn !== "") {
              args.element.querySelector('[aria-label = "' + activeBtn + '"]').classList.add("e-selected-btn");
            }
          },
          select: function(args) {
            _this.triggerTbarClickEvent(args);
            spanElem_3.textContent = args.item.text;
            parent.updateStrokeWidth(args.item.id, "width", parent.activeObj.shape);
            if (Browser.isDevice) {
              if ((undefined).getElementById(id + "_bottomToolbar")) {
                var toolbar_9 = getComponent(id + "_bottomToolbar", "toolbar");
                toolbar_9.refreshOverflow();
              }
            } else {
              if ((undefined).getElementById(id + "_toolbar")) {
                var toolbar_10 = getComponent(id + "_toolbar", "toolbar");
                toolbar_10.refreshOverflow();
              }
            }
            parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
          }
        });
        drpDownBtn_3.appendTo("#" + id + "_borderWidthBtn");
      }
    };
    ToolbarModule2.prototype.createZOrderBtn = function(items) {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      if (items.indexOf("z-order") > -1) {
        var zOrderItems = [
          { text: this.l10n.getConstant("BringForward"), id: "bringForward", iconCss: "e-icons e-bring-forward" },
          { text: this.l10n.getConstant("SendBackward"), id: "sendBackward", iconCss: "e-icons e-send-backward" },
          { text: this.l10n.getConstant("BringToFront"), id: "bringToFront", iconCss: "e-icons e-bring-to-front" },
          { text: this.l10n.getConstant("SendToBack"), id: "sendToBack", iconCss: "e-icons e-send-to-back" }
        ];
        var drpDownBtn_4 = new DropDownButton({
          items: zOrderItems,
          iconCss: "e-icons e-layers",
          beforeOpen: function(args) {
            if ((undefined).getElementById(parent.element.id + "_zOrderBtn").classList.contains("e-disabled")) {
              args.cancel = true;
            }
            var indexObj = { freehandSelectedIndex: -1 };
            parent.notify("freehand-draw", { prop: "getFreehandSelectedIndex", onPropertyChange: false, value: { obj: indexObj } });
            var orderObj = { order: null };
            parent.notify("shape", { prop: "getHighestOrder", onPropertyChange: false, value: { obj: orderObj } });
            var order = parent.activeObj.order ? parent.activeObj.order : parent.getObjFromId(parent.pointColl[indexObj["freehandSelectedIndex"]].id).order;
            if (order && order >= orderObj["order"]) {
              args.items[0].disabled = true;
              args.items[2].disabled = true;
            } else {
              args.items[0].disabled = false;
              args.items[2].disabled = false;
            }
            parent.notify("shape", { prop: "getLowestOrder", onPropertyChange: false, value: { obj: orderObj } });
            if (order && order <= orderObj["order"]) {
              args.items[1].disabled = true;
              args.items[3].disabled = true;
            } else {
              args.items[1].disabled = false;
              args.items[3].disabled = false;
            }
          },
          open: function(args) {
            if (Browser.isDevice) {
              args.element.parentElement.style.top = drpDownBtn_4.element.getBoundingClientRect().top - args.element.parentElement.offsetHeight + "px";
            }
          },
          select: function(args) {
            _this.triggerTbarClickEvent(args);
            var obj = { freehandDrawSelectedId: null };
            parent.notify("freehand-draw", { prop: "getFreehandDrawSelectedId", onPropertyChange: false, value: { obj } });
            var shapeId = obj["freehandDrawSelectedId"] ? obj["freehandDrawSelectedId"] : parent.activeObj.currIndex;
            parent.updateShapeOrder(shapeId, args.item.id);
            if (Browser.isDevice) {
              if ((undefined).getElementById(id + "_bottomToolbar")) {
                var toolbar_11 = getComponent(id + "_bottomToolbar", "toolbar");
                toolbar_11.refreshOverflow();
              }
            } else {
              if ((undefined).getElementById(id + "_toolbar")) {
                var toolbar_12 = getComponent(id + "_toolbar", "toolbar");
                toolbar_12.refreshOverflow();
              }
            }
            if (shapeId.indexOf("shape") > -1) {
              parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
            } else if (shapeId.indexOf("pen") > -1) {
              parent.notify("undo-redo", { prop: "updateUndoRedoStack", value: { isPenDraw: true } });
            }
          }
        });
        drpDownBtn_4.appendTo("#" + id + "_zOrderBtn");
      }
    };
    ToolbarModule2.prototype.createStartBtn = function() {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      var strokeWidthItems = [
        { id: "1", text: this.l10n.getConstant("None") },
        { id: "2", text: this.l10n.getConstant("Bar") },
        { id: "3", text: this.l10n.getConstant("Arrow") },
        { id: "4", text: this.l10n.getConstant("ArrowSolid") },
        { id: "5", text: this.l10n.getConstant("Circle") },
        { id: "6", text: this.l10n.getConstant("CircleSolid") },
        { id: "7", text: this.l10n.getConstant("Square") },
        { id: "8", text: this.l10n.getConstant("SquareSolid") }
      ];
      var strokeWidthBtn = (undefined).getElementById(id + "_startBtn");
      var spanElem = (undefined).createElement("span");
      if (isNullOrUndefined(parent.activeObj.start)) {
        parent.activeObj.start = "none";
      }
      spanElem.innerHTML = parent.pascalToSplitWords(parent.activeObj.start);
      spanElem.className = "e-shape-start";
      strokeWidthBtn.appendChild(spanElem);
      var drpDownBtn = new DropDownButton({
        items: strokeWidthItems,
        open: function(args) {
          if (Browser.isDevice) {
            args.element.parentElement.style.top = drpDownBtn.element.getBoundingClientRect().top - args.element.parentElement.offsetHeight + "px";
          }
          var activeBtn = spanElem.innerHTML;
          if (activeBtn !== "") {
            args.element.querySelector('[aria-label = "' + activeBtn + '"]').classList.add("e-selected-btn");
          }
        },
        select: function(args) {
          var idToValue = {
            "1": "none",
            "2": "bar",
            "3": "arrow",
            "4": "arrowSolid",
            "5": "circle",
            "6": "circleSolid",
            "7": "square",
            "8": "squareSolid"
          };
          parent.notify("selection", { prop: "setArrowShape", value: { type: "initial", shape: idToValue["" + args.item.id] } });
          _this.triggerTbarClickEvent(args);
          spanElem.textContent = args.item.text;
          parent.updateArrow("startArrow", args.item.id);
          parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
        }
      });
      drpDownBtn.appendTo("#" + id + "_startBtn");
    };
    ToolbarModule2.prototype.createEndBtn = function() {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      var strokeWidthItems = [
        { id: "1", text: this.l10n.getConstant("None") },
        { id: "2", text: this.l10n.getConstant("Bar") },
        { id: "3", text: this.l10n.getConstant("Arrow") },
        { id: "4", text: this.l10n.getConstant("ArrowSolid") },
        { id: "5", text: this.l10n.getConstant("Circle") },
        { id: "6", text: this.l10n.getConstant("CircleSolid") },
        { id: "7", text: this.l10n.getConstant("Square") },
        { id: "8", text: this.l10n.getConstant("SquareSolid") }
      ];
      var strokeEndBtn = (undefined).getElementById(id + "_endBtn");
      var spanElem = (undefined).createElement("span");
      if (isNullOrUndefined(parent.activeObj.end)) {
        parent.activeObj.end = "arrowSolid";
      }
      spanElem.innerHTML = parent.pascalToSplitWords(parent.activeObj.end);
      spanElem.className = "e-shape-end";
      strokeEndBtn.appendChild(spanElem);
      var drpDownBtn = new DropDownButton({
        items: strokeWidthItems,
        open: function(args) {
          if (Browser.isDevice) {
            args.element.parentElement.style.top = drpDownBtn.element.getBoundingClientRect().top - args.element.parentElement.offsetHeight + "px";
          }
          var activeBtn = spanElem.innerHTML;
          if (activeBtn !== "") {
            args.element.querySelector('[aria-label = "' + activeBtn + '"]').classList.add("e-selected-btn");
          }
        },
        select: function(args) {
          var idToValue = {
            "1": "none",
            "2": "bar",
            "3": "arrow",
            "4": "arrowSolid",
            "5": "circle",
            "6": "circleSolid",
            "7": "square",
            "8": "squareSolid"
          };
          parent.notify("selection", { prop: "setArrowShape", value: { type: "final", shape: idToValue["" + args.item.id] } });
          _this.triggerTbarClickEvent(args);
          spanElem.textContent = args.item.text;
          parent.updateArrow("endArrow", args.item.id);
          parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
        }
      });
      drpDownBtn.appendTo("#" + id + "_endBtn");
    };
    ToolbarModule2.prototype.getTextToolbarItem = function(items) {
      var parent = this.parent;
      var id = parent.element.id;
      var toolbarItems = [];
      if (isNullOrUndefined(parent.toolbar) || parent.toolbar) {
        toolbarItems.push({
          id: id + "_annotation",
          tooltipText: this.l10n.getConstant("Annotation"),
          align: "Center",
          template: '<button id="' + id + '_annotationBtn"></button>'
        });
      }
      if (items.indexOf("fontFamily") > -1) {
        toolbarItems.push({
          id: id + "_fontFamily",
          cssClass: "top-icon e-img-font-family",
          tooltipText: this.l10n.getConstant("FontFamily"),
          align: "Center",
          template: '<button id="' + id + '_fontFamilyBtn"></button>'
        });
      }
      if (items.indexOf("fontSize") > -1) {
        toolbarItems.push({
          id: id + "_fontSize",
          cssClass: "top-icon e-img-font-size",
          tooltipText: this.l10n.getConstant("FontSize"),
          align: "Center",
          template: '<button id="' + id + '_fontSizeBtn"></button>'
        });
      }
      if (items.indexOf("fontColor") > -1) {
        toolbarItems.push({
          cssClass: "top-icon e-text-font-color",
          id: id + "_text_strokecolor",
          tooltipText: this.l10n.getConstant("FontColor"),
          align: "Center",
          type: "Input",
          template: '<button id="' + id + '_fontColorBtn"></button>'
        });
      }
      if (items.indexOf("strokeColor") > -1) {
        toolbarItems.push({
          cssClass: "top-icon e-stroke-text-font-color",
          id: id + "_stroke_text_color",
          tooltipText: this.l10n.getConstant("TextOutlineColor"),
          align: "Center",
          type: "Input",
          template: '<button id="' + id + '_strokeTextColorBtn"></button>'
        });
      }
      if (items.indexOf("fillColor") > -1) {
        toolbarItems.push({
          cssClass: "top-icon e-text-background-color",
          id: id + "_text_backgroundcolor",
          tooltipText: this.l10n.getConstant("FillColor"),
          align: "Center",
          type: "Input",
          template: '<button id="' + id + '_bgColorBtn"></button>'
        });
      }
      if (items.indexOf("bold") > -1) {
        toolbarItems.push({
          id: id + "_bold",
          prefixIcon: "e-icons e-bold",
          cssClass: "top-icon e-bold",
          tooltipText: this.l10n.getConstant("Bold"),
          align: "Center"
        });
      }
      if (items.indexOf("italic") > -1) {
        toolbarItems.push({
          id: id + "_italic",
          prefixIcon: "e-icons e-italic",
          cssClass: "top-icon e-italic",
          tooltipText: this.l10n.getConstant("Italic"),
          align: "Center"
        });
      }
      if (items.indexOf("strokeWidth") > -1) {
        toolbarItems.push({
          id: id + "_strokeWidth",
          cssClass: "top-icon e-size",
          tooltipText: this.l10n.getConstant("TextOutlineWidth"),
          align: "Center",
          type: "Input",
          template: '<button id="' + id + '_borderWidthBtn"></button>'
        });
      }
      if (items.indexOf("transparency") > -1) {
        toolbarItems.push({
          id: id + "_transparency",
          prefixIcon: "e-opacity",
          tooltipText: this.l10n.getConstant("Opacity"),
          align: "Center"
        });
      }
      toolbarItems.push({ align: "Center", type: "Separator" });
      if (items.indexOf("z-order") > -1) {
        toolbarItems.push({
          id: id + "_zOrder",
          cssClass: "top-icon e-list-unordered-3",
          tooltipText: this.l10n.getConstant("ZOrder"),
          align: "Center",
          type: "Input",
          template: '<button id="' + id + '_zOrderBtn"></button>'
        });
      }
      if (items.indexOf("duplicate") > -1) {
        toolbarItems.push({
          id: id + "_duplicate",
          prefixIcon: "e-icons e-order",
          cssClass: "top-icon e-order",
          tooltipText: this.l10n.getConstant("Duplicate"),
          align: "Center",
          disabled: parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block" ? true : false
        });
      }
      if (items.indexOf("remove") > -1) {
        toolbarItems.push({
          id: id + "_remove",
          prefixIcon: "e-icons e-trash",
          cssClass: "top-icon e-trash",
          tooltipText: this.l10n.getConstant("Remove"),
          align: "Center",
          disabled: parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block" ? true : false
        });
      }
      if (items.indexOf("text") > -1) {
        toolbarItems.push({
          id: id + "_editText",
          prefixIcon: "e-icons e-annotation-edit",
          cssClass: "top-icon e-annotation-edit",
          tooltipText: this.l10n.getConstant("EditText"),
          align: "Center",
          disabled: parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block" ? true : false
        });
      }
      var tempToolbarItems = this.processSubToolbar(items);
      for (var i = 0, len = tempToolbarItems.length; i < len; i++) {
        toolbarItems.push(tempToolbarItems[i]);
      }
      if (!Browser.isDevice) {
        toolbarItems.push({
          id: id + "_ok",
          prefixIcon: "e-icons e-check",
          cssClass: "top-icon e-tick",
          tooltipText: this.l10n.getConstant("OK"),
          align: "Right",
          tabIndex: 0
        });
        toolbarItems.push({
          id: id + "_cancel",
          prefixIcon: "e-icons e-close",
          cssClass: "top-icon e-save",
          tooltipText: this.l10n.getConstant("Cancel"),
          align: "Right"
        });
      }
      return toolbarItems;
    };
    ToolbarModule2.prototype.getFontFamilyItems = function() {
      var parent = this.parent;
      var items = [];
      if (parent.fontFamily && parent.fontFamily.items && parent.fontFamily.items.length > 0) {
        items = parent.fontFamily.items;
      } else {
        if (Browser.isDevice) {
          items = [
            { id: "arial", text: "ABC" },
            { id: "calibri", text: "ABC" },
            { id: "georgia", text: "ABC" },
            { id: "roboto", text: "ABC" },
            { id: "tahoma", text: "ABC" }
          ];
        } else {
          items = [
            { id: "arial", text: "Arial" },
            { id: "calibri", text: "Calibri" },
            { id: "georgia", text: "Georgia" },
            { id: "roboto", text: "Roboto" },
            { id: "tahoma", text: "Tahoma" }
          ];
        }
      }
      return items;
    };
    ToolbarModule2.prototype.initTextToolbarItem = function(items) {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      var leftItem = this.getLeftToolbarItem();
      var rightItem = this.getRightToolbarItem();
      var mainItem = this.getTextToolbarItem(items);
      var zoomItem = this.getZoomToolbarItem();
      if (Browser.isDevice) {
        this.defToolbarItems = mainItem;
      } else {
        this.defToolbarItems = leftItem.concat(zoomItem, mainItem, rightItem);
      }
      var args = { toolbarType: "text", toolbarItems: this.defToolbarItems };
      parent.trigger("toolbarUpdating", args);
      if (this.isToolbarString(args.toolbarItems)) {
        items = args.toolbarItems;
        this.excludeItems(args.toolbarItems);
      } else {
        this.defToolbarItems = args.toolbarItems;
      }
      var toolbar = new Toolbar({
        width: "100%",
        items: this.defToolbarItems,
        clicked: this.defToolbarClicked.bind(this),
        created: function() {
          _this.renderAnnotationBtn(true);
          _this.createTextColor(items);
          _this.createStrokeTextColor(items);
          _this.createShapeBtn(items);
          _this.createBackgroundColor(items);
          _this.createTextBtn(items);
          _this.createZOrderBtn(items);
          _this.wireZoomBtnEvents();
          parent.trigger("toolbarCreated", { toolbarType: "text" });
          if (Browser.isDevice) {
            if (_this.defToolbarItems.length > 0 && (undefined).getElementById(id + "_bottomToolbar")) {
              toolbar.refreshOverflow();
              toolbar.refreshOverflow();
              toolbar.refreshOverflow();
            }
          } else {
            _this.createLeftToolbarControls();
            if (_this.defToolbarItems.length > 0 && (undefined).getElementById(id + "_toolbar")) {
              toolbar.refreshOverflow();
            }
          }
        }
      });
      if (Browser.isDevice) {
        toolbar.appendTo("#" + id + "_bottomToolbar");
      } else {
        toolbar.appendTo("#" + id + "_toolbar");
      }
      this.enableDisableTbrBtn();
    };
    ToolbarModule2.prototype.createTextColor = function(items) {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      if (items.indexOf("fontColor") > -1 && parent.element.querySelector(".e-template.e-text-font-color")) {
        parent.element.querySelector(".e-template.e-text-font-color").appendChild(parent.createElement("input", {
          id: id + "_text_font"
        }));
        var fontColor_1 = new ColorPicker({
          modeSwitcher: true,
          noColor: false,
          value: "#fff",
          inline: true,
          showButtons: false,
          mode: "Palette",
          cssClass: "e-text-fontt-color",
          beforeModeSwitch: function(args) {
            _this.popupLeft = args.element.offsetParent.style.left;
            fontColor_1.value = parent.activeObj.strokeSettings.strokeColor !== "#fff" ? parent.activeObj.strokeSettings.strokeColor : "#008000ff";
            _this.beforeModeSwitch(args, fontColor_1);
          },
          presetColors: this.presetColors,
          change: function(args) {
            parent.updateFontColor(args.value, "Text");
            strokeDDB_2.element.children[0].style.backgroundColor = args.currentValue.rgba;
            strokeDDB_2.toggle();
            if (parent.activeObj.activePoint.width !== 0 || parent.activeObj.activePoint.height !== 0) {
              parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
            }
          },
          onModeSwitch: function(args) {
            if (Browser.isDevice) {
              args.element.parentElement.parentElement.style.left = _this.popupLeft;
              args.element.parentElement.parentElement.style.top = strokeDDB_2.element.getBoundingClientRect().top - args.element.parentElement.parentElement.offsetHeight + "px";
            }
          },
          beforeClose: function() {
            strokeDDB_2.toggle();
          }
        }, "#" + id + "_text_font");
        var strokeDDB_2 = new DropDownButton({
          open: function(args) {
            var parenElem = args.element.parentElement;
            if (Browser.isDevice) {
              parenElem.style.top = strokeDDB_2.element.getBoundingClientRect().top - parenElem.offsetHeight + "px";
              if ((undefined).innerWidth <= 520) {
                parenElem.style.left = parent.element.offsetLeft + "px";
              }
            }
          },
          target: ".e-text-fontt-color",
          iconCss: "e-dropdownbtn-preview",
          cssClass: "e-ie-ddb-popup"
        }, "#" + id + "_fontColorBtn");
        fontColor_1.inline = true;
        fontColor_1.value = fontColor_1.getValue(fontColor_1.value, "rgba");
        parent.element.querySelector(".e-text-font-color.e-template .e-dropdownbtn-preview").style.background = "#fff";
      }
    };
    ToolbarModule2.prototype.createBackgroundColor = function(items) {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      if (items.indexOf("fillColor") > -1 && parent.element.querySelector(".e-template.e-text-background-color")) {
        parent.element.querySelector(".e-template.e-text-background-color").appendChild(parent.createElement("input", {
          id: id + "_text_bgColor"
        }));
        var backgroundColor_1 = new ColorPicker({
          modeSwitcher: true,
          noColor: true,
          value: "",
          inline: true,
          showButtons: false,
          mode: "Palette",
          cssClass: "e-text-fontt-color",
          beforeModeSwitch: function(args) {
            _this.popupLeft = args.element.offsetParent.style.left;
            _this.beforeModeSwitch(args, backgroundColor_1);
          },
          presetColors: {
            "custom": [
              "",
              "#f44336",
              "#e91e63",
              "#9c27b0",
              "#673ab7",
              "#2196f3",
              "#03a9f4",
              "#00bcd4",
              "#009688",
              "#ffeb3b",
              "#ffffff",
              "#ffebee",
              "#fce4ec",
              "#f3e5f5",
              "#ede7f6",
              "#e3f2fd",
              "#e1f5fe",
              "#e0f7fa",
              "#e0f2f1",
              "#fffde7",
              "#f2f2f2",
              "#ffcdd2",
              "#f8bbd0",
              "#e1bee7",
              "#d1c4e9",
              "#bbdefb",
              "#b3e5fc",
              "#b2ebf2",
              "#b2dfdb",
              "#fff9c4",
              "#e6e6e6",
              "#ef9a9a",
              "#f48fb1",
              "#ce93d8",
              "#b39ddb",
              "#90caf9",
              "#81d4fa",
              "#80deea",
              "#80cbc4",
              "#fff59d",
              "#cccccc",
              "#e57373",
              "#f06292",
              "#ba68c8",
              "#9575cd",
              "#64b5f6",
              "#4fc3f7",
              "#4dd0e1",
              "#4db6ac",
              "#fff176",
              "#b3b3b3",
              "#ef5350",
              "#ec407a",
              "#ab47bc",
              "#7e57c2",
              "#42a5f5",
              "#29b6f6",
              "#26c6da",
              "#26a69a",
              "#ffee58",
              "#999999",
              "#e53935",
              "#d81b60",
              "#8e24aa",
              "#5e35b1",
              "#1e88e5",
              "#039be5",
              "#00acc1",
              "#00897b",
              "#fdd835",
              "#808080",
              "#d32f2f",
              "#c2185b",
              "#7b1fa2",
              "#512da8",
              "#1976d2",
              "#0288d1",
              "#0097a7",
              "#00796b",
              "#fbc02d",
              "#666666",
              "#c62828",
              "#ad1457",
              "#6a1b9a",
              "#4527a0",
              "#1565c0",
              "#0277bd",
              "#00838f",
              "#00695c",
              "#f9a825",
              "#4d4d4d",
              "#b71c1c",
              "#880e4f",
              "#4a148c",
              "#311b92",
              "#0d47a1",
              "#01579b",
              "#006064",
              "#004d40",
              "#f57f17"
            ]
          },
          beforeTileRender: function(args) {
            if (args.value === "") {
              args.element.classList.add("e-nocolor-item");
            }
          },
          change: function(args) {
            parent.updateFontColor(args.value, "Background");
            if (args.currentValue.rgba === "") {
              strokeDDB_3.element.children[0].classList.add("e-nocolor-item");
            } else {
              strokeDDB_3.element.children[0].classList.remove("e-nocolor-item");
              strokeDDB_3.element.children[0].style.backgroundColor = args.currentValue.rgba;
            }
            strokeDDB_3.toggle();
            if (parent.activeObj.activePoint.width !== 0 || parent.activeObj.activePoint.height !== 0) {
              parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
            }
          },
          onModeSwitch: function(args) {
            if (Browser.isDevice) {
              args.element.parentElement.parentElement.style.left = _this.popupLeft;
              args.element.parentElement.parentElement.style.top = strokeDDB_3.element.getBoundingClientRect().top - args.element.parentElement.parentElement.offsetHeight + "px";
            }
          },
          beforeClose: function() {
            strokeDDB_3.toggle();
          }
        }, "#" + id + "_text_bgColor");
        var strokeDDB_3 = new DropDownButton({
          open: function(args) {
            var parenElem = args.element.parentElement;
            if (Browser.isDevice) {
              parenElem.style.top = strokeDDB_3.element.getBoundingClientRect().top - parenElem.offsetHeight + "px";
              if ((undefined).innerWidth <= 520) {
                parenElem.style.left = parent.element.offsetLeft + "px";
              }
            }
          },
          target: ".e-text-fontt-color",
          iconCss: "e-dropdownbtn-preview",
          cssClass: "e-ie-ddb-popup"
        }, "#" + id + "_bgColorBtn");
        backgroundColor_1.inline = true;
        backgroundColor_1.value = backgroundColor_1.getValue(backgroundColor_1.value, "rgba");
        parent.element.querySelector(".e-text-background-color.e-template .e-dropdownbtn-preview").style.background = "#fff";
      }
    };
    ToolbarModule2.prototype.createStrokeTextColor = function(items) {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      if (items.indexOf("strokeColor") > -1 && parent.element.querySelector(".e-template.e-stroke-text-font-color")) {
        parent.element.querySelector(".e-template.e-stroke-text-font-color").appendChild(parent.createElement("input", {
          id: id + "_stroke_text"
        }));
        var fontColor_2 = new ColorPicker({
          modeSwitcher: true,
          noColor: true,
          value: "",
          inline: true,
          showButtons: false,
          mode: "Palette",
          cssClass: "e-text-fontt-color",
          beforeModeSwitch: function(args) {
            _this.popupLeft = args.element.offsetParent.style.left;
            _this.beforeModeSwitch(args, fontColor_2);
          },
          presetColors: {
            "custom": [
              "",
              "#f44336",
              "#e91e63",
              "#9c27b0",
              "#673ab7",
              "#2196f3",
              "#03a9f4",
              "#00bcd4",
              "#009688",
              "#ffeb3b",
              "#ffffff",
              "#ffebee",
              "#fce4ec",
              "#f3e5f5",
              "#ede7f6",
              "#e3f2fd",
              "#e1f5fe",
              "#e0f7fa",
              "#e0f2f1",
              "#fffde7",
              "#f2f2f2",
              "#ffcdd2",
              "#f8bbd0",
              "#e1bee7",
              "#d1c4e9",
              "#bbdefb",
              "#b3e5fc",
              "#b2ebf2",
              "#b2dfdb",
              "#fff9c4",
              "#e6e6e6",
              "#ef9a9a",
              "#f48fb1",
              "#ce93d8",
              "#b39ddb",
              "#90caf9",
              "#81d4fa",
              "#80deea",
              "#80cbc4",
              "#fff59d",
              "#cccccc",
              "#e57373",
              "#f06292",
              "#ba68c8",
              "#9575cd",
              "#64b5f6",
              "#4fc3f7",
              "#4dd0e1",
              "#4db6ac",
              "#fff176",
              "#b3b3b3",
              "#ef5350",
              "#ec407a",
              "#ab47bc",
              "#7e57c2",
              "#42a5f5",
              "#29b6f6",
              "#26c6da",
              "#26a69a",
              "#ffee58",
              "#999999",
              "#e53935",
              "#d81b60",
              "#8e24aa",
              "#5e35b1",
              "#1e88e5",
              "#039be5",
              "#00acc1",
              "#00897b",
              "#fdd835",
              "#808080",
              "#d32f2f",
              "#c2185b",
              "#7b1fa2",
              "#512da8",
              "#1976d2",
              "#0288d1",
              "#0097a7",
              "#00796b",
              "#fbc02d",
              "#666666",
              "#c62828",
              "#ad1457",
              "#6a1b9a",
              "#4527a0",
              "#1565c0",
              "#0277bd",
              "#00838f",
              "#00695c",
              "#f9a825",
              "#4d4d4d",
              "#b71c1c",
              "#880e4f",
              "#4a148c",
              "#311b92",
              "#0d47a1",
              "#01579b",
              "#006064",
              "#004d40",
              "#f57f17"
            ]
          },
          beforeTileRender: function(args) {
            if (args.value === "") {
              args.element.classList.add("e-nocolor-item");
            }
          },
          change: function(args) {
            parent.updateStrokeTextColor(args.value);
            if (args.currentValue.rgba === "") {
              strokeDDB_4.element.children[0].classList.add("e-nocolor-item");
            } else {
              strokeDDB_4.element.children[0].classList.remove("e-nocolor-item");
              strokeDDB_4.element.children[0].style.backgroundColor = args.currentValue.rgba;
            }
            strokeDDB_4.toggle();
            if (parent.activeObj.activePoint.width !== 0 || parent.activeObj.activePoint.height !== 0) {
              parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
            }
          },
          onModeSwitch: function(args) {
            if (Browser.isDevice) {
              args.element.parentElement.parentElement.style.left = _this.popupLeft;
              args.element.parentElement.parentElement.style.top = strokeDDB_4.element.getBoundingClientRect().top - args.element.parentElement.parentElement.offsetHeight + "px";
            }
          },
          beforeClose: function() {
            strokeDDB_4.toggle();
          }
        }, "#" + id + "_stroke_text");
        var strokeDDB_4 = new DropDownButton({
          open: function(args) {
            var parenElem = args.element.parentElement;
            if (Browser.isDevice) {
              parenElem.style.top = strokeDDB_4.element.getBoundingClientRect().top - parenElem.offsetHeight + "px";
              if ((undefined).innerWidth <= 520) {
                parenElem.style.left = parent.element.offsetLeft + "px";
              }
            }
          },
          target: ".e-text-fontt-color",
          iconCss: "e-dropdownbtn-preview",
          cssClass: "e-ie-ddb-popup"
        }, "#" + id + "_strokeTextColorBtn");
        fontColor_2.inline = true;
        fontColor_2.value = fontColor_2.getValue(fontColor_2.value, "rgba");
        parent.element.querySelector(".e-stroke-text-font-color.e-template .e-dropdownbtn-preview").style.background = "#fff";
      }
    };
    ToolbarModule2.prototype.createTextBtn = function(items) {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      if (items.indexOf("fontFamily") > -1) {
        var fontNameBtn = (undefined).getElementById(id + "_fontFamilyBtn");
        var spanElem_4 = (undefined).createElement("span");
        if (Browser.isDevice) {
          spanElem_4.innerHTML = "ABC";
          spanElem_4.setAttribute("style", "font-family: " + parent.fontFamily.default.toLowerCase() + "'");
        } else {
          spanElem_4.innerHTML = parent.fontFamily.default;
        }
        spanElem_4.className = "e-text-font-family";
        if (fontNameBtn) {
          fontNameBtn.appendChild(spanElem_4);
        }
        var fontFamilyBtn_1 = new DropDownButton({
          items: this.getFontFamilyItems(),
          cssClass: "e-font-family",
          createPopupOnClick: true,
          beforeItemRender: function(args) {
            args.element.setAttribute("style", "font-family:" + args.element.id);
          },
          open: function(args) {
            if (Browser.isDevice) {
              args.element.parentElement.style.top = fontFamilyBtn_1.element.getBoundingClientRect().top - args.element.parentElement.offsetHeight + "px";
            }
            var fontFamily;
            if (parent.textArea.style.display === "block" || parent.textArea.style.display === "inline-block") {
              fontFamily = parent.textArea.style.fontFamily;
            } else {
              fontFamily = parent.activeObj.textSettings.fontFamily;
            }
            var elem = args.element.querySelector('[id *= "' + fontFamily.toLowerCase() + '"]');
            if (elem) {
              elem.classList.add("e-selected-btn");
            }
          },
          select: function(args) {
            _this.triggerTbarClickEvent(args);
            spanElem_4.textContent = args.item.text;
            if (Browser.isDevice) {
              spanElem_4.setAttribute("style", "font-family:" + args.item.id);
            }
            parent.updateFontFamily(args.item.id);
            parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
            var toolbar = (undefined).getElementById(parent.element.id + "_toolbar");
            if (toolbar && toolbar.classList.contains("e-control")) {
              getComponent(toolbar, "toolbar").refreshOverflow();
            }
          }
        });
        fontFamilyBtn_1.appendTo("#" + id + "_fontFamilyBtn");
      }
      if (items.indexOf("fontSize") > -1) {
        var fontSizeBtnElem = (undefined).getElementById(id + "_fontSizeBtn");
        var fontSizeSpanElem_1 = (undefined).createElement("span");
        var fontSizes = parent.getFontSizes();
        fontSizeSpanElem_1.innerHTML = fontSizes[0].text;
        fontSizeSpanElem_1.className = "e-text-font-size";
        fontSizeBtnElem.appendChild(fontSizeSpanElem_1);
        var fontSizeBtn_1 = new DropDownButton({
          cssClass: "e-font-size",
          items: fontSizes,
          open: function(args) {
            if (Browser.isDevice) {
              args.element.parentElement.style.top = fontSizeBtn_1.element.getBoundingClientRect().top - args.element.parentElement.offsetHeight + "px";
            }
            var activeBtn = fontSizeSpanElem_1.innerHTML;
            args.element.querySelector('[aria-label *= "' + activeBtn + '"]').classList.add("e-selected-btn");
          },
          select: function(args) {
            _this.triggerTbarClickEvent(args);
            fontSizeSpanElem_1.textContent = args.item.text;
            parent.updateFontSize(args.item.text);
            parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
          }
        });
        fontSizeBtn_1.appendTo("#" + id + "_fontSizeBtn");
      }
    };
    ToolbarModule2.prototype.refreshToolbar = function(type, isApplyBtn, isCropping, isZooming, cType, shape, isTransform) {
      var parent = this.parent;
      var id = parent.element.id;
      if (!parent.isImageLoaded || parent.isCropToolbar) {
        return;
      }
      var args = {};
      var aspectIcon;
      var nonAspectIcon;
      if (type !== "filter" && type !== "color") {
        var toolbarElement = (undefined).getElementById(id + "_toolbar");
        var cusWrapper = (undefined).getElementById(id + "_customizeWrapper");
        var bottomToolbar = (undefined).getElementById(id + "_bottomToolbar");
        if (cusWrapper && getComponent(cusWrapper, "toolbar") && this.defToolbarItems.length > 0) {
          getComponent(cusWrapper, "toolbar").destroy();
          cusWrapper.innerHTML = "";
        }
        if (toolbarElement && toolbarElement.classList.contains("e-control") && this.defToolbarItems.length > 0) {
          getComponent(toolbarElement, "toolbar").destroy();
          toolbarElement.innerHTML = "";
        }
        if (toolbarElement && (this.defToolbarItems.length > 0 || parent.toolbar && parent.toolbar.length > 0 && parent.toolbar.indexOf("Open") === -1)) {
          var toolbar_13 = getComponent(toolbarElement, "toolbar");
          if (!isNullOrUndefined(toolbar_13)) {
            toolbar_13.destroy();
            (undefined).getElementById(parent.element.id + "_toolbar").innerHTML = "";
          }
        }
        if (bottomToolbar && this.defToolbarItems.length > 0) {
          if (bottomToolbar.className.indexOf("e-control") > -1) {
            getComponent(bottomToolbar, "toolbar").destroy();
            bottomToolbar.innerHTML = "";
          }
        }
      }
      this.refreshSlider();
      if ((undefined).querySelector(".e-slider-tooltip")) {
        (undefined).querySelector(".e-slider-tooltip").remove();
      }
      this.isFrameToolbar = parent.isCropTab = false;
      switch (type) {
        case "main":
          if (Browser.isDevice) {
            if (isCropping) {
              this.initMainToolbar(false, true, true, false, false, true);
            } else {
              this.initMainToolbar(false, true, null, false, false, true);
            }
          } else if (!Browser.isDevice || isZooming) {
            if (isZooming) {
              this.initMainToolbar(isApplyBtn, Browser.isDevice, null);
            } else {
              this.initMainToolbar(isApplyBtn, Browser.isDevice, null);
            }
          }
          if (Browser.isDevice) {
            this.initBottomToolbar();
          }
          break;
        case "shapes":
          if (!parent.isPublicMethod) {
            parent.noPushUndo = true;
          }
          if (Browser.isDevice) {
            this.initMainToolbar(false, true, true);
          }
          if (parent.activeObj.shape === "line" || parent.activeObj.shape === "path") {
            args.toolbarItems = ["strokeColor", "strokeWidth", "z-order", "duplicate", "remove"];
          } else if (parent.activeObj.shape === "arrow") {
            args.toolbarItems = ["strokeColor", "strokeWidth", "start", "end", "z-order", "duplicate", "remove"];
          } else if (parent.activeObj.shape === "image") {
            args.toolbarItems = ["flip", "z-order", "duplicate", "remove", "transparency"];
          } else if (parent.activeObj.shape === "rectangle") {
            args.toolbarItems = ["fillColor", "strokeColor", "strokeWidth", "borderRadius", "z-order", "duplicate", "remove"];
          } else {
            args.toolbarItems = ["fillColor", "strokeColor", "strokeWidth", "z-order", "duplicate", "remove"];
          }
          this.initShapesToolbarItem(args.toolbarItems);
          if (parent.activeObj.shape === "image") {
            var actObj = extend({}, parent.activeObj, {}, true);
            parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
            parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
            parent.activeObj = actObj;
            parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: {
              canvas: "duplicate",
              obj: parent.activeObj,
              isCropRatio: null,
              points: null,
              isPreventDrag: true
            } });
            this.renderQAT(false);
          }
          break;
        case "text":
          if (Browser.isDevice) {
            this.initMainToolbar(false, true, true);
          }
          args.toolbarItems = ["fontFamily", "fontSize", "fontColor", "fillColor", "strokeColor", "strokeWidth", "bold", "italic", "z-order", "duplicate", "remove", "text"];
          this.initTextToolbarItem(args.toolbarItems);
          break;
        case "pen":
          if (Browser.isDevice) {
            this.initMainToolbar(false, true, true);
          }
          args.toolbarItems = ["strokeColor", "strokeWidth", "z-order", "remove", "transparency"];
          this.initPenToolbarItem(args.toolbarItems);
          break;
        case "adjustment":
          if (Browser.isDevice) {
            this.initMainToolbar(false, true, true);
          }
          this.initAdjustmentToolbarItem();
          break;
        case "filter":
          this.updateContextualToolbar(type);
          break;
        case "resize":
          if (parent.isCircleCrop || parent.currSelectionPoint && parent.currSelectionPoint.shape === "crop-circle") {
            parent.aspectHeight = parent.aspectWidth;
            this.isAspectRatio = false;
          }
          this.initResizeToolbar();
          if (Browser.isDevice) {
            this.initMainToolbar(false, true, true, true);
          }
          aspectIcon = parent.element.querySelector("#" + id + "_aspectratio");
          nonAspectIcon = parent.element.querySelector("#" + id + "_nonaspectratio");
          if (parent.aspectWidth && parent.aspectHeight) {
            if (nonAspectIcon) {
              parent.notify("transform", { prop: "resize", value: { width: parent.aspectWidth, height: parent.aspectHeight, isAspectRatio: false } });
            } else if (aspectIcon) {
              parent.notify("transform", { prop: "resize", value: { width: parent.aspectWidth, height: null, isAspectRatio: true } });
            }
          }
          break;
        case "color":
          this.updateContextualToolbar(type, cType);
          break;
        case "croptransform":
          if (isNullOrUndefined(isTransform)) {
            parent.allowDownScale = false;
            parent.isCropTab = true;
          }
          if (Browser.isDevice) {
            this.initMainToolbar(false, true, true);
          }
          if (isNullOrUndefined(isTransform)) {
            parent.updateCropTransformItems();
          }
          this.initCropTransformToolbar(shape, isTransform);
          if (Browser.isDevice && this.isToolbar()) {
            this.updateContextualToolbar("color", "straighten", true);
          }
          if (parent.isMaskImage) {
            this.refreshToolbar("main");
          }
          break;
        case "frame":
          this.isFrameToolbar = true;
          if (Browser.isDevice) {
            this.initMainToolbar(false, true, true);
            this.initMainToolbar(false, true, true, false, true);
          } else {
            this.initMainToolbar(true, null, null, false, true);
          }
          var frameElem = parent.element.querySelector("#" + id + "_" + parent.frameObj.type);
          if (frameElem) {
            frameElem.classList.add("e-selected-btn");
          }
          if (parent.frameObj.type !== "none") {
            this.updateContextualToolbar(type, cType);
          }
          parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
          break;
        case "redact":
          if (Browser.isDevice) {
            this.initMainToolbar(false, true, true);
            this.initMainToolbar(false, true, true, null, null, null, true);
          } else {
            this.initMainToolbar(isApplyBtn, Browser.isDevice, null, null, null, null, true);
          }
          this.enableDisableTbrBtn();
          if (parent.activeObj.redactType === "blur") {
            var redactBlurElement = parent.element.querySelector("#" + id + "_redactBlur");
            if (redactBlurElement) {
              redactBlurElement.classList.add("e-selected-btn");
            }
          } else {
            var pixelateElement = parent.element.querySelector("#" + id + "_pixelate");
            if (pixelateElement) {
              pixelateElement.classList.add("e-selected-btn");
            }
          }
          this.redactSlider(parent.activeObj.redactType);
          break;
      }
      this.refreshDropDownBtn(isCropping);
      this.updateKBDNavigation(type);
      this.currToolbar = type;
    };
    ToolbarModule2.prototype.updateRedactObj = function() {
      var parent = this.parent;
      var objColl = extend([], parent.objColl, [], true);
      parent.objColl = [];
      var activeObj = extend({}, parent.activeObj, {}, true);
      parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
      parent.objColl = objColl;
      for (var i = 0; i < parent.objColl.length; i++) {
        var obj = parent.objColl[i];
        if (obj.shape === "redact") {
          obj.redactImage = parent.createElement("canvas");
          obj.redactImage.width = obj.activePoint.width;
          obj.redactImage.height = obj.activePoint.height;
          obj.redactImage.getContext("2d").drawImage(parent.lowerCanvas, obj.activePoint.startX, obj.activePoint.startY, obj.activePoint.width, obj.activePoint.height, 0, 0, obj.redactImage.width, obj.redactImage.height);
        }
      }
      parent.isCropTab = false;
      parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
      parent.isCropTab = true;
      if (activeObj) {
        parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: {
          canvas: "duplicate",
          obj: activeObj,
          isCropRatio: null,
          points: null,
          isPreventDrag: true
        } });
      }
      var panMoveObj = { panMove: null };
      parent.notify("transform", {
        prop: "getPanMove",
        onPropertyChange: false,
        value: { obj: panMoveObj }
      });
      if (panMoveObj["panMove"]) {
        parent.notify("transform", {
          prop: "drawPannedImage",
          onPropertyChange: false,
          value: { xDiff: null, yDiff: null }
        });
      }
    };
    ToolbarModule2.prototype.updateKBDNavigation = function(type) {
      var parent = this.parent;
      var id = parent.element.id;
      if (!parent.isKBDNavigation || this.currToolbar === type) {
        return;
      }
      if (this.isToolbar()) {
        var tbar = parent.element.querySelectorAll("#" + id + "_toolbar")[0];
        var tbarInitialChild = undefined;
        var tbarInitialBtn_1;
        if (tbar) {
          tbarInitialChild = tbar.querySelector(".e-toolbar-center");
          if (!tbarInitialChild || !tbarInitialChild.children[0]) {
            return;
          }
          tbarInitialBtn_1 = tbarInitialChild.children[0].querySelector(".e-btn");
          var tempElem = tbarInitialChild.children[1];
          if (tempElem) {
            tempElem = tempElem.children[0];
          }
          if (tempElem) {
            tempElem = tempElem.children[0];
          }
          if (type === "resize" && tempElem) {
            tbarInitialBtn_1 = tempElem;
          }
          if (type === "filter") {
            var defaultFilter_1 = (undefined).querySelector("#" + id + "_defaultCanvas");
            if (defaultFilter_1) {
              setTimeout(function() {
                return defaultFilter_1.focus();
              }, 50);
            }
          }
          if (tbarInitialBtn_1) {
            if (type === "main") {
              setTimeout(function() {
                return tbarInitialBtn_1.focus();
              }, 50);
            } else {
              tbarInitialBtn_1.focus();
            }
          }
        }
      }
    };
    ToolbarModule2.prototype.performCropTransformClick = function(shape, isTransform) {
      var parent = this.parent;
      if (isNullOrUndefined(isTransform)) {
        parent.notify("draw", { prop: "setTempStraightenZoomDeg" });
        parent.tempStraighten = parent.transform.straighten;
        if (parent.currObjType.isFiltered || parent.currObjType.isRedact) {
          parent.okBtn();
        }
        parent.isStraightening = true;
      }
      this.refreshToolbar("croptransform", null, null, null, null, shape, isTransform);
      if (isNullOrUndefined(isTransform)) {
        parent.notify("draw", { prop: "setDestForStraighten" });
        parent.notify("draw", { prop: "setTempDestForStraighten" });
      }
    };
    ToolbarModule2.prototype.getAdjustmentToolbarItem = function() {
      var toolbarItems = [];
      var parent = this.parent;
      var isCustomized = false;
      var id = parent.element.id;
      var defItems = ["Brightness", "Contrast", "Hue", "Saturation", "Exposure", "Opacity", "Blur"];
      if (parent.toolbar) {
        for (var i = 0; i < defItems.length; i++) {
          if (parent.toolbar.indexOf(defItems[i]) !== -1) {
            isCustomized = true;
            break;
          }
        }
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Brightness") > -1) {
        toolbarItems.push({
          id: id + "_brightness",
          prefixIcon: "e-icons e-brightness",
          cssClass: "top-icon e-brightness",
          tooltipText: this.l10n.getConstant("Brightness"),
          align: "Center"
        });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Contrast") > -1) {
        toolbarItems.push({
          id: id + "_contrast",
          prefixIcon: "e-icons e-contrast",
          cssClass: "top-icon e-contrast",
          tooltipText: this.l10n.getConstant("Contrast"),
          align: "Center"
        });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Hue") > -1) {
        toolbarItems.push({
          id: id + "_hue",
          prefixIcon: "e-icons e-fade",
          cssClass: "top-icon e-fade",
          tooltipText: this.l10n.getConstant("Hue"),
          align: "Center"
        });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Saturation") > -1) {
        toolbarItems.push({
          id: id + "_saturation",
          prefixIcon: "e-icons e-saturation",
          cssClass: "top-icon e-saturation",
          tooltipText: this.l10n.getConstant("Saturation"),
          align: "Center"
        });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Exposure") > -1) {
        toolbarItems.push({
          id: id + "_exposure",
          prefixIcon: "e-icons e-grain",
          cssClass: "top-icon e-grain",
          tooltipText: this.l10n.getConstant("Exposure"),
          align: "Center"
        });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Opacity") > -1) {
        toolbarItems.push({
          id: id + "_opacity",
          prefixIcon: "e-icons e-opacity",
          cssClass: "top-icon e-opacity",
          tooltipText: this.l10n.getConstant("Opacity"),
          align: "Center"
        });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Blur") > -1) {
        toolbarItems.push({
          id: id + "_blur",
          prefixIcon: "e-icons e-tint",
          cssClass: "top-icon e-tint",
          tooltipText: this.l10n.getConstant("Blur"),
          align: "Center"
        });
      }
      var tempToolbarItems = this.processToolbar("center");
      for (var i = 0, len = tempToolbarItems.length; i < len; i++) {
        toolbarItems.push(tempToolbarItems[i]);
      }
      if (!Browser.isDevice) {
        toolbarItems.push({
          id: id + "_ok",
          prefixIcon: "e-icons e-check",
          cssClass: "top-icon e-tick",
          tooltipText: this.l10n.getConstant("OK"),
          align: "Right",
          tabIndex: 0
        });
        toolbarItems.push({
          id: id + "_cancel",
          prefixIcon: "e-icons e-close",
          cssClass: "top-icon e-save",
          tooltipText: this.l10n.getConstant("Cancel"),
          align: "Right"
        });
      }
      return toolbarItems;
    };
    ToolbarModule2.prototype.getFrameToolbarItem = function() {
      var parent = this.parent;
      var id = parent.element.id;
      var toolbarItems = [];
      toolbarItems.push({
        prefixIcon: "e-icons e-copy",
        id: id + "_frameColor",
        cssClass: "top-icon e-stroke",
        tooltipText: this.l10n.getConstant("Color"),
        align: "Center",
        type: "Input",
        template: "<span>" + this.l10n.getConstant("Color") + '</span><button id="' + id + '_frameColorBtn"></button>'
      });
      toolbarItems.push({
        prefixIcon: "e-icons e-copy",
        id: id + "_frameGradient",
        cssClass: "top-icon e-frame-stroke",
        tooltipText: this.l10n.getConstant("GradientColor"),
        align: "Center",
        type: "Input",
        template: "<span>" + this.l10n.getConstant("GradientColor") + '</span><button id="' + id + '_frameGradientColorBtn"></button>'
      });
      toolbarItems.push({
        id: id + "_frameSize",
        cssClass: "top-icon e-size",
        tooltipText: this.l10n.getConstant("Size"),
        align: "Center",
        type: "Input",
        template: "<span>" + this.l10n.getConstant("Size") + '</span><button id="' + id + '_frameSizeBtn"></button>'
      });
      if (parent.frameObj.type === "line" || parent.frameObj.type === "inset" || parent.frameObj.type === "hook") {
        toolbarItems.push({
          id: id + "_frameInset",
          cssClass: "top-icon e-size",
          tooltipText: this.l10n.getConstant("Inset"),
          align: "Center",
          type: "Input",
          template: "<span>" + this.l10n.getConstant("Inset") + '</span><button id="' + id + '_frameInsetBtn"></button>'
        });
      }
      if (parent.frameObj.type === "line" || parent.frameObj.type === "inset") {
        toolbarItems.push({
          id: id + "_frameOffset",
          cssClass: "top-icon e-size",
          tooltipText: this.l10n.getConstant("Offset"),
          align: "Center",
          type: "Input",
          template: "<span>" + this.l10n.getConstant("Offset") + '</span><button id="' + id + '_frameOffsetBtn"></button>'
        });
      }
      if (parent.frameObj.type === "line") {
        toolbarItems.push({
          id: id + "_frameRadius",
          cssClass: "top-icon e-size",
          tooltipText: this.l10n.getConstant("Radius"),
          align: "Center",
          type: "Input",
          template: "<span>" + this.l10n.getConstant("Radius") + '</span><button id="' + id + '_frameRadiusBtn"></button>'
        });
        toolbarItems.push({
          id: id + "_frameAmount",
          cssClass: "top-icon e-size",
          tooltipText: this.l10n.getConstant("Amount"),
          align: "Center",
          type: "Input",
          template: "<span>" + this.l10n.getConstant("Amount") + '</span><button id="' + id + '_frameAmountBtn"></button>'
        });
        toolbarItems.push({
          id: id + "_frameBorder",
          cssClass: "top-icon e-size",
          tooltipText: this.l10n.getConstant("Border"),
          align: "Center",
          type: "Input",
          template: "<span>" + this.l10n.getConstant("Border") + '</span><button id="' + id + '_frameBorderBtn"></button>'
        });
      }
      return toolbarItems;
    };
    ToolbarModule2.prototype.getFilterToolbarItem = function() {
      var toolbarItems = [];
      var parent = this.parent;
      var isCustomized = false;
      var id = parent.element.id;
      var defItems = ["Default", "Chrome", "Cold", "Warm", "Grayscale", "Sepia", "Invert"];
      if (parent.toolbar) {
        for (var i = 0; i < defItems.length; i++) {
          if (parent.toolbar.indexOf(defItems[i]) !== -1) {
            isCustomized = true;
            break;
          }
        }
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Default") > -1) {
        toolbarItems.push({
          id: id + "_default",
          prefixIcon: "e-icons e-none",
          cssClass: "top-icon e-none",
          tooltipText: this.l10n.getConstant("Default"),
          align: "Center",
          template: '<div class="filter-wrapper"><canvas id=' + id + "_defaultCanvas tabindex=0></canvas><div><span>" + this.l10n.getConstant("Default") + "</span></div></div>"
        });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Chrome") > -1) {
        toolbarItems.push({
          id: id + "_chrome",
          prefixIcon: "e-icons e-none",
          cssClass: "top-icon e-none",
          tooltipText: this.l10n.getConstant("Chrome"),
          align: "Center",
          template: '<div class="filter-wrapper"><canvas id=' + id + "_chromeCanvas></canvas><div><span>" + this.l10n.getConstant("Chrome") + "</span></div></div>"
        });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Cold") > -1) {
        toolbarItems.push({
          id: id + "_cold",
          prefixIcon: "e-icons e-none",
          cssClass: "top-icon e-none",
          tooltipText: this.l10n.getConstant("Cold"),
          align: "Center",
          template: '<div class="filter-wrapper"><canvas id=' + id + "_coldCanvas></canvas><div><span>" + this.l10n.getConstant("Cold") + "</span></div></div>"
        });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Warm") > -1) {
        toolbarItems.push({
          id: id + "_warm",
          prefixIcon: "e-icons e-none",
          cssClass: "top-icon e-none",
          tooltipText: this.l10n.getConstant("Warm"),
          align: "Center",
          template: '<div class="filter-wrapper"><canvas id=' + id + "_warmCanvas></canvas><div><span>" + this.l10n.getConstant("Warm") + "</span></div></div>"
        });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Grayscale") > -1) {
        toolbarItems.push({
          id: id + "_grayscale",
          prefixIcon: "e-icons e-none",
          cssClass: "top-icon e-none",
          tooltipText: this.l10n.getConstant("Grayscale"),
          align: "Center",
          template: '<div class="filter-wrapper"><canvas id=' + id + "_grayscaleCanvas></canvas><div><span>" + this.l10n.getConstant("Grayscale") + "</span></div></div>"
        });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Sepia") > -1) {
        toolbarItems.push({
          id: id + "_sepia",
          prefixIcon: "e-icons e-none",
          cssClass: "top-icon e-none",
          tooltipText: this.l10n.getConstant("Sepia"),
          align: "Center",
          template: '<div class="filter-wrapper"><canvas id=' + id + "_sepiaCanvas></canvas><div><span>" + this.l10n.getConstant("Sepia") + "</span></div></div>"
        });
      }
      if (isNullOrUndefined(parent.toolbar) || !isCustomized || parent.toolbar && parent.toolbar.indexOf("Invert") > -1) {
        toolbarItems.push({
          id: id + "_invert",
          prefixIcon: "e-icons e-none",
          cssClass: "top-icon e-none",
          tooltipText: this.l10n.getConstant("Invert"),
          align: "Center",
          template: '<div class="filter-wrapper"><canvas id=' + id + "_invertCanvas></canvas><div><span>" + this.l10n.getConstant("Invert") + "</span></div></div>"
        });
      }
      var tempToolbarItems = this.processToolbar("center");
      for (var i = 0, len = tempToolbarItems.length; i < len; i++) {
        toolbarItems.push(tempToolbarItems[i]);
      }
      return toolbarItems;
    };
    ToolbarModule2.prototype.getPenToolbarItem = function(items) {
      var parent = this.parent;
      var id = parent.element.id;
      var toolbarItems = [];
      if (isNullOrUndefined(parent.toolbar) || parent.toolbar) {
        toolbarItems.push({
          id: id + "_annotation",
          tooltipText: this.l10n.getConstant("Annotation"),
          align: "Center",
          template: '<button id="' + id + '_annotationBtn"></button>'
        });
      }
      if (items.indexOf("strokeColor") > -1) {
        toolbarItems.push({
          prefixIcon: "e-icons e-copy",
          id: id + "_pen_strokecolor",
          cssClass: "top-icon e-pen-stroke-color",
          tooltipText: this.l10n.getConstant("StrokeColor"),
          align: "Center",
          type: "Input",
          template: '<button id="' + id + '_penColorBtn"></button>'
        });
      }
      if (items.indexOf("strokeWidth") > -1) {
        toolbarItems.push({
          prefixIcon: "e-icons e-copy",
          id: id + "_pen_strokewidth",
          cssClass: "top-icon e-size",
          tooltipText: this.l10n.getConstant("StrokeWidth"),
          align: "Center",
          type: "Input",
          template: '<button id="' + id + '_penStrokeWidth"></button>'
        });
      }
      toolbarItems.push({ align: "Center", type: "Separator" });
      if (items.indexOf("z-order") > -1) {
        toolbarItems.push({
          id: id + "_zOrder",
          cssClass: "top-icon e-list-unordered-3",
          tooltipText: this.l10n.getConstant("ZOrder"),
          align: "Center",
          type: "Input",
          template: '<button id="' + id + '_zOrderBtn"></button>'
        });
      }
      if (items.indexOf("remove") > -1) {
        toolbarItems.push({
          id: id + "_remove",
          prefixIcon: "e-icons e-trash",
          cssClass: "top-icon e-trash",
          tooltipText: this.l10n.getConstant("Remove"),
          align: "Center"
        });
      }
      var tempToolbarItems = this.processSubToolbar(items);
      for (var i = 0, len = tempToolbarItems.length; i < len; i++) {
        toolbarItems.push(tempToolbarItems[i]);
      }
      if (!Browser.isDevice) {
        toolbarItems.push({
          id: id + "_ok",
          prefixIcon: "e-icons e-check",
          cssClass: "top-icon e-tick",
          tooltipText: this.l10n.getConstant("OK"),
          align: "Right",
          tabIndex: 0
        });
        toolbarItems.push({
          id: id + "_cancel",
          prefixIcon: "e-icons e-close",
          cssClass: "top-icon e-save",
          tooltipText: this.l10n.getConstant("Cancel"),
          align: "Right"
        });
      }
      return toolbarItems;
    };
    ToolbarModule2.prototype.initPenToolbarItem = function(items) {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      var leftItem = this.getLeftToolbarItem();
      var rightItem = this.getRightToolbarItem();
      var mainItem = this.getPenToolbarItem(items);
      var zoomItem = this.getZoomToolbarItem();
      if (Browser.isDevice) {
        this.defToolbarItems = mainItem;
      } else {
        this.defToolbarItems = leftItem.concat(zoomItem, mainItem, rightItem);
      }
      var args = { toolbarType: "pen", toolbarItems: this.defToolbarItems };
      parent.trigger("toolbarUpdating", args);
      if (this.isToolbarString(args.toolbarItems)) {
        items = args.toolbarItems;
        this.excludeItems(args.toolbarItems);
      } else {
        this.defToolbarItems = args.toolbarItems;
      }
      var toolbar = new Toolbar({
        width: "100%",
        items: this.defToolbarItems,
        clicked: this.defToolbarClicked.bind(this),
        created: function() {
          _this.renderAnnotationBtn(true);
          _this.createPenColor(items);
          _this.createPenBtn(items);
          _this.createZOrderBtn(items);
          _this.wireZoomBtnEvents();
          parent.trigger("toolbarCreated", { toolbarType: "pen" });
          if (Browser.isDevice) {
            if (_this.defToolbarItems.length > 0 && (undefined).getElementById(id + "_toolbar")) {
              toolbar.refreshOverflow();
              toolbar.refreshOverflow();
            }
          } else {
            _this.createLeftToolbarControls();
            if (_this.defToolbarItems.length > 0 && (undefined).getElementById(id + "_toolbar")) {
              toolbar.refreshOverflow();
            }
          }
        }
      });
      if (Browser.isDevice) {
        toolbar.appendTo("#" + id + "_bottomToolbar");
      } else {
        toolbar.appendTo("#" + id + "_toolbar");
      }
      this.enableDisableTbrBtn();
    };
    ToolbarModule2.prototype.createPenColor = function(items) {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      if (items.indexOf("strokeColor") > -1) {
        parent.element.querySelector(".e-template.e-pen-stroke-color").appendChild(parent.createElement("input", {
          id: id + "_pen_stroke"
        }));
        var presentVal = parent.activeObj.strokeSettings.strokeColor;
        var penColor = new ColorPicker({
          modeSwitcher: false,
          value: "#fff",
          showButtons: false,
          mode: "Palette",
          cssClass: "e-pen-color",
          change: function(args) {
            parent.updatePenStrokeColor(args.currentValue.hex);
            _this.selFhdColor = args.currentValue.hex;
            strokeDDB_5.element.children[0].style.backgroundColor = args.currentValue.rgba;
            strokeDDB_5.toggle();
            parent.notify("undo-redo", { prop: "updateUndoRedoStack", value: { isPenDraw: true } });
          }
        }, "#" + id + "_pen_stroke");
        var strokeDDB_5 = new DropDownButton({
          open: function(args) {
            var parentElem = args.element.parentElement;
            if (Browser.isDevice) {
              parentElem.style.top = strokeDDB_5.element.getBoundingClientRect().top - parentElem.offsetHeight + "px";
              if ((undefined).innerWidth <= 520) {
                parentElem.style.left = parent.element.offsetLeft + "px";
              }
            }
          },
          target: ".e-pen-color",
          iconCss: "e-dropdownbtn-preview",
          cssClass: "e-ie-ddb-popup"
        }, "#" + id + "_penColorBtn");
        penColor.inline = true;
        penColor.value = penColor.getValue(parent.activeObj.strokeSettings.strokeColor, "rgba");
        if (penColor.value === "null") {
          penColor.value = presentVal;
        }
        var obj = { tempFreeHandDrawEditingStyles: null };
        parent.notify("freehand-draw", { prop: "getTempFreeHandDrawEditingStyles", value: { obj } });
        var indexObj = { freehandSelectedIndex: null };
        parent.notify("freehand-draw", { prop: "getFreehandSelectedIndex", onPropertyChange: false, value: { obj: indexObj } });
        if (!isNullOrUndefined(indexObj["freehandSelectedIndex"]) && indexObj["freehandSelectedIndex"] > -1) {
          parent.element.querySelector(".e-pen-stroke-color.e-template .e-dropdownbtn-preview").style.background = this.selFhdColor === "#42a5f5" ? obj["tempFreeHandDrawEditingStyles"].strokeColor : parent.pointColl[indexObj["freehandSelectedIndex"]].strokeColor;
        } else {
          parent.element.querySelector(".e-pen-stroke-color.e-template .e-dropdownbtn-preview").style.background = penColor.value;
        }
      }
    };
    ToolbarModule2.prototype.createPenBtn = function(items) {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      var strokeWidthItems = [
        { id: "1", text: this.l10n.getConstant("XSmall") },
        { id: "2", text: this.l10n.getConstant("Small") },
        { id: "3", text: this.l10n.getConstant("Medium") },
        { id: "4", text: this.l10n.getConstant("Large") },
        { id: "5", text: this.l10n.getConstant("XLarge") }
      ];
      if (items.indexOf("strokeWidth") > -1) {
        var strokeWidthBtn = (undefined).getElementById(id + "_penStrokeWidth");
        var spanElem_5 = (undefined).createElement("span");
        var indexObj = { freehandSelectedIndex: null };
        parent.notify("freehand-draw", { prop: "getFreehandSelectedIndex", onPropertyChange: false, value: { obj: indexObj } });
        if (!isNullOrUndefined(indexObj["freehandSelectedIndex"]) && indexObj["freehandSelectedIndex"] > -1) {
          spanElem_5.innerHTML = this.getPenStroke(parent.pointColl[indexObj["freehandSelectedIndex"]].strokeWidth);
        } else {
          var obj = { penStrokeWidth: 2 };
          parent.notify("freehand-draw", { prop: "getPenStrokeWidth", onPropertyChange: false, value: { obj } });
          if (obj["penStrokeWidth"]) {
            spanElem_5.innerHTML = this.getPenStroke(obj["penStrokeWidth"]);
          } else {
            spanElem_5.innerHTML = this.l10n.getConstant("Small");
          }
        }
        spanElem_5.className = "e-pen-stroke-width";
        strokeWidthBtn.appendChild(spanElem_5);
        var drpDownBtn_5 = new DropDownButton({
          items: strokeWidthItems,
          open: function(args) {
            if (Browser.isDevice) {
              args.element.parentElement.style.top = drpDownBtn_5.element.getBoundingClientRect().top - args.element.parentElement.offsetHeight + "px";
            }
            var activeBtn = spanElem_5.innerHTML;
            args.element.querySelector('[aria-label = "' + activeBtn + '"]').classList.add("e-selected-btn");
          },
          select: function(args) {
            _this.triggerTbarClickEvent(args);
            spanElem_5.textContent = args.item.text;
            parent.updatePenStrokeWidth(args.item.id);
            if (Browser.isDevice) {
              if ((undefined).getElementById(id + "_bottomToolbar")) {
                var toolbar_14 = getComponent(id + "_bottomToolbar", "toolbar");
                toolbar_14.refreshOverflow();
              }
            } else {
              if ((undefined).getElementById(id + "_toolbar")) {
                var toolbar_15 = getComponent(id + "_toolbar", "toolbar");
                toolbar_15.refreshOverflow();
              }
            }
            var widthObj = { penStrokeWidth: null };
            parent.notify("freehand-draw", { prop: "getPenStrokeWidth", onPropertyChange: false, value: { obj: widthObj } });
            parent.notify("undo-redo", { prop: "updateUndoRedoStack", value: { isPenDraw: true } });
            parent.notify("freehand-draw", { prop: "setPenStrokeWidth", onPropertyChange: false, value: { value: widthObj["penStrokeWidth"] } });
          }
        });
        drpDownBtn_5.appendTo("#" + id + "_penStrokeWidth");
      }
    };
    ToolbarModule2.prototype.getPenStroke = function(value) {
      var textContent = "";
      var valueToTextContent = {
        1: this.l10n.getConstant("XSmall"),
        2: this.l10n.getConstant("Small"),
        3: this.l10n.getConstant("Medium"),
        4: this.l10n.getConstant("Large"),
        5: this.l10n.getConstant("XLarge")
      };
      if (value >= 1 && value <= 5) {
        textContent = valueToTextContent[value];
      }
      return textContent;
    };
    ToolbarModule2.prototype.initAdjustmentToolbarItem = function() {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      var leftItem = this.getLeftToolbarItem(null);
      var rightItem = this.getRightToolbarItem();
      var mainItem = this.getAdjustmentToolbarItem();
      var zoomItem = this.getZoomToolbarItem();
      if (Browser.isDevice) {
        this.defToolbarItems = mainItem;
      } else {
        this.defToolbarItems = leftItem.concat(zoomItem, mainItem, rightItem);
      }
      var args = { toolbarType: "finetune", toolbarItems: this.defToolbarItems };
      parent.trigger("toolbarUpdating", args);
      this.defToolbarItems = args.toolbarItems;
      var toolbar = new Toolbar({
        width: "100%",
        items: this.defToolbarItems,
        clicked: this.defToolbarClicked.bind(this),
        created: function() {
          _this.wireZoomBtnEvents();
          if (Browser.isDevice) {
            if (_this.defToolbarItems.length > 0 && (undefined).getElementById(id + "_toolbar")) {
              toolbar.refreshOverflow();
            }
          } else {
            _this.createLeftToolbarControls();
            if (_this.defToolbarItems.length > 0 && (undefined).getElementById(id + "_toolbar")) {
              toolbar.refreshOverflow();
            }
          }
        }
      });
      if (Browser.isDevice) {
        toolbar.appendTo("#" + id + "_bottomToolbar");
      } else {
        toolbar.appendTo("#" + id + "_toolbar");
      }
      this.enableDisableTbrBtn();
    };
    ToolbarModule2.prototype.initFrameToolbarItem = function() {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      var canvasWrapper = (undefined).querySelector("#" + id + "_contextualToolbarArea");
      var frameWrapper = (undefined).querySelector("#" + id + "_frameWrapper");
      if (frameWrapper) {
        frameWrapper.style.display = "block";
      } else {
        frameWrapper = canvasWrapper.appendChild(parent.createElement("div", {
          id: id + "_frameWrapper",
          className: "e-frame-wrapper",
          styles: "position: relative"
        }));
      }
      frameWrapper.appendChild(parent.createElement("div", {
        id: id + "_customizeWrapper",
        styles: "position: absolute"
      }));
      var mainItem = this.getFrameToolbarItem();
      var args = { toolbarType: "frame", toolbarItems: mainItem };
      parent.trigger("toolbarUpdating", args);
      mainItem = args.toolbarItems;
      var toolbar = new Toolbar({
        width: "100%",
        items: mainItem,
        clicked: this.defToolbarClicked.bind(this),
        created: function() {
          _this.createFrameColor();
          _this.createFrameSize();
          var frameType = parent.frameObj.type;
          if (frameType === "line") {
            _this.createFrameRadius();
          }
          if (frameType === "line" || frameType === "inset" || frameType === "hook") {
            _this.createFrameInset();
          }
          if (frameType === "line" || frameType === "inset") {
            _this.createFrameOffset();
          }
          if (frameType === "line") {
            _this.createFrameAmount();
            _this.createFrameBorder();
          }
          _this.createFrameGradientColor();
          if (Browser.isDevice) {
            if (_this.defToolbarItems.length > 0 && (undefined).getElementById(id + "_bottomToolbar")) {
              toolbar.refreshOverflow();
              toolbar.refreshOverflow();
              toolbar.refreshOverflow();
            }
          } else {
            _this.createLeftToolbarControls();
            if (_this.defToolbarItems.length > 0 && (undefined).getElementById(id + "_toolbar")) {
              toolbar.refreshOverflow();
            }
          }
          parent.element.querySelector("#" + id + "_" + frameType).focus();
        }
      });
      toolbar.appendTo("#" + id + "_customizeWrapper");
    };
    ToolbarModule2.prototype.createFrameGradientColor = function() {
      var parent = this.parent;
      var prevFrameSettings;
      var obj = { frameChangeEventArgs: null };
      var id = parent.element.id;
      parent.element.querySelector(".e-template.e-frame-stroke").appendChild(parent.createElement("input", {
        id: id + "_frame_gradient_fill"
      }));
      var fillColor = new ColorPicker({
        modeSwitcher: false,
        noColor: true,
        value: parent.frameObj.gradientColor,
        showButtons: false,
        mode: "Palette",
        cssClass: "e-frame-gradient-fill-color",
        change: function(args) {
          prevFrameSettings = {
            type: parent.toPascalCase(parent.frameObj.type),
            color: parent.frameObj.color,
            gradientColor: parent.frameObj.gradientColor,
            size: parent.frameObj.size,
            inset: parent.frameObj.inset,
            offset: parent.frameObj.offset,
            borderRadius: parent.frameObj.radius,
            frameLineStyle: parent.toPascalCase(parent.frameObj.border),
            lineCount: parent.frameObj.amount
          };
          var temp = parent.frameObj.gradientColor;
          var object = { currObj: {} };
          parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
          parent.frameObj.gradientColor = args.currentValue.hex;
          parent.notify("draw", { prop: "triggerFrameChange", value: { prevFrameSettings, obj } });
          if (obj["frameChangeEventArgs"] && !obj["frameChangeEventArgs"].cancel) {
            parent.notify("undo-redo", { prop: "updateUndoRedoColl", onPropertyChange: false, value: {
              operation: "frame",
              previousObj: object["currObj"],
              previousObjColl: object["currObj"]["objColl"],
              previousPointColl: object["currObj"]["pointColl"],
              previousSelPointColl: object["currObj"]["selPointColl"],
              previousCropObj: extend({}, parent.cropObj, {}, true),
              previousText: null,
              currentText: null,
              previousFilter: null,
              isCircleCrop: null
            } });
            parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
            parent.notify("draw", { prop: "redrawDownScale" });
            if (args.currentValue.rgba === "") {
              fillDDB.element.children[0].classList.add("e-nocolor-item");
            } else {
              fillDDB.element.children[0].classList.remove("e-nocolor-item");
              fillDDB.element.children[0].style.backgroundColor = args.currentValue.rgba;
            }
            parent.curFrameObjEvent = {
              previousFrameSetting: obj["frameChangeEventArgs"].previousFrameSetting,
              currentFrameSetting: obj["frameChangeEventArgs"].currentFrameSetting
            };
            parent.isFrameBtnClick = true;
          } else {
            parent.frameObj.gradientColor = temp;
          }
          fillDDB.toggle();
        }
      }, "#" + id + "_frame_gradient_fill");
      var fillDDB = new DropDownButton({
        open: function(args) {
          if (Browser.isDevice) {
            var parentElem = args.element.parentElement;
            parentElem.style.top = fillDDB.element.getBoundingClientRect().top - parentElem.offsetHeight + "px";
            if ((undefined).innerWidth <= 520) {
              parentElem.style.left = parent.element.offsetLeft + "px";
            }
          }
        },
        target: ".e-frame-gradient-fill-color",
        iconCss: "e-dropdownbtn-preview",
        cssClass: "e-ie-ddb-popup"
      }, "#" + id + "_frameGradientColorBtn");
      fillColor.inline = true;
      if (parent.frameObj.gradientColor === "") {
        parent.element.querySelector(".e-frame-stroke.e-template .e-dropdownbtn-preview").classList.add("e-nocolor-item");
      } else {
        parent.element.querySelector(".e-frame-stroke.e-template .e-dropdownbtn-preview").style.background = parent.frameObj.gradientColor;
      }
    };
    ToolbarModule2.prototype.createFrameColor = function() {
      var parent = this.parent;
      var prevFrameSettings;
      var obj = { frameChangeEventArgs: null };
      var id = parent.element.id;
      parent.element.querySelector(".e-template.e-stroke").appendChild(parent.createElement("input", {
        id: id + "_frame_fill"
      }));
      var fillColor = new ColorPicker({
        modeSwitcher: false,
        value: parent.frameObj.color,
        showButtons: false,
        mode: "Palette",
        cssClass: "e-frame-fill-color",
        change: function(args) {
          prevFrameSettings = {
            type: parent.toPascalCase(parent.frameObj.type),
            color: parent.frameObj.color,
            gradientColor: parent.frameObj.gradientColor,
            size: parent.frameObj.size,
            inset: parent.frameObj.inset,
            offset: parent.frameObj.offset,
            borderRadius: parent.frameObj.radius,
            frameLineStyle: parent.toPascalCase(parent.frameObj.border),
            lineCount: parent.frameObj.amount
          };
          var temp = parent.frameObj.color;
          var object = { currObj: {} };
          parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
          parent.frameObj.color = args.currentValue.hex;
          parent.notify("draw", { prop: "triggerFrameChange", value: { prevFrameSettings, obj } });
          if (obj["frameChangeEventArgs"] && !obj["frameChangeEventArgs"].cancel) {
            parent.notify("undo-redo", { prop: "updateUndoRedoColl", onPropertyChange: false, value: {
              operation: "frame",
              previousObj: object["currObj"],
              previousObjColl: object["currObj"]["objColl"],
              previousPointColl: object["currObj"]["pointColl"],
              previousSelPointColl: object["currObj"]["selPointColl"],
              previousCropObj: extend({}, parent.cropObj, {}, true),
              previousText: null,
              currentText: null,
              previousFilter: null,
              isCircleCrop: null
            } });
            parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
            parent.notify("draw", { prop: "redrawDownScale" });
            if (args.currentValue.rgba === "") {
              fillDDB.element.children[0].classList.add("e-nocolor-item");
            } else {
              fillDDB.element.children[0].classList.remove("e-nocolor-item");
              fillDDB.element.children[0].style.backgroundColor = args.currentValue.rgba;
            }
            parent.curFrameObjEvent = {
              previousFrameSetting: obj["frameChangeEventArgs"].previousFrameSetting,
              currentFrameSetting: obj["frameChangeEventArgs"].currentFrameSetting
            };
            parent.isFrameBtnClick = true;
          } else {
            parent.frameObj.color = temp;
          }
          fillDDB.toggle();
        }
      }, "#" + id + "_frame_fill");
      var fillDDB = new DropDownButton({
        open: function(args) {
          if (Browser.isDevice) {
            var parentElem = args.element.parentElement;
            parentElem.style.top = fillDDB.element.getBoundingClientRect().top - parentElem.offsetHeight + "px";
            if ((undefined).innerWidth <= 520) {
              parentElem.style.left = parent.element.offsetLeft + "px";
            }
          }
        },
        target: ".e-frame-fill-color",
        iconCss: "e-dropdownbtn-preview",
        cssClass: "e-ie-ddb-popup"
      }, "#" + id + "_frameColorBtn");
      fillColor.inline = true;
      parent.element.querySelector(".e-stroke.e-template .e-dropdownbtn-preview").style.background = parent.frameObj.color;
    };
    ToolbarModule2.prototype.createFrameSize = function() {
      var _this = this;
      var parent = this.parent;
      var prevFrameSettings;
      var obj = { frameChangeEventArgs: null };
      var id = parent.element.id;
      var strokeWidthItems = [
        { id: "1", text: this.l10n.getConstant("20") },
        { id: "2", text: this.l10n.getConstant("40") },
        { id: "3", text: this.l10n.getConstant("60") },
        { id: "4", text: this.l10n.getConstant("80") },
        { id: "5", text: this.l10n.getConstant("100") }
      ];
      var strokeWidthBtn = (undefined).getElementById(id + "_frameSizeBtn");
      var spanElem = (undefined).createElement("span");
      spanElem.innerHTML = this.l10n.getConstant(parent.frameObj.size.toString());
      spanElem.className = "e-frame-stroke-width";
      strokeWidthBtn.appendChild(spanElem);
      var drpDownBtn = new DropDownButton({
        items: strokeWidthItems,
        open: function(args) {
          if (Browser.isDevice) {
            var parentElem = args.element.parentElement;
            parentElem.style.top = drpDownBtn.element.getBoundingClientRect().top - parentElem.offsetHeight + "px";
          }
          var activeBtn = drpDownBtn.element.childNodes[0].textContent;
          if (activeBtn !== "") {
            args.element.querySelector('[aria-label = "' + activeBtn + '"]').classList.add("e-selected-btn");
          }
        },
        select: function(args) {
          _this.triggerTbarClickEvent(args);
          prevFrameSettings = {
            type: parent.toPascalCase(parent.frameObj.type),
            color: parent.frameObj.color,
            gradientColor: parent.frameObj.gradientColor,
            size: parent.frameObj.size,
            inset: parent.frameObj.inset,
            offset: parent.frameObj.offset,
            borderRadius: parent.frameObj.radius,
            frameLineStyle: parent.toPascalCase(parent.frameObj.border),
            lineCount: parent.frameObj.amount
          };
          var temp = parent.frameObj.size;
          var object = { currObj: {} };
          parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
          parent.frameObj.size = parseInt(args.item.text, 10);
          parent.notify("draw", { prop: "triggerFrameChange", value: { prevFrameSettings, obj } });
          if (obj["frameChangeEventArgs"] && !obj["frameChangeEventArgs"].cancel) {
            parent.notify("undo-redo", { prop: "updateUndoRedoColl", onPropertyChange: false, value: {
              operation: "frame",
              previousObj: object["currObj"],
              previousObjColl: object["currObj"]["objColl"],
              previousPointColl: object["currObj"]["pointColl"],
              previousSelPointColl: object["currObj"]["selPointColl"],
              previousCropObj: extend({}, parent.cropObj, {}, true),
              previousText: null,
              currentText: null,
              previousFilter: null,
              isCircleCrop: null
            } });
            parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
            parent.notify("draw", { prop: "redrawDownScale" });
            drpDownBtn.content = args.item.text;
            parent.curFrameObjEvent = {
              previousFrameSetting: obj["frameChangeEventArgs"].previousFrameSetting,
              currentFrameSetting: obj["frameChangeEventArgs"].currentFrameSetting
            };
            parent.isFrameBtnClick = true;
          } else {
            parent.frameObj.size = temp;
          }
          if (Browser.isDevice) {
            if ((undefined).getElementById(id + "_bottomToolbar")) {
              var toolbar_16 = getComponent(id + "_bottomToolbar", "toolbar");
              toolbar_16.refreshOverflow();
            }
          } else {
            if ((undefined).getElementById(id + "_toolbar")) {
              var toolbar_17 = getComponent(id + "_toolbar", "toolbar");
              toolbar_17.refreshOverflow();
            }
          }
        }
      });
      drpDownBtn.appendTo("#" + id + "_frameSizeBtn");
    };
    ToolbarModule2.prototype.createFrameInset = function() {
      var _this = this;
      var parent = this.parent;
      var prevFrameSettings;
      var obj = { frameChangeEventArgs: null };
      var id = parent.element.id;
      var strokeWidthItems = [
        { id: "1", text: this.l10n.getConstant("20") },
        { id: "2", text: this.l10n.getConstant("40") },
        { id: "3", text: this.l10n.getConstant("60") },
        { id: "4", text: this.l10n.getConstant("80") },
        { id: "5", text: this.l10n.getConstant("100") }
      ];
      var strokeWidthBtn = (undefined).getElementById(id + "_frameInsetBtn");
      var spanElem = (undefined).createElement("span");
      spanElem.innerHTML = this.l10n.getConstant(parent.frameObj.inset.toString());
      spanElem.className = "e-frame-inset";
      strokeWidthBtn.appendChild(spanElem);
      var drpDownBtn = new DropDownButton({
        items: strokeWidthItems,
        open: function(args) {
          if (Browser.isDevice) {
            var parentElem = args.element.parentElement;
            parentElem.style.top = drpDownBtn.element.getBoundingClientRect().top - parentElem.offsetHeight + "px";
          }
          var activeBtn = drpDownBtn.element.childNodes[0].textContent;
          if (activeBtn !== "") {
            args.element.querySelector('[aria-label = "' + activeBtn + '"]').classList.add("e-selected-btn");
          }
        },
        select: function(args) {
          _this.triggerTbarClickEvent(args);
          prevFrameSettings = {
            type: parent.toPascalCase(parent.frameObj.type),
            color: parent.frameObj.color,
            gradientColor: parent.frameObj.gradientColor,
            size: parent.frameObj.size,
            inset: parent.frameObj.inset,
            offset: parent.frameObj.offset,
            borderRadius: parent.frameObj.radius,
            frameLineStyle: parent.toPascalCase(parent.frameObj.border),
            lineCount: parent.frameObj.amount
          };
          var temp = parent.frameObj.inset;
          var object = { currObj: {} };
          parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
          parent.frameObj.inset = parseInt(args.item.text, 10);
          parent.notify("draw", { prop: "triggerFrameChange", value: { prevFrameSettings, obj } });
          if (obj["frameChangeEventArgs"] && !obj["frameChangeEventArgs"].cancel) {
            parent.notify("undo-redo", { prop: "updateUndoRedoColl", onPropertyChange: false, value: {
              operation: "frame",
              previousObj: object["currObj"],
              previousObjColl: object["currObj"]["objColl"],
              previousPointColl: object["currObj"]["pointColl"],
              previousSelPointColl: object["currObj"]["selPointColl"],
              previousCropObj: extend({}, parent.cropObj, {}, true),
              previousText: null,
              currentText: null,
              previousFilter: null,
              isCircleCrop: null
            } });
            parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
            parent.notify("draw", { prop: "redrawDownScale" });
            drpDownBtn.content = args.item.text;
            parent.curFrameObjEvent = {
              previousFrameSetting: obj["frameChangeEventArgs"].previousFrameSetting,
              currentFrameSetting: obj["frameChangeEventArgs"].currentFrameSetting
            };
            parent.isFrameBtnClick = true;
          } else {
            parent.frameObj.inset = temp;
          }
          if (Browser.isDevice) {
            if ((undefined).getElementById(id + "_bottomToolbar")) {
              var toolbar_18 = getComponent(id + "_bottomToolbar", "toolbar");
              toolbar_18.refreshOverflow();
            }
          } else {
            if ((undefined).getElementById(id + "_toolbar")) {
              var toolbar_19 = getComponent(id + "_toolbar", "toolbar");
              toolbar_19.refreshOverflow();
            }
          }
        }
      });
      drpDownBtn.appendTo("#" + id + "_frameInsetBtn");
    };
    ToolbarModule2.prototype.createFrameOffset = function() {
      var _this = this;
      var parent = this.parent;
      var prevFrameSettings;
      var obj = { frameChangeEventArgs: null };
      var id = parent.element.id;
      var strokeWidthItems = [
        { id: "1", text: this.l10n.getConstant("20") },
        { id: "2", text: this.l10n.getConstant("40") },
        { id: "3", text: this.l10n.getConstant("60") },
        { id: "4", text: this.l10n.getConstant("80") },
        { id: "5", text: this.l10n.getConstant("100") }
      ];
      var strokeWidthBtn = (undefined).getElementById(id + "_frameOffsetBtn");
      var spanElem = (undefined).createElement("span");
      spanElem.innerHTML = this.l10n.getConstant(parent.frameObj.offset.toString());
      spanElem.className = "e-frame-offset";
      strokeWidthBtn.appendChild(spanElem);
      var drpDownBtn = new DropDownButton({
        items: strokeWidthItems,
        open: function(args) {
          if (Browser.isDevice) {
            var parentElem = args.element.parentElement;
            parentElem.style.top = drpDownBtn.element.getBoundingClientRect().top - parentElem.offsetHeight + "px";
          }
          var activeBtn = drpDownBtn.element.childNodes[0].textContent;
          if (activeBtn !== "") {
            args.element.querySelector('[aria-label = "' + activeBtn + '"]').classList.add("e-selected-btn");
          }
        },
        select: function(args) {
          _this.triggerTbarClickEvent(args);
          prevFrameSettings = {
            type: parent.toPascalCase(parent.frameObj.type),
            color: parent.frameObj.color,
            gradientColor: parent.frameObj.gradientColor,
            size: parent.frameObj.size,
            inset: parent.frameObj.inset,
            offset: parent.frameObj.offset,
            borderRadius: parent.frameObj.radius,
            lineCount: parent.frameObj.amount,
            frameLineStyle: parent.toPascalCase(parent.frameObj.border)
          };
          var temp = parent.frameObj.offset;
          var object = { currObj: {} };
          parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
          parent.frameObj.offset = parseInt(args.item.text, 10);
          parent.notify("draw", { prop: "triggerFrameChange", value: { prevFrameSettings, obj } });
          if (obj["frameChangeEventArgs"] && !obj["frameChangeEventArgs"].cancel) {
            parent.notify("undo-redo", { prop: "updateUndoRedoColl", onPropertyChange: false, value: {
              operation: "frame",
              previousObj: object["currObj"],
              previousObjColl: object["currObj"]["objColl"],
              previousPointColl: object["currObj"]["pointColl"],
              previousSelPointColl: object["currObj"]["selPointColl"],
              previousCropObj: extend({}, parent.cropObj, {}, true),
              previousText: null,
              currentText: null,
              previousFilter: null,
              isCircleCrop: null
            } });
            parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
            parent.notify("draw", { prop: "redrawDownScale" });
            drpDownBtn.content = args.item.text;
            parent.curFrameObjEvent = {
              previousFrameSetting: obj["frameChangeEventArgs"].previousFrameSetting,
              currentFrameSetting: obj["frameChangeEventArgs"].currentFrameSetting
            };
            parent.isFrameBtnClick = true;
          } else {
            parent.frameObj.offset = temp;
          }
          if (Browser.isDevice) {
            if ((undefined).getElementById(id + "_bottomToolbar")) {
              var toolbar_20 = getComponent(id + "_bottomToolbar", "toolbar");
              toolbar_20.refreshOverflow();
            }
          } else {
            if ((undefined).getElementById(id + "_toolbar")) {
              var toolbar_21 = getComponent(id + "_toolbar", "toolbar");
              toolbar_21.refreshOverflow();
            }
          }
        }
      });
      drpDownBtn.appendTo("#" + id + "_frameOffsetBtn");
    };
    ToolbarModule2.prototype.createFrameRadius = function() {
      var _this = this;
      var parent = this.parent;
      var prevFrameSettings;
      var obj = { frameChangeEventArgs: null };
      var id = parent.element.id;
      var strokeWidthItems = [
        { id: "1", text: this.l10n.getConstant("0") },
        { id: "2", text: this.l10n.getConstant("20") },
        { id: "3", text: this.l10n.getConstant("40") },
        { id: "4", text: this.l10n.getConstant("60") },
        { id: "5", text: this.l10n.getConstant("80") },
        { id: "6", text: this.l10n.getConstant("100") }
      ];
      var strokeWidthBtn = (undefined).getElementById(id + "_frameRadiusBtn");
      var spanElem = (undefined).createElement("span");
      spanElem.innerHTML = this.l10n.getConstant(parent.frameObj.radius.toString());
      spanElem.className = "e-frame-radius";
      strokeWidthBtn.appendChild(spanElem);
      var drpDownBtn = new DropDownButton({
        items: strokeWidthItems,
        open: function(args) {
          if (Browser.isDevice) {
            var parentElem = args.element.parentElement;
            parentElem.style.top = drpDownBtn.element.getBoundingClientRect().top - parentElem.offsetHeight + "px";
          }
          var activeBtn = drpDownBtn.element.childNodes[0].textContent;
          if (activeBtn !== "") {
            args.element.querySelector('[aria-label = "' + activeBtn + '"]').classList.add("e-selected-btn");
          }
        },
        select: function(args) {
          _this.triggerTbarClickEvent(args);
          prevFrameSettings = {
            type: parent.toPascalCase(parent.frameObj.type),
            color: parent.frameObj.color,
            gradientColor: parent.frameObj.gradientColor,
            size: parent.frameObj.size,
            inset: parent.frameObj.inset,
            offset: parent.frameObj.offset,
            borderRadius: parent.frameObj.radius,
            frameLineStyle: parent.toPascalCase(parent.frameObj.border),
            lineCount: parent.frameObj.amount
          };
          var temp = parent.frameObj.radius;
          var object = { currObj: {} };
          parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
          parent.frameObj.radius = parseInt(args.item.text, 10);
          parent.notify("draw", { prop: "triggerFrameChange", value: { prevFrameSettings, obj } });
          if (obj["frameChangeEventArgs"] && !obj["frameChangeEventArgs"].cancel) {
            parent.notify("undo-redo", { prop: "updateUndoRedoColl", onPropertyChange: false, value: {
              operation: "frame",
              previousObj: object["currObj"],
              previousObjColl: object["currObj"]["objColl"],
              previousPointColl: object["currObj"]["pointColl"],
              previousSelPointColl: object["currObj"]["selPointColl"],
              previousCropObj: extend({}, parent.cropObj, {}, true),
              previousText: null,
              currentText: null,
              previousFilter: null,
              isCircleCrop: null
            } });
            parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
            parent.notify("draw", { prop: "redrawDownScale" });
            drpDownBtn.content = args.item.text;
            parent.curFrameObjEvent = {
              previousFrameSetting: obj["frameChangeEventArgs"].previousFrameSetting,
              currentFrameSetting: obj["frameChangeEventArgs"].currentFrameSetting
            };
            parent.isFrameBtnClick = true;
          } else {
            parent.frameObj.radius = temp;
          }
          if (Browser.isDevice) {
            if ((undefined).getElementById(id + "_bottomToolbar")) {
              var toolbar_22 = getComponent(id + "_bottomToolbar", "toolbar");
              toolbar_22.refreshOverflow();
            }
          } else {
            if ((undefined).getElementById(id + "_toolbar")) {
              var toolbar_23 = getComponent(id + "_toolbar", "toolbar");
              toolbar_23.refreshOverflow();
            }
          }
        }
      });
      drpDownBtn.appendTo("#" + id + "_frameRadiusBtn");
    };
    ToolbarModule2.prototype.createFrameAmount = function() {
      var _this = this;
      var parent = this.parent;
      var prevFrameSettings;
      var obj = { frameChangeEventArgs: null };
      var id = parent.element.id;
      var strokeWidthItems = [
        { id: "1", text: this.l10n.getConstant("1") },
        { id: "2", text: this.l10n.getConstant("2") },
        { id: "3", text: this.l10n.getConstant("3") },
        { id: "4", text: this.l10n.getConstant("4") },
        { id: "5", text: this.l10n.getConstant("5") }
      ];
      var strokeWidthBtn = (undefined).getElementById(id + "_frameAmountBtn");
      var spanElem = (undefined).createElement("span");
      spanElem.innerHTML = this.l10n.getConstant(parent.frameObj.amount.toString());
      spanElem.className = "e-frame-amount";
      strokeWidthBtn.appendChild(spanElem);
      var drpDownBtn = new DropDownButton({
        items: strokeWidthItems,
        open: function(args) {
          if (Browser.isDevice) {
            var parentElem = args.element.parentElement;
            parentElem.style.top = drpDownBtn.element.getBoundingClientRect().top - parentElem.offsetHeight + "px";
          }
          var activeBtn = drpDownBtn.element.childNodes[0].textContent;
          if (activeBtn !== "") {
            args.element.querySelector('[aria-label = "' + activeBtn + '"]').classList.add("e-selected-btn");
          }
        },
        select: function(args) {
          _this.triggerTbarClickEvent(args);
          prevFrameSettings = {
            type: parent.toPascalCase(parent.frameObj.type),
            color: parent.frameObj.color,
            gradientColor: parent.frameObj.gradientColor,
            size: parent.frameObj.size,
            inset: parent.frameObj.inset,
            offset: parent.frameObj.offset,
            borderRadius: parent.frameObj.radius,
            lineCount: parent.frameObj.amount,
            frameLineStyle: parent.toPascalCase(parent.frameObj.border)
          };
          var temp = parent.frameObj.amount;
          var object = { currObj: {} };
          parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
          parent.frameObj.amount = parseInt(args.item.text, 10);
          parent.notify("draw", { prop: "triggerFrameChange", value: { prevFrameSettings, obj } });
          if (obj["frameChangeEventArgs"] && !obj["frameChangeEventArgs"].cancel) {
            parent.notify("undo-redo", { prop: "updateUndoRedoColl", onPropertyChange: false, value: {
              operation: "frame",
              previousObj: object["currObj"],
              previousObjColl: object["currObj"]["objColl"],
              previousPointColl: object["currObj"]["pointColl"],
              previousSelPointColl: object["currObj"]["selPointColl"],
              previousCropObj: extend({}, parent.cropObj, {}, true),
              previousText: null,
              currentText: null,
              previousFilter: null,
              isCircleCrop: null
            } });
            parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
            parent.notify("draw", { prop: "redrawDownScale" });
            drpDownBtn.content = args.item.text;
            parent.curFrameObjEvent = { previousFrameSetting: obj["frameChangeEventArgs"].previousFrameSetting, currentFrameSetting: obj["frameChangeEventArgs"].currentFrameSetting };
            parent.isFrameBtnClick = true;
          } else {
            parent.frameObj.amount = temp;
          }
          if (Browser.isDevice) {
            if ((undefined).getElementById(id + "_bottomToolbar")) {
              var toolbar_24 = getComponent(id + "_bottomToolbar", "toolbar");
              toolbar_24.refreshOverflow();
            }
          } else {
            if ((undefined).getElementById(id + "_toolbar")) {
              var toolbar_25 = getComponent(id + "_toolbar", "toolbar");
              toolbar_25.refreshOverflow();
            }
          }
        }
      });
      drpDownBtn.appendTo("#" + id + "_frameAmountBtn");
    };
    ToolbarModule2.prototype.createFrameBorder = function() {
      var _this = this;
      var parent = this.parent;
      var prevFrameSettings;
      var obj = { frameChangeEventArgs: null };
      var id = parent.element.id;
      var strokeWidthItems = [
        { id: "1", text: this.l10n.getConstant("Solid") },
        { id: "2", text: this.l10n.getConstant("Dashed") },
        { id: "3", text: this.l10n.getConstant("Dotted") }
      ];
      var strokeWidthBtn = (undefined).getElementById(id + "_frameBorderBtn");
      var spanElem = (undefined).createElement("span");
      spanElem.innerHTML = this.l10n.getConstant(parent.toPascalCase(parent.frameObj.border));
      spanElem.className = "e-frame-border";
      strokeWidthBtn.appendChild(spanElem);
      var drpDownBtn = new DropDownButton({
        items: strokeWidthItems,
        open: function(args) {
          if (Browser.isDevice) {
            var parentElem = args.element.parentElement;
            parentElem.style.top = drpDownBtn.element.getBoundingClientRect().top - parentElem.offsetHeight + "px";
          }
          var activeBtn = drpDownBtn.element.childNodes[0].textContent;
          if (activeBtn !== "") {
            args.element.querySelector('[aria-label = "' + activeBtn + '"]').classList.add("e-selected-btn");
          }
        },
        select: function(args) {
          _this.triggerTbarClickEvent(args);
          prevFrameSettings = {
            lineCount: parent.frameObj.amount,
            color: parent.frameObj.color,
            borderRadius: parent.frameObj.radius,
            gradientColor: parent.frameObj.gradientColor,
            size: parent.frameObj.size,
            inset: parent.frameObj.inset,
            offset: parent.frameObj.offset,
            frameLineStyle: parent.toPascalCase(parent.frameObj.border),
            type: parent.toPascalCase(parent.frameObj.type)
          };
          var temp = parent.frameObj.border;
          var object = { currObj: {} };
          parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
          parent.frameObj.border = args.item.text.toLowerCase();
          parent.notify("draw", { prop: "triggerFrameChange", value: { prevFrameSettings, obj } });
          if (obj["frameChangeEventArgs"] && !obj["frameChangeEventArgs"].cancel) {
            parent.notify("undo-redo", { prop: "updateUndoRedoColl", onPropertyChange: false, value: {
              operation: "frame",
              previousObj: object["currObj"],
              previousObjColl: object["currObj"]["objColl"],
              previousPointColl: object["currObj"]["pointColl"],
              previousSelPointColl: object["currObj"]["selPointColl"],
              previousCropObj: extend({}, parent.cropObj, {}, true),
              previousText: null,
              currentText: null,
              previousFilter: null,
              isCircleCrop: null
            } });
            parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
            parent.notify("draw", { prop: "redrawDownScale" });
            drpDownBtn.content = args.item.text;
            parent.curFrameObjEvent = { previousFrameSetting: obj["frameChangeEventArgs"].previousFrameSetting, currentFrameSetting: obj["frameChangeEventArgs"].currentFrameSetting };
            parent.isFrameBtnClick = true;
          } else {
            parent.frameObj.border = temp;
          }
          if (Browser.isDevice) {
            if ((undefined).getElementById(id + "_bottomToolbar")) {
              var toolbar_26 = getComponent(id + "_bottomToolbar", "toolbar");
              toolbar_26.refreshOverflow();
            }
          } else {
            if ((undefined).getElementById(id + "_toolbar")) {
              var toolbar_27 = getComponent(id + "_toolbar", "toolbar");
              toolbar_27.refreshOverflow();
            }
          }
        }
      });
      drpDownBtn.appendTo("#" + id + "_frameBorderBtn");
    };
    ToolbarModule2.prototype.initFilterToolbarItem = function() {
      var _this = this;
      var parent = this.parent;
      var id = parent.element.id;
      var mainItem = this.getFilterToolbarItem();
      var args = { toolbarType: "filter", toolbarItems: mainItem };
      parent.trigger("toolbarUpdating", args);
      mainItem = args.toolbarItems;
      if ((undefined).querySelector("#" + id + "_contextualToolbar").classList.contains("e-control")) {
        getComponent((undefined).getElementById(id + "_contextualToolbar"), "toolbar").destroy();
      }
      var toolbar = new Toolbar({
        width: "100%",
        items: mainItem,
        clicked: this.contextualToolbarClicked.bind(this),
        created: function() {
          _this.updatePrivateVariables();
          _this.createCanvasFilter();
          if (parent.currentFilter === "") {
            parent.currentFilter = id + "_default";
          }
          var hdrWrapper = (undefined).querySelector("#" + id + "_headWrapper");
          if (hdrWrapper) {
            hdrWrapper.style.display = "none";
          }
          var filterElem = (undefined).getElementById(parent.currentFilter + "Canvas");
          if (filterElem) {
            filterElem.parentElement.parentElement.classList.add("e-selected");
          }
          _this.enableDisableTbrBtn();
          toolbar.refreshOverflow();
        }
      });
      toolbar.appendTo("#" + id + "_contextualToolbar");
    };
    ToolbarModule2.prototype.drawDashedLine = function(ctx) {
      ctx.beginPath();
      ctx.setLineDash([5]);
      ctx.rect(10, 10, 280, 130);
      ctx.stroke();
      ctx.closePath();
    };
    ToolbarModule2.prototype.createCanvasFilter = function() {
      var parent = this.parent;
      showSpinner(parent.element);
      parent.element.style.opacity = "0.5";
      var imageData = parent.getCurrentCanvasData();
      this.inMemoryCanvas.width = imageData.width;
      this.inMemoryCanvas.height = imageData.height;
      this.inMemoryContext.putImageData(imageData, 0, 0);
      this.updateFilterCanvas("_defaultCanvas", "default");
      this.updateFilterCanvas("_chromeCanvas", "chrome");
      this.updateFilterCanvas("_coldCanvas", "cold");
      this.updateFilterCanvas("_warmCanvas", "warm");
      this.updateFilterCanvas("_grayscaleCanvas", "grayscale");
      this.updateFilterCanvas("_sepiaCanvas", "sepia");
      this.updateFilterCanvas("_invertCanvas", "invert");
      hideSpinner(parent.element);
      parent.element.style.opacity = "1";
      parent.initialAdjustmentValue = this.lowerContext.filter;
    };
    ToolbarModule2.prototype.updateFilterCanvas = function(selector, type) {
      var parent = this.parent;
      var filter = parent.element.querySelector("#" + parent.element.id + selector);
      if (filter) {
        var ctx = filter.getContext("2d");
        ctx = filter.getContext("2d");
        filter.style.width = "100px";
        filter.style.height = "100px";
        parent.notify("filter", { prop: "updateAdj", value: { type, value: null, isPreview: true, ctx } });
        ctx.drawImage(this.inMemoryCanvas, 0, 0, 300, 150);
        if (parent.isSafari) {
          parent.notify("filter", { prop: "apply-filter", onPropertyChange: false, value: { context: ctx } });
        }
      }
    };
    ToolbarModule2.prototype.getQuickAccessToolbarItem = function(isPenEdit) {
      var parent = this.parent;
      var id = parent.element.id;
      var args = { cancel: false, toolbarItems: [] };
      var toolbarItems = [];
      if (isNullOrUndefined(isPenEdit)) {
        if (parent.activeObj.shape === "image") {
          toolbarItems.push("Flip");
        }
        if (parent.activeObj.shape !== "redact") {
          toolbarItems.push("BringToFront");
        }
        toolbarItems.push("Clone");
        toolbarItems.push("Delete");
        if (parent.activeObj.shape === "text") {
          toolbarItems.push("EditText");
        }
        args.shape = parent.toPascalCase(parent.activeObj.shape);
      } else if (isPenEdit) {
        toolbarItems.push("BringToFront");
        toolbarItems.push("Delete");
        args.shape = "Freehand draw";
      }
      args.toolbarItems = extend([], toolbarItems, null, true);
      parent.trigger("quickAccessToolbarOpen", args);
      var orgToolbarItems = [];
      if (args.cancel) {
        orgToolbarItems = [];
      } else {
        for (var i = 0; i < args.toolbarItems.length; i++) {
          switch (args.toolbarItems[i]) {
            case "BringToFront":
              orgToolbarItems.push({
                id: id + "_bringToFront",
                prefixIcon: "e-icons e-bring-to-front",
                tooltipText: this.l10n.getConstant("BringToFront"),
                align: "Left"
              });
              break;
            case "Clone":
              orgToolbarItems.push({
                id: id + "_duplicate",
                prefixIcon: "e-icons e-order",
                cssClass: "top-icon e-order",
                tooltipText: this.l10n.getConstant("Duplicate"),
                align: "Left"
              });
              break;
            case "Delete":
              orgToolbarItems.push({
                id: id + "_remove",
                prefixIcon: "e-icons e-trash",
                cssClass: "top-icon e-trash",
                tooltipText: this.l10n.getConstant("Remove"),
                align: "Left"
              });
              break;
            case "EditText":
              orgToolbarItems.push({
                id: id + "_editText",
                prefixIcon: "e-icons e-annotation-edit",
                cssClass: "top-icon e-annotation-edit",
                tooltipText: this.l10n.getConstant("EditText"),
                align: "Left"
              });
              break;
            case "Flip":
              orgToolbarItems.push({
                id: id + "_hFlip",
                prefixIcon: "e-icons e-horizontal-flip",
                tooltipText: this.l10n.getConstant("HorizontalFlip"),
                align: "Left"
              });
              orgToolbarItems.push({
                id: id + "_vFlip",
                prefixIcon: "e-icons e-vertical-flip",
                tooltipText: this.l10n.getConstant("VerticalFlip"),
                align: "Left"
              });
              break;
            default:
              orgToolbarItems.push(args.toolbarItems[i]);
              break;
          }
        }
      }
      return orgToolbarItems;
    };
    ToolbarModule2.prototype.renderQAT = function(isPenEdit) {
      var parent = this.parent;
      var id = parent.element.id;
      if (parent.activeObj && parent.showQuickAccessToolbar) {
        var qtArea = (undefined).getElementById(id + "_quickAccessToolbarArea");
        if (qtArea) {
          this.destroyQuickAccessToolbar();
          qtArea.style.display = "block";
        }
        var items = this.getQuickAccessToolbarItem(isPenEdit);
        if (items.length === 0) {
          return;
        }
        if (isNullOrUndefined(parent.quickAccessToolbarTemplate)) {
          var toolbarObj = new Toolbar({
            items,
            clicked: this.quickAccessToolbarClicked.bind(this)
          });
          toolbarObj.appendTo("#" + id + "_quickAccessToolbar");
        }
        var height = this.toolbarHeight && this.toolbarHeight !== 0 ? this.toolbarHeight : qtArea.clientHeight;
        var wrapperElement = parent.element.querySelector("#" + id + "_headWrapper");
        if (isNullOrUndefined(isPenEdit) && (parent.activeObj.activePoint.width !== 0 || parent.activeObj.activePoint.height !== 0 || parent.activeObj.shape && parent.activeObj.shape === "path" && parent.activeObj.pointColl.length > 0)) {
          var orderObj = { order: null };
          parent.notify("shape", { prop: "getHighestOrder", onPropertyChange: false, value: { obj: orderObj } });
          if (parent.activeObj.order > orderObj["order"] && (undefined).getElementById(parent.element.id + "_bringToFront")) {
            (undefined).getElementById(parent.element.id + "_bringToFront").classList.add("e-overlay");
          } else {
            if ((undefined).getElementById(parent.element.id + "_bringToFront")) {
              (undefined).getElementById(parent.element.id + "_bringToFront").classList.remove("e-overlay");
            }
          }
          qtArea.style.width = "auto";
          parent.activeObj.activePoint.width = Math.abs(parent.activeObj.activePoint.width);
          parent.activeObj.activePoint.height = Math.abs(parent.activeObj.activePoint.height);
          var x = parent.activeObj.activePoint.startX < parent.activeObj.activePoint.endX ? parent.activeObj.activePoint.startX : parent.activeObj.activePoint.endX;
          var y = parent.activeObj.activePoint.startY < parent.activeObj.activePoint.endY ? parent.activeObj.activePoint.startY : parent.activeObj.activePoint.endY;
          var width = parent.activeObj.activePoint.width;
          if (parent.activeObj.rotatedAngle !== 0 && parent.activeObj.shape !== "arrow") {
            var object = { activePoint: null };
            parent.notify("shape", {
              prop: "getSquarePointForRotatedShape",
              onPropertyChange: false,
              value: { obj: parent.activeObj, object }
            });
            var point = object["activePoint"];
            x = point.startX;
            y = point.startY;
            width = point.width;
          } else if (parent.activeObj.shape === "path") {
            var path = parent.getSquarePointForPath(parent.activeObj);
            x = path.startX;
            y = path.startY;
            width = path.width;
          }
          qtArea.style.left = x + width / 2 - items.length * 25 + "px";
          if (parseFloat(qtArea.style.left) + qtArea.clientWidth / 2 !== x + width / 2) {
            var diff = x + width / 2 - (parseFloat(qtArea.style.left) + qtArea.clientWidth / 2);
            qtArea.style.left = parseFloat(qtArea.style.left) + diff + "px";
          }
          if (wrapperElement) {
            height = wrapperElement.offsetHeight + height;
          }
          if (y - (height + height / 1.5) < parent.img.destTop) {
            qtArea.style.top = parent.img.destTop + "px";
            if (wrapperElement) {
              qtArea.style.top = (parent.img.destTop < 0 ? 0 : parent.img.destTop) + wrapperElement.offsetHeight + "px";
            }
          } else {
            height = this.toolbarHeight;
            qtArea.style.top = y - (height + height / 1.5) + "px";
          }
        } else if (isPenEdit) {
          var indexObj = { freehandSelectedIndex: -1 };
          parent.notify("freehand-draw", { prop: "getFreehandSelectedIndex", onPropertyChange: false, value: { obj: indexObj } });
          var orderObj = { order: null };
          parent.notify("shape", { prop: "getHighestOrder", onPropertyChange: false, value: { obj: orderObj } });
          if (parent.getObjFromId(parent.pointColl[indexObj["freehandSelectedIndex"]].id).order >= orderObj["order"] && (undefined).getElementById(parent.element.id + "_bringToFront")) {
            (undefined).getElementById(parent.element.id + "_bringToFront").classList.add("e-overlay");
          } else {
            if ((undefined).getElementById(parent.element.id + "_bringToFront")) {
              (undefined).getElementById(parent.element.id + "_bringToFront").classList.remove("e-overlay");
            }
          }
          var obj = { activePoint: null };
          parent.notify("freehand-draw", {
            prop: "getSqPtFD",
            value: { idx: indexObj["freehandSelectedIndex"], obj }
          });
          var point = obj["activePoint"];
          qtArea.style.width = "auto";
          qtArea.style.left = point.startX + point.width / 2 - items.length * 24 + "px";
          if (point.startY - (height + height / 1.5) < parent.img.destTop) {
            qtArea.style.top = parent.img.destTop + "px";
          } else {
            qtArea.style.top = point.startY - (height + height / 1.5) + "px";
          }
        } else {
          qtArea.style.display = "none";
        }
        if (parseFloat(qtArea.style.top) < 0) {
          qtArea.style.top = "0px";
        }
      }
    };
    ToolbarModule2.prototype.refreshDropDownBtn = function(isDisabled) {
      if (isNullOrUndefined(isDisabled)) {
        return;
      }
      var parent = this.parent;
      var id = parent.element.id;
      var annotation = (undefined).querySelector("#" + id + "_annotationBtn");
      if (annotation) {
        if (isDisabled) {
          annotation.classList.add("e-disabled");
          annotation.parentElement.classList.add("e-overlay");
        } else {
          annotation.classList.remove("e-disabled");
          annotation.parentElement.classList.remove("e-overlay");
        }
        getComponent(annotation, "dropdown-btn").disabled = isDisabled;
      }
      var transform = (undefined).querySelector("#" + id + "_transformBtn");
      if (transform) {
        if (isDisabled) {
          transform.classList.add("e-disabled");
          transform.parentElement.classList.add("e-overlay");
        } else {
          transform.classList.remove("e-disabled");
          transform.parentElement.classList.remove("e-overlay");
        }
        getComponent(transform, "dropdown-btn").disabled = isDisabled;
      }
      var adjustment = (undefined).querySelector("#" + id + "_adjustment");
      if (adjustment) {
        if (isDisabled) {
          adjustment.classList.add("e-disabled");
          adjustment.parentElement.classList.add("e-overlay");
        } else {
          adjustment.classList.remove("e-disabled");
          adjustment.parentElement.classList.remove("e-overlay");
        }
        getComponent(adjustment, "btn").disabled = isDisabled;
      }
      var filter = (undefined).querySelector("#" + id + "_filter");
      if (filter) {
        if (isDisabled) {
          filter.classList.add("e-disabled");
          filter.parentElement.classList.add("e-overlay");
        } else {
          filter.classList.remove("e-disabled");
          filter.parentElement.classList.remove("e-overlay");
        }
        getComponent(filter, "btn").disabled = isDisabled;
      }
    };
    ToolbarModule2.prototype.cropSelect = function(args) {
      var parent = this.parent;
      parent.isCropTab = true;
      if (isNullOrUndefined(parent.transform.cropZoomFactor)) {
        parent.transform.cropZoomFactor = parent.transform.zoomFactor;
        parent.notify("draw", { prop: "setTempZoomFactor", onPropertyChange: false, value: { tempZoomFactor: parent.transform.zoomFactor } });
      }
      parent.transform.zoomFactor = parent.transform.cropZoomFactor;
      var text = args.item.id;
      this.currentToolbar = "crop";
      parent.currSelectionPoint = null;
      parent.notify("draw", { prop: "setIsCropSelect", value: { bool: true } });
      var obj = { prevObj: null };
      parent.notify("crop", { prop: "getPreviousCropCurrentObj", value: { obj } });
      parent.notify("draw", {
        prop: "select",
        onPropertyChange: false,
        value: { type: text, startX: null, startY: null, width: null, height: null }
      });
      parent.notify("crop", { prop: "setPreviousCropCurrentObj", value: { obj: obj["prevObj"] } });
      this.enableDisableTbrBtn();
      parent.notify("transform", { prop: "disableZoomOutBtn", value: { isZoomOut: true } });
    };
    ToolbarModule2.prototype.quickAccessToolbarClicked = function(args, isContextualToolbar) {
      var parent = this.parent;
      var id = parent.element.id;
      if (args.item) {
        var isPreventUndoRedo = null;
        var obj = { prevActObj: null };
        var object = { tempObj: null };
        parent.notify("draw", { prop: "getPrevActObj", onPropertyChange: false, value: { obj } });
        parent.notify("selection", { prop: "getTempActObj", onPropertyChange: false, value: { obj: object } });
        object["tempObj"]["activePoint"]["height"] = Math.abs(object["tempObj"]["activePoint"]["height"]);
        var pathObject = { isNewPath: null };
        var ctx = undefined;
        parent.notify("draw", { prop: "getNewPath", value: { obj: pathObject } });
        var type = args.item.id.replace(id + "_", "").toLowerCase();
        var left = undefined;
        var right = undefined;
        var indexObj = { freehandSelectedIndex: null };
        var shapeId = undefined;
        var isDisabled = undefined;
        var orderObj = { order: null };
        switch (type) {
          case "duplicate":
            if (!parent.element.querySelector("#" + id + "_duplicate").classList.contains("e-overlay")) {
              this.refreshSlider();
              if (!pathObject["isNewPath"] && JSON.stringify(object["tempObj"]) === JSON.stringify(parent.activeObj)) {
                isPreventUndoRedo = true;
              }
              this.duplicateShape(isPreventUndoRedo);
            }
            break;
          case "remove":
            if (!parent.element.querySelector("#" + id + "_remove").classList.contains("e-overlay")) {
              parent.noPushUndo = false;
              this.refreshSlider();
              parent.notify("selection", { prop: "deleteItem", onPropertyChange: false });
            }
            break;
          case "edittext":
            if (!parent.element.querySelector("#" + id + "_editText").classList.contains("e-overlay")) {
              this.editText();
            }
            break;
          case "rotleft":
          case "rotright":
            left = parent.element.querySelector("#" + id + "_rotLeft");
            right = parent.element.querySelector("#" + id + "_rotRight");
            if (left && !left.classList.contains("e-disabled") || right && !right.classList.contains("e-disabled")) {
              parent.rotateImage(args.item.id.replace(id + "_", "").toLowerCase());
            }
            parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
            break;
          case "hflip":
            if (!parent.element.querySelector("#" + id + "_hFlip").classList.contains("e-disabled")) {
              ctx = parent.activeObj.imageCanvas.getContext("2d");
              parent.horizontalFlip(ctx);
            }
            parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
            break;
          case "vflip":
            if (!parent.element.querySelector("#" + id + "_vFlip").classList.contains("e-disabled")) {
              ctx = parent.activeObj.imageCanvas.getContext("2d");
              parent.verticalFlip(ctx);
            }
            parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
            break;
          case "bringtofront":
            if (!parent.element.querySelector("#" + id + "_bringToFront").classList.contains("e-overlay")) {
              parent.notify("freehand-draw", { prop: "getFreehandSelectedIndex", onPropertyChange: false, value: { obj: indexObj } });
              shapeId = indexObj["freehandSelectedIndex"] !== null ? parent.pointColl[indexObj["freehandSelectedIndex"]].id : parent.activeObj.currIndex;
              parent.updateShapeOrder(shapeId, type);
              isDisabled = false;
              parent.notify("shape", { prop: "getHighestOrder", onPropertyChange: false, value: { obj: orderObj } });
              if (shapeId.indexOf("pen") > -1) {
                parent.notify("shape", { prop: "updateShapeColl", onPropertyChange: false });
                var order = parent.getObjFromId(shapeId).order;
                isDisabled = order >= orderObj["order"] ? true : false;
              } else {
                var order = parent.getObjFromId(shapeId).order;
                isDisabled = order > orderObj["order"] ? true : false;
              }
              if (isDisabled) {
                (undefined).getElementById(parent.element.id + "_bringToFront").classList.add("e-overlay");
              } else {
                (undefined).getElementById(parent.element.id + "_bringToFront").classList.remove("e-overlay");
              }
              parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
            }
            break;
        }
        if (type === "duplicate" || type === "remove") {
          parent.notify("draw", { prop: "redrawDownScale" });
        }
      }
      if (isNullOrUndefined(isContextualToolbar)) {
        parent.trigger("quickAccessToolbarItemClick", args);
      }
    };
    ToolbarModule2.prototype.editText = function() {
      var parent = this.parent;
      var points = { x: parent.activeObj.activePoint.startX, y: parent.activeObj.activePoint.startY };
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      parent.notify("selection", {
        prop: "setTempActObj",
        onPropertyChange: false,
        value: { obj: extend({}, parent.activeObj, {}, true) }
      });
      parent.notify("selection", {
        prop: "setInitialTextEdit",
        onPropertyChange: false,
        value: { bool: true }
      });
      parent.notify("draw", {
        prop: "setPrevActObj",
        onPropertyChange: false,
        value: { prevActObj: extend({}, parent.activeObj, {}, true) }
      });
      if (parent.activeObj.rotatedAngle !== 0) {
        var object = { x: points.x, y: points.y };
        parent.notify("shape", {
          prop: "getTextBoxPosition",
          onPropertyChange: false,
          value: { obj: parent.activeObj, object }
        });
        points.x = object["x"];
        points.y = object["y"];
        var object1 = { x: points.x, y: points.y };
        parent.notify("shape", {
          prop: "setFlipState",
          onPropertyChange: false,
          value: { x: points.x, y: points.y, obj: parent.activeObj, object: object1 }
        });
        points.x = object1["x"];
        points.y = object1["y"];
      }
      var tempActiveObj = extend({}, parent.activeObj, {}, true);
      parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      this.lowerContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
      parent.notify("draw", { prop: "redrawImgWithObj", onPropertyChange: false });
      parent.notify("draw", { prop: "redrawDownScale" });
      parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.lowerContext } });
      parent.notify("draw", { prop: "clearOuterCanvas", onPropertyChange: false, value: { context: this.upperContext } });
      parent.activeObj = tempActiveObj;
      parent.notify("shape", {
        prop: "renderTextArea",
        onPropertyChange: false,
        value: { x: points.x, y: points.y, actObj: parent.activeObj }
      });
      if (isNullOrUndefined(parent.activeObj.currIndex)) {
        parent.notify("draw", { prop: "setShapeTextInsert", onPropertyChange: false, value: { bool: true } });
      }
      if ((undefined).getElementById(parent.element.id + "_quickAccessToolbarArea")) {
        (undefined).getElementById(parent.element.id + "_quickAccessToolbarArea").style.display = "none";
      }
    };
    ToolbarModule2.prototype.duplicateShape = function(isPreventUndoRedo, isPublicMethod) {
      var parent = this.parent;
      var tempObj = {
        activePoint: { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 },
        flipObjColl: [],
        triangle: [],
        triangleRatio: []
      };
      parent.notify("selection", {
        prop: "setTempActObj",
        onPropertyChange: false,
        value: { obj: tempObj }
      });
      var obj = { prevActObj: null };
      parent.notify("draw", { prop: "getPrevActObj", onPropertyChange: false, value: { obj } });
      var pathObject = { isNewPath: null };
      parent.notify("draw", { prop: "getNewPath", value: { obj: pathObject } });
      var objColl;
      var duplicateObj = extend({}, parent.activeObj, {}, true);
      var orderObj = { order: null };
      parent.notify("shape", { prop: "getHighestOrder", onPropertyChange: false, value: { obj: orderObj } });
      if (duplicateObj.order) {
        parent.notify("shape", { prop: "updateShapeColl", onPropertyChange: false });
        duplicateObj.order = orderObj["order"] > duplicateObj.order ? orderObj["order"] + 1 : duplicateObj.order + 1;
      } else {
        parent.noPushUndo = true;
        parent.okBtn();
        parent.noPushUndo = false;
        parent.selectShape(duplicateObj.currIndex);
        duplicateObj.order = orderObj["order"] > duplicateObj.order ? orderObj["order"] + 1 : duplicateObj.order + 1;
      }
      if (duplicateObj.shape === "image") {
        objColl = extend([], parent.objColl, [], true);
        parent.notify("undo-redo", { prop: "updateUrObj", onPropertyChange: false, value: { objColl } });
      }
      if (isNullOrUndefined(parent.activeObj.currIndex)) {
        parent.notify("shape", { prop: "applyActObj", onPropertyChange: false, value: { isMouseDown: isPreventUndoRedo } });
      } else if (obj["prevActObj"] || isPublicMethod) {
        parent.activeObj.currIndex = null;
        duplicateObj.currIndex = null;
        parent.notify("shape", { prop: "applyActObj", onPropertyChange: false, value: { isMouseDown: isPreventUndoRedo } });
      } else {
        parent.notify("shape", { prop: "applyActObj", onPropertyChange: false, value: { isMouseDown: true } });
      }
      var noPushUndo = parent.noPushUndo;
      parent.noPushUndo = false;
      parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
      parent.noPushUndo = noPushUndo;
      objColl = extend([], parent.objColl, [], true);
      duplicateObj.activePoint.startX += 10;
      duplicateObj.activePoint.startY -= 10;
      duplicateObj.activePoint.endX += 10;
      duplicateObj.activePoint.endY -= 10;
      if (duplicateObj.shape === "path") {
        for (var i = 0; i < duplicateObj.pointColl.length; i++) {
          duplicateObj.pointColl[i].x += 10;
          duplicateObj.pointColl[i].y -= 10;
        }
      } else if (duplicateObj.shape === "image") {
        duplicateObj.imageCanvas = parent.createElement("canvas");
      }
      var shapeIDObj = { id: "shape_" + (parent.objColl.length + 1) };
      parent.notify("shape", { prop: "getNewShapeId", onPropertyChange: false, value: { obj: shapeIDObj } });
      duplicateObj.currIndex = shapeIDObj["id"];
      parent.activeObj = extend({}, duplicateObj, {}, true);
      if (parent.activeObj.shape === "image") {
        var activePoint = extend({}, duplicateObj.activePoint, {}, true);
        var dimObj = { width: 0, height: 0 };
        parent.notify("transform", {
          prop: "calcMaxDimension",
          onPropertyChange: false,
          value: {
            width: parent.activeObj.imageElement.width,
            height: parent.activeObj.imageElement.height,
            obj: dimObj,
            isImgShape: null
          }
        });
        parent.activeObj.activePoint.width = dimObj["width"];
        parent.activeObj.activePoint.height = dimObj["height"];
        if (parent.activeObj.isHorImageFlip && parent.activeObj.isVerImageFlip) {
          parent.activeObj.isHorImageFlip = parent.activeObj.isVerImageFlip = false;
          parent.notify("draw", {
            prop: "downScaleImgCanvas",
            onPropertyChange: false,
            value: { ctx: duplicateObj.imageCanvas.getContext("2d"), isImgAnnotation: true, isHFlip: true, isVFlip: true }
          });
          parent.activeObj.isHorImageFlip = parent.activeObj.isVerImageFlip = true;
        } else if (parent.activeObj.isHorImageFlip) {
          parent.activeObj.isHorImageFlip = false;
          parent.notify("draw", {
            prop: "downScaleImgCanvas",
            onPropertyChange: false,
            value: { ctx: duplicateObj.imageCanvas.getContext("2d"), isImgAnnotation: true, isHFlip: true, isVFlip: null }
          });
          parent.activeObj.isHorImageFlip = true;
        } else if (parent.activeObj.isVerImageFlip) {
          parent.activeObj.isVerImageFlip = false;
          parent.notify("draw", {
            prop: "downScaleImgCanvas",
            onPropertyChange: false,
            value: { ctx: duplicateObj.imageCanvas.getContext("2d"), isImgAnnotation: true, isHFlip: null, isVFlip: true }
          });
          parent.activeObj.isVerImageFlip = true;
        } else {
          parent.notify("draw", {
            prop: "downScaleImgCanvas",
            onPropertyChange: false,
            value: { ctx: duplicateObj.imageCanvas.getContext("2d"), isImgAnnotation: true, isHFlip: null, isVFlip: null }
          });
        }
        parent.activeObj.activePoint = activePoint;
      }
      if (parent.activeObj.shape === "line" || parent.activeObj.shape === "arrow") {
        parent.notify("shape", {
          prop: "setPointCollForLineArrow",
          onPropertyChange: false,
          value: { obj: parent.activeObj }
        });
      }
      parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: {
        canvas: "duplicate",
        obj: parent.activeObj,
        isCropRatio: null,
        points: null,
        isPreventDrag: true
      } });
      parent.notify("undo-redo", { prop: "updateUrObj", onPropertyChange: false, value: { objColl } });
      parent.notify("shape", { prop: "applyActObj", onPropertyChange: false, value: { isMouseDown: true } });
      parent.noPushUndo = false;
      parent.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
      parent.noPushUndo = true;
      parent.notify("selection", {
        prop: "redrawShape",
        onPropertyChange: false,
        value: { obj: parent.objColl[parent.objColl.length - 1] }
      });
      var id = parent.element.id;
      var toolbarId = Browser.isDevice ? "#" + id + "_bottomToolbar #" + id : "#" + id;
      var object = { freehandDrawSelectedId: null };
      parent.notify("freehand-draw", { prop: "getFreehandDrawSelectedId", onPropertyChange: false, value: { obj: object } });
      this.enableDisableCloneBtn(toolbarId, object);
      this.renderQAT();
      if (parent.activeObj.shape && parent.activeObj.shape === "redact") {
        this.redactSlider(parent.activeObj.redactType);
      }
    };
    ToolbarModule2.prototype.defToolbarClicked = function(args) {
      var parent = this.parent;
      var id = parent.element.id;
      var isContextualToolbar = false;
      var isFilterFinetune = false;
      if (!this.isFrameToolbar && parent.element.querySelector(".e-contextual-toolbar-wrapper")) {
        if (!parent.element.querySelector(".e-contextual-toolbar-wrapper").classList.contains("e-hide")) {
          isContextualToolbar = isFilterFinetune = true;
        }
        var straightenObj = { bool: parent.isStraightening };
        if (!Browser.isDevice || Browser.isDevice && !straightenObj["bool"]) {
          parent.element.querySelector(".e-contextual-toolbar-wrapper").classList.add("e-hide");
        }
      }
      if (args.item) {
        var type = args.item.id.replace(id + "_", "").toLowerCase();
        if (type === "duplicate" || type === "remove" || type === "edittext" || type === "hflip" || type === "vflip" || type === "rotleft" || type === "rotright") {
          this.quickAccessToolbarClicked(args, true);
          parent.trigger("toolbarItemClicked", args);
        } else {
          var isDisabledFilter = false;
          var isDisabledAdjustment = false;
          var adjustment = (undefined).querySelector("#" + id + "_adjustment");
          if (adjustment && adjustment.classList.contains("e-disabled")) {
            isDisabledAdjustment = true;
          }
          var filter = (undefined).querySelector("#" + id + "_filter");
          if (filter && filter.classList.contains("e-disabled")) {
            isDisabledFilter = true;
          }
          this.enableDisableTbrBtn();
          this.performDefTbrClick(type, isContextualToolbar, isDisabledAdjustment, isDisabledFilter, isFilterFinetune);
          parent.trigger("toolbarItemClicked", args);
          if (parent.isStraightening) {
            parent.notify("transform", { prop: "disableZoomOutBtn", value: { isZoomOut: true } });
          }
          var validTypes = [
            "undo",
            "redo",
            "cancel",
            "aspectratio",
            "nonaspectratio",
            "save",
            "duplicate",
            "filter",
            "frame",
            "none",
            "mat",
            "bevel",
            "line",
            "inset",
            "hook",
            "resize",
            "remove"
          ];
          if (validTypes.indexOf(type) !== -1) {
            parent.notify("draw", { prop: "redrawDownScale" });
          }
        }
      }
    };
    ToolbarModule2.prototype.performDefTbrClick = function(type, isContextualToolbar, isDisabledAdjustment, isDisabledFilter, isFilterFinetune) {
      var parent = this.parent;
      var id = parent.element.id;
      var zoomIn = parent.element.querySelector("#" + id + "_zoomIn");
      var aspectRatioHeight = parent.element.querySelector("#" + id + "_resizeHeight");
      var aspectRatioWidth = parent.element.querySelector("#" + id + "_resizeWidth");
      var isCropSelection = false;
      var panBtn;
      var splitWords;
      var actionType;
      var actionArgs;
      var isRedactClick = false;
      var zoomLevel = 0;
      var actObj;
      var isRedact = false;
      if (parent.activeObj.shape !== undefined) {
        splitWords = parent.activeObj.shape.split("-");
      }
      if (splitWords === undefined && parent.currObjType.isCustomCrop) {
        isCropSelection = true;
      } else if (splitWords !== undefined && splitWords[0] === "crop") {
        isCropSelection = true;
      }
      if (!parent.disabled) {
        switch (type) {
          case "pan":
            parent.currObjType.isCustomCrop = parent.currObjType.isFiltered = false;
            parent.currObjType.isRedact = false;
            if (parent.currObjType.isUndoAction) {
              parent.notify("undo-redo", { prop: "refreshUrc", value: { bool: null } });
            }
            if (isCropSelection) {
              parent.currObjType.isCustomCrop = false;
              parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
              this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
              this.refreshToolbar("main");
            }
            if (parent.togglePan) {
              this.cancelPan();
              parent.notify("transform", { prop: "setDisablePan", onPropertyChange: false, value: { bool: true } });
              if (this.currentToolbar === "pen") {
                parent.freeHandDraw(true);
              }
            } else {
              panBtn = parent.element.querySelector(".e-img-pan .e-btn");
              if (panBtn) {
                panBtn.classList.add("e-selected-btn");
              }
              parent.pan(true);
              parent.notify("transform", { prop: "setDisablePan", onPropertyChange: false, value: { bool: false } });
            }
            if (zoomIn && parent.zoomSettings.zoomFactor >= parent.zoomSettings.maxZoomFactor) {
              zoomIn.classList.add("e-disabled");
              zoomIn.parentElement.classList.add("e-overlay");
            } else if (zoomIn) {
              zoomIn.classList.remove("e-disabled");
              zoomIn.parentElement.classList.remove("e-overlay");
            }
            this.refreshToolbar("main");
            break;
          case "cancel":
            if (parent.currObjType.isRedact) {
              parent.currObjType.isRedact = false;
            }
            if (this.isFrameToolbar && parent.element.querySelector(".e-contextual-toolbar-wrapper") && !parent.element.querySelector(".e-contextual-toolbar-wrapper").classList.contains("e-hide")) {
              parent.element.querySelector(".e-contextual-toolbar-wrapper").classList.add("e-hide");
            }
            parent.notify("draw", { prop: "performCancel", value: { isContextualToolbar, isFinalCancel: true } });
            break;
          case "ok":
            if (Browser.isDevice && this.isFrameToolbar && parent.element.querySelector(".e-contextual-toolbar-wrapper") && !parent.element.querySelector(".e-contextual-toolbar-wrapper").classList.contains("e-hide")) {
              parent.element.querySelector(".e-contextual-toolbar-wrapper").classList.add("e-hide");
            }
            parent.okBtn(null, true);
            parent.drawingShape = null;
            this.refreshDropDownBtn(false);
            this.currentToolbar = "main";
            parent.isStraightening = false;
            parent.notify("draw", { prop: "resetTempObjColl" });
            parent.notify("draw", { prop: "resetTempPointColl" });
            break;
          case "crop":
            parent.notify("transform", { prop: "disableZoomOutBtn", value: { isZoomOut: true } });
            if (Browser.isDevice) {
              this.updateContextualToolbar("color", "straighten");
            }
            break;
          case "reset":
            parent.reset();
            this.imageHeight = null;
            this.imageWidth = null;
            parent.aspectHeight = null;
            parent.aspectWidth = null;
            this.isAspectRatio = true;
            this.currentToolbar = "main";
            break;
          case "undo":
            parent.noPushUndo = false;
            if (parent.togglePen || parent.drawingShape) {
              parent.okBtn();
              parent.drawingShape = null;
            }
            parent.notify("undo-redo", { prop: "call-undo" });
            break;
          case "redo":
            parent.noPushUndo = false;
            if (parent.togglePen || parent.drawingShape) {
              parent.okBtn();
              parent.drawingShape = null;
            }
            parent.notify("undo-redo", { prop: "call-redo" });
            break;
          case "aspectratio":
            if (!parent.isCircleCrop && isNullOrUndefined(parent.currSelectionPoint) || parent.currSelectionPoint && parent.currSelectionPoint.shape !== "crop-circle") {
              if (getComponent(aspectRatioWidth, "numerictextbox").value) {
                parent.aspectWidth = getComponent(aspectRatioWidth, "numerictextbox").value;
                parent.aspectHeight = getComponent(aspectRatioHeight, "numerictextbox").value;
                parent.notify("transform", { prop: "resize", value: { width: parent.aspectWidth, height: null, isAspectRatio: true } });
              } else if (getComponent(aspectRatioHeight, "numerictextbox").value) {
                parent.aspectWidth = parseFloat(getComponent(aspectRatioWidth, "numerictextbox").placeholder);
                parent.aspectHeight = getComponent(aspectRatioHeight, "numerictextbox").value;
                parent.notify("transform", { prop: "resize", value: { width: parent.aspectWidth, height: parent.aspectHeight, isAspectRatio: true } });
              }
              parent.resizeSrc = {
                startX: parent.img.srcLeft,
                startY: parent.img.srcTop,
                width: parent.img.srcWidth,
                height: parent.img.srcHeight
              };
              this.refreshToolbar("resize");
            }
            break;
          case "nonaspectratio":
            if (getComponent(aspectRatioWidth, "numerictextbox").value || getComponent(aspectRatioHeight, "numerictextbox").value) {
              parent.aspectWidth = getComponent(aspectRatioWidth, "numerictextbox").value ? getComponent(aspectRatioWidth, "numerictextbox").value : parseFloat(getComponent(aspectRatioWidth, "numerictextbox").placeholder);
              parent.aspectHeight = getComponent(aspectRatioHeight, "numerictextbox").value ? getComponent(aspectRatioHeight, "numerictextbox").value : parseFloat(getComponent(aspectRatioHeight, "numerictextbox").placeholder);
              parent.notify("transform", { prop: "resize", value: { width: parent.aspectWidth, height: parent.aspectHeight, isAspectRatio: false } });
            }
            parent.resizeSrc = {
              startX: parent.img.srcLeft,
              startY: parent.img.srcTop,
              width: parent.img.srcWidth,
              height: parent.img.srcHeight
            };
            this.refreshToolbar("resize");
            break;
          case "resize":
            if (parent.currObjType.isFiltered || parent.currObjType.isRedact) {
              parent.okBtn();
            }
            this.resizeClick();
            break;
          case "adjustment":
            if (!isDisabledAdjustment) {
              if (parent.currObjType.isFiltered || parent.currObjType.isRedact) {
                parent.okBtn();
              }
              this.refreshToolbar("adjustment");
              parent.setTempFilterProperties();
              parent.notify("draw", { prop: "updateFinetune" });
              parent.notify("filter", { prop: "setTempAdjVal" });
              this.openSlider("brightness");
            }
            break;
          case "brightness":
          case "contrast":
          case "hue":
          case "saturation":
          case "opacity":
          case "blur":
          case "exposure":
            this.openSlider(type);
            break;
          case "filter":
            if (!isDisabledFilter) {
              showSpinner(parent.element);
              this.refreshToolbar("filter");
              parent.setTempFilterProperties();
              hideSpinner(parent.element);
            }
            break;
          case "default":
          case "chrome":
          case "cold":
          case "warm":
          case "grayscale":
          case "blackandwhite":
          case "sepia":
          case "invert":
          case "sharpen":
            parent.currObjType.isFiltered = true;
            parent.notify("filter", { prop: "applyImageFilter", value: { option: type } });
            break;
          case "upload":
            if (isFilterFinetune) {
              parent.element.querySelector(".e-contextual-toolbar-wrapper").classList.remove("e-hide");
            }
            break;
          case "bold":
            parent.notify("selection", { prop: "setInitialTextEdit", value: { bool: false } });
            if (parent.activeObj.textSettings.bold && parent.activeObj.textSettings.italic) {
              parent.notify("shape", {
                prop: "applyFontStyle",
                onPropertyChange: false,
                value: { item: "italic" }
              });
            } else if (parent.activeObj.textSettings.bold && !parent.activeObj.textSettings.italic) {
              parent.notify("shape", {
                prop: "applyFontStyle",
                onPropertyChange: false,
                value: { item: "default" }
              });
            } else if (!parent.activeObj.textSettings.bold && parent.activeObj.textSettings.italic) {
              parent.notify("shape", {
                prop: "applyFontStyle",
                onPropertyChange: false,
                value: { item: "bolditalic" }
              });
            } else if (!parent.activeObj.textSettings.bold && !parent.activeObj.textSettings.italic) {
              parent.notify("shape", {
                prop: "applyFontStyle",
                onPropertyChange: false,
                value: { item: "bold" }
              });
            }
            if (parent.element.querySelector("#" + id + "_bold").classList.contains("e-selected-btn")) {
              parent.element.querySelector("#" + id + "_bold").classList.remove("e-selected-btn");
            } else {
              parent.element.querySelector("#" + id + "_bold").classList.add("e-selected-btn");
            }
            if (parent.activeObj.activePoint.width !== 0 || parent.activeObj.activePoint.height !== 0) {
              parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
            }
            break;
          case "italic":
            parent.notify("selection", { prop: "setInitialTextEdit", value: { bool: false } });
            if (parent.activeObj.textSettings.bold && parent.activeObj.textSettings.italic) {
              parent.notify("shape", {
                prop: "applyFontStyle",
                onPropertyChange: false,
                value: { item: "bold" }
              });
            } else if (parent.activeObj.textSettings.bold && !parent.activeObj.textSettings.italic) {
              parent.notify("shape", {
                prop: "applyFontStyle",
                onPropertyChange: false,
                value: { item: "bolditalic" }
              });
            } else if (!parent.activeObj.textSettings.bold && parent.activeObj.textSettings.italic) {
              parent.notify("shape", {
                prop: "applyFontStyle",
                onPropertyChange: false,
                value: { item: "default" }
              });
            } else if (!parent.activeObj.textSettings.bold && !parent.activeObj.textSettings.italic) {
              parent.notify("shape", {
                prop: "applyFontStyle",
                onPropertyChange: false,
                value: { item: "italic" }
              });
            }
            if (parent.element.querySelector("#" + id + "_italic").classList.contains("e-selected-btn")) {
              parent.element.querySelector("#" + id + "_italic").classList.remove("e-selected-btn");
            } else {
              parent.element.querySelector("#" + id + "_italic").classList.add("e-selected-btn");
            }
            if (parent.activeObj.activePoint.width !== 0 || parent.activeObj.activePoint.height !== 0) {
              parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
            }
            break;
          case "croptransform":
            this.performCropTransformClick();
            break;
          case "rotateleft":
          case "rotateright":
          case "horizontalflip":
          case "verticalflip":
            parent.transformSelect(type);
            for (var i = 0; i < parent.objColl.length; i++) {
              if (parent.objColl[i].shape === "redact") {
                isRedact = true;
                break;
              }
            }
            if (isRedact) {
              parent.notify("draw", { prop: "setRedactStraighten", value: { bool: true } });
              actObj = extend({}, parent.activeObj, {}, true);
              while (parent.img.destLeft < 0 || parent.img.destTop < 0) {
                parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
                parent.notify("transform", {
                  prop: "zoomAction",
                  onPropertyChange: false,
                  value: { zoomFactor: -0.125, zoomPoint: null, isResize: false }
                });
                zoomLevel += 1;
              }
            }
            this.updateRedactObj();
            if (isRedact) {
              if (zoomLevel > 0) {
                parent.isCropTab = true;
                for (var i = 0; i < zoomLevel; i++) {
                  parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
                  parent.notify("transform", {
                    prop: "zoomAction",
                    onPropertyChange: false,
                    value: { zoomFactor: 0.125, zoomPoint: null, isResize: false }
                  });
                }
                parent.activeObj = actObj;
                parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate" } });
              }
              parent.notify("draw", { prop: "setRedactStraighten", value: { bool: false } });
            }
            if (type === "rotateleft" || type === "rotateright") {
              parent.notify("draw", { prop: "resetStraightenDestPoints" });
              parent.notify("draw", { prop: "setDestForStraighten" });
            }
            parent.notify("transform", { prop: "disableZoomOutBtn", value: { isZoomOut: true } });
            if (Browser.isDevice) {
              this.updateContextualToolbar("color", "straighten");
            }
            actionType = type === "rotateleft" || type === "rotateright" ? "rotate" : "flip";
            actionArgs = { action: actionType, actionEventArgs: parent.editCompleteArgs };
            parent.triggerEditCompleteEvent(actionArgs);
            break;
          case "save":
            parent.noPushUndo = false;
            parent.okBtn();
            parent.drawingShape = null;
            this.saveDialogPopup();
            break;
          case "transparency":
            this.updateContextualToolbar("transparency", "transparency");
            break;
          case "frame":
            this.frameToolbarClick();
            break;
          case "none":
          case "mat":
          case "bevel":
          case "line":
          case "inset":
          case "hook":
            this.unselectFrameBtn();
            if (parent.element.querySelector("#" + id + "_" + type)) {
              parent.element.querySelector("#" + id + "_" + type).classList.add("e-selected-btn");
            }
            parent.frameObj.type = type;
            parent.frameObj.size = 20;
            parent.frameObj.inset = 20;
            parent.frameObj.radius = 0;
            parent.frameObj.amount = 1;
            if (type === "inset") {
              parent.frameObj.offset = 60;
            } else {
              parent.frameObj.offset = 20;
            }
            this.refreshToolbar("frame");
            parent.notify("draw", { prop: "render-image", value: { isMouseWheel: null, isPreventClearRect: null, isFrame: true } });
            parent.isFrameBtnClick = true;
            parent.curFrameObjEvent = { previousFrameSetting: parent.tempFrameObj, currentFrameSetting: parent.frameObj };
            parent.notify("draw", { prop: "triggerFrameChange", value: { prevFrameSettings: parent.tempFrameObj, obj: { frameChangeEventArgs: null } } });
            break;
          case "redact":
            parent.currObjType.isRedact = isRedactClick = true;
            parent.drawingShape = "redact";
            if (isNullOrUndefined(parent.activeObj.redactBlur)) {
              parent.activeObj.redactBlur = 20;
            }
            if (isNullOrUndefined(parent.activeObj.redactPixelate)) {
              parent.activeObj.redactPixelate = 20;
            }
            parent.notify("selection", { prop: "annotate", value: { shape: "redact" } });
            this.refreshToolbar("redact");
            this.redactSlider(parent.activeObj.redactType);
            break;
          case "pixelate":
            parent.currObjType.isRedact = isRedactClick = true;
            parent.drawingShape = "redact";
            parent.notify("selection", { prop: "annotate", value: { shape: "redact" } });
            if (parent.activeObj.redactType === "blur") {
              this.updateRedactType("pixelate");
            }
            parent.notify("shape", {
              prop: "setRedactType",
              onPropertyChange: false,
              value: { redactType: "pixelate" }
            });
            if (parent.activeObj.redactType === "pixelate") {
              var pixelateBtn = parent.element.querySelector("#" + id + "_pixelate");
              var redactBlurBtn = parent.element.querySelector("#" + id + "_redactBlur");
              if (pixelateBtn) {
                pixelateBtn.classList.add("e-selected-btn");
              }
              if (redactBlurBtn && redactBlurBtn.classList.contains("e-selected-btn")) {
                redactBlurBtn.classList.remove("e-selected-btn");
              }
            } else {
              var redactBlurBtn = parent.element.querySelector("#" + id + "_redactBlur");
              if (redactBlurBtn) {
                redactBlurBtn.classList.add("e-selected-btn");
              }
            }
            this.redactSlider(parent.activeObj.redactType);
            if (parent.activeObj.activePoint.width !== 0 || parent.activeObj.activePoint.height !== 0) {
              parent.notify("undo-redo", {
                prop: "updateUndoRedoColl",
                onPropertyChange: false,
                value: {
                  operation: "shapeTransform",
                  previousObj: null,
                  previousObjColl: null,
                  previousPointColl: null,
                  previousSelPointColl: null,
                  previousCropObj: null,
                  previousText: null,
                  currentText: null,
                  previousFilter: null,
                  isCircleCrop: null
                }
              });
            }
            break;
          case "redactblur":
            parent.currObjType.isRedact = isRedactClick = true;
            parent.drawingShape = "redact";
            parent.notify("selection", { prop: "annotate", value: { shape: "redact" } });
            parent.notify("shape", {
              prop: "setRedactType",
              onPropertyChange: false,
              value: { redactType: "blur" }
            });
            if (parent.activeObj.redactType === "pixelate") {
              this.updateRedactType("blur");
            }
            parent.notify("shape", { prop: "setRedactType", onPropertyChange: false, value: { redactType: "blur" } });
            if (parent.activeObj.redactType === "blur") {
              var redactBlurBtn = parent.element.querySelector("#" + id + "_redactBlur");
              var pixelateBtn = parent.element.querySelector("#" + id + "_pixelate");
              if (redactBlurBtn) {
                redactBlurBtn.classList.add("e-selected-btn");
              }
              if (pixelateBtn && pixelateBtn.classList.contains("e-selected-btn")) {
                pixelateBtn.classList.remove("e-selected-btn");
              }
            } else {
              var pixelateBtn = parent.element.querySelector("#" + id + "_pixelate");
              if (pixelateBtn) {
                pixelateBtn.classList.add("e-selected-btn");
              }
            }
            this.redactSlider(parent.activeObj.redactType);
            if (parent.activeObj.activePoint.width !== 0 || parent.activeObj.activePoint.height !== 0) {
              parent.notify("undo-redo", {
                prop: "updateUndoRedoColl",
                onPropertyChange: false,
                value: {
                  operation: "shapeTransform",
                  previousObj: null,
                  previousObjColl: null,
                  previousPointColl: null,
                  previousSelPointColl: null,
                  previousCropObj: null,
                  previousText: null,
                  currentText: null,
                  previousFilter: null,
                  isCircleCrop: null
                }
              });
            }
            break;
        }
        if (isRedactClick) {
          parent.notify("draw", { prop: "updateTempObjColl" });
          parent.notify("draw", { prop: "updateTempPointColl" });
        }
      }
    };
    ToolbarModule2.prototype.updateRedactType = function(value) {
      var parent = this.parent;
      parent.activeObj.redactType = value;
      parent.notify("shape", { prop: "setRedactType", value: { type: value } });
      this.parent.objColl.push(parent.activeObj);
      parent.notify("selection", { prop: "redrawShape", value: { obj: parent.objColl[parent.objColl.length - 1] } });
    };
    ToolbarModule2.prototype.frameToolbarClick = function() {
      var parent = this.parent;
      var id = parent.element.id;
      var frame = (undefined).querySelector("#" + id + "_frame");
      var zoom;
      var frameObj;
      var tempFrameObj;
      parent.notify("draw", { prop: "updateCropSelection", onPropertyChange: false });
      if (parent.currObjType.isFiltered || parent.currObjType.isRedact) {
        parent.okBtn();
      }
      if (frame && !frame.classList.contains("e-overlay")) {
        zoom = parent.transform.zoomFactor;
        parent.frameDestPoints = extend({}, parent.img, {}, true);
        if (isNullOrUndefined(parent.cxtTbarHeight)) {
          frameObj = extend({}, parent.frameObj, {}, true);
          tempFrameObj = extend({}, parent.tempFrameObj, {}, true);
          this.callFrameToolbar();
          parent.frameObj.type = "mat";
          this.callFrameToolbar();
          parent.cxtTbarHeight = parent.element.querySelector("#" + id + "_customizeWrapper").scrollHeight;
          parent.frameObj = frameObj;
          parent.tempFrameObj = tempFrameObj;
        }
        this.zoomToFrameRange();
        parent.tempFrameZoomLevel = zoom;
        if (Browser.isDevice) {
          parent.img.destTop -= parent.cxtTbarHeight / 2;
        } else {
          parent.img.destTop += parent.cxtTbarHeight / 2;
        }
        this.callFrameToolbar();
        parent.notify("draw", { prop: "triggerFrameChange", value: { prevFrameSettings: parent.frameObj, obj: { frameChangeEventArgs: null } } });
      }
    };
    ToolbarModule2.prototype.zoomToFrameRange = function() {
      var parent = this.parent;
      this.isFrameToolbar = false;
      parent.notify("transform", { prop: "resetZoom", onPropertyChange: false });
      var isSmaller = true;
      while (isSmaller) {
        if (this.toolbarHeight + parent.img.destTop >= this.toolbarHeight + parent.cxtTbarHeight) {
          isSmaller = false;
          break;
        }
        parent.notify("transform", {
          prop: "zoomAction",
          onPropertyChange: false,
          value: { zoomFactor: -0.1, zoomPoint: null, isResize: true }
        });
      }
      this.isFrameToolbar = true;
    };
    ToolbarModule2.prototype.resizeClick = function() {
      var parent = this.parent;
      parent.notify("draw", { prop: "updateCropSelection", onPropertyChange: false });
      parent.upperCanvas.style.cursor = "default";
      parent.notify("transform", { prop: "updateResize", value: { bool: false } });
      if (this.isAspectRatio) {
        this.isAspectRatio = false;
      } else {
        this.isAspectRatio = true;
      }
      parent.isResize = true;
      this.refreshToolbar("resize");
    };
    ToolbarModule2.prototype.callFrameToolbar = function() {
      var parent = this.parent;
      extend(parent.tempFrameObj, parent.frameObj);
      var undoRedoObj = { appliedUndoRedoColl: [] };
      parent.notify("undo-redo", { prop: "getAppliedUndoRedoColl", value: { obj: undoRedoObj } });
      if (undoRedoObj["appliedUndoRedoColl"]["length"] === 0) {
        var object = { currObj: {} };
        parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
        parent.notify("undo-redo", { prop: "updateUndoRedoColl", onPropertyChange: false, value: {
          operation: "frame",
          previousObj: object["currObj"],
          previousObjColl: object["currObj"]["objColl"],
          previousPointColl: object["currObj"]["pointColl"],
          previousSelPointColl: object["currObj"]["selPointColl"],
          previousCropObj: extend({}, parent.cropObj, {}, true),
          previousText: null,
          currentText: null,
          previousFilter: null,
          isCircleCrop: null
        } });
      }
      this.refreshToolbar("frame");
    };
    ToolbarModule2.prototype.contextualToolbarClicked = function(args) {
      var parent = this.parent;
      var selEle = parent.element.querySelector(".e-contextual-toolbar-wrapper .e-toolbar-item.e-selected");
      if (selEle) {
        selEle.classList.remove("e-selected");
      }
      var type = args.item.id.replace(parent.element.id, "").split("_")[1];
      var imageFiltering = { filter: parent.toPascalCase(type), cancel: false };
      parent.trigger("imageFiltering", imageFiltering);
      parent.editCompleteArgs = imageFiltering;
      if (imageFiltering.cancel) {
        return;
      }
      (undefined).getElementById(args.item.id + "Canvas").parentElement.parentElement.classList.add("e-selected");
      parent.currObjType.isFiltered = true;
      parent.notify("filter", { prop: "applyImageFilter", value: { option: type.toLowerCase() } });
      parent.notify("draw", { prop: "redrawDownScale" });
      parent.currentFilter = args.item.id;
      this.enableDisableTbrBtn();
      parent.isFilterCanvasClick = true;
      parent.curFilterObjEvent = imageFiltering;
    };
    ToolbarModule2.prototype.refreshShapeDrawing = function() {
      var parent = this.parent;
      var object = { shape: "" };
      parent.notify("selection", { prop: "getCurrentDrawingShape", onPropertyChange: false, value: { obj: object } });
      if (object["shape"] !== "") {
        parent.notify("selection", { prop: "setCurrentDrawingShape", onPropertyChange: false, value: { value: "" } });
        parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
        this.refreshToolbar("main", false);
      }
    };
    ToolbarModule2.prototype.zoomInBtnClickHandler = function(e) {
      if (e) {
        var parent_1 = this.parent;
        if ((parent_1.zoomSettings.zoomTrigger & ZoomTrigger.Toolbar) === ZoomTrigger.Toolbar) {
          parent_1.noPushUndo = false;
          if (parent_1.currObjType.isFiltered) {
            parent_1.okBtn();
          }
          var drawingShape = parent_1.drawingShape;
          if (parent_1.drawingShape) {
            var id = parent_1.activeObj.currIndex;
            parent_1.noPushUndo = true;
            parent_1.okBtn();
            parent_1.noPushUndo = false;
            parent_1.drawingShape = null;
            if (id) {
              parent_1.selectShape(id);
            }
          }
          this.refreshShapeDrawing();
          if (Browser.isDevice && e.type === "touchstart") {
            if (!e.returnValue) {
              return;
            }
            e.preventDefault();
          }
          var zoomIn = (undefined).querySelector("#" + parent_1.element.id + "_zoomIn");
          EventHandler.trigger(zoomIn, "click");
          var obj = { bool: false };
          parent_1.notify("selection", { prop: "getFreehandDrawEditing", onPropertyChange: false, value: { obj } });
          if (obj["bool"]) {
            parent_1.notify("freehand-draw", { prop: "applyFhd", onPropertyChange: false });
            this.destroyQuickAccessToolbar();
          }
          parent_1.isZoomBtnClick = true;
          this.applyPreviewFilter();
          parent_1.currObjType.isFiltered = false;
          parent_1.currObjType.isRedact = false;
          if (parent_1.togglePen) {
            parent_1.currObjType.isZoomed = true;
            parent_1.freeHandDraw(false);
            parent_1.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
          }
          parent_1.notify("draw", { prop: "resetCurrentSelectionPoint" });
          parent_1.drawingShape = drawingShape;
          parent_1.notify("transform", {
            prop: "zoomAction",
            onPropertyChange: false,
            value: { zoomFactor: 0.1, zoomPoint: null, isResize: null }
          });
          parent_1.notify("draw", { prop: "redrawDownScale" });
          if (parent_1.isCropTab || parent_1.activeObj.shape) {
            parent_1.notify("draw", { prop: "setStraightenActObj", value: { activeObj: null } });
            parent_1.notify("freehand-draw", { prop: "resetStraightenPoint" });
          }
          if (parent_1.isStraightening) {
            parent_1.notify("draw", { prop: "resetStraightenDestPoints" });
            parent_1.notify("draw", { prop: "setDestForStraighten" });
          }
          var actionArgs = {
            action: "zoom-in",
            actionEventArgs: parent_1.editCompleteArgs
          };
          parent_1.triggerEditCompleteEvent(actionArgs);
          if (Browser.isDevice) {
            zoomIn.focus();
          }
        }
      }
    };
    ToolbarModule2.prototype.zoomOutBtnClickHandler = function(e) {
      if (e) {
        var parent_2 = this.parent;
        if ((parent_2.zoomSettings.zoomTrigger & ZoomTrigger.Toolbar) === ZoomTrigger.Toolbar) {
          parent_2.noPushUndo = false;
          if (parent_2.currObjType.isFiltered) {
            parent_2.okBtn();
          }
          var drawingShape = parent_2.drawingShape;
          if (parent_2.drawingShape) {
            var id = parent_2.activeObj.currIndex;
            parent_2.noPushUndo = true;
            parent_2.okBtn();
            parent_2.noPushUndo = false;
            parent_2.drawingShape = null;
            if (id) {
              parent_2.selectShape(id);
            }
          }
          this.refreshShapeDrawing();
          if (Browser.isDevice && e.type === "touchstart") {
            if (!e.returnValue) {
              return;
            }
            e.preventDefault();
          }
          var zoomOut = (undefined).querySelector("#" + parent_2.element.id + "_zoomOut");
          EventHandler.trigger(zoomOut, "click");
          var obj = { bool: false };
          parent_2.notify("selection", { prop: "getFreehandDrawEditing", onPropertyChange: false, value: { obj } });
          if (obj["bool"]) {
            parent_2.notify("freehand-draw", { prop: "applyFhd", onPropertyChange: false });
            this.destroyQuickAccessToolbar();
          }
          parent_2.isZoomBtnClick = true;
          this.applyPreviewFilter();
          parent_2.currObjType.isFiltered = false;
          parent_2.currObjType.isRedact = false;
          if (parent_2.togglePen) {
            parent_2.currObjType.isZoomed = true;
            parent_2.freeHandDraw(false);
            parent_2.notify("undo-redo", { prop: "updateCurrUrc", value: { type: "ok" } });
          }
          parent_2.notify("draw", { prop: "resetCurrentSelectionPoint" });
          parent_2.drawingShape = drawingShape;
          parent_2.notify("transform", {
            prop: "zoomAction",
            onPropertyChange: false,
            value: { zoomFactor: -0.1, zoomPoint: null, isResize: null }
          });
          parent_2.notify("draw", { prop: "redrawDownScale" });
          if (parent_2.isCropTab || parent_2.activeObj.shape) {
            parent_2.notify("draw", { prop: "setStraightenActObj", value: { activeObj: null } });
            parent_2.notify("freehand-draw", { prop: "resetStraightenPoint" });
          }
          if (parent_2.isStraightening) {
            parent_2.notify("draw", { prop: "resetStraightenDestPoints" });
            parent_2.notify("draw", { prop: "setDestForStraighten" });
          }
          var actionArgs = {
            action: "zoom-out",
            actionEventArgs: parent_2.editCompleteArgs
          };
          parent_2.triggerEditCompleteEvent(actionArgs);
          if (Browser.isDevice) {
            zoomOut.focus();
          }
        }
      }
    };
    ToolbarModule2.prototype.zoomInBtnMouseDownHandler = function(e) {
      e.preventDefault();
      this.zoomBtnHold = setInterval(this.zoomInBtnClickHandler.bind(this), 250);
    };
    ToolbarModule2.prototype.zoomOutBtnMouseDownHandler = function(e) {
      e.preventDefault();
      this.zoomBtnHold = setInterval(this.zoomOutBtnClickHandler.bind(this), 250);
    };
    ToolbarModule2.prototype.zoomBtnMouseUpHandler = function() {
      clearInterval(this.zoomBtnHold);
      this.zoomBtnHold = 0;
    };
    ToolbarModule2.prototype.closeContextualToolbar = function() {
      var parent = this.parent;
      var id = parent.element.id;
      var isContextualToolbar = false;
      var straightenObj = { bool: parent.isStraightening };
      if (!Browser.isDevice || Browser.isDevice && !straightenObj["bool"]) {
        if (parent.element.querySelector("#" + id + "_contextualToolbar") && !parent.element.querySelector("#" + id + "_contextualToolbar").parentElement.classList.contains("e-hide") || parent.element.querySelector("#" + id + "_headWrapper") && !parent.element.querySelector("#" + id + "_headWrapper").parentElement.classList.contains("e-hide")) {
          parent.element.querySelector(".e-contextual-toolbar-wrapper").classList.add("e-hide");
          parent.okBtn();
          this.refreshMainToolbar();
          isContextualToolbar = true;
        }
      }
      return isContextualToolbar;
    };
    ToolbarModule2.prototype.destroyQuickAccessToolbar = function() {
      var parent = this.parent;
      var id = parent.element.id;
      var quickToolbar = (undefined).getElementById(id + "_quickAccessToolbar");
      if (quickToolbar && quickToolbar.classList.contains("e-control")) {
        getComponent(quickToolbar, "toolbar").destroy();
      }
      var qatArea = (undefined).getElementById(id + "_quickAccessToolbarArea");
      if (qatArea) {
        qatArea.style.display = "none";
      }
    };
    ToolbarModule2.prototype.renderSlider = function(type, isSelect) {
      var parent = this.parent;
      var id = parent.element.id;
      var canvasWrapper = (undefined).querySelector("#" + id + "_contextualToolbarArea");
      var hdrWrapper = (undefined).querySelector("#" + id + "_headWrapper");
      var labelWrapper = (undefined).querySelector("#" + id + "_labelWrapper");
      if (hdrWrapper) {
        hdrWrapper.remove();
        labelWrapper.remove();
      }
      hdrWrapper = canvasWrapper.appendChild(parent.createElement("div", {
        id: id + "_headWrapper",
        styles: "position: relative"
      }));
      if (type === "transparency") {
        labelWrapper = hdrWrapper.appendChild(parent.createElement("label", {
          id: id + "_labelWrapper",
          className: "e-ie-finetune-slider-label",
          styles: Browser.isDevice ? "position: absolute; top: 31%; left: calc(50% - 150px); font-size: 15px; text-transform: capitalize; font-weight: 400;" : "position: absolute; top: 31%; left: calc(50% - 220px); font-size: 15px; text-transform: capitalize; font-weight: 400;"
        }));
      } else {
        labelWrapper = hdrWrapper.appendChild(parent.createElement("label", {
          id: id + "_labelWrapper",
          className: "e-ie-finetune-slider-label",
          styles: Browser.isDevice ? "position: absolute; top: 31%; left: calc(50% - 160px); font-size: 15px; text-transform: capitalize; font-weight: 400;" : "position: absolute; top: 25%; left: calc(50% - 226px); font-size: 15px; text-transform: capitalize; font-weight: 400;"
        }));
      }
      labelWrapper.textContent = this.l10n.getConstant(parent.toPascalCase(type === "transparency" ? "opacity" : type));
      var sliderWrapper = hdrWrapper.appendChild(parent.createElement("div", {
        id: id + "_sliderWrapper",
        className: "e-ie-finetune-slider-wrap",
        styles: "position: absolute"
      }));
      var value = parent.getCurrAdjustmentValue(type);
      if (isSelect && type === "straighten" && Browser.isDevice) {
        value = parent.cropObj.straighten;
      }
      var min;
      var max;
      var slider;
      if (type === "brightness" || type === "contrast" || type === "saturation" || type === "exposure") {
        if (parent.finetuneSettings) {
          if (type === "brightness" && parent.finetuneSettings.brightness) {
            min = parent.finetuneSettings.brightness.min;
            max = parent.finetuneSettings.brightness.max;
          } else if (type === "contrast" && parent.finetuneSettings.contrast) {
            min = parent.finetuneSettings.contrast.min;
            max = parent.finetuneSettings.contrast.max;
          } else if (type === "saturation" && parent.finetuneSettings.saturation) {
            min = parent.finetuneSettings.saturation.min;
            max = parent.finetuneSettings.saturation.max;
          } else if (type === "exposure" && parent.finetuneSettings.exposure) {
            min = parent.finetuneSettings.exposure.min;
            max = parent.finetuneSettings.exposure.max;
          } else {
            min = -100;
            max = 100;
          }
        } else {
          min = -100;
          max = 100;
        }
        slider = this.createSlider(min, max, value, type);
      } else if (type === "hue" || type === "blur" || type === "opacity") {
        if (parent.finetuneSettings) {
          if (type === "hue" && parent.finetuneSettings.hue) {
            min = parent.finetuneSettings.hue.min;
            max = parent.finetuneSettings.hue.max;
          } else if (type === "blur" && parent.finetuneSettings.blur) {
            min = parent.finetuneSettings.blur.min;
            max = parent.finetuneSettings.blur.max;
          } else if (type === "opacity" && parent.finetuneSettings.opacity) {
            min = parent.finetuneSettings.opacity.min;
            max = parent.finetuneSettings.opacity.max;
          } else {
            min = 0;
            max = 100;
          }
        } else {
          min = 0;
          max = 100;
        }
        slider = this.createSlider(min, max, value, type);
      } else if (type === "transparency") {
        min = 0;
        max = 100;
        slider = this.createSlider(min, max, value, type);
      } else if (type === "straighten") {
        min = -45;
        max = 45;
        slider = this.createSlider(min, max, value, type);
      }
      slider.appendTo("#" + id + "_sliderWrapper");
      sliderWrapper.style.left = (parseFloat(canvasWrapper.style.width) - parseFloat(slider.width)) / 2 + "px";
      if (type === "straighten" && Browser.isDevice) {
        var sLabelWrapper = hdrWrapper.appendChild(parent.createElement("label", {
          id: id + "_sLabelWrapper",
          className: "e-ie-straighten-value-span e-ie-finetune-value-span",
          styles: "position: absolute; top: 31%; margin-left: 20px; font-size: 15px; text-transform: capitalize; font-weight: 400;"
        }));
        sLabelWrapper.innerHTML = parent.transform.straighten.toString() + "&#176";
        sliderWrapper.parentElement.classList.add("e-straighten-slider");
      }
      if (type !== "straighten") {
        hdrWrapper.appendChild(parent.createElement("label", {
          id: id + "_finetuneSpan",
          className: "e-ie-finetune-value-span",
          styles: Browser.isDevice ? "position: absolute; top: 25%; margin-left: 20px; font-size: 15px; text-transform: capitalize; font-weight: 400;" : "position: absolute; top: 25%; left: calc(50% + 190px); font-size: 15px; text-transform: capitalize; font-weight: 400;"
        }));
        sliderWrapper.parentElement.classList.add("e-finetune-slider");
        if (type === "transparency" && Browser.isDevice) {
          sliderWrapper.parentElement.classList.add("e-ie-device-transparency-slider");
        }
        this.updateFinetuneSpan(type);
      }
    };
    ToolbarModule2.prototype.createSlider = function(min, max, value, type) {
      var _this = this;
      var parent = this.parent;
      var step = type === "straighten" ? 3 : 1;
      return new Slider({
        value,
        type: "MinRange",
        min,
        max,
        step,
        width: Browser.isDevice ? "180px" : type === "straighten" ? "200px" : "300px",
        cssClass: "e-slider",
        change: function(args) {
          parent.notify("selection", { prop: "setSliderActive", onPropertyChange: false, value: { bool: true } });
          if (type === "transparency") {
            if (parent.activeObj.shape) {
              if (isNullOrUndefined(parent.activeObj.imageRatio)) {
                parent.notify("shape", { prop: "updImgRatioForActObj", onPropertyChange: false });
              }
              parent.notify("shape", { prop: "pushActItemIntoObj" });
              var prevCropObj = extend({}, parent.cropObj, {}, true);
              var object = { currObj: {} };
              parent.notify("filter", { prop: "getCurrentObj", onPropertyChange: false, value: { object } });
              var prevObj = object["currObj"];
              prevObj.objColl = extend([], parent.objColl, [], true);
              prevObj.pointColl = extend([], parent.pointColl, [], true);
              prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
              var selPointCollObj = { selPointColl: null };
              parent.notify("freehand-draw", {
                prop: "getSelPointColl",
                onPropertyChange: false,
                value: { obj: selPointCollObj }
              });
              prevObj.selPointColl = extend([], selPointCollObj["selPointColl"], [], true);
              parent.objColl.pop();
              parent.activeObj.opacity = args.value / 100;
              _this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
              parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: { canvas: "duplicate" } });
              parent.objColl.push(parent.activeObj);
              parent.notify("undo-redo", {
                prop: "updateUndoRedoColl",
                onPropertyChange: false,
                value: {
                  operation: "shapeTransform",
                  previousObj: prevObj,
                  previousObjColl: prevObj.objColl,
                  previousPointColl: prevObj.pointColl,
                  previousSelPointColl: prevObj.selPointColl,
                  previousCropObj: prevCropObj,
                  previousText: null,
                  currentText: null,
                  previousFilter: null,
                  isCircleCrop: null
                }
              });
              parent.notify("selection", { prop: "redrawShape", value: { obj: parent.objColl[parent.objColl.length - 1] } });
              _this.updateFinetuneSpan(type);
            }
          } else if (type === "straighten") {
            parent.setStraighten(args.value);
          } else {
            if (parent.transform.zoomFactor && parent.transform.zoomFactor < 0) {
              parent.isFinetuning = true;
            }
            parent.notify("selection", { prop: "setSliding", value: { bool: true } });
            parent.setCurrAdjustmentValue(type, args.value);
            _this.updateFinetuneSpan(type);
            _this.enableDisableTbrBtn();
            parent.isFinetuning = false;
          }
        },
        changed: function() {
          if (type !== "transparency" && type !== "straighten") {
            parent.notify("selection", { prop: "setSliding", value: { bool: false } });
            parent.notify("draw", { prop: "redrawDownScale" });
          }
          parent.notify("selection", { prop: "setSliderActive", onPropertyChange: false, value: { bool: false } });
          if (type === "transparency") {
            setTimeout(function() {
              parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
              parent.element.querySelector("#" + parent.element.id + "_transparency").click();
            }, 50);
          }
        }
      });
    };
    ToolbarModule2.prototype.updateFinetuneSpan = function(type) {
      var parent = this.parent;
      var ftValPan = parent.element.querySelector(".e-ie-finetune-value-span");
      if (ftValPan) {
        var adjObj = { adjustmentLevel: null };
        parent.notify("filter", { prop: "getAdjustmentLevel", onPropertyChange: false, value: { obj: adjObj } });
        ftValPan.innerHTML = Math.round(adjObj["adjustmentLevel"][type]).toString();
      }
    };
    ToolbarModule2.prototype.applyPreviewFilter = function() {
      var parent = this.parent;
      if ((undefined).querySelector("#" + parent.element.id + "_sliderWrapper") || parent.currObjType.isFiltered) {
        parent.initialAdjustmentValue = this.lowerContext.filter;
        parent.canvasFilter = this.lowerContext.filter;
        parent.currObjType.isFiltered = false;
      }
    };
    ToolbarModule2.prototype.unselectBtn = function() {
      var parent = this.parent;
      var id = parent.element.id;
      var selectors = [
        "#" + id + "_brightness",
        "#" + id + "_contrast",
        "#" + id + "_hue",
        "#" + id + "_saturation",
        "#" + id + "_opacity",
        "#" + id + "_blur",
        "#" + id + "_exposure"
      ];
      for (var _i = 0, selectors_1 = selectors; _i < selectors_1.length; _i++) {
        var selector = selectors_1[_i];
        var element2 = (undefined).querySelector(selector);
        if (element2 && element2.classList.contains("e-selected-btn")) {
          element2.classList.remove("e-selected-btn");
          break;
        }
      }
    };
    ToolbarModule2.prototype.openSlider = function(type) {
      this.unselectBtn();
      this.parent.currObjType.isFiltered = true;
      this.refreshToolbar("color", null, null, null, type);
      (undefined).getElementById(this.parent.element.id + "_" + type).classList.add("e-selected-btn");
    };
    ToolbarModule2.prototype.refreshSlider = function() {
      var id = this.parent.element.id;
      var sliderWrapper = (undefined).querySelector("#" + id + "_sliderWrapper");
      var slider = (undefined).querySelector(".e-slider");
      var hdrWrapper = (undefined).querySelector("#" + id + "_headWrapper");
      if (hdrWrapper) {
        hdrWrapper.style.display = "none";
      }
      if (sliderWrapper && slider) {
        slider.ej2_instances[0].destroy();
        sliderWrapper.remove();
      }
    };
    ToolbarModule2.prototype.unselectFrameBtn = function() {
      var parent = this.parent;
      var id = parent.element.id;
      var selectors = [
        "#" + id + "_none",
        "#" + id + "_mat",
        "#" + id + "_line",
        "#" + id + "_inset",
        "#" + id + "_bevel",
        "#" + id + "_hook"
      ];
      for (var _i = 0, selectors_2 = selectors; _i < selectors_2.length; _i++) {
        var selector = selectors_2[_i];
        var element2 = (undefined).querySelector(selector);
        if (element2.classList.contains("e-selected-btn")) {
          element2.classList.remove("e-selected-btn");
          break;
        }
      }
    };
    ToolbarModule2.prototype.updateToolbarItems = function() {
      var parent = this.parent;
      var id = parent.element.id;
      if (!parent.isImageLoaded) {
        return;
      }
      if (this.isToolbar()) {
        var selFillElem = parent.element.querySelector(".e-fill.e-template .e-dropdownbtn-preview");
        var selStrokeElem = parent.element.querySelector(".e-stroke.e-template .e-dropdownbtn-preview");
        var selTextStrokeElem = parent.element.querySelector(".e-text-font-color.e-template .e-dropdownbtn-preview");
        var selStrokeTextColorElem = parent.element.querySelector(".e-stroke-text-font-color.e-template .e-dropdownbtn-preview");
        var selTextBGElem = parent.element.querySelector(".e-text-background-color.e-template .e-dropdownbtn-preview");
        var selPenStrokeElem = parent.element.querySelector(".e-pen-stroke-color.e-template .e-dropdownbtn-preview");
        var strokeWidthElem = parent.element.querySelector(".e-shape-stroke-width");
        var rectangleRadiusElem = parent.element.querySelector(".e-shape-rectangle-radius");
        var fontFamilyElem = parent.element.querySelector(".e-text-font-family");
        var fontSizeElem = parent.element.querySelector(".e-text-font-size");
        var boldBtn = parent.element.querySelector("#" + id + "_bold");
        var italicBtn = parent.element.querySelector("#" + id + "_italic");
        if (parent.activeObj.strokeSettings && parent.activeObj.textSettings) {
          if (isNullOrUndefined(parent.activeObj.strokeSettings.strokeWidth)) {
            parent.activeObj.strokeSettings.strokeWidth = 2;
          }
          if (isNullOrUndefined(parent.activeObj.strokeSettings.outlineWidth)) {
            parent.activeObj.strokeSettings.outlineWidth = 2;
          }
          if (selFillElem) {
            var value = parent.activeObj.strokeSettings.fillColor;
            if (parent.activeObj.strokeSettings.fillColor === "") {
              selFillElem.classList.add("e-nocolor-item");
            } else {
              selFillElem.classList.remove("e-nocolor-item");
              selFillElem.style.background = value;
            }
            if ((undefined).querySelector("#" + id + "_shape_fill")) {
              getComponent(id + "_shape_fill", "colorpicker").value = value;
            }
          }
          if (selStrokeElem) {
            var value = parent.activeObj.strokeSettings.strokeColor;
            selStrokeElem.style.background = value;
            if ((undefined).querySelector("#" + id + "_shape_stroke")) {
              getComponent(id + "_shape_stroke", "colorpicker").value = value;
            }
          }
          if (selTextStrokeElem) {
            var value = parent.activeObj.strokeSettings.strokeColor;
            selTextStrokeElem.style.background = value;
            if ((undefined).querySelector("#" + id + "_text_font")) {
              getComponent(id + "_text_font", "colorpicker").value = value;
            }
          }
          if (selStrokeTextColorElem) {
            var value = parent.activeObj.strokeSettings.outlineColor;
            if (!/^#([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6}|[0-9A-Fa-f]{8})$|^[a-zA-Z]+$/.test(parent.activeObj.strokeSettings.outlineColor)) {
              selStrokeTextColorElem.classList.add("e-nocolor-item");
            } else {
              selStrokeTextColorElem.classList.remove("e-nocolor-item");
              selStrokeTextColorElem.style.background = value;
            }
            if ((undefined).querySelector("#" + id + "_stroke_text")) {
              getComponent(id + "_stroke_text", "colorpicker").value = value;
            }
          }
          if (selTextBGElem) {
            var value = parent.activeObj.strokeSettings.fillColor;
            if (parent.activeObj.strokeSettings.fillColor === "" || parent.activeObj.strokeSettings.fillColor === "transparent") {
              selTextBGElem.classList.add("e-nocolor-item");
            } else {
              selTextBGElem.classList.remove("e-nocolor-item");
              selTextBGElem.style.background = value;
            }
            if ((undefined).querySelector("#" + id + "_text_bgColor")) {
              getComponent(id + "_text_bgColor", "colorpicker").value = value;
            }
          }
          if (selPenStrokeElem) {
            var value = parent.activeObj.strokeSettings.strokeColor;
            selPenStrokeElem.style.background = value;
            if ((undefined).querySelector("#" + id + "_pen_stroke")) {
              getComponent(id + "_pen_stroke", "colorpicker").value = value;
            }
            var obj = { penOpacity: 1 };
            parent.notify("freehand-draw", { prop: "getPenOpacity", onPropertyChange: false, value: { obj } });
          }
          if (fontFamilyElem) {
            if (Browser.isDevice) {
              fontFamilyElem.setAttribute("style", "font-family:" + parent.activeObj.textSettings.fontFamily.toLowerCase());
            } else {
              fontFamilyElem.textContent = parent.activeObj.textSettings.fontFamily;
            }
          }
          if (fontSizeElem) {
            for (var i = 0; i < parent.fontSizeColl.length; i++) {
              if (parseInt(parent.fontSizeColl[i].text, 10) >= Math.round(parent.activeObj.textSettings.fontSize)) {
                fontSizeElem.textContent = (i + 1).toString();
                break;
              } else {
                if (Math.round(parent.activeObj.textSettings.fontSize) < parseInt(parent.fontSizeColl[0].text, 10)) {
                  fontSizeElem.textContent = "1";
                  break;
                } else if (Math.round(parent.activeObj.textSettings.fontSize) > parseInt(parent.fontSizeColl[parent.fontSizeColl.length - 1].text, 10)) {
                  fontSizeElem.textContent = (parent.fontSizeColl.length - 1 + 1).toString();
                  break;
                }
              }
            }
          }
          if (boldBtn) {
            if (parent.activeObj.textSettings.bold) {
              boldBtn.classList.add("e-selected-btn");
            } else {
              boldBtn.classList.remove("e-selected-btn");
            }
          }
          if (italicBtn) {
            if (parent.activeObj.textSettings.italic) {
              italicBtn.classList.add("e-selected-btn");
            } else {
              italicBtn.classList.remove("e-selected-btn");
            }
          }
          if (strokeWidthElem) {
            var width = parent.activeObj.shape === "text" ? parent.activeObj.strokeSettings.outlineWidth : parent.activeObj.strokeSettings.strokeWidth;
            var strokeWidth = Math.round(width).toString();
            strokeWidthElem.textContent = this.getStrokeWidth(strokeWidth);
          }
          if (rectangleRadiusElem) {
            var rectRadius = Math.round(parent.activeObj.strokeSettings.radius).toString();
            rectangleRadiusElem.textContent = this.getRectRadius(rectRadius);
          }
        }
      }
    };
    ToolbarModule2.prototype.getStrokeWidth = function(text) {
      var strokeWidth;
      var currentWidth = parseInt(text, 10) / 2;
      switch (currentWidth) {
        case 0:
          strokeWidth = this.l10n.getConstant("NoOutline");
          break;
        case 1:
          strokeWidth = this.l10n.getConstant("XSmall");
          break;
        case 2:
          strokeWidth = this.l10n.getConstant("Small");
          break;
        case 3:
          strokeWidth = this.l10n.getConstant("Medium");
          break;
        case 4:
          strokeWidth = this.l10n.getConstant("Large");
          break;
        case 5:
          strokeWidth = this.l10n.getConstant("XLarge");
          break;
      }
      return strokeWidth;
    };
    ToolbarModule2.prototype.getRectRadius = function(text) {
      var rectRadius;
      var currentWidth = parseInt(text, 10) / 2;
      switch (currentWidth) {
        case 0:
          rectRadius = this.l10n.getConstant("0");
          break;
        case 1:
          rectRadius = this.l10n.getConstant("20");
          break;
        case 2:
          rectRadius = this.l10n.getConstant("40");
          break;
        case 3:
          rectRadius = this.l10n.getConstant("60");
          break;
        case 4:
          rectRadius = this.l10n.getConstant("80");
          break;
        case 5:
          rectRadius = this.l10n.getConstant("100");
          break;
      }
      return rectRadius;
    };
    ToolbarModule2.prototype.cancelPan = function() {
      var parent = this.parent;
      parent.notify("shape", { prop: "applyActObj", onPropertyChange: false, value: { isMouseDown: true } });
      var panBtn = parent.element.querySelector(".e-img-pan .e-btn");
      if (panBtn) {
        panBtn.classList.remove("e-selected-btn");
      }
      parent.pan(false);
    };
    ToolbarModule2.prototype.refreshMainToolbar = function() {
      if (this.currToolbar !== "main") {
        this.refreshToolbar("main");
      }
    };
    ToolbarModule2.prototype.destroySubComponents = function() {
      var parent = this.parent;
      var inputElement = parent.element.querySelectorAll("input.e-control");
      var btnElement = parent.element.querySelectorAll("button.e-control");
      for (var i = 0, len = inputElement.length; i < len; i++) {
        if (inputElement[i].classList.contains("e-color-picker")) {
          getComponent(inputElement[i], "color-picker").destroy();
          detach(select("input#" + inputElement[i].id, parent.element));
        }
      }
      for (var i = 0, len = btnElement.length; i < len; i++) {
        if (btnElement[i].classList.contains("e-dropdown-btn")) {
          getComponent(btnElement[i], "dropdown-btn").destroy();
          detach(select("button#" + btnElement[i].id, parent.element));
        } else if (btnElement[i].classList.contains("e-btn")) {
          getComponent(btnElement[i], "btn").destroy();
          detach(select("button#" + btnElement[i].id, parent.element));
        }
      }
    };
    ToolbarModule2.prototype.setInitialShapeSettings = function(args) {
      var parent = this.parent;
      parent.notify("shape", { prop: "refreshActiveObj", onPropertyChange: false });
      parent.currObjType.shape = args.item.id;
      parent.activeObj.shape = parent.currObjType.shape.toLowerCase();
      parent.currObjType.isDragging = parent.currObjType.isCustomCrop = false;
      parent.activeObj.shapeDegree = parent.transform.degree;
      parent.activeObj.shapeFlip = parent.transform.currFlipState;
      parent.activeObj.textFlip = parent.transform.currFlipState;
      parent.activeObj.flipObjColl = [];
      var orderObj = { order: null };
      parent.notify("shape", { prop: "getNewOrder", onPropertyChange: false, value: { obj: orderObj } });
      parent.activeObj.order = orderObj["order"];
    };
    ToolbarModule2.prototype.isToolbarString = function(items) {
      var isString = false;
      for (var i = 0; i < items.length; i++) {
        if (typeof items[i] === "string") {
          isString = true;
          break;
        }
      }
      return isString;
    };
    ToolbarModule2.prototype.excludeItems = function(items) {
      var indexArr = [];
      for (var i = 0; i < items.length; i++) {
        var index = this.getIndex(items[i]);
        if (index !== -1) {
          indexArr.push(index);
        }
      }
      var negativeIndexArr = [];
      for (var i = 0; i < this.defToolbarItems.length; i++) {
        if (this.defToolbarItems[i].align === "Center" && !this.isSameIndex(indexArr, i) && this.defToolbarItems[i].id !== this.parent.element.id + "_annotation") {
          negativeIndexArr.push(i);
        }
      }
      for (var i = negativeIndexArr.length - 1; i >= 0; i--) {
        this.defToolbarItems.splice(negativeIndexArr[i], 1);
      }
    };
    ToolbarModule2.prototype.isSameIndex = function(indexArr, index) {
      for (var i = 0; i < indexArr.length; i++) {
        if (indexArr[i] === index) {
          return true;
        }
      }
      return false;
    };
    ToolbarModule2.prototype.getIndex = function(item) {
      var index = -1;
      var isFontColor = false;
      if (item === "rotateLeft") {
        item = "rotLeft";
      }
      if (item === "rotateRight") {
        item = "rotRight";
      }
      if (item === "horizontalFlip") {
        item = "hflip";
      }
      if (item === "verticalFlip") {
        item = "vflip";
      }
      if (item === "arrowStart") {
        item = "start";
      }
      if (item === "arrowEnd") {
        item = "end";
      }
      if (item === "fontColor") {
        item = "strokeColor";
        isFontColor = true;
      }
      for (var i = 0; i < this.defToolbarItems.length; i++) {
        var id = this.defToolbarItems[i].id;
        if (id && id.toLowerCase().indexOf(item.toLowerCase()) !== -1) {
          index = i;
          break;
        }
      }
      if (isFontColor) {
        item = "fontColor";
      }
      return index;
    };
    ToolbarModule2.prototype.getModuleName = function() {
      return "toolbar-module";
    };
    ToolbarModule2.prototype.redactSlider = function(type) {
      var parent = this.parent;
      var id = parent.element.id;
      var toolbarArea = parent.element.querySelector("#" + id + "_toolbarArea");
      var contextualToolbarArea = parent.element.querySelector("#" + id + "_contextualToolbarArea");
      if (!contextualToolbarArea) {
        return;
      }
      contextualToolbarArea.classList.remove("e-hide");
      contextualToolbarArea.style.left = toolbarArea.offsetLeft + "px";
      var canvasWrapper = (undefined).querySelector("#" + id + "_contextualToolbarArea");
      var hdrWrapper = (undefined).querySelector("#" + id + "_headWrapper");
      var labelWrapper = (undefined).querySelector("#" + id + "_labelWrapper");
      var ctxTbar = (undefined).querySelector("#" + id + "_contextualToolbar");
      if (hdrWrapper) {
        hdrWrapper.remove();
        labelWrapper.remove();
      }
      if (ctxTbar) {
        ctxTbar.remove();
        this.createContextualToolbar();
      }
      hdrWrapper = canvasWrapper.appendChild(parent.createElement("div", {
        id: id + "_headWrapper",
        styles: "position: relative"
      }));
      labelWrapper = hdrWrapper.appendChild(parent.createElement("label", {
        id: id + "_labelWrapper",
        className: "e-ie-finetune-slider-label",
        styles: Browser.isDevice ? "position: absolute; top: 31%; left: calc(50% - 160px); font-size: 15px; text-transform: capitalize; font-weight: 400;" : "position: absolute; top: 25%; left: calc(50% - 226px); font-size: 15px; text-transform: capitalize; font-weight: 400;"
      }));
      var text = type === "blur" ? this.l10n.getConstant("Blur") : this.l10n.getConstant("PixelSize");
      labelWrapper.textContent = text;
      var sliderWrapper = hdrWrapper.appendChild(parent.createElement("div", {
        id: id + "_sliderWrapper",
        className: "e-ie-finetune-slider-wrap",
        styles: "position: absolute"
      }));
      hdrWrapper.appendChild(parent.createElement("label", {
        id: id + "_redactSpan",
        className: "e-ie-redact-value-span",
        styles: Browser.isDevice ? "position: absolute; top: 30%; margin-left: 20px; font-size: 15px; text-transform: capitalize; font-weight: 400;" : "position: absolute; top: 30%; left: calc(50% + 190px); font-size: 15px; text-transform: capitalize; font-weight: 400;"
      }));
      sliderWrapper.parentElement.classList.add("e-finetune-slider");
      var value = parent.activeObj.redactType === "blur" ? parent.activeObj.redactBlur : parent.activeObj.redactPixelate;
      var redactSlider = new Slider({
        tooltip: { placement: "Before", isVisible: true, showOn: "Focus" },
        min: 10,
        max: 100,
        step: 1,
        value,
        type: "MinRange",
        width: Browser.isDevice ? "130px" : "300px",
        created: function() {
          parent.element.querySelector(".e-ie-redact-value-span").innerText = value.toString();
        },
        change: function(args) {
          parent.element.querySelector(".e-ie-redact-value-span").innerText = args.value.toString();
          if (parent.activeObj.redactType === "blur") {
            parent.activeObj.redactBlur = parent.tempRedactBlur = args.value;
          } else if (parent.activeObj.redactType === "pixelate") {
            parent.activeObj.redactPixelate = parent.tempRedactPixel = args.value;
          }
          parent.notify("draw", { prop: "drawObject", onPropertyChange: false, value: {
            canvas: "duplicate",
            obj: parent.activeObj,
            isCropRatio: null,
            points: null,
            isPreventDrag: true,
            saveContext: null,
            isPreventSelection: true
          } });
        },
        changed: function() {
          setTimeout(function() {
            parent.notify("undo-redo", { prop: "updateUndoRedoStack", onPropertyChange: false });
          }, 50);
        }
      });
      redactSlider.appendTo("#" + id + "_sliderWrapper");
      if (Browser.isDevice) {
        var cHt = contextualToolbarArea.offsetHeight + 1;
        var cusWrapper = parent.element.querySelector("#" + id + "_customizeWrapper");
        if (this.isFrameToolbar && cusWrapper) {
          cHt = cusWrapper.offsetHeight + 2;
        }
        var ht = parent.element.querySelector("#" + id + "_canvasWrapper").offsetHeight;
        contextualToolbarArea.style.top = this.toolbarHeight + 1 + ht - cHt + "px";
      }
    };
    return ToolbarModule2;
  }()
);
function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          newObj["" + key] = obj["" + key];
        }
      }
    }
    newObj.default = obj;
    return newObj;
  }
}
var curVue = _interopRequireWildcard(Vue);
var isExecute = parseInt(curVue["version"], 10) > 2 ? false : true;
var aVue = !isExecute ? curVue : curVue["default"]["default"] ? curVue["default"]["default"] : curVue["default"];
var gh = curVue["h"];
var vueDefineComponent = function(options) {
  return !isExecute ? aVue["defineComponent"](options) : aVue["extend"](options);
};
var ComponentBase = vueDefineComponent({
  name: "ComponentBase",
  data: function() {
    return {
      tagMapper: {},
      tagNameMapper: {},
      hasInjectedModules: false,
      hasChildDirective: false,
      childDirObjects: "",
      propKeys: {},
      isDecorator: false
    };
  },
  created: function() {
    var _this = this;
    if (this.ej2Instance) {
      this.ej2Instances = this.isVue3 ? aVue.toRaw(this.ej2Instance) : this.ej2Instance;
    }
    if (!this.propKeys) {
      return;
    }
    var _loop_1 = function(prop2) {
      this_1.ej2Instances.addEventListener(prop2, function(args) {
        _this.$emit(prop2, args);
      });
    };
    var this_1 = this;
    for (var _i = 0, _a = this.propKeys; _i < _a.length; _i++) {
      var prop = _a[_i];
      _loop_1(prop);
    }
    var injectables = getValue("$root.$options.provide", this);
    var vueInjectables = getValue("$parent.$options.provide", this);
    vueInjectables = !isNullOrUndefined(vueInjectables) ? vueInjectables : getValue("$.parent.provides", this);
    if (this.hasInjectedModules && !isExecute) {
      var prevModule = [];
      if (injectables && injectables.managed) {
        this.isDecorator = true;
        prevModule = this.getInjectedServices() || [];
      } else if (injectables) {
        prevModule = injectables[this.ej2Instances.getModuleName()] || [];
      } else if (vueInjectables) {
        prevModule = this.getInjectedServices() || [];
      }
      var curModule = this.ej2Instances.getInjectedModules() || [];
      for (var _b = 0, curModule_1 = curModule; _b < curModule_1.length; _b++) {
        var mod = curModule_1[_b];
        if (prevModule.indexOf(mod) === -1) {
          prevModule.push(mod);
        }
      }
      this.ej2Instances.injectedModules = prevModule;
    }
  },
  mounted: function() {
    var cusEle = this.$el ? this.$el.querySelectorAll("div.e-directive") : null;
    if (!isExecute && cusEle) {
      for (var i = 0; i < cusEle.length; i++) {
        var cusElement = cusEle[parseInt(i.toString(), 10)];
        if (cusElement.parentElement) {
          cusElement.parentElement.removeChild(cusElement);
        }
      }
    }
    this.ej2Instances.isVue = true;
    this.ej2Instances.isVue3 = this.isVue3;
    this.ej2Instances.vueInstance = this;
    if (this.isVue3) {
      this.ej2Instances.ej2Instances = this.ej2Instances;
      this.ej2Instances.referModels = this.models;
      this.setModelValue();
    }
    this.ej2Instances.appendTo(this.$el);
  },
  updated: function() {
    this.updated();
  },
  beforeDestroy: function() {
    this.destroyComponent();
  },
  beforeUnmount: function() {
    this.destroyComponent();
  },
  methods: {
    setModelValue: function() {
      if (!isNullOrUndefined(this.modelValue) || !isNullOrUndefined(this.$attrs.modelValue)) {
        var key = this.models.toString().match(/checked|value/) || [];
        var propKey = key[0];
        if (!isNullOrUndefined(propKey)) {
          this.ej2Instances["" + propKey] = !isNullOrUndefined(this.modelValue) ? this.modelValue : this.$attrs.modelValue;
        }
      }
    },
    updated: function() {
      if (this.isVue3) {
        this.setModelValue();
      }
      if (this.hasChildDirective) {
        var childKey = {};
        this.fetchChildPropValues(childKey);
        var curChildDir = JSON.stringify(childKey);
        if (this.childDirObjects !== curChildDir) {
          this.childDirObjects = curChildDir;
          this.assignValueToWrapper(childKey, false);
        }
      }
    },
    getInjectedServices: function() {
      var ret = [];
      var provide;
      if (this.$root && this.isDecorator) {
        provide = getValue("$root.$options.provide", this);
      } else if (this.$vnode) {
        provide = getValue("$vnode.context.$options.provide", this);
      } else if (this.$parent) {
        provide = getValue("$parent.$options.provide", this);
      }
      if (isNullOrUndefined(provide) && !isNullOrUndefined(this.$)) {
        provide = getValue("$.parent.provides", this);
      }
      if (provide) {
        var injectables = provide;
        if (typeof provide === "function") {
          if (provide.managed) {
            var pKey = provide.managed;
            var pValue = Object.keys(pKey);
            var key = undefined;
            if (this.$root && this.isDecorator) {
              key = Object.keys(this.$root);
            } else if (this.$vnode) {
              key = Object.keys(this.$vnode.context);
            } else if (this.$parent) {
              key = Object.keys(this.$parent);
            }
            for (var i = 0; i < pValue.length; i++) {
              for (var j = 0; j < key.length; j++) {
                if (key[parseInt(j.toString(), 10)].indexOf(pValue[parseInt(i.toString(), 10)]) !== -1) {
                  if (this.$root && this.isDecorator) {
                    pKey[pValue[parseInt(j.toString(), 10)]] = this.$root[key[parseInt(i.toString(), 10)]];
                  } else if (this.$vnode) {
                    pKey[pValue[parseInt(i.toString(), 10)]] = this.$vnode.context[key[parseInt(j.toString(), 10)]];
                  } else if (this.$parent) {
                    pKey[pValue[parseInt(i.toString(), 10)]] = this.$parent[key[parseInt(j.toString(), 10)]];
                  }
                  injectables = pKey;
                }
              }
            }
          } else if (this.$vnode) {
            injectables = this.$vnode.context.$options.provide();
          } else if (this.$parent) {
            injectables = this.$parent.$options.provide();
          }
        }
        ret = injectables[this.ej2Instances.getModuleName()] || [];
      }
      this.isDecorator = false;
      return ret;
    },
    destroyComponent: function() {
      this.ej2Instances.destroy();
      this.$el.style.visibility = "hidden";
      this.clearTemplate();
    },
    destroyPortals: function(element2) {
      if (element2) {
        var destroy2 = getValue("__vue__.$destroy", element2);
        if (destroy2) {
          element2.__vue__.$destroy();
        } else if (!isExecute && element2._vnode) {
          try {
            aVue.render(null, element2);
          } catch (e) {
          }
        }
        if (element2.innerHTML) {
          element2.innerHTML = "";
        }
      }
    },
    bindProperties: function() {
      var options = {};
      for (var _i = 0, _a = this.propKeys; _i < _a.length; _i++) {
        var prop = _a[_i];
        if (!isNullOrUndefined(this["" + prop])) {
          options["" + prop] = this["" + prop];
        } else if (this[0] && !isNullOrUndefined(this[0][0]) && !isNullOrUndefined(this[0][0]["" + prop])) {
          options["" + prop] = this[0][0]["" + prop];
        }
      }
      if (this.hasChildDirective) {
        this.fetchChildPropValues(options);
      }
      if (this.hasInjectedModules) {
        var prevModule = this.getInjectedServices() || [];
        var curModule = this.ej2Instances.getInjectedModules() || [];
        for (var _b = 0, curModule_2 = curModule; _b < curModule_2.length; _b++) {
          var mod = curModule_2[_b];
          if (prevModule.indexOf(mod) === -1) {
            prevModule.push(mod);
          }
        }
        this.ej2Instances.injectedModules = prevModule;
      }
      this.assignValueToWrapper(options);
    },
    assignValueToWrapper: function(option, silent) {
      this.ej2Instances.setProperties(extend({}, {}, option, true), isNullOrUndefined(silent) ? true : silent);
    },
    fetchChildPropValues: function(childOption) {
      var dirProps = {};
      if (!this.isVue3) {
        dirProps = this.getDirectiveValues(this.$slots.default, this.tagMapper || {}, this.tagNameMapper || {});
      } else {
        var propRef = undefined;
        if (this[0] && this[0][1].slots.default) {
          propRef = this[0][1].slots.default();
        } else if (this && this.$ && this.$.slots && this.$.slots.default) {
          propRef = this.$.slots.default();
        }
        if (propRef) {
          for (var i = 0; i < propRef.length; i++) {
            if (propRef[parseInt(i.toString(), 10)].type.methods || propRef[parseInt(i.toString(), 10)].type === "e-seriescollection") {
              var key = propRef[parseInt(i.toString(), 10)].type === "e-seriescollection" ? "series-collection" : propRef[parseInt(i.toString(), 10)].type.methods.getTag().replace("e-", "");
              var ref2 = this.resolveArrayDirectives(propRef[parseInt(i.toString(), 10)].children, key);
              var spKeys = key.split("-");
              var controlName = this.ej2Instances.getModuleName().toLowerCase();
              var keyRef = spKeys.length > 1 && controlName.indexOf(spKeys[0]) > -1 ? spKeys[1] : spKeys[0];
              keyRef = keyRef.replace(controlName, "");
              keyRef = this.tagNameMapper["e-" + key] ? this.tagNameMapper["e-" + key].replace("e-", "") : keyRef;
              if (controlName === "splitter" && keyRef === "panes") {
                keyRef = "paneSettings";
              } else if (controlName === "bulletchart" && keyRef === "range") {
                keyRef = "ranges";
              } else if (controlName === "schedule" && keyRef === "header") {
                keyRef = "headerRows";
              }
              dirProps["" + keyRef] = ref2["" + key];
            }
          }
        } else {
          return;
        }
      }
      if (!this.childDirObjects) {
        this.childDirObjects = JSON.stringify(dirProps);
      }
      for (var _i = 0, _a = Object.keys(dirProps); _i < _a.length; _i++) {
        var dirProp = _a[_i];
        childOption["" + dirProp] = dirProps["" + dirProp];
      }
    },
    resolveArrayDirectives: function(slots, tagName) {
      var slot = [];
      var innerDirValues;
      slot = slots.default ? slots.default() : slots;
      slot = slot.flatMap(function(item) {
        return Array.isArray(item.children) ? item.children : item;
      });
      var items = {};
      items["" + tagName] = [];
      var _loop_2 = function(childSlot2) {
        var tempObj = {};
        var tagRef = childSlot2.type.methods ? childSlot2.type.methods.getTag() : tagName;
        if (childSlot2.children) {
          var key = undefined;
          innerDirValues = this_2.resolveComplexDirs(childSlot2.children, this_2.tagMapper["e-" + tagName], tagRef);
          if (innerDirValues.length) {
            tempObj = innerDirValues;
          } else {
            for (var i = 0; i < Object.keys(innerDirValues).length; i++) {
              key = Object.keys(innerDirValues)[parseInt(i.toString(), 10)];
              tempObj["" + key] = innerDirValues["" + key];
            }
          }
        }
        if (childSlot2.props) {
          Object.keys(childSlot2.props).forEach(function(key2) {
            var propName = key2.replace(/-[a-z]/g, function(e) {
              return e[1].toUpperCase();
            });
            if (propName) {
              tempObj["" + propName] = childSlot2.props["" + key2];
            }
          });
        }
        if (/[s]\b/.test(tagRef) && innerDirValues && (!/[s]\b/.test(tagName) || innerDirValues.length)) {
          if (Array.isArray(tempObj)) {
            tempObj.forEach(function(item) {
              items["" + tagName].push(item);
            });
          } else {
            items["" + tagName].push(tempObj);
          }
        } else if (tempObj && Object.keys(tempObj).length !== 0) {
          items["" + tagName].push(tempObj);
        }
      };
      var this_2 = this;
      for (var _i = 0, slot_1 = slot; _i < slot_1.length; _i++) {
        var childSlot = slot_1[_i];
        _loop_2(childSlot);
      }
      return items;
    },
    resolveComplexDirs: function(slots, tagObject, tagName) {
      var slot = [];
      var innerDirValues;
      slot = slots.default ? slots.default() : slots;
      var items = {};
      var _loop_3 = function(childSlot2) {
        var tagRef = undefined;
        var tag = undefined;
        if (tagObject["" + tagName]) {
          tagRef = Object.keys(tagObject["" + tagName]);
          tag = tagRef.find(function(key) {
            return tagObject["" + tagName]["" + key] === childSlot2.type.methods.getTag().replace(/[s]\b/, "");
          });
          tag = tag ? tag : childSlot2.type.methods.getTag();
          tag = (this_3.tagNameMapper["" + tag] ? this_3.tagNameMapper["" + tag] : tag).replace("e-", "");
          if (this_3.ej2Instances.getModuleName().toLowerCase() === "diagram" && tag.indexOf("annotations") !== -1) {
            tag = "annotations";
          }
        }
        if (childSlot2.children) {
          innerDirValues = this_3.resolveComplexInnerDirs(childSlot2.children, tagObject["" + tagName], childSlot2.type.methods.getTag());
          if (!items["" + tag]) {
            items["" + tag] = [];
          }
          if (innerDirValues.length > 1) {
            items["" + tag] = innerDirValues;
          } else {
            items["" + tag].push(innerDirValues);
          }
        }
        if (childSlot2.props) {
          childSlot2.props = this_3.getCamelCaseProps(childSlot2.props);
        }
        if (slot.length > 1) {
          items = Object.keys(items).length === 0 && !items.length ? [] : items;
          if (childSlot2.props) {
            items.push(childSlot2.props);
          }
        } else {
          items = childSlot2.props ? Object.assign(items, childSlot2.props) : items;
        }
      };
      var this_3 = this;
      for (var _i = 0, slot_2 = slot; _i < slot_2.length; _i++) {
        var childSlot = slot_2[_i];
        _loop_3(childSlot);
      }
      return items;
    },
    resolveComplexInnerDirs: function(slots, tagObject, tagName) {
      var slot = [];
      slot = slots.default ? slots.default() : slots;
      var items = slot.length > 1 ? [] : {};
      for (var _i = 0, slot_3 = slot; _i < slot_3.length; _i++) {
        var childSlot = slot_3[_i];
        var innerDirValues = null;
        var tag = childSlot.type.methods.getTag();
        tag = (this.tagNameMapper["" + tag] ? this.tagNameMapper["" + tag] : tag).replace("e-", "");
        if (childSlot.children) {
          innerDirValues = this.resolveMultilevelComplexInnerDirs(childSlot.children, tagObject["" + tagName], childSlot.type.methods.getTag());
          if (/[s]\b/.test(tag) || slot.length > 1) {
            if (/[s]\b/.test(tag)) {
              items["" + tag] = !items["" + tag] ? [] : items["" + tag];
              if (innerDirValues.length) {
                items["" + tag] = innerDirValues;
              } else {
                items["" + tag].push(innerDirValues);
              }
            } else if (innerDirValues && !childSlot.props) {
              items.push(innerDirValues);
            }
          } else {
            items = innerDirValues ? innerDirValues : items;
          }
        }
        if (childSlot.props) {
          childSlot.props = this.getCamelCaseProps(childSlot.props);
        }
        if (slot.length > 1 && childSlot.props) {
          if (innerDirValues) {
            innerDirValues = childSlot.props ? Object.assign(innerDirValues, childSlot.props) : innerDirValues;
            items.push(innerDirValues);
          } else if (items.length >= 0) {
            items.push(childSlot.props);
          } else {
            items = childSlot.props ? Object.assign(items, childSlot.props) : items;
          }
        } else {
          items = childSlot.props ? Object.assign(items, childSlot.props) : items;
        }
      }
      return items;
    },
    resolveMultilevelComplexInnerDirs: function(slots, tagObject, tagName) {
      var slot = [];
      slot = slots.default ? slots.default() : slots;
      var items = slot.length > 1 ? [] : {};
      for (var _i = 0, slot_4 = slot; _i < slot_4.length; _i++) {
        var childSlot = slot_4[_i];
        var innerDirValues = null;
        var tag = childSlot.type.methods.getTag();
        tag = (this.tagNameMapper["" + tag] ? this.tagNameMapper["" + tag] : tag).replace("e-", "");
        if (childSlot.children) {
          innerDirValues = this.resolveComplexInnerDirs(childSlot.children, tagObject["" + tagName], childSlot.type.methods.getTag());
        }
        if (childSlot.props) {
          childSlot.props = this.getCamelCaseProps(childSlot.props);
        }
        if (/[s]\b/.test(tag)) {
          items["" + tag] = !items["" + tag] ? [] : items["" + tag];
          if (innerDirValues.length) {
            items["" + tag] = innerDirValues;
          } else {
            items["" + tag].push(innerDirValues);
          }
          if (childSlot.props) {
            items["" + tag].push(childSlot.props);
          }
        } else {
          items = innerDirValues;
          items = childSlot.props ? Object.assign(items, childSlot.props) : items;
        }
      }
      return items;
    },
    getDirectiveValues: function(tagDirectives, tagMapper, tagNameMapper) {
      var keyTags = Object.keys(tagMapper);
      var dir = {};
      if (tagDirectives) {
        for (var _i = 0, tagDirectives_1 = tagDirectives; _i < tagDirectives_1.length; _i++) {
          var tagDirective = tagDirectives_1[_i];
          var tagCompOption = tagDirective.componentOptions;
          if (tagCompOption && tagCompOption.children && this.getTagName(tagCompOption) || tagDirective.tag === "e-seriescollection" && tagDirective.children) {
            var dirTag = tagCompOption ? this.getTagName(tagCompOption) : tagDirective.tag;
            dirTag = dirTag === "e-seriescollection" ? "e-seriesCollection" : dirTag;
            if (keyTags.indexOf(dirTag) !== -1) {
              var tagName = tagNameMapper["" + dirTag] ? tagNameMapper["" + dirTag] : dirTag;
              dir[tagName.replace("e-", "")] = [];
              var children = tagCompOption ? tagCompOption.children : tagDirective.children;
              for (var _a = 0, children_1 = children; _a < children_1.length; _a++) {
                var tagDirChild = children_1[_a];
                var retObj = this.getVNodeValue(tagDirChild, tagMapper["" + dirTag], tagNameMapper);
                if (Object.keys(retObj).length !== 0) {
                  dir[tagName.replace("e-", "")].push(retObj);
                }
              }
            }
          }
        }
      }
      return dir;
    },
    getMultiLevelDirValue: function(tagDirectories, tagKey, tagNameMapper) {
      var mulObj = {};
      for (var _i = 0, tagDirectories_1 = tagDirectories; _i < tagDirectories_1.length; _i++) {
        var tagDir = tagDirectories_1[_i];
        var key = undefined;
        var children = undefined;
        if (tagDir.componentOptions) {
          key = this.getTagName(tagDir.componentOptions);
          if (tagDir.componentOptions.children) {
            children = tagDir.componentOptions.children;
          }
        } else if ((tagDir.tag === "e-markersettings" || tagDir.tag === "e-markersetting") && tagDir.children) {
          key = tagDir.tag === "e-markersettings" ? "e-markerSettings" : "e-markerSetting";
          children = tagDir.children;
        }
        if (key) {
          var tagName = tagNameMapper["" + key] ? tagNameMapper["" + key] : key;
          mulObj[tagName.replace("e-", "")] = [];
          if (children) {
            for (var _a = 0, children_2 = children; _a < children_2.length; _a++) {
              var tagDirChild = children_2[_a];
              var mulLevObj = this.getVNodeValue(tagDirChild, tagKey["" + key], tagNameMapper);
              if (Object.keys(mulLevObj).length !== 0) {
                mulObj[tagName.replace("e-", "")].push(mulLevObj);
              }
            }
          }
        }
      }
      return mulObj;
    },
    getVNodeValue: function(tagDirective, tagKey, tagNameMapper) {
      var ret = {};
      if (tagDirective.componentOptions || (tagDirective.tag === "e-markersettings" || tagDirective.tag === "e-markersetting") && tagDirective.context) {
        var dirTag = undefined;
        if (tagDirective.componentOptions) {
          dirTag = this.getTagName(tagDirective.componentOptions);
        } else {
          dirTag = tagDirective.tag === "e-markersettings" ? "e-markerSettings" : "e-markerSetting";
        }
        var tagData = tagDirective.data;
        if (typeof tagKey === "string" && dirTag === tagKey && tagData) {
          ret = tagData.attrs ? this.getCamelCaseProps(tagData.attrs) : this.getCamelCaseProps(tagData);
        } else if (typeof tagKey === "object") {
          if (tagDirective.componentOptions.children && Object.keys(tagKey).indexOf(dirTag) !== -1) {
            ret = this.getMultiLevelDirValue(tagDirective.componentOptions.children, tagKey["" + dirTag], tagNameMapper);
          } else if (tagDirective.children && Object.keys(tagKey).indexOf(dirTag) !== -1 && (dirTag === "e-markersettings" || dirTag === "e-markersetting")) {
            ret = this.getMultiLevelDirValue(tagDirective.children, tagKey["" + dirTag], tagNameMapper);
          }
          if (tagData && tagData.attrs) {
            ret = extend(ret, this.getCamelCaseProps(tagData.attrs));
          }
        }
      }
      return ret;
    },
    /**
     * convert kebab case directive props to camel case.
     *
     * @param {Object} props - Objects in kebab case directive props.
     * @returns {Object} Object converted into camel case directive props.
     */
    getCamelCaseProps: function(props2) {
      var retProps = {};
      for (var _i = 0, _a = Object.keys(props2); _i < _a.length; _i++) {
        var prop = _a[_i];
        retProps[prop.replace(/-[a-z]/g, function(e) {
          return e[1].toUpperCase();
        })] = props2["" + prop];
      }
      return retProps;
    },
    dataBind: function() {
      this.ej2Instances.dataBind();
    },
    setProperties: function(arg, muteOnChange) {
      return this.ej2Instances.setProperties(arg, muteOnChange);
    },
    getTagName: function(options) {
      var tag = options.tag;
      var optCtor = options.Ctor;
      if (!tag && optCtor && optCtor.extendOptions && optCtor.extendOptions.methods && optCtor.extendOptions.methods.getTag) {
        tag = options.Ctor.extendOptions.methods.getTag();
      }
      return tag;
    }
  }
});
function getProps(options) {
  if (options === undefined) {
    options = {};
  }
  if (options.props) {
    var _loop_4 = function(prop2) {
      (options.newprops || (options.newprops = {}))["" + prop2] = {};
      (options.watch || (options.watch = {}))["" + prop2] = function(newVal) {
        this.ej2Instances["" + prop2] = newVal;
        if (this.dataBind && options.name !== "DateRangePickerComponent") {
          this.dataBind();
        }
      };
    };
    for (var _i = 0, _a = options.props; _i < _a.length; _i++) {
      var prop = _a[_i];
      _loop_4(prop);
    }
  }
  return [options.newprops, options.watch];
}
if (!isExecute) {
  setProxyToRaw(aVue.toRaw);
}
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var stringCompiler = getTemplateEngine();
function compile(templateElement, helper) {
  var _this = this;
  return function(data, context, propName, element2, root) {
    var returnEle;
    if (context) {
      var plugins = context.vueInstance && context.vueInstance.plugins ? { plugins: context.vueInstance.plugins } : {};
      var vueInstance = context.vueInstance ? context.vueInstance : root && root.vueInstance ? root.vueInstance : null;
      var pid = getUniqueID("templateParentDiv");
      var id = getUniqueID("templateDiv");
      var ele = createElement("div", {
        id: pid,
        innerHTML: '<div id="' + id + '"></div>'
      });
      (undefined).body.appendChild(ele);
      if (!isExecute && (typeof templateElement === "string" || templateElement.prototype && templateElement.prototype.CSPTemplate && typeof templateElement === "function")) {
        var vueSlot_1 = getCurrentVueSlot(context.vueInstance, templateElement, root);
        if (vueSlot_1) {
          var app = aVue.createVNode({
            render: function() {
              return vueSlot_1["" + templateElement]({ data });
            }
          }, plugins);
          ele.innerHTML = "";
          getValues(app, context.vueInstance, root);
          aVue.render(app, ele);
          returnEle = ele.childNodes;
          if (vueInstance) {
            var templateInstance = vueInstance.templateCollection;
            if (!templateInstance) {
              vueInstance.templateCollection = {};
              templateInstance = vueInstance.templateCollection;
            }
            if (propName) {
              if (!templateInstance["" + propName]) {
                templateInstance["" + propName] = [];
              }
              templateInstance["" + propName].push(ele);
            }
          }
          detach(ele);
        } else {
          detach(ele);
          return stringCompiler(templateElement, helper)(data);
        }
      } else if (!isExecute) {
        var tempObj = templateElement.call(_this, {});
        var object = tempObj;
        var propsData = getValue("template.propsData", tempObj);
        var dataObj_1 = {
          data: { data: extend(tempObj.data || {}, data) },
          parent: context.vueInstance
        };
        if (!object.template) {
          object.template = object[Object.keys(object)[0]];
        }
        var templateCompRef = undefined;
        if (object.template.extends) {
          templateCompRef = object.template.extends._context.components.template;
        } else {
          templateCompRef = object.template._context.components[templateElement.name];
          if (!templateCompRef) {
            var key = Object.keys(object.template._context.components)[0];
            templateCompRef = object.template._context.components["" + key];
          }
        }
        var tempRef_1;
        if (propsData) {
          if (templateCompRef.setup) {
            tempRef_1 = Object.assign({}, propsData);
          } else {
            tempRef_1 = Object.assign(templateCompRef.data(), propsData);
          }
        } else {
          if (templateCompRef.setup) {
            tempRef_1 = Object.assign({}, dataObj_1.data);
          } else {
            tempRef_1 = Object.assign(templateCompRef.data(), dataObj_1.data);
          }
          if (templateCompRef.components) {
            var objkeys = Object.keys(templateCompRef.components) || [];
            var _loop_1 = function(objstring2) {
              var intComponent = templateCompRef.components["" + objstring2];
              if (intComponent && intComponent.data) {
                if (!intComponent.__data) {
                  intComponent.__data = intComponent.data;
                }
                intComponent.data = function(proxy) {
                  return Object.assign(intComponent.__data.call(proxy), dataObj_1.data);
                };
              }
            };
            for (var _i = 0, objkeys_1 = objkeys; _i < objkeys_1.length; _i++) {
              var objstring = objkeys_1[_i];
              _loop_1(objstring);
            }
          }
        }
        if (templateCompRef.setup) {
          plugins = Object.assign(plugins, data);
        }
        templateCompRef.data = function() {
          return tempRef_1;
        };
        var app = aVue.createVNode(templateCompRef, plugins);
        ele.innerHTML = "";
        getValues(app, context.vueInstance, root);
        aVue.render(app, ele);
        returnEle = ele.childNodes;
        dataObj_1.parent = null;
        if (vueInstance) {
          var templateInstance = vueInstance.templateCollection;
          if (!templateInstance) {
            vueInstance.templateCollection = {};
            templateInstance = vueInstance.templateCollection;
          }
          if (propName) {
            if (!templateInstance["" + propName]) {
              templateInstance["" + propName] = [];
            }
            templateInstance["" + propName].push(ele);
          }
        }
        detach(ele);
      } else if (typeof templateElement === "string" || templateElement.prototype && templateElement.prototype.CSPTemplate && typeof templateElement === "function") {
        var vueSlot_2 = getVueSlot(context.vueInstance, templateElement, root);
        if (vueSlot_2) {
          var provided_1 = {};
          var getProvideValues_1 = function(vueinstance) {
            if (vueinstance["$parent"]) {
              getProvideValues_1(vueinstance.$parent);
            }
            if (vueinstance["_provided"] && Object.keys(vueinstance["_provided"]).length > 0) {
              provided_1 = __assign({}, provided_1, vueinstance._provided);
            }
          };
          var vueInstance_1 = context.vueInstance ? context.vueInstance : root && root.vueInstance ? root.vueInstance : null;
          if (vueInstance_1) {
            getProvideValues_1(vueInstance_1);
          }
          var vueTemplate = new aVue({
            provide: __assign({}, provided_1),
            render: function() {
              return vueSlot_2["" + templateElement]({ data });
            }
          });
          vueTemplate.$mount("#" + id);
          returnEle = ele.childNodes;
          if (vueInstance_1) {
            var templateInstance = vueInstance_1.templateCollection;
            if (!templateInstance) {
              vueInstance_1.templateCollection = {};
              templateInstance = vueInstance_1.templateCollection;
            }
            if (propName) {
              if (!templateInstance["" + propName]) {
                templateInstance["" + propName] = [];
              }
              templateInstance["" + propName].push(returnEle[0]);
            }
          }
          detach(ele);
        } else {
          detach(ele);
          return stringCompiler(templateElement, helper)(data);
        }
      } else {
        var tempObj = templateElement.call(_this, {});
        var templateFunction = tempObj.template;
        var propsData = getValue("template.propsData", tempObj);
        var dataObj = {
          data: { data: extend(tempObj.data || {}, data) },
          parent: context.vueInstance
        };
        if (propsData) {
          templateFunction = tempObj.template.extends;
          dataObj.propsData = propsData;
        }
        if (typeof templateFunction !== "function") {
          templateFunction = aVue.extend(templateFunction);
        }
        if (templateFunction.options.setup) {
          dataObj.propsData = Object.assign(dataObj.propsData || {}, data);
        }
        var templateVue = new templateFunction(dataObj);
        templateVue.$mount("#" + id);
        returnEle = ele.childNodes;
        dataObj.parent = null;
        if (vueInstance) {
          var templateInstance = vueInstance.templateCollection;
          if (!templateInstance) {
            vueInstance.templateCollection = {};
            templateInstance = vueInstance.templateCollection;
          }
          if (propName) {
            if (!templateInstance["" + propName]) {
              templateInstance["" + propName] = [];
            }
            templateInstance["" + propName].push(returnEle[0]);
          }
        }
        detach(ele);
      }
    }
    return returnEle || [];
  };
}
setTemplateEngine({ compile });
function getValues(app, cInstance, root) {
  var vueInstance = cInstance ? cInstance : root && root.vueInstance ? root.vueInstance : null;
  if (!vueInstance) {
    return;
  }
  app["appContext"] = vueInstance["$"]["appContext"];
  var provided = {};
  var getProvideValue = function(vueinstance) {
    if (vueinstance["$"] && vueinstance["$"]["parent"]) {
      getProvideValue(vueinstance.$.parent);
    }
    if (vueinstance["provides"] && Object.keys(vueinstance["provides"]).length > 0) {
      provided = __assign({}, provided, vueinstance.provides);
    }
  };
  getProvideValue(vueInstance);
  if (app["appContext"]["provides"]) {
    app.appContext.provides = __assign({}, app.appContext.provides, provided);
  }
}
function getVueSlot(vueInstance, templateElement, root) {
  if (!vueInstance && !(root && root.vueInstance)) {
    return undefined;
  }
  var instance = root && root.vueInstance ? root.vueInstance : vueInstance;
  return getVueChildSlot(instance, templateElement);
}
function getVueChildSlot(vueInstance, templateElement) {
  if (!vueInstance) {
    return undefined;
  }
  var slots = vueInstance.$slots;
  var scopedSlots = vueInstance.$scopedSlots;
  var vSlots = vueInstance.scopedSlots;
  var children = vueInstance.children;
  if (scopedSlots && scopedSlots["" + templateElement]) {
    return scopedSlots;
  } else if (slots && slots.default) {
    var childSlots = slots.default;
    for (var i = 0; i < childSlots.length; i++) {
      var slot = getVueChildSlot(getSlot(childSlots[parseInt(i.toString(), 10)]), templateElement);
      if (slot) {
        return slot;
      }
    }
  } else if (vSlots && vSlots["" + templateElement]) {
    return vSlots;
  } else if (children) {
    for (var i = 0; i < children.length; i++) {
      var slot = getVueChildSlot(getSlot(children[parseInt(i.toString(), 10)]), templateElement);
      if (slot) {
        return slot;
      }
    }
  }
  return undefined;
}
function getSlot(vnode) {
  var slot = vnode.componentOptions && vnode.componentOptions.children ? vnode.componentOptions : !vnode.data && (vnode.tag === "e-markersettings" || vnode.tag === "e-markersetting") ? vnode : vnode.data;
  return vnode.componentInstance ? vnode.componentInstance : slot;
}
function getCurrentVueSlot(vueInstance, templateElement, root) {
  if (!vueInstance && !(root && root.vueInstance)) {
    return undefined;
  }
  var slots = root && root.vueInstance ? root.vueInstance.$slots : vueInstance.$slots;
  return getChildVueSlot(slots, templateElement);
}
function getChildVueSlot(slots, templateElement) {
  if (slots && slots["" + templateElement]) {
    return slots;
  } else if (slots && slots.default) {
    var childSlots = slots.default();
    childSlots = childSlots.flatMap(function(item) {
      return Array.isArray(item.children) ? item.children : item;
    });
    for (var i = 0; i < childSlots.length; i++) {
      var slot = getChildVueSlot(childSlots[parseInt(i.toString(), 10)].children, templateElement);
      if (slot) {
        return slot;
      }
    }
  }
  return undefined;
}
var properties = ["isLazyUpdate", "plugins", "allowUndoRedo", "cssClass", "disabled", "enablePersistence", "enableRtl", "finetuneSettings", "fontFamily", "height", "isReadOnly", "locale", "quickAccessToolbarTemplate", "selectionSettings", "showQuickAccessToolbar", "theme", "toolbar", "toolbarTemplate", "uploadSettings", "width", "zoomSettings", "beforeSave", "click", "created", "cropping", "destroyed", "editComplete", "fileOpened", "finetuneValueChanging", "flipping", "frameChange", "imageFiltering", "panning", "quickAccessToolbarItemClick", "quickAccessToolbarOpen", "resizing", "rotating", "saved", "selectionChanging", "shapeChange", "shapeChanging", "toolbarCreated", "toolbarItemClicked", "toolbarUpdating", "zooming"];
var modelProps = [];
var testProp = getProps({ props: properties });
var props = testProp[0], watch = testProp[1], emitProbs = Object.keys(watch);
emitProbs.push("modelchanged", "update:modelValue");
for (var _i = 0, modelProps_1 = modelProps; _i < modelProps_1.length; _i++) {
  var props_1 = modelProps_1[_i];
  emitProbs.push("update:" + props_1);
}
var ImageEditorComponent = vueDefineComponent({
  name: "ImageEditorComponent",
  mixins: [ComponentBase],
  props,
  watch,
  emits: emitProbs,
  provide: function() {
    return { custom: this.custom };
  },
  data: function() {
    return {
      ej2Instances: new ImageEditor({}),
      propKeys: properties,
      models: modelProps,
      hasChildDirective: false,
      hasInjectedModules: false,
      tagMapper: {},
      tagNameMapper: {},
      isVue3: !isExecute,
      templateCollection: {}
    };
  },
  created: function() {
    this.bindProperties();
    this.ej2Instances._setProperties = this.ej2Instances.setProperties;
    this.ej2Instances.setProperties = this.setProperties;
    this.ej2Instances.clearTemplate = this.clearTemplate;
    this.updated = this.updated;
  },
  render: function(createElement2) {
    var h = !isExecute ? gh : createElement2;
    var slots = null;
    if (!isNullOrUndefined(this.$slots.default)) {
      slots = !isExecute ? this.$slots.default() : this.$slots.default;
    }
    return h("div", slots);
  },
  methods: {
    clearTemplate: function(templateNames) {
      if (!templateNames) {
        templateNames = Object.keys(this.templateCollection || {});
      }
      if (templateNames.length && this.templateCollection) {
        for (var _i = 0, templateNames_1 = templateNames; _i < templateNames_1.length; _i++) {
          var tempName = templateNames_1[_i];
          var elementCollection = this.templateCollection[tempName];
          if (elementCollection && elementCollection.length) {
            for (var _a = 0, elementCollection_1 = elementCollection; _a < elementCollection_1.length; _a++) {
              var ele = elementCollection_1[_a];
              this.destroyPortals(ele);
            }
            delete this.templateCollection[tempName];
          }
        }
      }
    },
    setProperties: function(prop, muteOnChange) {
      var _this = this;
      if (this.isVue3) {
        this.models = !this.models ? this.ej2Instances.referModels : this.models;
      }
      if (this.ej2Instances && this.ej2Instances._setProperties) {
        this.ej2Instances._setProperties(prop, muteOnChange);
      }
      if (prop && this.models && this.models.length) {
        Object.keys(prop).map(function(key) {
          _this.models.map(function(model) {
            if (key === model && !/datasource/i.test(key)) {
              if (_this.isVue3) {
                _this.ej2Instances.vueInstance.$emit("update:" + key, prop[key]);
              } else {
                _this.$emit("update:" + key, prop[key]);
                _this.$emit("modelchanged", prop[key]);
              }
            }
          });
        });
      }
    },
    custom: function() {
      this.updated();
    },
    apply: function() {
      return this.ej2Instances.apply();
    },
    applyImageFilter: function(filterOption) {
      return this.ej2Instances.applyImageFilter(filterOption);
    },
    bringForward: function(shapeId) {
      return this.ej2Instances.bringForward(shapeId);
    },
    bringToFront: function(shapeId) {
      return this.ej2Instances.bringToFront(shapeId);
    },
    canRedo: function() {
      return this.ej2Instances.canRedo();
    },
    canUndo: function() {
      return this.ej2Instances.canUndo();
    },
    clearImage: function() {
      return this.ej2Instances.clearImage();
    },
    clearSelection: function(resetCrop) {
      return this.ej2Instances.clearSelection(resetCrop);
    },
    cloneShape: function(shapeId) {
      return this.ej2Instances.cloneShape(shapeId);
    },
    crop: function() {
      return this.ej2Instances.crop();
    },
    deleteRedact: function(id) {
      return this.ej2Instances.deleteRedact(id);
    },
    deleteShape: function(id) {
      return this.ej2Instances.deleteShape(id);
    },
    destroy: function() {
      return this.ej2Instances.destroy();
    },
    discard: function() {
      return this.ej2Instances.discard();
    },
    drawArrow: function(startX, startY, endX, endY, strokeWidth, strokeColor, arrowStart, arrowEnd, isSelected) {
      return this.ej2Instances.drawArrow(startX, startY, endX, endY, strokeWidth, strokeColor, arrowStart, arrowEnd, isSelected);
    },
    drawEllipse: function(x, y, radiusX, radiusY, strokeWidth, strokeColor, fillColor, degree, isSelected) {
      return this.ej2Instances.drawEllipse(x, y, radiusX, radiusY, strokeWidth, strokeColor, fillColor, degree, isSelected);
    },
    drawFrame: function(frameType, color, gradientColor, size, inset, offset, borderRadius, frameLineStyle, lineCount) {
      return this.ej2Instances.drawFrame(frameType, color, gradientColor, size, inset, offset, borderRadius, frameLineStyle, lineCount);
    },
    drawImage: function(data, x, y, width, height, isAspectRatio, degree, opacity, isSelected) {
      return this.ej2Instances.drawImage(data, x, y, width, height, isAspectRatio, degree, opacity, isSelected);
    },
    drawLine: function(startX, startY, endX, endY, strokeWidth, strokeColor, isSelected) {
      return this.ej2Instances.drawLine(startX, startY, endX, endY, strokeWidth, strokeColor, isSelected);
    },
    drawPath: function(pointColl, strokeWidth, strokeColor, isSelected) {
      return this.ej2Instances.drawPath(pointColl, strokeWidth, strokeColor, isSelected);
    },
    drawRectangle: function(x, y, width, height, strokeWidth, strokeColor, fillColor, degree, isSelected, borderRadius) {
      return this.ej2Instances.drawRectangle(x, y, width, height, strokeWidth, strokeColor, fillColor, degree, isSelected, borderRadius);
    },
    drawRedact: function(type, x, y, width, height, value) {
      return this.ej2Instances.drawRedact(type, x, y, width, height, value);
    },
    drawText: function(x, y, text, fontFamily, fontSize, bold, italic, color, isSelected, degree, fillColor, strokeColor, strokeWidth, transformCollection) {
      return this.ej2Instances.drawText(x, y, text, fontFamily, fontSize, bold, italic, color, isSelected, degree, fillColor, strokeColor, strokeWidth, transformCollection);
    },
    enableShapeDrawing: function(shapeType, isEnabled) {
      return this.ej2Instances.enableShapeDrawing(shapeType, isEnabled);
    },
    enableTextEditing: function() {
      return this.ej2Instances.enableTextEditing();
    },
    export: function(type, fileName, imageQuality) {
      return this.ej2Instances.export(type, fileName, imageQuality);
    },
    finetuneImage: function(finetuneOption, value) {
      return this.ej2Instances.finetuneImage(finetuneOption, value);
    },
    flip: function(direction) {
      return this.ej2Instances.flip(direction);
    },
    freehandDraw: function(value) {
      return this.ej2Instances.freehandDraw(value);
    },
    getImageData: function(includeAnnotations) {
      return this.ej2Instances.getImageData(includeAnnotations);
    },
    getImageDimension: function() {
      return this.ej2Instances.getImageDimension();
    },
    getImageFilter: function(filterOption) {
      return this.ej2Instances.getImageFilter(filterOption);
    },
    getRedacts: function() {
      return this.ej2Instances.getRedacts();
    },
    getShapeSetting: function(id) {
      return this.ej2Instances.getShapeSetting(id);
    },
    getShapeSettings: function() {
      return this.ej2Instances.getShapeSettings();
    },
    initialize: function() {
      return this.ej2Instances.initialize();
    },
    open: function(data, resetChanges, imageSettings) {
      return this.ej2Instances.open(data, resetChanges, imageSettings);
    },
    pan: function(value, x, y) {
      return this.ej2Instances.pan(value, x, y);
    },
    redo: function() {
      return this.ej2Instances.redo();
    },
    reset: function() {
      return this.ej2Instances.reset();
    },
    resize: function(width, height, isAspectRatio) {
      return this.ej2Instances.resize(width, height, isAspectRatio);
    },
    rotate: function(degree) {
      return this.ej2Instances.rotate(degree);
    },
    select: function(type, startX, startY, width, height) {
      return this.ej2Instances.select(type, startX, startY, width, height);
    },
    selectRedact: function(id) {
      return this.ej2Instances.selectRedact(id);
    },
    selectShape: function(id) {
      return this.ej2Instances.selectShape(id);
    },
    sendBackward: function(shapeId) {
      return this.ej2Instances.sendBackward(shapeId);
    },
    sendToBack: function(shapeId) {
      return this.ej2Instances.sendToBack(shapeId);
    },
    straightenImage: function(degree) {
      return this.ej2Instances.straightenImage(degree);
    },
    triggerEditCompleteEvent: function(args) {
      return this.ej2Instances.triggerEditCompleteEvent(args);
    },
    undo: function() {
      return this.ej2Instances.undo();
    },
    update: function() {
      return this.ej2Instances.update();
    },
    updateRedact: function(setting, isSelected) {
      return this.ej2Instances.updateRedact(setting, isSelected);
    },
    updateShape: function(setting, isSelected) {
      return this.ej2Instances.updateShape(setting, isSelected);
    },
    zoom: function(zoomFactor, zoomPoint) {
      return this.ej2Instances.zoom(zoomFactor, zoomPoint);
    }
  }
});
const _sfc_main = {
  __name: "FichaCard",
  __ssrInlineRender: true,
  props: {
    show: Boolean,
    item: Object,
    isView: {
      type: Boolean,
      default: false
    },
    linkView: String,
    images: {
      type: Array,
      default: () => []
    },
    pessoaObj: Object
  },
  emits: ["close", "confirmar"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const toolbar = ["RotateLeft", "RotateRight", "Crop", "ZoomIn", "ZoomOut"];
    const config = useRuntimeConfig();
    const { $toast } = useNuxtApp();
    registerLicense(`${config.public.docEditor}`);
    const transformarTiffParaPng = `${config.public.managemant}/minio/tiff_para_png`;
    const atualizarFicha = `${config.public.managemant}/minio/update_image`;
    const imageEditorRef = ref(null);
    const isVisible2 = ref(props2.show);
    const currentIndex = ref(0);
    const fichaRender = ref(props2.linkView || null);
    const isCropActive = ref(false);
    ref([]);
    const emit = __emit;
    const images = computed(() => {
      if (props2.images && props2.images.length > 0) {
        if (Array.isArray(props2.images[0])) {
          return props2.images;
        }
        return props2.images;
      }
      return props2.linkView ? [props2.linkView] : [];
    });
    const onToolbarUpdating = (args) => {
      if (args.toolbarType === "crop-transform") {
        isCropActive.value = true;
        return;
      }
      isCropActive.value = false;
    };
    const confirmarRecebimento = () => {
      emit("confirmar");
      closeModal();
    };
    const nextImage = () => {
      if (currentIndex.value < images.value[0].length - 1) {
        currentIndex.value++;
        loadCurrentImage();
      }
    };
    const previousImage = () => {
      if (currentIndex.value > 0) {
        currentIndex.value--;
        loadCurrentImage();
      }
    };
    const selectImage = (index) => {
      currentIndex.value = index;
      loadCurrentImage();
    };
    const editarImagem = async () => {
      var _a;
      try {
        const imageEditor = (_a = imageEditorRef.value) == null ? void 0 : _a.ej2Instances;
        if (!imageEditor) return;
        const imageData = imageEditor.getImageData();
        const canvas = (void 0).createElement("canvas");
        canvas.width = imageData.width;
        canvas.height = imageData.height;
        const ctx = canvas.getContext("2d");
        ctx.putImageData(imageData, 0, 0);
        const blob = await new Promise((resolve) => {
          canvas.toBlob((blob2) => {
            resolve(blob2);
          }, "image/png");
        });
        const formData = new FormData();
        formData.append(
          "cartorio_token",
          useCookie("user-data").value.cartorio_token
        );
        formData.append("path", images.value[0][currentIndex.value].path);
        formData.append("file", blob, `ficha_editada_${currentIndex.value}.png`);
        const { status } = await useFetch(atualizarFicha, {
          method: "PUT",
          body: formData
        }, "$4omB3S9Tg3");
        if (status.value === "success") {
          $toast.success(`Ficha ${currentIndex.value + 1} atualizada com sucesso!`);
        }
      } catch (error) {
        console.error("Erro ao editar imagem:", error);
        $toast.error("Erro ao atualizar a ficha");
      }
    };
    const loadImageIntoEditor = async (imageUrl) => {
      var _a;
      if (!imageUrl || !((_a = imageEditorRef.value) == null ? undefined : _a.ej2Instances)) return;
      try {
        const imageEditor = imageEditorRef.value.ej2Instances;
        const response = await fetch(imageUrl.url);
        const blob = await response.blob();
        const file = new File([blob], "image.tiff", {
          type: blob.type || "application/octet-stream"
        });
        const formData = new FormData();
        formData.append("tipo", "ficha");
        formData.append(
          "cartorio_token",
          useCookie("user-data").value.cartorio_token
        );
        formData.append("path", imageUrl.path);
        formData.append("pessoa_token", props2.pessoaObj.token);
        formData.append("file", file);
        const { data: imagemBiometria } = await useFetch(transformarTiffParaPng, {
          method: "POST",
          body: formData
        }, "$yanMHqBuqW");
        await imageEditor.open(imagemBiometria.value.msg);
      } catch (error) {
        console.error("Erro ao carregar imagem no editor:", error);
      }
    };
    const loadCurrentImage = async () => {
      if (images.value[0].length > 0 && currentIndex.value < images.value[0].length) {
        await loadImageIntoEditor(images.value[0][currentIndex.value]);
      }
    };
    watch$1(
      () => props2.linkView,
      async (newLinkView) => {
        if (newLinkView) {
          fichaRender.value = newLinkView;
          currentIndex.value = 0;
          await loadCurrentImage();
        }
      },
      { immediate: true }
    );
    watch$1(
      () => props2.images,
      async (newImages) => {
        if (newImages && newImages.length > 0) {
          currentIndex.value = 0;
          await loadCurrentImage();
        }
      },
      { immediate: true, deep: true }
    );
    watch$1(
      () => currentIndex.value,
      async (newIndex, oldIndex) => {
        if (newIndex !== oldIndex && oldIndex !== undefined) {
          await loadCurrentImage();
        }
      }
    );
    const closeModal = () => {
      isVisible2.value = false;
      fichaRender.value = null;
      currentIndex.value = 0;
      emit("close");
    };
    return (_ctx, _push, _parent, _attrs) => {
      _push(ssrRenderComponent(VDialog, mergeProps({
        persistent: "",
        modelValue: unref(isVisible2),
        "onUpdate:modelValue": ($event) => isRef(isVisible2) ? isVisible2.value = $event : null,
        "max-width": "1200"
      }, _attrs), {
        default: withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(ssrRenderComponent(VCard, null, {
              default: withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(ssrRenderComponent(VCardTitle, { class: "text-h5 d-flex justify-space-between align-center" }, {
                    default: withCtx((_3, _push4, _parent4, _scopeId3) => {
                      if (_push4) {
                        _push4(`<span${_scopeId3}>Ficha de Firma</span>`);
                        if (unref(images)[0].length > 1) {
                          _push4(`<div class="d-flex align-center"${_scopeId3}>`);
                          _push4(ssrRenderComponent(VBtn, {
                            icon: "",
                            small: "",
                            onClick: previousImage,
                            disabled: unref(currentIndex) === 0
                          }, {
                            default: withCtx((_4, _push5, _parent5, _scopeId4) => {
                              if (_push5) {
                                _push5(ssrRenderComponent(VIcon, null, {
                                  default: withCtx((_5, _push6, _parent6, _scopeId5) => {
                                    if (_push6) {
                                      _push6(`mdi-chevron-left`);
                                    } else {
                                      return [
                                        createTextVNode("mdi-chevron-left")
                                      ];
                                    }
                                  }),
                                  _: 1
                                }, _parent5, _scopeId4));
                              } else {
                                return [
                                  createVNode(VIcon, null, {
                                    default: withCtx(() => [
                                      createTextVNode("mdi-chevron-left")
                                    ]),
                                    _: 1
                                  })
                                ];
                              }
                            }),
                            _: 1
                          }, _parent4, _scopeId3));
                          _push4(`<span class="mx-2"${_scopeId3}>${ssrInterpolate(unref(currentIndex) + 1)} / ${ssrInterpolate(unref(images)[0].length)}</span>`);
                          _push4(ssrRenderComponent(VBtn, {
                            icon: "",
                            small: "",
                            onClick: nextImage,
                            disabled: unref(currentIndex) === unref(images)[0].length - 1
                          }, {
                            default: withCtx((_4, _push5, _parent5, _scopeId4) => {
                              if (_push5) {
                                _push5(ssrRenderComponent(VIcon, null, {
                                  default: withCtx((_5, _push6, _parent6, _scopeId5) => {
                                    if (_push6) {
                                      _push6(`mdi-chevron-right`);
                                    } else {
                                      return [
                                        createTextVNode("mdi-chevron-right")
                                      ];
                                    }
                                  }),
                                  _: 1
                                }, _parent5, _scopeId4));
                              } else {
                                return [
                                  createVNode(VIcon, null, {
                                    default: withCtx(() => [
                                      createTextVNode("mdi-chevron-right")
                                    ]),
                                    _: 1
                                  })
                                ];
                              }
                            }),
                            _: 1
                          }, _parent4, _scopeId3));
                          _push4(`</div>`);
                        } else {
                          _push4(`<!---->`);
                        }
                      } else {
                        return [
                          createVNode("span", null, "Ficha de Firma"),
                          unref(images)[0].length > 1 ? (openBlock(), createBlock("div", {
                            key: 0,
                            class: "d-flex align-center"
                          }, [
                            createVNode(VBtn, {
                              icon: "",
                              small: "",
                              onClick: previousImage,
                              disabled: unref(currentIndex) === 0
                            }, {
                              default: withCtx(() => [
                                createVNode(VIcon, null, {
                                  default: withCtx(() => [
                                    createTextVNode("mdi-chevron-left")
                                  ]),
                                  _: 1
                                })
                              ]),
                              _: 1
                            }, 8, ["disabled"]),
                            createVNode("span", { class: "mx-2" }, toDisplayString(unref(currentIndex) + 1) + " / " + toDisplayString(unref(images)[0].length), 1),
                            createVNode(VBtn, {
                              icon: "",
                              small: "",
                              onClick: nextImage,
                              disabled: unref(currentIndex) === unref(images)[0].length - 1
                            }, {
                              default: withCtx(() => [
                                createVNode(VIcon, null, {
                                  default: withCtx(() => [
                                    createTextVNode("mdi-chevron-right")
                                  ]),
                                  _: 1
                                })
                              ]),
                              _: 1
                            }, 8, ["disabled"])
                          ])) : createCommentVNode("", true)
                        ];
                      }
                    }),
                    _: 1
                  }, _parent3, _scopeId2));
                  if (unref(images)[0].length > 1) {
                    _push3(`<div class="d-flex justify-center pa-2"${_scopeId2}>`);
                    _push3(ssrRenderComponent(VChipGroup, {
                      modelValue: unref(currentIndex),
                      "onUpdate:modelValue": ($event) => isRef(currentIndex) ? currentIndex.value = $event : null,
                      mandatory: ""
                    }, {
                      default: withCtx((_3, _push4, _parent4, _scopeId3) => {
                        if (_push4) {
                          _push4(`<!--[-->`);
                          ssrRenderList(unref(images)[0], (image, index) => {
                            _push4(ssrRenderComponent(VChip, {
                              key: index,
                              value: index,
                              small: "",
                              onClick: ($event) => selectImage(index),
                              class: { "v-chip--active": index === unref(currentIndex) }
                            }, {
                              default: withCtx((_4, _push5, _parent5, _scopeId4) => {
                                if (_push5) {
                                  _push5(`${ssrInterpolate(index + 1)}`);
                                } else {
                                  return [
                                    createTextVNode(toDisplayString(index + 1), 1)
                                  ];
                                }
                              }),
                              _: 2
                            }, _parent4, _scopeId3));
                          });
                          _push4(`<!--]-->`);
                        } else {
                          return [
                            (openBlock(true), createBlock(Fragment, null, renderList(unref(images)[0], (image, index) => {
                              return openBlock(), createBlock(VChip, {
                                key: index,
                                value: index,
                                small: "",
                                onClick: ($event) => selectImage(index),
                                class: { "v-chip--active": index === unref(currentIndex) }
                              }, {
                                default: withCtx(() => [
                                  createTextVNode(toDisplayString(index + 1), 1)
                                ]),
                                _: 2
                              }, 1032, ["value", "onClick", "class"]);
                            }), 128))
                          ];
                        }
                      }),
                      _: 1
                    }, _parent3, _scopeId2));
                    _push3(`</div>`);
                  } else {
                    _push3(`<!---->`);
                  }
                  _push3(`<div class="d-flex justify-center align-center"${_scopeId2}>`);
                  _push3(ssrRenderComponent(unref(ImageEditorComponent), {
                    height: "750px",
                    width: "850px",
                    ref_key: "imageEditorRef",
                    ref: imageEditorRef,
                    toolbar,
                    toolbarUpdating: onToolbarUpdating
                  }, null, _parent3, _scopeId2));
                  _push3(`</div>`);
                  _push3(ssrRenderComponent(VCardActions, null, {
                    default: withCtx((_3, _push4, _parent4, _scopeId3) => {
                      if (_push4) {
                        _push4(ssrRenderComponent(VBtn, {
                          style: { "background-color": "#429946", "color": "white" },
                          onClick: editarImagem,
                          disabled: unref(isCropActive)
                        }, {
                          default: withCtx((_4, _push5, _parent5, _scopeId4) => {
                            if (_push5) {
                              _push5(`Salvar`);
                            } else {
                              return [
                                createTextVNode("Salvar")
                              ];
                            }
                          }),
                          _: 1
                        }, _parent4, _scopeId3));
                        if (!props2.isView) {
                          _push4(ssrRenderComponent(VBtn, {
                            style: { "background-color": "#085a98", "color": "white" },
                            onClick: confirmarRecebimento
                          }, {
                            default: withCtx((_4, _push5, _parent5, _scopeId4) => {
                              if (_push5) {
                                _push5(`Reconhecer`);
                              } else {
                                return [
                                  createTextVNode("Reconhecer")
                                ];
                              }
                            }),
                            _: 1
                          }, _parent4, _scopeId3));
                        } else {
                          _push4(`<!---->`);
                        }
                        _push4(ssrRenderComponent(VBtn, {
                          style: { "background-color": "red", "color": "white" },
                          onClick: closeModal
                        }, {
                          default: withCtx((_4, _push5, _parent5, _scopeId4) => {
                            if (_push5) {
                              _push5(`Voltar`);
                            } else {
                              return [
                                createTextVNode("Voltar")
                              ];
                            }
                          }),
                          _: 1
                        }, _parent4, _scopeId3));
                      } else {
                        return [
                          createVNode(VBtn, {
                            style: { "background-color": "#429946", "color": "white" },
                            onClick: editarImagem,
                            disabled: unref(isCropActive)
                          }, {
                            default: withCtx(() => [
                              createTextVNode("Salvar")
                            ]),
                            _: 1
                          }, 8, ["disabled"]),
                          !props2.isView ? (openBlock(), createBlock(VBtn, {
                            key: 0,
                            style: { "background-color": "#085a98", "color": "white" },
                            onClick: confirmarRecebimento
                          }, {
                            default: withCtx(() => [
                              createTextVNode("Reconhecer")
                            ]),
                            _: 1
                          })) : createCommentVNode("", true),
                          createVNode(VBtn, {
                            style: { "background-color": "red", "color": "white" },
                            onClick: closeModal
                          }, {
                            default: withCtx(() => [
                              createTextVNode("Voltar")
                            ]),
                            _: 1
                          })
                        ];
                      }
                    }),
                    _: 1
                  }, _parent3, _scopeId2));
                } else {
                  return [
                    createVNode(VCardTitle, { class: "text-h5 d-flex justify-space-between align-center" }, {
                      default: withCtx(() => [
                        createVNode("span", null, "Ficha de Firma"),
                        unref(images)[0].length > 1 ? (openBlock(), createBlock("div", {
                          key: 0,
                          class: "d-flex align-center"
                        }, [
                          createVNode(VBtn, {
                            icon: "",
                            small: "",
                            onClick: previousImage,
                            disabled: unref(currentIndex) === 0
                          }, {
                            default: withCtx(() => [
                              createVNode(VIcon, null, {
                                default: withCtx(() => [
                                  createTextVNode("mdi-chevron-left")
                                ]),
                                _: 1
                              })
                            ]),
                            _: 1
                          }, 8, ["disabled"]),
                          createVNode("span", { class: "mx-2" }, toDisplayString(unref(currentIndex) + 1) + " / " + toDisplayString(unref(images)[0].length), 1),
                          createVNode(VBtn, {
                            icon: "",
                            small: "",
                            onClick: nextImage,
                            disabled: unref(currentIndex) === unref(images)[0].length - 1
                          }, {
                            default: withCtx(() => [
                              createVNode(VIcon, null, {
                                default: withCtx(() => [
                                  createTextVNode("mdi-chevron-right")
                                ]),
                                _: 1
                              })
                            ]),
                            _: 1
                          }, 8, ["disabled"])
                        ])) : createCommentVNode("", true)
                      ]),
                      _: 1
                    }),
                    unref(images)[0].length > 1 ? (openBlock(), createBlock("div", {
                      key: 0,
                      class: "d-flex justify-center pa-2"
                    }, [
                      createVNode(VChipGroup, {
                        modelValue: unref(currentIndex),
                        "onUpdate:modelValue": ($event) => isRef(currentIndex) ? currentIndex.value = $event : null,
                        mandatory: ""
                      }, {
                        default: withCtx(() => [
                          (openBlock(true), createBlock(Fragment, null, renderList(unref(images)[0], (image, index) => {
                            return openBlock(), createBlock(VChip, {
                              key: index,
                              value: index,
                              small: "",
                              onClick: ($event) => selectImage(index),
                              class: { "v-chip--active": index === unref(currentIndex) }
                            }, {
                              default: withCtx(() => [
                                createTextVNode(toDisplayString(index + 1), 1)
                              ]),
                              _: 2
                            }, 1032, ["value", "onClick", "class"]);
                          }), 128))
                        ]),
                        _: 1
                      }, 8, ["modelValue", "onUpdate:modelValue"])
                    ])) : createCommentVNode("", true),
                    createVNode("div", { class: "d-flex justify-center align-center" }, [
                      createVNode(unref(ImageEditorComponent), {
                        height: "750px",
                        width: "850px",
                        ref_key: "imageEditorRef",
                        ref: imageEditorRef,
                        toolbar,
                        toolbarUpdating: onToolbarUpdating
                      }, null, 512)
                    ]),
                    createVNode(VCardActions, null, {
                      default: withCtx(() => [
                        createVNode(VBtn, {
                          style: { "background-color": "#429946", "color": "white" },
                          onClick: editarImagem,
                          disabled: unref(isCropActive)
                        }, {
                          default: withCtx(() => [
                            createTextVNode("Salvar")
                          ]),
                          _: 1
                        }, 8, ["disabled"]),
                        !props2.isView ? (openBlock(), createBlock(VBtn, {
                          key: 0,
                          style: { "background-color": "#085a98", "color": "white" },
                          onClick: confirmarRecebimento
                        }, {
                          default: withCtx(() => [
                            createTextVNode("Reconhecer")
                          ]),
                          _: 1
                        })) : createCommentVNode("", true),
                        createVNode(VBtn, {
                          style: { "background-color": "red", "color": "white" },
                          onClick: closeModal
                        }, {
                          default: withCtx(() => [
                            createTextVNode("Voltar")
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
          } else {
            return [
              createVNode(VCard, null, {
                default: withCtx(() => [
                  createVNode(VCardTitle, { class: "text-h5 d-flex justify-space-between align-center" }, {
                    default: withCtx(() => [
                      createVNode("span", null, "Ficha de Firma"),
                      unref(images)[0].length > 1 ? (openBlock(), createBlock("div", {
                        key: 0,
                        class: "d-flex align-center"
                      }, [
                        createVNode(VBtn, {
                          icon: "",
                          small: "",
                          onClick: previousImage,
                          disabled: unref(currentIndex) === 0
                        }, {
                          default: withCtx(() => [
                            createVNode(VIcon, null, {
                              default: withCtx(() => [
                                createTextVNode("mdi-chevron-left")
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        }, 8, ["disabled"]),
                        createVNode("span", { class: "mx-2" }, toDisplayString(unref(currentIndex) + 1) + " / " + toDisplayString(unref(images)[0].length), 1),
                        createVNode(VBtn, {
                          icon: "",
                          small: "",
                          onClick: nextImage,
                          disabled: unref(currentIndex) === unref(images)[0].length - 1
                        }, {
                          default: withCtx(() => [
                            createVNode(VIcon, null, {
                              default: withCtx(() => [
                                createTextVNode("mdi-chevron-right")
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        }, 8, ["disabled"])
                      ])) : createCommentVNode("", true)
                    ]),
                    _: 1
                  }),
                  unref(images)[0].length > 1 ? (openBlock(), createBlock("div", {
                    key: 0,
                    class: "d-flex justify-center pa-2"
                  }, [
                    createVNode(VChipGroup, {
                      modelValue: unref(currentIndex),
                      "onUpdate:modelValue": ($event) => isRef(currentIndex) ? currentIndex.value = $event : null,
                      mandatory: ""
                    }, {
                      default: withCtx(() => [
                        (openBlock(true), createBlock(Fragment, null, renderList(unref(images)[0], (image, index) => {
                          return openBlock(), createBlock(VChip, {
                            key: index,
                            value: index,
                            small: "",
                            onClick: ($event) => selectImage(index),
                            class: { "v-chip--active": index === unref(currentIndex) }
                          }, {
                            default: withCtx(() => [
                              createTextVNode(toDisplayString(index + 1), 1)
                            ]),
                            _: 2
                          }, 1032, ["value", "onClick", "class"]);
                        }), 128))
                      ]),
                      _: 1
                    }, 8, ["modelValue", "onUpdate:modelValue"])
                  ])) : createCommentVNode("", true),
                  createVNode("div", { class: "d-flex justify-center align-center" }, [
                    createVNode(unref(ImageEditorComponent), {
                      height: "750px",
                      width: "850px",
                      ref_key: "imageEditorRef",
                      ref: imageEditorRef,
                      toolbar,
                      toolbarUpdating: onToolbarUpdating
                    }, null, 512)
                  ]),
                  createVNode(VCardActions, null, {
                    default: withCtx(() => [
                      createVNode(VBtn, {
                        style: { "background-color": "#429946", "color": "white" },
                        onClick: editarImagem,
                        disabled: unref(isCropActive)
                      }, {
                        default: withCtx(() => [
                          createTextVNode("Salvar")
                        ]),
                        _: 1
                      }, 8, ["disabled"]),
                      !props2.isView ? (openBlock(), createBlock(VBtn, {
                        key: 0,
                        style: { "background-color": "#085a98", "color": "white" },
                        onClick: confirmarRecebimento
                      }, {
                        default: withCtx(() => [
                          createTextVNode("Reconhecer")
                        ]),
                        _: 1
                      })) : createCommentVNode("", true),
                      createVNode(VBtn, {
                        style: { "background-color": "red", "color": "white" },
                        onClick: closeModal
                      }, {
                        default: withCtx(() => [
                          createTextVNode("Voltar")
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ];
          }
        }),
        _: 1
      }, _parent));
    };
  }
};
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props2, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/Modal/FichaCard.vue");
  return _sfc_setup ? _sfc_setup(props2, ctx) : undefined;
};

export { Draggable as $, Animation$1 as A, Collection as B, Component as C, selectAll as D, EventHandler as E, Fetch as F, Browser as G, getScrollableParent as H, select as I, Popup as J, KeyboardEvents as K, isVisible as L, getZindexPartial as M, fit as N, isCollide as O, Property as P, calculatePosition as Q, HScroll as R, SanitizeHtmlHelper as S, Touch as T, setStyleAttribute as U, VScroll as V, getRandomId as W, Toolbar as X, animationMode as Y, L10n as Z, _sfc_main as _, removeClass as a, isUndefined as a0, Input as a1, getElement as a2, Droppable as a3, matches as a4, createSpinner as a5, showSpinner as a6, hideSpinner as a7, updateCSSText as a8, createElement as a9, TextBox as aa, classList as ab, Internationalization as ac, getDefaultDateObject as ad, cldrData as ae, throwError as af, DropDownButton as ag, Dialog as ah, DialogUtility as ai, NumericTextBox as aj, Tooltip as ak, ColorPicker as al, Button as am, initializeCSPTemplate as an, resetBlazorTemplate as ao, updateBlazorTemplate as ap, SplitButton as aq, getProps as ar, vueDefineComponent as as, ComponentBase as at, isExecute as au, NotifyPropertyChanges as av, gh as aw, print as ax, addClass as b, closest as c, detach as d, setHiddenInput as e, rippleMouseHandler as f, getUniqueID as g, getInstance as h, isNullOrUndefined as i, attributes as j, Event as k, getValue as l, merge as m, extend as n, ChildProperty as o, formatUnit as p, compile$1 as q, registerLicense as r, setValue as s, append as t, prepend as u, createCheckBox as v, wrapperInitialize as w, remove as x, rippleEffect as y, Complex as z };
//# sourceMappingURL=FichaCard-CSSAE02g.mjs.map
